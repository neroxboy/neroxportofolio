{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MpegParser = void 0;\nconst Token = require(\"token-types\");\nconst core_1 = require(\"strtok3/lib/core\");\nconst debug_1 = require(\"debug\");\nconst common = require(\"../common/Util\");\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\nconst XingTag_1 = require(\"./XingTag\");\nconst debug = (0, debug_1.default)('music-metadata:parser:mpeg');\n/**\n * Cache buffer size used for searching synchronization preabmle\n */\nconst maxPeekLen = 1024;\n/**\n * MPEG-4 Audio definitions\n * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio\n */\nconst MPEG4 = {\n  /**\n   * Audio Object Types\n   */\n  AudioObjectTypes: ['AAC Main', 'AAC LC', 'AAC SSR', 'AAC LTP' // Long Term Prediction\n  ],\n  /**\n   * Sampling Frequencies\n   * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies\n   */\n  SamplingFrequencies: [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, undefined, undefined, -1]\n  /**\n   * Channel Configurations\n   */\n};\nconst MPEG4_ChannelConfigurations = [undefined, ['front-center'], ['front-left', 'front-right'], ['front-center', 'front-left', 'front-right'], ['front-center', 'front-left', 'front-right', 'back-center'], ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'], ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'], ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']];\n/**\n * MPEG Audio Layer I/II/III frame header\n * Ref: https://www.mp3-tech.org/programmer/frame_header.html\n * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM\n * Ref: https://wiki.multimedia.cx/index.php/ADTS\n */\nclass MpegFrameHeader {\n  constructor(buf, off) {\n    // B(20,19): MPEG Audio versionIndex ID\n    this.versionIndex = common.getBitAllignedNumber(buf, off + 1, 3, 2);\n    // C(18,17): Layer description\n    this.layer = MpegFrameHeader.LayerDescription[common.getBitAllignedNumber(buf, off + 1, 5, 2)];\n    if (this.versionIndex > 1 && this.layer === 0) {\n      this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)\n    } else {\n      this.parseMpegHeader(buf, off); // Conventional MPEG header\n    }\n    // D(16): Protection bit (if true 16-bit CRC follows header)\n    this.isProtectedByCRC = !common.isBitSet(buf, off + 1, 7);\n  }\n  calcDuration(numFrames) {\n    return numFrames * this.calcSamplesPerFrame() / this.samplingRate;\n  }\n  calcSamplesPerFrame() {\n    return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];\n  }\n  calculateSideInfoLength() {\n    if (this.layer !== 3) return 2;\n    if (this.channelModeIndex === 3) {\n      // mono\n      if (this.version === 1) {\n        return 17;\n      } else if (this.version === 2 || this.version === 2.5) {\n        return 9;\n      }\n    } else {\n      if (this.version === 1) {\n        return 32;\n      } else if (this.version === 2 || this.version === 2.5) {\n        return 17;\n      }\n    }\n  }\n  calcSlotSize() {\n    return [null, 4, 1, 1][this.layer];\n  }\n  parseMpegHeader(buf, off) {\n    this.container = 'MPEG';\n    // E(15,12): Bitrate index\n    this.bitrateIndex = common.getBitAllignedNumber(buf, off + 2, 0, 4);\n    // F(11,10): Sampling rate frequency index\n    this.sampRateFreqIndex = common.getBitAllignedNumber(buf, off + 2, 4, 2);\n    // G(9): Padding bit\n    this.padding = common.isBitSet(buf, off + 2, 6);\n    // H(8): Private bit\n    this.privateBit = common.isBitSet(buf, off + 2, 7);\n    // I(7,6): Channel Mode\n    this.channelModeIndex = common.getBitAllignedNumber(buf, off + 3, 0, 2);\n    // J(5,4): Mode extension (Only used in Joint stereo)\n    this.modeExtension = common.getBitAllignedNumber(buf, off + 3, 2, 2);\n    // K(3): Copyright\n    this.isCopyrighted = common.isBitSet(buf, off + 3, 4);\n    // L(2): Original\n    this.isOriginalMedia = common.isBitSet(buf, off + 3, 5);\n    // M(3): The original bit indicates, if it is set, that the frame is located on its original media.\n    this.emphasis = common.getBitAllignedNumber(buf, off + 3, 7, 2);\n    this.version = MpegFrameHeader.VersionID[this.versionIndex];\n    this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];\n    this.codec = `MPEG ${this.version} Layer ${this.layer}`;\n    // Calculate bitrate\n    const bitrateInKbps = this.calcBitrate();\n    if (!bitrateInKbps) {\n      throw new Error('Cannot determine bit-rate');\n    }\n    this.bitrate = bitrateInKbps * 1000;\n    // Calculate sampling rate\n    this.samplingRate = this.calcSamplingRate();\n    if (this.samplingRate == null) {\n      throw new Error('Cannot determine sampling-rate');\n    }\n  }\n  parseAdtsHeader(buf, off) {\n    debug(`layer=0 => ADTS`);\n    this.version = this.versionIndex === 2 ? 4 : 2;\n    this.container = 'ADTS/MPEG-' + this.version;\n    const profileIndex = common.getBitAllignedNumber(buf, off + 2, 0, 2);\n    this.codec = 'AAC';\n    this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];\n    debug(`MPEG-4 audio-codec=${this.codec}`);\n    const samplingFrequencyIndex = common.getBitAllignedNumber(buf, off + 2, 2, 4);\n    this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];\n    debug(`sampling-rate=${this.samplingRate}`);\n    const channelIndex = common.getBitAllignedNumber(buf, off + 2, 7, 3);\n    this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];\n    debug(`channel-config=${this.mp4ChannelConfig.join('+')}`);\n    this.frameLength = common.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;\n  }\n  calcBitrate() {\n    if (this.bitrateIndex === 0x00 ||\n    // free\n    this.bitrateIndex === 0x0F) {\n      // reserved\n      return;\n    }\n    const codecIndex = `${Math.floor(this.version)}${this.layer}`;\n    return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];\n  }\n  calcSamplingRate() {\n    if (this.sampRateFreqIndex === 0x03) return null; // 'reserved'\n    return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];\n  }\n}\nMpegFrameHeader.SyncByte1 = 0xFF;\nMpegFrameHeader.SyncByte2 = 0xE0;\nMpegFrameHeader.VersionID = [2.5, null, 2, 1];\nMpegFrameHeader.LayerDescription = [0, 3, 2, 1];\nMpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\nMpegFrameHeader.bitrate_index = {\n  0x01: {\n    11: 32,\n    12: 32,\n    13: 32,\n    21: 32,\n    22: 8,\n    23: 8\n  },\n  0x02: {\n    11: 64,\n    12: 48,\n    13: 40,\n    21: 48,\n    22: 16,\n    23: 16\n  },\n  0x03: {\n    11: 96,\n    12: 56,\n    13: 48,\n    21: 56,\n    22: 24,\n    23: 24\n  },\n  0x04: {\n    11: 128,\n    12: 64,\n    13: 56,\n    21: 64,\n    22: 32,\n    23: 32\n  },\n  0x05: {\n    11: 160,\n    12: 80,\n    13: 64,\n    21: 80,\n    22: 40,\n    23: 40\n  },\n  0x06: {\n    11: 192,\n    12: 96,\n    13: 80,\n    21: 96,\n    22: 48,\n    23: 48\n  },\n  0x07: {\n    11: 224,\n    12: 112,\n    13: 96,\n    21: 112,\n    22: 56,\n    23: 56\n  },\n  0x08: {\n    11: 256,\n    12: 128,\n    13: 112,\n    21: 128,\n    22: 64,\n    23: 64\n  },\n  0x09: {\n    11: 288,\n    12: 160,\n    13: 128,\n    21: 144,\n    22: 80,\n    23: 80\n  },\n  0x0A: {\n    11: 320,\n    12: 192,\n    13: 160,\n    21: 160,\n    22: 96,\n    23: 96\n  },\n  0x0B: {\n    11: 352,\n    12: 224,\n    13: 192,\n    21: 176,\n    22: 112,\n    23: 112\n  },\n  0x0C: {\n    11: 384,\n    12: 256,\n    13: 224,\n    21: 192,\n    22: 128,\n    23: 128\n  },\n  0x0D: {\n    11: 416,\n    12: 320,\n    13: 256,\n    21: 224,\n    22: 144,\n    23: 144\n  },\n  0x0E: {\n    11: 448,\n    12: 384,\n    13: 320,\n    21: 256,\n    22: 160,\n    23: 160\n  }\n};\nMpegFrameHeader.sampling_rate_freq_index = {\n  1: {\n    0x00: 44100,\n    0x01: 48000,\n    0x02: 32000\n  },\n  2: {\n    0x00: 22050,\n    0x01: 24000,\n    0x02: 16000\n  },\n  2.5: {\n    0x00: 11025,\n    0x01: 12000,\n    0x02: 8000\n  }\n};\nMpegFrameHeader.samplesInFrameTable = [/* Layer   I    II   III */\n[0, 384, 1152, 1152], [0, 384, 1152, 576] // MPEG-2(.5\n];\n/**\n * MPEG Audio Layer I/II/III\n */\nconst FrameHeader = {\n  len: 4,\n  get: (buf, off) => {\n    return new MpegFrameHeader(buf, off);\n  }\n};\nfunction getVbrCodecProfile(vbrScale) {\n  return 'V' + Math.floor((100 - vbrScale) / 10);\n}\nclass MpegParser extends AbstractID3Parser_1.AbstractID3Parser {\n  constructor() {\n    super(...arguments);\n    this.frameCount = 0;\n    this.syncFrameCount = -1;\n    this.countSkipFrameData = 0;\n    this.totalDataLength = 0;\n    this.bitrates = [];\n    this.calculateEofDuration = false;\n    this.buf_frame_header = Buffer.alloc(4);\n    this.syncPeek = {\n      buf: Buffer.alloc(maxPeekLen),\n      len: 0\n    };\n  }\n  /**\n   * Called after ID3 headers have been parsed\n   */\n  async postId3v2Parse() {\n    this.metadata.setFormat('lossless', false);\n    try {\n      let quit = false;\n      while (!quit) {\n        await this.sync();\n        quit = await this.parseCommonMpegHeader();\n      }\n    } catch (err) {\n      if (err instanceof core_1.EndOfStreamError) {\n        debug(`End-of-stream`);\n        if (this.calculateEofDuration) {\n          const numberOfSamples = this.frameCount * this.samplesPerFrame;\n          this.metadata.setFormat('numberOfSamples', numberOfSamples);\n          const duration = numberOfSamples / this.metadata.format.sampleRate;\n          debug(`Calculate duration at EOF: ${duration} sec.`, duration);\n          this.metadata.setFormat('duration', duration);\n        }\n      } else {\n        throw err;\n      }\n    }\n  }\n  /**\n   * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length\n   */\n  finalize() {\n    const format = this.metadata.format;\n    const hasID3v1 = this.metadata.native.hasOwnProperty('ID3v1');\n    if (format.duration && this.tokenizer.fileInfo.size) {\n      const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n      if (format.codecProfile && format.codecProfile[0] === 'V') {\n        this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);\n      }\n    } else if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {\n      const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n      const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;\n      this.metadata.setFormat('numberOfSamples', numberOfSamples);\n      const duration = numberOfSamples / format.sampleRate;\n      debug(\"Calculate CBR duration based on file size: %s\", duration);\n      this.metadata.setFormat('duration', duration);\n    }\n  }\n  async sync() {\n    let gotFirstSync = false;\n    while (true) {\n      let bo = 0;\n      this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, {\n        length: maxPeekLen,\n        mayBeLess: true\n      });\n      if (this.syncPeek.len <= 163) {\n        throw new core_1.EndOfStreamError();\n      }\n      while (true) {\n        if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {\n          this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;\n          this.buf_frame_header[1] = this.syncPeek.buf[bo];\n          await this.tokenizer.ignore(bo);\n          debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);\n          if (this.syncFrameCount === this.frameCount) {\n            debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);\n            this.frameCount = 0;\n            this.frame_size = 0;\n          }\n          this.syncFrameCount = this.frameCount;\n          return; // sync\n        } else {\n          gotFirstSync = false;\n          bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);\n          if (bo === -1) {\n            if (this.syncPeek.len < this.syncPeek.buf.length) {\n              throw new core_1.EndOfStreamError();\n            }\n            await this.tokenizer.ignore(this.syncPeek.len);\n            break; // continue with next buffer\n          } else {\n            ++bo;\n            gotFirstSync = true;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Combined ADTS & MPEG (MP2 & MP3) header handling\n   * @return {Promise<boolean>} true if parser should quit\n   */\n  async parseCommonMpegHeader() {\n    if (this.frameCount === 0) {\n      this.mpegOffset = this.tokenizer.position - 1;\n    }\n    await this.tokenizer.peekBuffer(this.buf_frame_header, {\n      offset: 1,\n      length: 3\n    });\n    let header;\n    try {\n      header = FrameHeader.get(this.buf_frame_header, 0);\n    } catch (err) {\n      await this.tokenizer.ignore(1);\n      this.metadata.addWarning('Parse error: ' + err.message);\n      return false; // sync\n    }\n    await this.tokenizer.ignore(3);\n    this.metadata.setFormat('container', header.container);\n    this.metadata.setFormat('codec', header.codec);\n    this.metadata.setFormat('lossless', false);\n    this.metadata.setFormat('sampleRate', header.samplingRate);\n    this.frameCount++;\n    return header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);\n  }\n  /**\n   * @return {Promise<boolean>} true if parser should quit\n   */\n  async parseAudioFrameHeader(header) {\n    this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);\n    this.metadata.setFormat('bitrate', header.bitrate);\n    if (this.frameCount < 20 * 10000) {\n      debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);\n    }\n    const slot_size = header.calcSlotSize();\n    if (slot_size === null) {\n      throw new Error('invalid slot_size');\n    }\n    const samples_per_frame = header.calcSamplesPerFrame();\n    debug(`samples_per_frame=${samples_per_frame}`);\n    const bps = samples_per_frame / 8.0;\n    const fsize = bps * header.bitrate / header.samplingRate + (header.padding ? slot_size : 0);\n    this.frame_size = Math.floor(fsize);\n    this.audioFrameHeader = header;\n    this.bitrates.push(header.bitrate);\n    // xtra header only exists in first frame\n    if (this.frameCount === 1) {\n      this.offset = FrameHeader.len;\n      await this.skipSideInformation();\n      return false;\n    }\n    if (this.frameCount === 3) {\n      // the stream is CBR if the first 3 frame bitrates are the same\n      if (this.areAllSame(this.bitrates)) {\n        // Actual calculation will be done in finalize\n        this.samplesPerFrame = samples_per_frame;\n        this.metadata.setFormat('codecProfile', 'CBR');\n        if (this.tokenizer.fileInfo.size) return true; // Will calculate duration based on the file size\n      } else if (this.metadata.format.duration) {\n        return true; // We already got the duration, stop processing MPEG stream any further\n      }\n      if (!this.options.duration) {\n        return true; // Enforce duration not enabled, stop processing entire stream\n      }\n    }\n    // once we know the file is VBR attach listener to end of\n    // stream so we can do the duration calculation when we\n    // have counted all the frames\n    if (this.options.duration && this.frameCount === 4) {\n      this.samplesPerFrame = samples_per_frame;\n      this.calculateEofDuration = true;\n    }\n    this.offset = 4;\n    if (header.isProtectedByCRC) {\n      await this.parseCrc();\n      return false;\n    } else {\n      await this.skipSideInformation();\n      return false;\n    }\n  }\n  async parseAdts(header) {\n    const buf = Buffer.alloc(3);\n    await this.tokenizer.readBuffer(buf);\n    header.frameLength += common.getBitAllignedNumber(buf, 0, 0, 11);\n    this.totalDataLength += header.frameLength;\n    this.samplesPerFrame = 1024;\n    const framesPerSec = header.samplingRate / this.samplesPerFrame;\n    const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;\n    const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;\n    this.metadata.setFormat('bitrate', bitrate);\n    debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);\n    await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);\n    // Consume remaining header and frame data\n    if (this.frameCount === 3) {\n      this.metadata.setFormat('codecProfile', header.codecProfile);\n      if (header.mp4ChannelConfig) {\n        this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);\n      }\n      if (this.options.duration) {\n        this.calculateEofDuration = true;\n      } else {\n        return true; // Stop parsing after the third frame\n      }\n    }\n    return false;\n  }\n  async parseCrc() {\n    this.crc = await this.tokenizer.readNumber(Token.INT16_BE);\n    this.offset += 2;\n    return this.skipSideInformation();\n  }\n  async skipSideInformation() {\n    const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();\n    // side information\n    await this.tokenizer.readToken(new Token.Uint8ArrayType(sideinfo_length));\n    this.offset += sideinfo_length;\n    await this.readXtraInfoHeader();\n    return;\n  }\n  async readXtraInfoHeader() {\n    const headerTag = await this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag);\n    this.offset += XingTag_1.InfoTagHeaderTag.len; // 12\n    switch (headerTag) {\n      case 'Info':\n        this.metadata.setFormat('codecProfile', 'CBR');\n        return this.readXingInfoHeader();\n      case 'Xing':\n        const infoTag = await this.readXingInfoHeader();\n        const codecProfile = getVbrCodecProfile(infoTag.vbrScale);\n        this.metadata.setFormat('codecProfile', codecProfile);\n        return null;\n      case 'Xtra':\n        // ToDo: ???\n        break;\n      case 'LAME':\n        const version = await this.tokenizer.readToken(XingTag_1.LameEncoderVersion);\n        if (this.frame_size >= this.offset + XingTag_1.LameEncoderVersion.len) {\n          this.offset += XingTag_1.LameEncoderVersion.len;\n          this.metadata.setFormat('tool', 'LAME ' + version);\n          await this.skipFrameData(this.frame_size - this.offset);\n          return null;\n        } else {\n          this.metadata.addWarning('Corrupt LAME header');\n          break;\n        }\n      // ToDo: ???\n    }\n    // ToDo: promise duration???\n    const frameDataLeft = this.frame_size - this.offset;\n    if (frameDataLeft < 0) {\n      this.metadata.addWarning('Frame ' + this.frameCount + 'corrupt: negative frameDataLeft');\n    } else {\n      await this.skipFrameData(frameDataLeft);\n    }\n    return null;\n  }\n  /**\n   * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n   * @returns {Promise<string>}\n   */\n  async readXingInfoHeader() {\n    const offset = this.tokenizer.position;\n    const infoTag = await (0, XingTag_1.readXingHeader)(this.tokenizer);\n    this.offset += this.tokenizer.position - offset;\n    if (infoTag.lame) {\n      this.metadata.setFormat('tool', 'LAME ' + common.stripNulls(infoTag.lame.version));\n      if (infoTag.lame.extended) {\n        // this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain);\n        this.metadata.setFormat('trackPeakLevel', infoTag.lame.extended.track_peak);\n        if (infoTag.lame.extended.track_gain) {\n          this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain.adjustment);\n        }\n        if (infoTag.lame.extended.album_gain) {\n          this.metadata.setFormat('albumGain', infoTag.lame.extended.album_gain.adjustment);\n        }\n        this.metadata.setFormat('duration', infoTag.lame.extended.music_length / 1000);\n      }\n    }\n    if (infoTag.streamSize) {\n      const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);\n      this.metadata.setFormat('duration', duration);\n      debug('Get duration from Xing header: %s', this.metadata.format.duration);\n      return infoTag;\n    }\n    // frames field is not present\n    const frameDataLeft = this.frame_size - this.offset;\n    await this.skipFrameData(frameDataLeft);\n    return infoTag;\n  }\n  async skipFrameData(frameDataLeft) {\n    if (frameDataLeft < 0) throw new Error('frame-data-left cannot be negative');\n    await this.tokenizer.ignore(frameDataLeft);\n    this.countSkipFrameData += frameDataLeft;\n  }\n  areAllSame(array) {\n    const first = array[0];\n    return array.every(element => {\n      return element === first;\n    });\n  }\n}\nexports.MpegParser = MpegParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","MpegParser","Token","require","core_1","debug_1","common","AbstractID3Parser_1","XingTag_1","debug","default","maxPeekLen","MPEG4","AudioObjectTypes","SamplingFrequencies","undefined","MPEG4_ChannelConfigurations","MpegFrameHeader","constructor","buf","off","versionIndex","getBitAllignedNumber","layer","LayerDescription","parseAdtsHeader","parseMpegHeader","isProtectedByCRC","isBitSet","calcDuration","numFrames","calcSamplesPerFrame","samplingRate","samplesInFrameTable","version","calculateSideInfoLength","channelModeIndex","calcSlotSize","container","bitrateIndex","sampRateFreqIndex","padding","privateBit","modeExtension","isCopyrighted","isOriginalMedia","emphasis","VersionID","channelMode","ChannelMode","codec","bitrateInKbps","calcBitrate","Error","bitrate","calcSamplingRate","profileIndex","codecProfile","samplingFrequencyIndex","channelIndex","mp4ChannelConfig","join","frameLength","codecIndex","Math","floor","bitrate_index","sampling_rate_freq_index","SyncByte1","SyncByte2","FrameHeader","len","get","getVbrCodecProfile","vbrScale","AbstractID3Parser","arguments","frameCount","syncFrameCount","countSkipFrameData","totalDataLength","bitrates","calculateEofDuration","buf_frame_header","Buffer","alloc","syncPeek","postId3v2Parse","metadata","setFormat","quit","sync","parseCommonMpegHeader","err","EndOfStreamError","numberOfSamples","samplesPerFrame","duration","format","sampleRate","finalize","hasID3v1","native","hasOwnProperty","tokenizer","fileInfo","size","mpegSize","mpegOffset","round","frame_size","gotFirstSync","bo","peekBuffer","length","mayBeLess","ignore","position","indexOf","offset","header","addWarning","message","parseAdts","parseAudioFrameHeader","slot_size","samples_per_frame","bps","fsize","audioFrameHeader","push","skipSideInformation","areAllSame","options","parseCrc","readBuffer","framesPerSec","bytesPerFrame","crc","readNumber","INT16_BE","sideinfo_length","readToken","Uint8ArrayType","readXtraInfoHeader","headerTag","InfoTagHeaderTag","readXingInfoHeader","infoTag","LameEncoderVersion","skipFrameData","frameDataLeft","readXingHeader","lame","stripNulls","extended","track_peak","track_gain","adjustment","album_gain","music_length","streamSize","array","first","every","element"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/mpeg/MpegParser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MpegParser = void 0;\nconst Token = require(\"token-types\");\nconst core_1 = require(\"strtok3/lib/core\");\nconst debug_1 = require(\"debug\");\nconst common = require(\"../common/Util\");\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\nconst XingTag_1 = require(\"./XingTag\");\nconst debug = (0, debug_1.default)('music-metadata:parser:mpeg');\n/**\n * Cache buffer size used for searching synchronization preabmle\n */\nconst maxPeekLen = 1024;\n/**\n * MPEG-4 Audio definitions\n * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio\n */\nconst MPEG4 = {\n    /**\n     * Audio Object Types\n     */\n    AudioObjectTypes: [\n        'AAC Main',\n        'AAC LC',\n        'AAC SSR',\n        'AAC LTP' // Long Term Prediction\n    ],\n    /**\n     * Sampling Frequencies\n     * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies\n     */\n    SamplingFrequencies: [\n        96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, undefined, undefined, -1\n    ]\n    /**\n     * Channel Configurations\n     */\n};\nconst MPEG4_ChannelConfigurations = [\n    undefined,\n    ['front-center'],\n    ['front-left', 'front-right'],\n    ['front-center', 'front-left', 'front-right'],\n    ['front-center', 'front-left', 'front-right', 'back-center'],\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'],\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'],\n    ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']\n];\n/**\n * MPEG Audio Layer I/II/III frame header\n * Ref: https://www.mp3-tech.org/programmer/frame_header.html\n * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM\n * Ref: https://wiki.multimedia.cx/index.php/ADTS\n */\nclass MpegFrameHeader {\n    constructor(buf, off) {\n        // B(20,19): MPEG Audio versionIndex ID\n        this.versionIndex = common.getBitAllignedNumber(buf, off + 1, 3, 2);\n        // C(18,17): Layer description\n        this.layer = MpegFrameHeader.LayerDescription[common.getBitAllignedNumber(buf, off + 1, 5, 2)];\n        if (this.versionIndex > 1 && this.layer === 0) {\n            this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)\n        }\n        else {\n            this.parseMpegHeader(buf, off); // Conventional MPEG header\n        }\n        // D(16): Protection bit (if true 16-bit CRC follows header)\n        this.isProtectedByCRC = !common.isBitSet(buf, off + 1, 7);\n    }\n    calcDuration(numFrames) {\n        return numFrames * this.calcSamplesPerFrame() / this.samplingRate;\n    }\n    calcSamplesPerFrame() {\n        return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];\n    }\n    calculateSideInfoLength() {\n        if (this.layer !== 3)\n            return 2;\n        if (this.channelModeIndex === 3) {\n            // mono\n            if (this.version === 1) {\n                return 17;\n            }\n            else if (this.version === 2 || this.version === 2.5) {\n                return 9;\n            }\n        }\n        else {\n            if (this.version === 1) {\n                return 32;\n            }\n            else if (this.version === 2 || this.version === 2.5) {\n                return 17;\n            }\n        }\n    }\n    calcSlotSize() {\n        return [null, 4, 1, 1][this.layer];\n    }\n    parseMpegHeader(buf, off) {\n        this.container = 'MPEG';\n        // E(15,12): Bitrate index\n        this.bitrateIndex = common.getBitAllignedNumber(buf, off + 2, 0, 4);\n        // F(11,10): Sampling rate frequency index\n        this.sampRateFreqIndex = common.getBitAllignedNumber(buf, off + 2, 4, 2);\n        // G(9): Padding bit\n        this.padding = common.isBitSet(buf, off + 2, 6);\n        // H(8): Private bit\n        this.privateBit = common.isBitSet(buf, off + 2, 7);\n        // I(7,6): Channel Mode\n        this.channelModeIndex = common.getBitAllignedNumber(buf, off + 3, 0, 2);\n        // J(5,4): Mode extension (Only used in Joint stereo)\n        this.modeExtension = common.getBitAllignedNumber(buf, off + 3, 2, 2);\n        // K(3): Copyright\n        this.isCopyrighted = common.isBitSet(buf, off + 3, 4);\n        // L(2): Original\n        this.isOriginalMedia = common.isBitSet(buf, off + 3, 5);\n        // M(3): The original bit indicates, if it is set, that the frame is located on its original media.\n        this.emphasis = common.getBitAllignedNumber(buf, off + 3, 7, 2);\n        this.version = MpegFrameHeader.VersionID[this.versionIndex];\n        this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];\n        this.codec = `MPEG ${this.version} Layer ${this.layer}`;\n        // Calculate bitrate\n        const bitrateInKbps = this.calcBitrate();\n        if (!bitrateInKbps) {\n            throw new Error('Cannot determine bit-rate');\n        }\n        this.bitrate = bitrateInKbps * 1000;\n        // Calculate sampling rate\n        this.samplingRate = this.calcSamplingRate();\n        if (this.samplingRate == null) {\n            throw new Error('Cannot determine sampling-rate');\n        }\n    }\n    parseAdtsHeader(buf, off) {\n        debug(`layer=0 => ADTS`);\n        this.version = this.versionIndex === 2 ? 4 : 2;\n        this.container = 'ADTS/MPEG-' + this.version;\n        const profileIndex = common.getBitAllignedNumber(buf, off + 2, 0, 2);\n        this.codec = 'AAC';\n        this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];\n        debug(`MPEG-4 audio-codec=${this.codec}`);\n        const samplingFrequencyIndex = common.getBitAllignedNumber(buf, off + 2, 2, 4);\n        this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];\n        debug(`sampling-rate=${this.samplingRate}`);\n        const channelIndex = common.getBitAllignedNumber(buf, off + 2, 7, 3);\n        this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];\n        debug(`channel-config=${this.mp4ChannelConfig.join('+')}`);\n        this.frameLength = common.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;\n    }\n    calcBitrate() {\n        if (this.bitrateIndex === 0x00 || // free\n            this.bitrateIndex === 0x0F) { // reserved\n            return;\n        }\n        const codecIndex = `${Math.floor(this.version)}${this.layer}`;\n        return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];\n    }\n    calcSamplingRate() {\n        if (this.sampRateFreqIndex === 0x03)\n            return null; // 'reserved'\n        return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];\n    }\n}\nMpegFrameHeader.SyncByte1 = 0xFF;\nMpegFrameHeader.SyncByte2 = 0xE0;\nMpegFrameHeader.VersionID = [2.5, null, 2, 1];\nMpegFrameHeader.LayerDescription = [0, 3, 2, 1];\nMpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\nMpegFrameHeader.bitrate_index = {\n    0x01: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },\n    0x02: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },\n    0x03: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },\n    0x04: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },\n    0x05: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },\n    0x06: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },\n    0x07: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },\n    0x08: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },\n    0x09: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },\n    0x0A: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },\n    0x0B: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },\n    0x0C: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },\n    0x0D: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },\n    0x0E: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }\n};\nMpegFrameHeader.sampling_rate_freq_index = {\n    1: { 0x00: 44100, 0x01: 48000, 0x02: 32000 },\n    2: { 0x00: 22050, 0x01: 24000, 0x02: 16000 },\n    2.5: { 0x00: 11025, 0x01: 12000, 0x02: 8000 }\n};\nMpegFrameHeader.samplesInFrameTable = [\n    /* Layer   I    II   III */\n    [0, 384, 1152, 1152],\n    [0, 384, 1152, 576] // MPEG-2(.5\n];\n/**\n * MPEG Audio Layer I/II/III\n */\nconst FrameHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return new MpegFrameHeader(buf, off);\n    }\n};\nfunction getVbrCodecProfile(vbrScale) {\n    return 'V' + Math.floor((100 - vbrScale) / 10);\n}\nclass MpegParser extends AbstractID3Parser_1.AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.frameCount = 0;\n        this.syncFrameCount = -1;\n        this.countSkipFrameData = 0;\n        this.totalDataLength = 0;\n        this.bitrates = [];\n        this.calculateEofDuration = false;\n        this.buf_frame_header = Buffer.alloc(4);\n        this.syncPeek = {\n            buf: Buffer.alloc(maxPeekLen),\n            len: 0\n        };\n    }\n    /**\n     * Called after ID3 headers have been parsed\n     */\n    async postId3v2Parse() {\n        this.metadata.setFormat('lossless', false);\n        try {\n            let quit = false;\n            while (!quit) {\n                await this.sync();\n                quit = await this.parseCommonMpegHeader();\n            }\n        }\n        catch (err) {\n            if (err instanceof core_1.EndOfStreamError) {\n                debug(`End-of-stream`);\n                if (this.calculateEofDuration) {\n                    const numberOfSamples = this.frameCount * this.samplesPerFrame;\n                    this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                    const duration = numberOfSamples / this.metadata.format.sampleRate;\n                    debug(`Calculate duration at EOF: ${duration} sec.`, duration);\n                    this.metadata.setFormat('duration', duration);\n                }\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    /**\n     * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length\n     */\n    finalize() {\n        const format = this.metadata.format;\n        const hasID3v1 = this.metadata.native.hasOwnProperty('ID3v1');\n        if (format.duration && this.tokenizer.fileInfo.size) {\n            const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n            if (format.codecProfile && format.codecProfile[0] === 'V') {\n                this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);\n            }\n        }\n        else if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {\n            const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n            const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;\n            this.metadata.setFormat('numberOfSamples', numberOfSamples);\n            const duration = numberOfSamples / format.sampleRate;\n            debug(\"Calculate CBR duration based on file size: %s\", duration);\n            this.metadata.setFormat('duration', duration);\n        }\n    }\n    async sync() {\n        let gotFirstSync = false;\n        while (true) {\n            let bo = 0;\n            this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: true });\n            if (this.syncPeek.len <= 163) {\n                throw new core_1.EndOfStreamError();\n            }\n            while (true) {\n                if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {\n                    this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;\n                    this.buf_frame_header[1] = this.syncPeek.buf[bo];\n                    await this.tokenizer.ignore(bo);\n                    debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);\n                    if (this.syncFrameCount === this.frameCount) {\n                        debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);\n                        this.frameCount = 0;\n                        this.frame_size = 0;\n                    }\n                    this.syncFrameCount = this.frameCount;\n                    return; // sync\n                }\n                else {\n                    gotFirstSync = false;\n                    bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);\n                    if (bo === -1) {\n                        if (this.syncPeek.len < this.syncPeek.buf.length) {\n                            throw new core_1.EndOfStreamError();\n                        }\n                        await this.tokenizer.ignore(this.syncPeek.len);\n                        break; // continue with next buffer\n                    }\n                    else {\n                        ++bo;\n                        gotFirstSync = true;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Combined ADTS & MPEG (MP2 & MP3) header handling\n     * @return {Promise<boolean>} true if parser should quit\n     */\n    async parseCommonMpegHeader() {\n        if (this.frameCount === 0) {\n            this.mpegOffset = this.tokenizer.position - 1;\n        }\n        await this.tokenizer.peekBuffer(this.buf_frame_header, { offset: 1, length: 3 });\n        let header;\n        try {\n            header = FrameHeader.get(this.buf_frame_header, 0);\n        }\n        catch (err) {\n            await this.tokenizer.ignore(1);\n            this.metadata.addWarning('Parse error: ' + err.message);\n            return false; // sync\n        }\n        await this.tokenizer.ignore(3);\n        this.metadata.setFormat('container', header.container);\n        this.metadata.setFormat('codec', header.codec);\n        this.metadata.setFormat('lossless', false);\n        this.metadata.setFormat('sampleRate', header.samplingRate);\n        this.frameCount++;\n        return header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);\n    }\n    /**\n     * @return {Promise<boolean>} true if parser should quit\n     */\n    async parseAudioFrameHeader(header) {\n        this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);\n        this.metadata.setFormat('bitrate', header.bitrate);\n        if (this.frameCount < 20 * 10000) {\n            debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);\n        }\n        const slot_size = header.calcSlotSize();\n        if (slot_size === null) {\n            throw new Error('invalid slot_size');\n        }\n        const samples_per_frame = header.calcSamplesPerFrame();\n        debug(`samples_per_frame=${samples_per_frame}`);\n        const bps = samples_per_frame / 8.0;\n        const fsize = (bps * header.bitrate / header.samplingRate) +\n            ((header.padding) ? slot_size : 0);\n        this.frame_size = Math.floor(fsize);\n        this.audioFrameHeader = header;\n        this.bitrates.push(header.bitrate);\n        // xtra header only exists in first frame\n        if (this.frameCount === 1) {\n            this.offset = FrameHeader.len;\n            await this.skipSideInformation();\n            return false;\n        }\n        if (this.frameCount === 3) {\n            // the stream is CBR if the first 3 frame bitrates are the same\n            if (this.areAllSame(this.bitrates)) {\n                // Actual calculation will be done in finalize\n                this.samplesPerFrame = samples_per_frame;\n                this.metadata.setFormat('codecProfile', 'CBR');\n                if (this.tokenizer.fileInfo.size)\n                    return true; // Will calculate duration based on the file size\n            }\n            else if (this.metadata.format.duration) {\n                return true; // We already got the duration, stop processing MPEG stream any further\n            }\n            if (!this.options.duration) {\n                return true; // Enforce duration not enabled, stop processing entire stream\n            }\n        }\n        // once we know the file is VBR attach listener to end of\n        // stream so we can do the duration calculation when we\n        // have counted all the frames\n        if (this.options.duration && this.frameCount === 4) {\n            this.samplesPerFrame = samples_per_frame;\n            this.calculateEofDuration = true;\n        }\n        this.offset = 4;\n        if (header.isProtectedByCRC) {\n            await this.parseCrc();\n            return false;\n        }\n        else {\n            await this.skipSideInformation();\n            return false;\n        }\n    }\n    async parseAdts(header) {\n        const buf = Buffer.alloc(3);\n        await this.tokenizer.readBuffer(buf);\n        header.frameLength += common.getBitAllignedNumber(buf, 0, 0, 11);\n        this.totalDataLength += header.frameLength;\n        this.samplesPerFrame = 1024;\n        const framesPerSec = header.samplingRate / this.samplesPerFrame;\n        const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;\n        const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;\n        this.metadata.setFormat('bitrate', bitrate);\n        debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);\n        await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);\n        // Consume remaining header and frame data\n        if (this.frameCount === 3) {\n            this.metadata.setFormat('codecProfile', header.codecProfile);\n            if (header.mp4ChannelConfig) {\n                this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);\n            }\n            if (this.options.duration) {\n                this.calculateEofDuration = true;\n            }\n            else {\n                return true; // Stop parsing after the third frame\n            }\n        }\n        return false;\n    }\n    async parseCrc() {\n        this.crc = await this.tokenizer.readNumber(Token.INT16_BE);\n        this.offset += 2;\n        return this.skipSideInformation();\n    }\n    async skipSideInformation() {\n        const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();\n        // side information\n        await this.tokenizer.readToken(new Token.Uint8ArrayType(sideinfo_length));\n        this.offset += sideinfo_length;\n        await this.readXtraInfoHeader();\n        return;\n    }\n    async readXtraInfoHeader() {\n        const headerTag = await this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag);\n        this.offset += XingTag_1.InfoTagHeaderTag.len; // 12\n        switch (headerTag) {\n            case 'Info':\n                this.metadata.setFormat('codecProfile', 'CBR');\n                return this.readXingInfoHeader();\n            case 'Xing':\n                const infoTag = await this.readXingInfoHeader();\n                const codecProfile = getVbrCodecProfile(infoTag.vbrScale);\n                this.metadata.setFormat('codecProfile', codecProfile);\n                return null;\n            case 'Xtra':\n                // ToDo: ???\n                break;\n            case 'LAME':\n                const version = await this.tokenizer.readToken(XingTag_1.LameEncoderVersion);\n                if (this.frame_size >= this.offset + XingTag_1.LameEncoderVersion.len) {\n                    this.offset += XingTag_1.LameEncoderVersion.len;\n                    this.metadata.setFormat('tool', 'LAME ' + version);\n                    await this.skipFrameData(this.frame_size - this.offset);\n                    return null;\n                }\n                else {\n                    this.metadata.addWarning('Corrupt LAME header');\n                    break;\n                }\n            // ToDo: ???\n        }\n        // ToDo: promise duration???\n        const frameDataLeft = this.frame_size - this.offset;\n        if (frameDataLeft < 0) {\n            this.metadata.addWarning('Frame ' + this.frameCount + 'corrupt: negative frameDataLeft');\n        }\n        else {\n            await this.skipFrameData(frameDataLeft);\n        }\n        return null;\n    }\n    /**\n     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n     * @returns {Promise<string>}\n     */\n    async readXingInfoHeader() {\n        const offset = this.tokenizer.position;\n        const infoTag = await (0, XingTag_1.readXingHeader)(this.tokenizer);\n        this.offset += this.tokenizer.position - offset;\n        if (infoTag.lame) {\n            this.metadata.setFormat('tool', 'LAME ' + common.stripNulls(infoTag.lame.version));\n            if (infoTag.lame.extended) {\n                // this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain);\n                this.metadata.setFormat('trackPeakLevel', infoTag.lame.extended.track_peak);\n                if (infoTag.lame.extended.track_gain) {\n                    this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain.adjustment);\n                }\n                if (infoTag.lame.extended.album_gain) {\n                    this.metadata.setFormat('albumGain', infoTag.lame.extended.album_gain.adjustment);\n                }\n                this.metadata.setFormat('duration', infoTag.lame.extended.music_length / 1000);\n            }\n        }\n        if (infoTag.streamSize) {\n            const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);\n            this.metadata.setFormat('duration', duration);\n            debug('Get duration from Xing header: %s', this.metadata.format.duration);\n            return infoTag;\n        }\n        // frames field is not present\n        const frameDataLeft = this.frame_size - this.offset;\n        await this.skipFrameData(frameDataLeft);\n        return infoTag;\n    }\n    async skipFrameData(frameDataLeft) {\n        if (frameDataLeft < 0)\n            throw new Error('frame-data-left cannot be negative');\n        await this.tokenizer.ignore(frameDataLeft);\n        this.countSkipFrameData += frameDataLeft;\n    }\n    areAllSame(array) {\n        const first = array[0];\n        return array.every(element => {\n            return element === first;\n        });\n    }\n}\nexports.MpegParser = MpegParser;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,UAAU,GAAG,KAAK,CAAC;AAC3B,MAAMC,KAAK,GAAGC,OAAO,CAAC,aAAa,CAAC;AACpC,MAAMC,MAAM,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AAC1C,MAAME,OAAO,GAAGF,OAAO,CAAC,OAAO,CAAC;AAChC,MAAMG,MAAM,GAAGH,OAAO,CAAC,gBAAgB,CAAC;AACxC,MAAMI,mBAAmB,GAAGJ,OAAO,CAAC,4BAA4B,CAAC;AACjE,MAAMK,SAAS,GAAGL,OAAO,CAAC,WAAW,CAAC;AACtC,MAAMM,KAAK,GAAG,CAAC,CAAC,EAAEJ,OAAO,CAACK,OAAO,EAAE,4BAA4B,CAAC;AAChE;AACA;AACA;AACA,MAAMC,UAAU,GAAG,IAAI;AACvB;AACA;AACA;AACA;AACA,MAAMC,KAAK,GAAG;EACV;AACJ;AACA;EACIC,gBAAgB,EAAE,CACd,UAAU,EACV,QAAQ,EACR,SAAS,EACT,SAAS,CAAC;EAAA,CACb;EACD;AACJ;AACA;AACA;EACIC,mBAAmB,EAAE,CACjB,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAEC,SAAS,EAAEA,SAAS,EAAE,CAAC,CAAC;EAErH;AACJ;AACA;AACA,CAAC;AACD,MAAMC,2BAA2B,GAAG,CAChCD,SAAS,EACT,CAAC,cAAc,CAAC,EAChB,CAAC,YAAY,EAAE,aAAa,CAAC,EAC7B,CAAC,cAAc,EAAE,YAAY,EAAE,aAAa,CAAC,EAC7C,CAAC,cAAc,EAAE,YAAY,EAAE,aAAa,EAAE,aAAa,CAAC,EAC5D,CAAC,cAAc,EAAE,YAAY,EAAE,aAAa,EAAE,WAAW,EAAE,YAAY,CAAC,EACxE,CAAC,cAAc,EAAE,YAAY,EAAE,aAAa,EAAE,WAAW,EAAE,YAAY,EAAE,aAAa,CAAC,EACvF,CAAC,cAAc,EAAE,YAAY,EAAE,aAAa,EAAE,WAAW,EAAE,YAAY,EAAE,WAAW,EAAE,YAAY,EAAE,aAAa,CAAC,CACrH;AACD;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,eAAe,CAAC;EAClBC,WAAWA,CAACC,GAAG,EAAEC,GAAG,EAAE;IAClB;IACA,IAAI,CAACC,YAAY,GAAGf,MAAM,CAACgB,oBAAoB,CAACH,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACnE;IACA,IAAI,CAACG,KAAK,GAAGN,eAAe,CAACO,gBAAgB,CAAClB,MAAM,CAACgB,oBAAoB,CAACH,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAC9F,IAAI,IAAI,CAACC,YAAY,GAAG,CAAC,IAAI,IAAI,CAACE,KAAK,KAAK,CAAC,EAAE;MAC3C,IAAI,CAACE,eAAe,CAACN,GAAG,EAAEC,GAAG,CAAC,CAAC,CAAC;IACpC,CAAC,MACI;MACD,IAAI,CAACM,eAAe,CAACP,GAAG,EAAEC,GAAG,CAAC,CAAC,CAAC;IACpC;IACA;IACA,IAAI,CAACO,gBAAgB,GAAG,CAACrB,MAAM,CAACsB,QAAQ,CAACT,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC;EAC7D;EACAS,YAAYA,CAACC,SAAS,EAAE;IACpB,OAAOA,SAAS,GAAG,IAAI,CAACC,mBAAmB,CAAC,CAAC,GAAG,IAAI,CAACC,YAAY;EACrE;EACAD,mBAAmBA,CAAA,EAAG;IAClB,OAAOd,eAAe,CAACgB,mBAAmB,CAAC,IAAI,CAACC,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAACX,KAAK,CAAC;EACtF;EACAY,uBAAuBA,CAAA,EAAG;IACtB,IAAI,IAAI,CAACZ,KAAK,KAAK,CAAC,EAChB,OAAO,CAAC;IACZ,IAAI,IAAI,CAACa,gBAAgB,KAAK,CAAC,EAAE;MAC7B;MACA,IAAI,IAAI,CAACF,OAAO,KAAK,CAAC,EAAE;QACpB,OAAO,EAAE;MACb,CAAC,MACI,IAAI,IAAI,CAACA,OAAO,KAAK,CAAC,IAAI,IAAI,CAACA,OAAO,KAAK,GAAG,EAAE;QACjD,OAAO,CAAC;MACZ;IACJ,CAAC,MACI;MACD,IAAI,IAAI,CAACA,OAAO,KAAK,CAAC,EAAE;QACpB,OAAO,EAAE;MACb,CAAC,MACI,IAAI,IAAI,CAACA,OAAO,KAAK,CAAC,IAAI,IAAI,CAACA,OAAO,KAAK,GAAG,EAAE;QACjD,OAAO,EAAE;MACb;IACJ;EACJ;EACAG,YAAYA,CAAA,EAAG;IACX,OAAO,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAACd,KAAK,CAAC;EACtC;EACAG,eAAeA,CAACP,GAAG,EAAEC,GAAG,EAAE;IACtB,IAAI,CAACkB,SAAS,GAAG,MAAM;IACvB;IACA,IAAI,CAACC,YAAY,GAAGjC,MAAM,CAACgB,oBAAoB,CAACH,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACnE;IACA,IAAI,CAACoB,iBAAiB,GAAGlC,MAAM,CAACgB,oBAAoB,CAACH,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACxE;IACA,IAAI,CAACqB,OAAO,GAAGnC,MAAM,CAACsB,QAAQ,CAACT,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC;IAC/C;IACA,IAAI,CAACsB,UAAU,GAAGpC,MAAM,CAACsB,QAAQ,CAACT,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC;IAClD;IACA,IAAI,CAACgB,gBAAgB,GAAG9B,MAAM,CAACgB,oBAAoB,CAACH,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACvE;IACA,IAAI,CAACuB,aAAa,GAAGrC,MAAM,CAACgB,oBAAoB,CAACH,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACpE;IACA,IAAI,CAACwB,aAAa,GAAGtC,MAAM,CAACsB,QAAQ,CAACT,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC;IACrD;IACA,IAAI,CAACyB,eAAe,GAAGvC,MAAM,CAACsB,QAAQ,CAACT,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC;IACvD;IACA,IAAI,CAAC0B,QAAQ,GAAGxC,MAAM,CAACgB,oBAAoB,CAACH,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC/D,IAAI,CAACc,OAAO,GAAGjB,eAAe,CAAC8B,SAAS,CAAC,IAAI,CAAC1B,YAAY,CAAC;IAC3D,IAAI,CAAC2B,WAAW,GAAG/B,eAAe,CAACgC,WAAW,CAAC,IAAI,CAACb,gBAAgB,CAAC;IACrE,IAAI,CAACc,KAAK,GAAG,QAAQ,IAAI,CAAChB,OAAO,UAAU,IAAI,CAACX,KAAK,EAAE;IACvD;IACA,MAAM4B,aAAa,GAAG,IAAI,CAACC,WAAW,CAAC,CAAC;IACxC,IAAI,CAACD,aAAa,EAAE;MAChB,MAAM,IAAIE,KAAK,CAAC,2BAA2B,CAAC;IAChD;IACA,IAAI,CAACC,OAAO,GAAGH,aAAa,GAAG,IAAI;IACnC;IACA,IAAI,CAACnB,YAAY,GAAG,IAAI,CAACuB,gBAAgB,CAAC,CAAC;IAC3C,IAAI,IAAI,CAACvB,YAAY,IAAI,IAAI,EAAE;MAC3B,MAAM,IAAIqB,KAAK,CAAC,gCAAgC,CAAC;IACrD;EACJ;EACA5B,eAAeA,CAACN,GAAG,EAAEC,GAAG,EAAE;IACtBX,KAAK,CAAC,iBAAiB,CAAC;IACxB,IAAI,CAACyB,OAAO,GAAG,IAAI,CAACb,YAAY,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;IAC9C,IAAI,CAACiB,SAAS,GAAG,YAAY,GAAG,IAAI,CAACJ,OAAO;IAC5C,MAAMsB,YAAY,GAAGlD,MAAM,CAACgB,oBAAoB,CAACH,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACpE,IAAI,CAAC8B,KAAK,GAAG,KAAK;IAClB,IAAI,CAACO,YAAY,GAAG7C,KAAK,CAACC,gBAAgB,CAAC2C,YAAY,CAAC;IACxD/C,KAAK,CAAC,sBAAsB,IAAI,CAACyC,KAAK,EAAE,CAAC;IACzC,MAAMQ,sBAAsB,GAAGpD,MAAM,CAACgB,oBAAoB,CAACH,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC9E,IAAI,CAACY,YAAY,GAAGpB,KAAK,CAACE,mBAAmB,CAAC4C,sBAAsB,CAAC;IACrEjD,KAAK,CAAC,iBAAiB,IAAI,CAACuB,YAAY,EAAE,CAAC;IAC3C,MAAM2B,YAAY,GAAGrD,MAAM,CAACgB,oBAAoB,CAACH,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACpE,IAAI,CAACwC,gBAAgB,GAAG5C,2BAA2B,CAAC2C,YAAY,CAAC;IACjElD,KAAK,CAAC,kBAAkB,IAAI,CAACmD,gBAAgB,CAACC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;IAC1D,IAAI,CAACC,WAAW,GAAGxD,MAAM,CAACgB,oBAAoB,CAACH,GAAG,EAAEC,GAAG,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE;EAC5E;EACAgC,WAAWA,CAAA,EAAG;IACV,IAAI,IAAI,CAACb,YAAY,KAAK,IAAI;IAAI;IAC9B,IAAI,CAACA,YAAY,KAAK,IAAI,EAAE;MAAE;MAC9B;IACJ;IACA,MAAMwB,UAAU,GAAG,GAAGC,IAAI,CAACC,KAAK,CAAC,IAAI,CAAC/B,OAAO,CAAC,GAAG,IAAI,CAACX,KAAK,EAAE;IAC7D,OAAON,eAAe,CAACiD,aAAa,CAAC,IAAI,CAAC3B,YAAY,CAAC,CAACwB,UAAU,CAAC;EACvE;EACAR,gBAAgBA,CAAA,EAAG;IACf,IAAI,IAAI,CAACf,iBAAiB,KAAK,IAAI,EAC/B,OAAO,IAAI,CAAC,CAAC;IACjB,OAAOvB,eAAe,CAACkD,wBAAwB,CAAC,IAAI,CAACjC,OAAO,CAAC,CAAC,IAAI,CAACM,iBAAiB,CAAC;EACzF;AACJ;AACAvB,eAAe,CAACmD,SAAS,GAAG,IAAI;AAChCnD,eAAe,CAACoD,SAAS,GAAG,IAAI;AAChCpD,eAAe,CAAC8B,SAAS,GAAG,CAAC,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;AAC7C9B,eAAe,CAACO,gBAAgB,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAC/CP,eAAe,CAACgC,WAAW,GAAG,CAAC,QAAQ,EAAE,cAAc,EAAE,cAAc,EAAE,MAAM,CAAC;AAChFhC,eAAe,CAACiD,aAAa,GAAG;EAC5B,IAAI,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,CAAC;IAAE,EAAE,EAAE;EAAE,CAAC;EACtD,IAAI,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE;EAAG,CAAC;EACxD,IAAI,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE;EAAG,CAAC;EACxD,IAAI,EAAE;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE;EAAG,CAAC;EACzD,IAAI,EAAE;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE;EAAG,CAAC;EACzD,IAAI,EAAE;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE;EAAG,CAAC;EACzD,IAAI,EAAE;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE;EAAG,CAAC;EAC3D,IAAI,EAAE;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE;EAAG,CAAC;EAC5D,IAAI,EAAE;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE;EAAG,CAAC;EAC5D,IAAI,EAAE;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,EAAE;IAAE,EAAE,EAAE;EAAG,CAAC;EAC5D,IAAI,EAAE;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE;EAAI,CAAC;EAC9D,IAAI,EAAE;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE;EAAI,CAAC;EAC9D,IAAI,EAAE;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE;EAAI,CAAC;EAC9D,IAAI,EAAE;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE,GAAG;IAAE,EAAE,EAAE;EAAI;AACjE,CAAC;AACDjD,eAAe,CAACkD,wBAAwB,GAAG;EACvC,CAAC,EAAE;IAAE,IAAI,EAAE,KAAK;IAAE,IAAI,EAAE,KAAK;IAAE,IAAI,EAAE;EAAM,CAAC;EAC5C,CAAC,EAAE;IAAE,IAAI,EAAE,KAAK;IAAE,IAAI,EAAE,KAAK;IAAE,IAAI,EAAE;EAAM,CAAC;EAC5C,GAAG,EAAE;IAAE,IAAI,EAAE,KAAK;IAAE,IAAI,EAAE,KAAK;IAAE,IAAI,EAAE;EAAK;AAChD,CAAC;AACDlD,eAAe,CAACgB,mBAAmB,GAAG,CAClC;AACA,CAAC,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,EACpB,CAAC,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;AAAA,CACvB;AACD;AACA;AACA;AACA,MAAMqC,WAAW,GAAG;EAChBC,GAAG,EAAE,CAAC;EACNC,GAAG,EAAEA,CAACrD,GAAG,EAAEC,GAAG,KAAK;IACf,OAAO,IAAIH,eAAe,CAACE,GAAG,EAAEC,GAAG,CAAC;EACxC;AACJ,CAAC;AACD,SAASqD,kBAAkBA,CAACC,QAAQ,EAAE;EAClC,OAAO,GAAG,GAAGV,IAAI,CAACC,KAAK,CAAC,CAAC,GAAG,GAAGS,QAAQ,IAAI,EAAE,CAAC;AAClD;AACA,MAAMzE,UAAU,SAASM,mBAAmB,CAACoE,iBAAiB,CAAC;EAC3DzD,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,GAAG0D,SAAS,CAAC;IACnB,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,cAAc,GAAG,CAAC,CAAC;IACxB,IAAI,CAACC,kBAAkB,GAAG,CAAC;IAC3B,IAAI,CAACC,eAAe,GAAG,CAAC;IACxB,IAAI,CAACC,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACC,oBAAoB,GAAG,KAAK;IACjC,IAAI,CAACC,gBAAgB,GAAGC,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;IACvC,IAAI,CAACC,QAAQ,GAAG;MACZnE,GAAG,EAAEiE,MAAM,CAACC,KAAK,CAAC1E,UAAU,CAAC;MAC7B4D,GAAG,EAAE;IACT,CAAC;EACL;EACA;AACJ;AACA;EACI,MAAMgB,cAAcA,CAAA,EAAG;IACnB,IAAI,CAACC,QAAQ,CAACC,SAAS,CAAC,UAAU,EAAE,KAAK,CAAC;IAC1C,IAAI;MACA,IAAIC,IAAI,GAAG,KAAK;MAChB,OAAO,CAACA,IAAI,EAAE;QACV,MAAM,IAAI,CAACC,IAAI,CAAC,CAAC;QACjBD,IAAI,GAAG,MAAM,IAAI,CAACE,qBAAqB,CAAC,CAAC;MAC7C;IACJ,CAAC,CACD,OAAOC,GAAG,EAAE;MACR,IAAIA,GAAG,YAAYzF,MAAM,CAAC0F,gBAAgB,EAAE;QACxCrF,KAAK,CAAC,eAAe,CAAC;QACtB,IAAI,IAAI,CAACyE,oBAAoB,EAAE;UAC3B,MAAMa,eAAe,GAAG,IAAI,CAAClB,UAAU,GAAG,IAAI,CAACmB,eAAe;UAC9D,IAAI,CAACR,QAAQ,CAACC,SAAS,CAAC,iBAAiB,EAAEM,eAAe,CAAC;UAC3D,MAAME,QAAQ,GAAGF,eAAe,GAAG,IAAI,CAACP,QAAQ,CAACU,MAAM,CAACC,UAAU;UAClE1F,KAAK,CAAC,8BAA8BwF,QAAQ,OAAO,EAAEA,QAAQ,CAAC;UAC9D,IAAI,CAACT,QAAQ,CAACC,SAAS,CAAC,UAAU,EAAEQ,QAAQ,CAAC;QACjD;MACJ,CAAC,MACI;QACD,MAAMJ,GAAG;MACb;IACJ;EACJ;EACA;AACJ;AACA;EACIO,QAAQA,CAAA,EAAG;IACP,MAAMF,MAAM,GAAG,IAAI,CAACV,QAAQ,CAACU,MAAM;IACnC,MAAMG,QAAQ,GAAG,IAAI,CAACb,QAAQ,CAACc,MAAM,CAACC,cAAc,CAAC,OAAO,CAAC;IAC7D,IAAIL,MAAM,CAACD,QAAQ,IAAI,IAAI,CAACO,SAAS,CAACC,QAAQ,CAACC,IAAI,EAAE;MACjD,MAAMC,QAAQ,GAAG,IAAI,CAACH,SAAS,CAACC,QAAQ,CAACC,IAAI,GAAG,IAAI,CAACE,UAAU,IAAIP,QAAQ,GAAG,GAAG,GAAG,CAAC,CAAC;MACtF,IAAIH,MAAM,CAACzC,YAAY,IAAIyC,MAAM,CAACzC,YAAY,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QACvD,IAAI,CAAC+B,QAAQ,CAACC,SAAS,CAAC,SAAS,EAAEkB,QAAQ,GAAG,CAAC,GAAGT,MAAM,CAACD,QAAQ,CAAC;MACtE;IACJ,CAAC,MACI,IAAI,IAAI,CAACO,SAAS,CAACC,QAAQ,CAACC,IAAI,IAAIR,MAAM,CAACzC,YAAY,KAAK,KAAK,EAAE;MACpE,MAAMkD,QAAQ,GAAG,IAAI,CAACH,SAAS,CAACC,QAAQ,CAACC,IAAI,GAAG,IAAI,CAACE,UAAU,IAAIP,QAAQ,GAAG,GAAG,GAAG,CAAC,CAAC;MACtF,MAAMN,eAAe,GAAG/B,IAAI,CAAC6C,KAAK,CAACF,QAAQ,GAAG,IAAI,CAACG,UAAU,CAAC,GAAG,IAAI,CAACd,eAAe;MACrF,IAAI,CAACR,QAAQ,CAACC,SAAS,CAAC,iBAAiB,EAAEM,eAAe,CAAC;MAC3D,MAAME,QAAQ,GAAGF,eAAe,GAAGG,MAAM,CAACC,UAAU;MACpD1F,KAAK,CAAC,+CAA+C,EAAEwF,QAAQ,CAAC;MAChE,IAAI,CAACT,QAAQ,CAACC,SAAS,CAAC,UAAU,EAAEQ,QAAQ,CAAC;IACjD;EACJ;EACA,MAAMN,IAAIA,CAAA,EAAG;IACT,IAAIoB,YAAY,GAAG,KAAK;IACxB,OAAO,IAAI,EAAE;MACT,IAAIC,EAAE,GAAG,CAAC;MACV,IAAI,CAAC1B,QAAQ,CAACf,GAAG,GAAG,MAAM,IAAI,CAACiC,SAAS,CAACS,UAAU,CAAC,IAAI,CAAC3B,QAAQ,CAACnE,GAAG,EAAE;QAAE+F,MAAM,EAAEvG,UAAU;QAAEwG,SAAS,EAAE;MAAK,CAAC,CAAC;MAC/G,IAAI,IAAI,CAAC7B,QAAQ,CAACf,GAAG,IAAI,GAAG,EAAE;QAC1B,MAAM,IAAInE,MAAM,CAAC0F,gBAAgB,CAAC,CAAC;MACvC;MACA,OAAO,IAAI,EAAE;QACT,IAAIiB,YAAY,IAAI,CAAC,IAAI,CAACzB,QAAQ,CAACnE,GAAG,CAAC6F,EAAE,CAAC,GAAG,IAAI,MAAM,IAAI,EAAE;UACzD,IAAI,CAAC7B,gBAAgB,CAAC,CAAC,CAAC,GAAGlE,eAAe,CAACmD,SAAS;UACpD,IAAI,CAACe,gBAAgB,CAAC,CAAC,CAAC,GAAG,IAAI,CAACG,QAAQ,CAACnE,GAAG,CAAC6F,EAAE,CAAC;UAChD,MAAM,IAAI,CAACR,SAAS,CAACY,MAAM,CAACJ,EAAE,CAAC;UAC/BvG,KAAK,CAAC,kBAAkB,IAAI,CAAC+F,SAAS,CAACa,QAAQ,GAAG,CAAC,gBAAgB,IAAI,CAACxC,UAAU,EAAE,CAAC;UACrF,IAAI,IAAI,CAACC,cAAc,KAAK,IAAI,CAACD,UAAU,EAAE;YACzCpE,KAAK,CAAC,qCAAqC,IAAI,CAACoE,UAAU,EAAE,CAAC;YAC7D,IAAI,CAACA,UAAU,GAAG,CAAC;YACnB,IAAI,CAACiC,UAAU,GAAG,CAAC;UACvB;UACA,IAAI,CAAChC,cAAc,GAAG,IAAI,CAACD,UAAU;UACrC,OAAO,CAAC;QACZ,CAAC,MACI;UACDkC,YAAY,GAAG,KAAK;UACpBC,EAAE,GAAG,IAAI,CAAC1B,QAAQ,CAACnE,GAAG,CAACmG,OAAO,CAACrG,eAAe,CAACmD,SAAS,EAAE4C,EAAE,CAAC;UAC7D,IAAIA,EAAE,KAAK,CAAC,CAAC,EAAE;YACX,IAAI,IAAI,CAAC1B,QAAQ,CAACf,GAAG,GAAG,IAAI,CAACe,QAAQ,CAACnE,GAAG,CAAC+F,MAAM,EAAE;cAC9C,MAAM,IAAI9G,MAAM,CAAC0F,gBAAgB,CAAC,CAAC;YACvC;YACA,MAAM,IAAI,CAACU,SAAS,CAACY,MAAM,CAAC,IAAI,CAAC9B,QAAQ,CAACf,GAAG,CAAC;YAC9C,MAAM,CAAC;UACX,CAAC,MACI;YACD,EAAEyC,EAAE;YACJD,YAAY,GAAG,IAAI;UACvB;QACJ;MACJ;IACJ;EACJ;EACA;AACJ;AACA;AACA;EACI,MAAMnB,qBAAqBA,CAAA,EAAG;IAC1B,IAAI,IAAI,CAACf,UAAU,KAAK,CAAC,EAAE;MACvB,IAAI,CAAC+B,UAAU,GAAG,IAAI,CAACJ,SAAS,CAACa,QAAQ,GAAG,CAAC;IACjD;IACA,MAAM,IAAI,CAACb,SAAS,CAACS,UAAU,CAAC,IAAI,CAAC9B,gBAAgB,EAAE;MAAEoC,MAAM,EAAE,CAAC;MAAEL,MAAM,EAAE;IAAE,CAAC,CAAC;IAChF,IAAIM,MAAM;IACV,IAAI;MACAA,MAAM,GAAGlD,WAAW,CAACE,GAAG,CAAC,IAAI,CAACW,gBAAgB,EAAE,CAAC,CAAC;IACtD,CAAC,CACD,OAAOU,GAAG,EAAE;MACR,MAAM,IAAI,CAACW,SAAS,CAACY,MAAM,CAAC,CAAC,CAAC;MAC9B,IAAI,CAAC5B,QAAQ,CAACiC,UAAU,CAAC,eAAe,GAAG5B,GAAG,CAAC6B,OAAO,CAAC;MACvD,OAAO,KAAK,CAAC,CAAC;IAClB;IACA,MAAM,IAAI,CAAClB,SAAS,CAACY,MAAM,CAAC,CAAC,CAAC;IAC9B,IAAI,CAAC5B,QAAQ,CAACC,SAAS,CAAC,WAAW,EAAE+B,MAAM,CAAClF,SAAS,CAAC;IACtD,IAAI,CAACkD,QAAQ,CAACC,SAAS,CAAC,OAAO,EAAE+B,MAAM,CAACtE,KAAK,CAAC;IAC9C,IAAI,CAACsC,QAAQ,CAACC,SAAS,CAAC,UAAU,EAAE,KAAK,CAAC;IAC1C,IAAI,CAACD,QAAQ,CAACC,SAAS,CAAC,YAAY,EAAE+B,MAAM,CAACxF,YAAY,CAAC;IAC1D,IAAI,CAAC6C,UAAU,EAAE;IACjB,OAAO2C,MAAM,CAACtF,OAAO,IAAI,CAAC,IAAIsF,MAAM,CAACjG,KAAK,KAAK,CAAC,GAAG,IAAI,CAACoG,SAAS,CAACH,MAAM,CAAC,GAAG,IAAI,CAACI,qBAAqB,CAACJ,MAAM,CAAC;EAClH;EACA;AACJ;AACA;EACI,MAAMI,qBAAqBA,CAACJ,MAAM,EAAE;IAChC,IAAI,CAAChC,QAAQ,CAACC,SAAS,CAAC,kBAAkB,EAAE+B,MAAM,CAACxE,WAAW,KAAK,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;IAClF,IAAI,CAACwC,QAAQ,CAACC,SAAS,CAAC,SAAS,EAAE+B,MAAM,CAAClE,OAAO,CAAC;IAClD,IAAI,IAAI,CAACuB,UAAU,GAAG,EAAE,GAAG,KAAK,EAAE;MAC9BpE,KAAK,CAAC,0CAA0C,EAAE,IAAI,CAAC+F,SAAS,CAACa,QAAQ,GAAG,CAAC,EAAEG,MAAM,CAACjG,KAAK,EAAEiG,MAAM,CAAClE,OAAO,EAAEkE,MAAM,CAACxF,YAAY,CAAC;IACrI;IACA,MAAM6F,SAAS,GAAGL,MAAM,CAACnF,YAAY,CAAC,CAAC;IACvC,IAAIwF,SAAS,KAAK,IAAI,EAAE;MACpB,MAAM,IAAIxE,KAAK,CAAC,mBAAmB,CAAC;IACxC;IACA,MAAMyE,iBAAiB,GAAGN,MAAM,CAACzF,mBAAmB,CAAC,CAAC;IACtDtB,KAAK,CAAC,qBAAqBqH,iBAAiB,EAAE,CAAC;IAC/C,MAAMC,GAAG,GAAGD,iBAAiB,GAAG,GAAG;IACnC,MAAME,KAAK,GAAID,GAAG,GAAGP,MAAM,CAAClE,OAAO,GAAGkE,MAAM,CAACxF,YAAY,IACnDwF,MAAM,CAAC/E,OAAO,GAAIoF,SAAS,GAAG,CAAC,CAAC;IACtC,IAAI,CAACf,UAAU,GAAG9C,IAAI,CAACC,KAAK,CAAC+D,KAAK,CAAC;IACnC,IAAI,CAACC,gBAAgB,GAAGT,MAAM;IAC9B,IAAI,CAACvC,QAAQ,CAACiD,IAAI,CAACV,MAAM,CAAClE,OAAO,CAAC;IAClC;IACA,IAAI,IAAI,CAACuB,UAAU,KAAK,CAAC,EAAE;MACvB,IAAI,CAAC0C,MAAM,GAAGjD,WAAW,CAACC,GAAG;MAC7B,MAAM,IAAI,CAAC4D,mBAAmB,CAAC,CAAC;MAChC,OAAO,KAAK;IAChB;IACA,IAAI,IAAI,CAACtD,UAAU,KAAK,CAAC,EAAE;MACvB;MACA,IAAI,IAAI,CAACuD,UAAU,CAAC,IAAI,CAACnD,QAAQ,CAAC,EAAE;QAChC;QACA,IAAI,CAACe,eAAe,GAAG8B,iBAAiB;QACxC,IAAI,CAACtC,QAAQ,CAACC,SAAS,CAAC,cAAc,EAAE,KAAK,CAAC;QAC9C,IAAI,IAAI,CAACe,SAAS,CAACC,QAAQ,CAACC,IAAI,EAC5B,OAAO,IAAI,CAAC,CAAC;MACrB,CAAC,MACI,IAAI,IAAI,CAAClB,QAAQ,CAACU,MAAM,CAACD,QAAQ,EAAE;QACpC,OAAO,IAAI,CAAC,CAAC;MACjB;MACA,IAAI,CAAC,IAAI,CAACoC,OAAO,CAACpC,QAAQ,EAAE;QACxB,OAAO,IAAI,CAAC,CAAC;MACjB;IACJ;IACA;IACA;IACA;IACA,IAAI,IAAI,CAACoC,OAAO,CAACpC,QAAQ,IAAI,IAAI,CAACpB,UAAU,KAAK,CAAC,EAAE;MAChD,IAAI,CAACmB,eAAe,GAAG8B,iBAAiB;MACxC,IAAI,CAAC5C,oBAAoB,GAAG,IAAI;IACpC;IACA,IAAI,CAACqC,MAAM,GAAG,CAAC;IACf,IAAIC,MAAM,CAAC7F,gBAAgB,EAAE;MACzB,MAAM,IAAI,CAAC2G,QAAQ,CAAC,CAAC;MACrB,OAAO,KAAK;IAChB,CAAC,MACI;MACD,MAAM,IAAI,CAACH,mBAAmB,CAAC,CAAC;MAChC,OAAO,KAAK;IAChB;EACJ;EACA,MAAMR,SAASA,CAACH,MAAM,EAAE;IACpB,MAAMrG,GAAG,GAAGiE,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;IAC3B,MAAM,IAAI,CAACmB,SAAS,CAAC+B,UAAU,CAACpH,GAAG,CAAC;IACpCqG,MAAM,CAAC1D,WAAW,IAAIxD,MAAM,CAACgB,oBAAoB,CAACH,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;IAChE,IAAI,CAAC6D,eAAe,IAAIwC,MAAM,CAAC1D,WAAW;IAC1C,IAAI,CAACkC,eAAe,GAAG,IAAI;IAC3B,MAAMwC,YAAY,GAAGhB,MAAM,CAACxF,YAAY,GAAG,IAAI,CAACgE,eAAe;IAC/D,MAAMyC,aAAa,GAAG,IAAI,CAAC5D,UAAU,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI,CAACG,eAAe,GAAG,IAAI,CAACH,UAAU;IACxF,MAAMvB,OAAO,GAAG,CAAC,GAAGmF,aAAa,GAAGD,YAAY,GAAG,GAAG;IACtD,IAAI,CAAChD,QAAQ,CAACC,SAAS,CAAC,SAAS,EAAEnC,OAAO,CAAC;IAC3C7C,KAAK,CAAC,eAAe,IAAI,CAACoE,UAAU,UAAU2C,MAAM,CAAC1D,WAAW,oBAAoBR,OAAO,EAAE,CAAC;IAC9F,MAAM,IAAI,CAACkD,SAAS,CAACY,MAAM,CAACI,MAAM,CAAC1D,WAAW,GAAG,CAAC,GAAG0D,MAAM,CAAC1D,WAAW,GAAG,CAAC,GAAG,CAAC,CAAC;IAChF;IACA,IAAI,IAAI,CAACe,UAAU,KAAK,CAAC,EAAE;MACvB,IAAI,CAACW,QAAQ,CAACC,SAAS,CAAC,cAAc,EAAE+B,MAAM,CAAC/D,YAAY,CAAC;MAC5D,IAAI+D,MAAM,CAAC5D,gBAAgB,EAAE;QACzB,IAAI,CAAC4B,QAAQ,CAACC,SAAS,CAAC,kBAAkB,EAAE+B,MAAM,CAAC5D,gBAAgB,CAACsD,MAAM,CAAC;MAC/E;MACA,IAAI,IAAI,CAACmB,OAAO,CAACpC,QAAQ,EAAE;QACvB,IAAI,CAACf,oBAAoB,GAAG,IAAI;MACpC,CAAC,MACI;QACD,OAAO,IAAI,CAAC,CAAC;MACjB;IACJ;IACA,OAAO,KAAK;EAChB;EACA,MAAMoD,QAAQA,CAAA,EAAG;IACb,IAAI,CAACI,GAAG,GAAG,MAAM,IAAI,CAAClC,SAAS,CAACmC,UAAU,CAACzI,KAAK,CAAC0I,QAAQ,CAAC;IAC1D,IAAI,CAACrB,MAAM,IAAI,CAAC;IAChB,OAAO,IAAI,CAACY,mBAAmB,CAAC,CAAC;EACrC;EACA,MAAMA,mBAAmBA,CAAA,EAAG;IACxB,MAAMU,eAAe,GAAG,IAAI,CAACZ,gBAAgB,CAAC9F,uBAAuB,CAAC,CAAC;IACvE;IACA,MAAM,IAAI,CAACqE,SAAS,CAACsC,SAAS,CAAC,IAAI5I,KAAK,CAAC6I,cAAc,CAACF,eAAe,CAAC,CAAC;IACzE,IAAI,CAACtB,MAAM,IAAIsB,eAAe;IAC9B,MAAM,IAAI,CAACG,kBAAkB,CAAC,CAAC;IAC/B;EACJ;EACA,MAAMA,kBAAkBA,CAAA,EAAG;IACvB,MAAMC,SAAS,GAAG,MAAM,IAAI,CAACzC,SAAS,CAACsC,SAAS,CAACtI,SAAS,CAAC0I,gBAAgB,CAAC;IAC5E,IAAI,CAAC3B,MAAM,IAAI/G,SAAS,CAAC0I,gBAAgB,CAAC3E,GAAG,CAAC,CAAC;IAC/C,QAAQ0E,SAAS;MACb,KAAK,MAAM;QACP,IAAI,CAACzD,QAAQ,CAACC,SAAS,CAAC,cAAc,EAAE,KAAK,CAAC;QAC9C,OAAO,IAAI,CAAC0D,kBAAkB,CAAC,CAAC;MACpC,KAAK,MAAM;QACP,MAAMC,OAAO,GAAG,MAAM,IAAI,CAACD,kBAAkB,CAAC,CAAC;QAC/C,MAAM1F,YAAY,GAAGgB,kBAAkB,CAAC2E,OAAO,CAAC1E,QAAQ,CAAC;QACzD,IAAI,CAACc,QAAQ,CAACC,SAAS,CAAC,cAAc,EAAEhC,YAAY,CAAC;QACrD,OAAO,IAAI;MACf,KAAK,MAAM;QACP;QACA;MACJ,KAAK,MAAM;QACP,MAAMvB,OAAO,GAAG,MAAM,IAAI,CAACsE,SAAS,CAACsC,SAAS,CAACtI,SAAS,CAAC6I,kBAAkB,CAAC;QAC5E,IAAI,IAAI,CAACvC,UAAU,IAAI,IAAI,CAACS,MAAM,GAAG/G,SAAS,CAAC6I,kBAAkB,CAAC9E,GAAG,EAAE;UACnE,IAAI,CAACgD,MAAM,IAAI/G,SAAS,CAAC6I,kBAAkB,CAAC9E,GAAG;UAC/C,IAAI,CAACiB,QAAQ,CAACC,SAAS,CAAC,MAAM,EAAE,OAAO,GAAGvD,OAAO,CAAC;UAClD,MAAM,IAAI,CAACoH,aAAa,CAAC,IAAI,CAACxC,UAAU,GAAG,IAAI,CAACS,MAAM,CAAC;UACvD,OAAO,IAAI;QACf,CAAC,MACI;UACD,IAAI,CAAC/B,QAAQ,CAACiC,UAAU,CAAC,qBAAqB,CAAC;UAC/C;QACJ;MACJ;IACJ;IACA;IACA,MAAM8B,aAAa,GAAG,IAAI,CAACzC,UAAU,GAAG,IAAI,CAACS,MAAM;IACnD,IAAIgC,aAAa,GAAG,CAAC,EAAE;MACnB,IAAI,CAAC/D,QAAQ,CAACiC,UAAU,CAAC,QAAQ,GAAG,IAAI,CAAC5C,UAAU,GAAG,iCAAiC,CAAC;IAC5F,CAAC,MACI;MACD,MAAM,IAAI,CAACyE,aAAa,CAACC,aAAa,CAAC;IAC3C;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;EACI,MAAMJ,kBAAkBA,CAAA,EAAG;IACvB,MAAM5B,MAAM,GAAG,IAAI,CAACf,SAAS,CAACa,QAAQ;IACtC,MAAM+B,OAAO,GAAG,MAAM,CAAC,CAAC,EAAE5I,SAAS,CAACgJ,cAAc,EAAE,IAAI,CAAChD,SAAS,CAAC;IACnE,IAAI,CAACe,MAAM,IAAI,IAAI,CAACf,SAAS,CAACa,QAAQ,GAAGE,MAAM;IAC/C,IAAI6B,OAAO,CAACK,IAAI,EAAE;MACd,IAAI,CAACjE,QAAQ,CAACC,SAAS,CAAC,MAAM,EAAE,OAAO,GAAGnF,MAAM,CAACoJ,UAAU,CAACN,OAAO,CAACK,IAAI,CAACvH,OAAO,CAAC,CAAC;MAClF,IAAIkH,OAAO,CAACK,IAAI,CAACE,QAAQ,EAAE;QACvB;QACA,IAAI,CAACnE,QAAQ,CAACC,SAAS,CAAC,gBAAgB,EAAE2D,OAAO,CAACK,IAAI,CAACE,QAAQ,CAACC,UAAU,CAAC;QAC3E,IAAIR,OAAO,CAACK,IAAI,CAACE,QAAQ,CAACE,UAAU,EAAE;UAClC,IAAI,CAACrE,QAAQ,CAACC,SAAS,CAAC,WAAW,EAAE2D,OAAO,CAACK,IAAI,CAACE,QAAQ,CAACE,UAAU,CAACC,UAAU,CAAC;QACrF;QACA,IAAIV,OAAO,CAACK,IAAI,CAACE,QAAQ,CAACI,UAAU,EAAE;UAClC,IAAI,CAACvE,QAAQ,CAACC,SAAS,CAAC,WAAW,EAAE2D,OAAO,CAACK,IAAI,CAACE,QAAQ,CAACI,UAAU,CAACD,UAAU,CAAC;QACrF;QACA,IAAI,CAACtE,QAAQ,CAACC,SAAS,CAAC,UAAU,EAAE2D,OAAO,CAACK,IAAI,CAACE,QAAQ,CAACK,YAAY,GAAG,IAAI,CAAC;MAClF;IACJ;IACA,IAAIZ,OAAO,CAACa,UAAU,EAAE;MACpB,MAAMhE,QAAQ,GAAG,IAAI,CAACgC,gBAAgB,CAACpG,YAAY,CAACuH,OAAO,CAACtH,SAAS,CAAC;MACtE,IAAI,CAAC0D,QAAQ,CAACC,SAAS,CAAC,UAAU,EAAEQ,QAAQ,CAAC;MAC7CxF,KAAK,CAAC,mCAAmC,EAAE,IAAI,CAAC+E,QAAQ,CAACU,MAAM,CAACD,QAAQ,CAAC;MACzE,OAAOmD,OAAO;IAClB;IACA;IACA,MAAMG,aAAa,GAAG,IAAI,CAACzC,UAAU,GAAG,IAAI,CAACS,MAAM;IACnD,MAAM,IAAI,CAAC+B,aAAa,CAACC,aAAa,CAAC;IACvC,OAAOH,OAAO;EAClB;EACA,MAAME,aAAaA,CAACC,aAAa,EAAE;IAC/B,IAAIA,aAAa,GAAG,CAAC,EACjB,MAAM,IAAIlG,KAAK,CAAC,oCAAoC,CAAC;IACzD,MAAM,IAAI,CAACmD,SAAS,CAACY,MAAM,CAACmC,aAAa,CAAC;IAC1C,IAAI,CAACxE,kBAAkB,IAAIwE,aAAa;EAC5C;EACAnB,UAAUA,CAAC8B,KAAK,EAAE;IACd,MAAMC,KAAK,GAAGD,KAAK,CAAC,CAAC,CAAC;IACtB,OAAOA,KAAK,CAACE,KAAK,CAACC,OAAO,IAAI;MAC1B,OAAOA,OAAO,KAAKF,KAAK;IAC5B,CAAC,CAAC;EACN;AACJ;AACApK,OAAO,CAACE,UAAU,GAAGA,UAAU","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}