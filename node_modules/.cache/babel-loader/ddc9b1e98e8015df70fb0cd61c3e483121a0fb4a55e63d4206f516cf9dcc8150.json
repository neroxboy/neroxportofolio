{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertMediaContent = exports.downloadMediaMessage = exports.aggregateMessageKeysNotFromMe = exports.getAggregateVotesInPollMessage = exports.updateMessageWithPollUpdate = exports.updateMessageWithReaction = exports.updateMessageWithReceipt = exports.getDevice = exports.extractMessageContent = exports.normalizeMessageContent = exports.getContentType = exports.generateWAMessage = exports.generateWAMessageFromContent = exports.generateWAMessageContent = exports.generateForwardMessageContent = exports.prepareDisappearingMessageSettingContent = exports.prepareWAMessageMedia = exports.generateLinkPreviewIfRequired = exports.extractUrlFromText = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst axios_1 = __importDefault(require(\"axios\"));\nconst crypto_1 = require(\"crypto\");\nconst fs_1 = require(\"fs\");\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst Types_1 = require(\"../Types\");\nconst WABinary_1 = require(\"../WABinary\");\nconst crypto_2 = require(\"./crypto\");\nconst generics_1 = require(\"./generics\");\nconst messages_media_1 = require(\"./messages-media\");\nconst MIMETYPE_MAP = {\n  image: 'image/jpeg',\n  video: 'video/mp4',\n  document: 'application/pdf',\n  audio: 'audio/ogg; codecs=opus',\n  sticker: 'image/webp',\n  'product-catalog-image': 'image/jpeg'\n};\nconst MessageTypeProto = {\n  'image': Types_1.WAProto.Message.ImageMessage,\n  'video': Types_1.WAProto.Message.VideoMessage,\n  'audio': Types_1.WAProto.Message.AudioMessage,\n  'sticker': Types_1.WAProto.Message.StickerMessage,\n  'document': Types_1.WAProto.Message.DocumentMessage\n};\n/**\n * Uses a regex to test whether the string contains a URL, and returns the URL if it does.\n * @param text eg. hello https://google.com\n * @returns the URL, eg. https://google.com\n */\nconst extractUrlFromText = text => {\n  var _a;\n  return (_a = text.match(Defaults_1.URL_REGEX)) === null || _a === void 0 ? void 0 : _a[0];\n};\nexports.extractUrlFromText = extractUrlFromText;\nconst generateLinkPreviewIfRequired = async (text, getUrlInfo, logger) => {\n  const url = (0, exports.extractUrlFromText)(text);\n  if (!!getUrlInfo && url) {\n    try {\n      const urlInfo = await getUrlInfo(url);\n      return urlInfo;\n    } catch (error) {\n      // ignore if fails\n      logger === null || logger === void 0 ? void 0 : logger.warn({\n        trace: error.stack\n      }, 'url generation failed');\n    }\n  }\n};\nexports.generateLinkPreviewIfRequired = generateLinkPreviewIfRequired;\nconst assertColor = async color => {\n  let assertedColor;\n  if (typeof color === 'number') {\n    assertedColor = color > 0 ? color : 0xffffffff + Number(color) + 1;\n  } else {\n    let hex = color.trim().replace('#', '');\n    if (hex.length <= 6) {\n      hex = 'FF' + hex.padStart(6, '0');\n    }\n    assertedColor = parseInt(hex, 16);\n    return assertedColor;\n  }\n};\nconst prepareWAMessageMedia = async (message, options) => {\n  const logger = options.logger;\n  let mediaType;\n  for (const key of Defaults_1.MEDIA_KEYS) {\n    if (key in message) {\n      mediaType = key;\n    }\n  }\n  if (!mediaType) {\n    throw new boom_1.Boom('Invalid media type', {\n      statusCode: 400\n    });\n  }\n  const uploadData = {\n    ...message,\n    media: message[mediaType]\n  };\n  delete uploadData[mediaType];\n  // check if cacheable + generate cache key\n  const cacheableKey = typeof uploadData.media === 'object' && 'url' in uploadData.media && !!uploadData.media.url && !!options.mediaCache &&\n  // generate the key\n  mediaType + ':' + uploadData.media.url.toString();\n  if (mediaType === 'document' && !uploadData.fileName) {\n    uploadData.fileName = 'file';\n  }\n  if (!uploadData.mimetype) {\n    uploadData.mimetype = MIMETYPE_MAP[mediaType];\n  }\n  // check for cache hit\n  if (cacheableKey) {\n    const mediaBuff = options.mediaCache.get(cacheableKey);\n    if (mediaBuff) {\n      logger === null || logger === void 0 ? void 0 : logger.debug({\n        cacheableKey\n      }, 'got media cache hit');\n      const obj = Types_1.WAProto.Message.decode(mediaBuff);\n      const key = `${mediaType}Message`;\n      Object.assign(obj[key], {\n        ...uploadData,\n        media: undefined\n      });\n      return obj;\n    }\n  }\n  const requiresDurationComputation = mediaType === 'audio' && typeof uploadData.seconds === 'undefined';\n  const requiresThumbnailComputation = (mediaType === 'image' || mediaType === 'video') && typeof uploadData['jpegThumbnail'] === 'undefined';\n  const requiresWaveformProcessing = mediaType === 'audio' && uploadData.ptt === true;\n  const requiresAudioBackground = options.backgroundColor && mediaType === 'audio' && uploadData.ptt === true;\n  const requiresOriginalForSomeProcessing = requiresDurationComputation || requiresThumbnailComputation;\n  const {\n    mediaKey,\n    encWriteStream,\n    bodyPath,\n    fileEncSha256,\n    fileSha256,\n    fileLength,\n    didSaveToTmpPath\n  } = await (0, messages_media_1.encryptedStream)(uploadData.media, options.mediaTypeOverride || mediaType, {\n    logger,\n    saveOriginalFileIfRequired: requiresOriginalForSomeProcessing,\n    opts: options.options\n  });\n  // url safe Base64 encode the SHA256 hash of the body\n  const fileEncSha256B64 = fileEncSha256.toString('base64');\n  const [{\n    mediaUrl,\n    directPath\n  }] = await Promise.all([(async () => {\n    const result = await options.upload(encWriteStream, {\n      fileEncSha256B64,\n      mediaType,\n      timeoutMs: options.mediaUploadTimeoutMs\n    });\n    logger === null || logger === void 0 ? void 0 : logger.debug({\n      mediaType,\n      cacheableKey\n    }, 'uploaded media');\n    return result;\n  })(), (async () => {\n    try {\n      if (requiresThumbnailComputation) {\n        const {\n          thumbnail,\n          originalImageDimensions\n        } = await (0, messages_media_1.generateThumbnail)(bodyPath, mediaType, options);\n        uploadData.jpegThumbnail = thumbnail;\n        if (!uploadData.width && originalImageDimensions) {\n          uploadData.width = originalImageDimensions.width;\n          uploadData.height = originalImageDimensions.height;\n          logger === null || logger === void 0 ? void 0 : logger.debug('set dimensions');\n        }\n        logger === null || logger === void 0 ? void 0 : logger.debug('generated thumbnail');\n      }\n      if (requiresDurationComputation) {\n        uploadData.seconds = await (0, messages_media_1.getAudioDuration)(bodyPath);\n        logger === null || logger === void 0 ? void 0 : logger.debug('computed audio duration');\n      }\n      if (requiresWaveformProcessing) {\n        uploadData.waveform = await (0, messages_media_1.getAudioWaveform)(bodyPath, logger);\n        logger === null || logger === void 0 ? void 0 : logger.debug('processed waveform');\n      }\n      if (requiresWaveformProcessing) {\n        uploadData.waveform = await (0, messages_media_1.getAudioWaveform)(bodyPath, logger);\n        logger === null || logger === void 0 ? void 0 : logger.debug('processed waveform');\n      }\n      if (requiresAudioBackground) {\n        uploadData.backgroundArgb = await assertColor(options.backgroundColor);\n        logger === null || logger === void 0 ? void 0 : logger.debug('computed backgroundColor audio status');\n      }\n    } catch (error) {\n      logger === null || logger === void 0 ? void 0 : logger.warn({\n        trace: error.stack\n      }, 'failed to obtain extra info');\n    }\n  })()]).finally(async () => {\n    encWriteStream.destroy();\n    // remove tmp files\n    if (didSaveToTmpPath && bodyPath) {\n      await fs_1.promises.unlink(bodyPath);\n      logger === null || logger === void 0 ? void 0 : logger.debug('removed tmp files');\n    }\n  });\n  const obj = Types_1.WAProto.Message.fromObject({\n    [`${mediaType}Message`]: MessageTypeProto[mediaType].fromObject({\n      url: mediaUrl,\n      directPath,\n      mediaKey,\n      fileEncSha256,\n      fileSha256,\n      fileLength,\n      mediaKeyTimestamp: (0, generics_1.unixTimestampSeconds)(),\n      ...uploadData,\n      media: undefined\n    })\n  });\n  if (uploadData.ptv) {\n    obj.ptvMessage = obj.videoMessage;\n    delete obj.videoMessage;\n  }\n  if (cacheableKey) {\n    logger === null || logger === void 0 ? void 0 : logger.debug({\n      cacheableKey\n    }, 'set cache');\n    options.mediaCache.set(cacheableKey, Types_1.WAProto.Message.encode(obj).finish());\n  }\n  return obj;\n};\nexports.prepareWAMessageMedia = prepareWAMessageMedia;\nconst prepareDisappearingMessageSettingContent = ephemeralExpiration => {\n  ephemeralExpiration = ephemeralExpiration || 0;\n  const content = {\n    ephemeralMessage: {\n      message: {\n        protocolMessage: {\n          type: Types_1.WAProto.Message.ProtocolMessage.Type.EPHEMERAL_SETTING,\n          ephemeralExpiration\n        }\n      }\n    }\n  };\n  return Types_1.WAProto.Message.fromObject(content);\n};\nexports.prepareDisappearingMessageSettingContent = prepareDisappearingMessageSettingContent;\n/**\n * Generate forwarded message content like WA does\n * @param message the message to forward\n * @param options.forceForward will show the message as forwarded even if it is from you\n */\nconst generateForwardMessageContent = (message, forceForward) => {\n  var _a;\n  let content = message.message;\n  if (!content) {\n    throw new boom_1.Boom('no content in message', {\n      statusCode: 400\n    });\n  }\n  // hacky copy\n  content = (0, exports.normalizeMessageContent)(content);\n  content = WAProto_1.proto.Message.decode(WAProto_1.proto.Message.encode(content).finish());\n  let key = Object.keys(content)[0];\n  let score = ((_a = content[key].contextInfo) === null || _a === void 0 ? void 0 : _a.forwardingScore) || 0;\n  score += message.key.fromMe && !forceForward ? 0 : 1;\n  if (key === 'conversation') {\n    content.extendedTextMessage = {\n      text: content[key]\n    };\n    delete content.conversation;\n    key = 'extendedTextMessage';\n  }\n  if (score > 0) {\n    content[key].contextInfo = {\n      forwardingScore: score,\n      isForwarded: true\n    };\n  } else {\n    content[key].contextInfo = {};\n  }\n  return content;\n};\nexports.generateForwardMessageContent = generateForwardMessageContent;\nconst generateWAMessageContent = async (message, options) => {\n  var _a;\n  var _b, _c;\n  let m = {};\n  if ('text' in message) {\n    const extContent = {\n      text: message.text\n    };\n    let urlInfo = message.linkPreview;\n    if (typeof urlInfo === 'undefined') {\n      urlInfo = await (0, exports.generateLinkPreviewIfRequired)(message.text, options.getUrlInfo, options.logger);\n    }\n    if (urlInfo) {\n      extContent.canonicalUrl = urlInfo['canonical-url'];\n      extContent.matchedText = urlInfo['matched-text'];\n      extContent.jpegThumbnail = urlInfo.jpegThumbnail;\n      extContent.description = urlInfo.description;\n      extContent.title = urlInfo.title;\n      extContent.previewType = 0;\n      const img = urlInfo.highQualityThumbnail;\n      if (img) {\n        extContent.thumbnailDirectPath = img.directPath;\n        extContent.mediaKey = img.mediaKey;\n        extContent.mediaKeyTimestamp = img.mediaKeyTimestamp;\n        extContent.thumbnailWidth = img.width;\n        extContent.thumbnailHeight = img.height;\n        extContent.thumbnailSha256 = img.fileSha256;\n        extContent.thumbnailEncSha256 = img.fileEncSha256;\n      }\n    }\n    if (options.backgroundColor) {\n      extContent.backgroundArgb = await assertColor(options.backgroundColor);\n    }\n    if (options.font) {\n      extContent.font = options.font;\n    }\n    m.extendedTextMessage = extContent;\n  } else if ('contacts' in message) {\n    const contactLen = message.contacts.contacts.length;\n    if (!contactLen) {\n      throw new boom_1.Boom('require atleast 1 contact', {\n        statusCode: 400\n      });\n    }\n    if (contactLen === 1) {\n      m.contactMessage = Types_1.WAProto.Message.ContactMessage.fromObject(message.contacts.contacts[0]);\n    } else {\n      m.contactsArrayMessage = Types_1.WAProto.Message.ContactsArrayMessage.fromObject(message.contacts);\n    }\n  } else if ('location' in message) {\n    m.locationMessage = Types_1.WAProto.Message.LocationMessage.fromObject(message.location);\n  } else if ('react' in message) {\n    if (!message.react.senderTimestampMs) {\n      message.react.senderTimestampMs = Date.now();\n    }\n    m.reactionMessage = Types_1.WAProto.Message.ReactionMessage.fromObject(message.react);\n  } else if ('delete' in message) {\n    m.protocolMessage = {\n      key: message.delete,\n      type: Types_1.WAProto.Message.ProtocolMessage.Type.REVOKE\n    };\n  } else if ('forward' in message) {\n    m = (0, exports.generateForwardMessageContent)(message.forward, message.force);\n  } else if ('disappearingMessagesInChat' in message) {\n    const exp = typeof message.disappearingMessagesInChat === 'boolean' ? message.disappearingMessagesInChat ? Defaults_1.WA_DEFAULT_EPHEMERAL : 0 : message.disappearingMessagesInChat;\n    m = (0, exports.prepareDisappearingMessageSettingContent)(exp);\n  } else if ('groupInvite' in message) {\n    m.groupInviteMessage = {};\n    m.groupInviteMessage.inviteCode = message.groupInvite.inviteCode;\n    m.groupInviteMessage.inviteExpiration = message.groupInvite.inviteExpiration;\n    m.groupInviteMessage.caption = message.groupInvite.text;\n    m.groupInviteMessage.groupJid = message.groupInvite.jid;\n    m.groupInviteMessage.groupName = message.groupInvite.subject;\n    //TODO: use built-in interface and get disappearing mode info etc.\n    //TODO: cache / use store!?\n    if (options.getProfilePicUrl) {\n      const pfpUrl = await options.getProfilePicUrl(message.groupInvite.jid, 'preview');\n      if (pfpUrl) {\n        const resp = await axios_1.default.get(pfpUrl, {\n          responseType: 'arraybuffer'\n        });\n        if (resp.status === 200) {\n          m.groupInviteMessage.jpegThumbnail = resp.data;\n        }\n      }\n    }\n  } else if ('pin' in message) {\n    m.pinInChatMessage = {};\n    m.messageContextInfo = {};\n    m.pinInChatMessage.key = message.pin;\n    m.pinInChatMessage.type = message.type;\n    m.pinInChatMessage.senderTimestampMs = Date.now();\n    m.messageContextInfo.messageAddOnDurationInSecs = message.type === 1 ? message.time || 86400 : 0;\n  } else if ('buttonReply' in message) {\n    switch (message.type) {\n      case 'template':\n        m.templateButtonReplyMessage = {\n          selectedDisplayText: message.buttonReply.displayText,\n          selectedId: message.buttonReply.id,\n          selectedIndex: message.buttonReply.index\n        };\n        break;\n      case 'plain':\n        m.buttonsResponseMessage = {\n          selectedButtonId: message.buttonReply.id,\n          selectedDisplayText: message.buttonReply.displayText,\n          type: WAProto_1.proto.Message.ButtonsResponseMessage.Type.DISPLAY_TEXT\n        };\n        break;\n    }\n  } else if ('ptv' in message && message.ptv) {\n    const {\n      videoMessage\n    } = await (0, exports.prepareWAMessageMedia)({\n      video: message.video\n    }, options);\n    m.ptvMessage = videoMessage;\n  } else if ('product' in message) {\n    const {\n      imageMessage\n    } = await (0, exports.prepareWAMessageMedia)({\n      image: message.product.productImage\n    }, options);\n    m.productMessage = Types_1.WAProto.Message.ProductMessage.fromObject({\n      ...message,\n      product: {\n        ...message.product,\n        productImage: imageMessage\n      }\n    });\n  } else if ('listReply' in message) {\n    m.listResponseMessage = {\n      ...message.listReply\n    };\n  } else if ('poll' in message) {\n    (_b = message.poll).selectableCount || (_b.selectableCount = 0);\n    (_c = message.poll).toAnnouncementGroup || (_c.toAnnouncementGroup = false);\n    if (!Array.isArray(message.poll.values)) {\n      throw new boom_1.Boom('Invalid poll values', {\n        statusCode: 400\n      });\n    }\n    if (message.poll.selectableCount < 0 || message.poll.selectableCount > message.poll.values.length) {\n      throw new boom_1.Boom(`poll.selectableCount in poll should be >= 0 and <= ${message.poll.values.length}`, {\n        statusCode: 400\n      });\n    }\n    m.messageContextInfo = {\n      // encKey\n      messageSecret: message.poll.messageSecret || (0, crypto_1.randomBytes)(32)\n    };\n    const pollCreationMessage = {\n      name: message.poll.name,\n      selectableOptionsCount: message.poll.selectableCount,\n      options: message.poll.values.map(optionName => ({\n        optionName\n      }))\n    };\n    if (message.poll.toAnnouncementGroup) {\n      // poll v2 is for community announcement groups (single select and multiple)\n      m.pollCreationMessageV2 = pollCreationMessage;\n    } else {\n      if (message.poll.selectableCount > 0) {\n        //poll v3 is for single select polls\n        m.pollCreationMessageV3 = pollCreationMessage;\n      } else {\n        // poll v3 for multiple choice polls\n        m.pollCreationMessage = pollCreationMessage;\n      }\n    }\n  } else if ('sharePhoneNumber' in message) {\n    m.protocolMessage = {\n      type: WAProto_1.proto.Message.ProtocolMessage.Type.SHARE_PHONE_NUMBER\n    };\n  } else if ('requestPhoneNumber' in message) {\n    m.requestPhoneNumberMessage = {};\n  } else {\n    m = await (0, exports.prepareWAMessageMedia)(message, options);\n  }\n  if ('viewOnce' in message && !!message.viewOnce) {\n    m = {\n      viewOnceMessage: {\n        message: m\n      }\n    };\n  }\n  if ('mentions' in message && ((_a = message.mentions) === null || _a === void 0 ? void 0 : _a.length)) {\n    const [messageType] = Object.keys(m);\n    m[messageType].contextInfo = m[messageType] || {};\n    m[messageType].contextInfo.mentionedJid = message.mentions;\n  }\n  if ('edit' in message) {\n    m = {\n      protocolMessage: {\n        key: message.edit,\n        editedMessage: m,\n        timestampMs: Date.now(),\n        type: Types_1.WAProto.Message.ProtocolMessage.Type.MESSAGE_EDIT\n      }\n    };\n  }\n  if ('contextInfo' in message && !!message.contextInfo) {\n    const [messageType] = Object.keys(m);\n    m[messageType] = m[messageType] || {};\n    m[messageType].contextInfo = message.contextInfo;\n  }\n  return Types_1.WAProto.Message.fromObject(m);\n};\nexports.generateWAMessageContent = generateWAMessageContent;\nconst generateWAMessageFromContent = (jid, message, options) => {\n  // set timestamp to now\n  // if not specified\n  if (!options.timestamp) {\n    options.timestamp = new Date();\n  }\n  const innerMessage = (0, exports.normalizeMessageContent)(message);\n  const key = (0, exports.getContentType)(innerMessage);\n  const timestamp = (0, generics_1.unixTimestampSeconds)(options.timestamp);\n  const {\n    quoted,\n    userJid\n  } = options;\n  if (quoted) {\n    const participant = quoted.key.fromMe ? userJid : quoted.participant || quoted.key.participant || quoted.key.remoteJid;\n    let quotedMsg = (0, exports.normalizeMessageContent)(quoted.message);\n    const msgType = (0, exports.getContentType)(quotedMsg);\n    // strip any redundant properties\n    quotedMsg = WAProto_1.proto.Message.fromObject({\n      [msgType]: quotedMsg[msgType]\n    });\n    const quotedContent = quotedMsg[msgType];\n    if (typeof quotedContent === 'object' && quotedContent && 'contextInfo' in quotedContent) {\n      delete quotedContent.contextInfo;\n    }\n    const contextInfo = innerMessage[key].contextInfo || {};\n    contextInfo.participant = (0, WABinary_1.jidNormalizedUser)(participant);\n    contextInfo.stanzaId = quoted.key.id;\n    contextInfo.quotedMessage = quotedMsg;\n    // if a participant is quoted, then it must be a group\n    // hence, remoteJid of group must also be entered\n    if (jid !== quoted.key.remoteJid) {\n      contextInfo.remoteJid = quoted.key.remoteJid;\n    }\n    innerMessage[key].contextInfo = contextInfo;\n  }\n  if (\n  // if we want to send a disappearing message\n  !!(options === null || options === void 0 ? void 0 : options.ephemeralExpiration) &&\n  // and it's not a protocol message -- delete, toggle disappear message\n  key !== 'protocolMessage' &&\n  // already not converted to disappearing message\n  key !== 'ephemeralMessage') {\n    innerMessage[key].contextInfo = {\n      ...(innerMessage[key].contextInfo || {}),\n      expiration: options.ephemeralExpiration || Defaults_1.WA_DEFAULT_EPHEMERAL\n      //ephemeralSettingTimestamp: options.ephemeralOptions.eph_setting_ts?.toString()\n    };\n  }\n  message = Types_1.WAProto.Message.fromObject(message);\n  const messageJSON = {\n    key: {\n      remoteJid: jid,\n      fromMe: true,\n      id: (options === null || options === void 0 ? void 0 : options.messageId) || (0, generics_1.generateMessageID)()\n    },\n    message: message,\n    messageTimestamp: timestamp,\n    messageStubParameters: [],\n    participant: (0, WABinary_1.isJidGroup)(jid) || (0, WABinary_1.isJidStatusBroadcast)(jid) ? userJid : undefined,\n    status: Types_1.WAMessageStatus.PENDING\n  };\n  return Types_1.WAProto.WebMessageInfo.fromObject(messageJSON);\n};\nexports.generateWAMessageFromContent = generateWAMessageFromContent;\nconst generateWAMessage = async (jid, content, options) => {\n  var _a;\n  // ensure msg ID is with every log\n  options.logger = (_a = options === null || options === void 0 ? void 0 : options.logger) === null || _a === void 0 ? void 0 : _a.child({\n    msgId: options.messageId\n  });\n  return (0, exports.generateWAMessageFromContent)(jid, await (0, exports.generateWAMessageContent)(content, options), options);\n};\nexports.generateWAMessage = generateWAMessage;\n/** Get the key to access the true type of content */\nconst getContentType = content => {\n  if (content) {\n    const keys = Object.keys(content);\n    const key = keys.find(k => (k === 'conversation' || k.includes('Message')) && k !== 'senderKeyDistributionMessage');\n    return key;\n  }\n};\nexports.getContentType = getContentType;\n/**\n * Normalizes ephemeral, view once messages to regular message content\n * Eg. image messages in ephemeral messages, in view once messages etc.\n * @param content\n * @returns\n */\nconst normalizeMessageContent = content => {\n  if (!content) {\n    return undefined;\n  }\n  // set max iterations to prevent an infinite loop\n  for (let i = 0; i < 5; i++) {\n    const inner = getFutureProofMessage(content);\n    if (!inner) {\n      break;\n    }\n    content = inner.message;\n  }\n  return content;\n  function getFutureProofMessage(message) {\n    return (message === null || message === void 0 ? void 0 : message.ephemeralMessage) || (message === null || message === void 0 ? void 0 : message.viewOnceMessage) || (message === null || message === void 0 ? void 0 : message.documentWithCaptionMessage) || (message === null || message === void 0 ? void 0 : message.viewOnceMessageV2) || (message === null || message === void 0 ? void 0 : message.viewOnceMessageV2Extension) || (message === null || message === void 0 ? void 0 : message.editedMessage);\n  }\n};\nexports.normalizeMessageContent = normalizeMessageContent;\n/**\n * Extract the true message content from a message\n * Eg. extracts the inner message from a disappearing message/view once message\n */\nconst extractMessageContent = content => {\n  var _a, _b, _c, _d, _e, _f;\n  const extractFromTemplateMessage = msg => {\n    if (msg.imageMessage) {\n      return {\n        imageMessage: msg.imageMessage\n      };\n    } else if (msg.documentMessage) {\n      return {\n        documentMessage: msg.documentMessage\n      };\n    } else if (msg.videoMessage) {\n      return {\n        videoMessage: msg.videoMessage\n      };\n    } else if (msg.locationMessage) {\n      return {\n        locationMessage: msg.locationMessage\n      };\n    } else {\n      return {\n        conversation: 'contentText' in msg ? msg.contentText : 'hydratedContentText' in msg ? msg.hydratedContentText : ''\n      };\n    }\n  };\n  content = (0, exports.normalizeMessageContent)(content);\n  if (content === null || content === void 0 ? void 0 : content.buttonsMessage) {\n    return extractFromTemplateMessage(content.buttonsMessage);\n  }\n  if ((_a = content === null || content === void 0 ? void 0 : content.templateMessage) === null || _a === void 0 ? void 0 : _a.hydratedFourRowTemplate) {\n    return extractFromTemplateMessage((_b = content === null || content === void 0 ? void 0 : content.templateMessage) === null || _b === void 0 ? void 0 : _b.hydratedFourRowTemplate);\n  }\n  if ((_c = content === null || content === void 0 ? void 0 : content.templateMessage) === null || _c === void 0 ? void 0 : _c.hydratedTemplate) {\n    return extractFromTemplateMessage((_d = content === null || content === void 0 ? void 0 : content.templateMessage) === null || _d === void 0 ? void 0 : _d.hydratedTemplate);\n  }\n  if ((_e = content === null || content === void 0 ? void 0 : content.templateMessage) === null || _e === void 0 ? void 0 : _e.fourRowTemplate) {\n    return extractFromTemplateMessage((_f = content === null || content === void 0 ? void 0 : content.templateMessage) === null || _f === void 0 ? void 0 : _f.fourRowTemplate);\n  }\n  return content;\n};\nexports.extractMessageContent = extractMessageContent;\n/**\n * Returns the device predicted by message ID\n */\nconst getDevice = id => /^3A.{18}$/.test(id) ? 'ios' : /^3E.{20}$/.test(id) ? 'web' : /^(.{21}|.{32})$/.test(id) ? 'android' : /^.{18}$/.test(id) ? 'desktop' : 'unknown';\nexports.getDevice = getDevice;\n/** Upserts a receipt in the message */\nconst updateMessageWithReceipt = (msg, receipt) => {\n  msg.userReceipt = msg.userReceipt || [];\n  const recp = msg.userReceipt.find(m => m.userJid === receipt.userJid);\n  if (recp) {\n    Object.assign(recp, receipt);\n  } else {\n    msg.userReceipt.push(receipt);\n  }\n};\nexports.updateMessageWithReceipt = updateMessageWithReceipt;\n/** Update the message with a new reaction */\nconst updateMessageWithReaction = (msg, reaction) => {\n  const authorID = (0, generics_1.getKeyAuthor)(reaction.key);\n  const reactions = (msg.reactions || []).filter(r => (0, generics_1.getKeyAuthor)(r.key) !== authorID);\n  if (reaction.text) {\n    reactions.push(reaction);\n  }\n  msg.reactions = reactions;\n};\nexports.updateMessageWithReaction = updateMessageWithReaction;\n/** Update the message with a new poll update */\nconst updateMessageWithPollUpdate = (msg, update) => {\n  var _a, _b;\n  const authorID = (0, generics_1.getKeyAuthor)(update.pollUpdateMessageKey);\n  const reactions = (msg.pollUpdates || []).filter(r => (0, generics_1.getKeyAuthor)(r.pollUpdateMessageKey) !== authorID);\n  if ((_b = (_a = update.vote) === null || _a === void 0 ? void 0 : _a.selectedOptions) === null || _b === void 0 ? void 0 : _b.length) {\n    reactions.push(update);\n  }\n  msg.pollUpdates = reactions;\n};\nexports.updateMessageWithPollUpdate = updateMessageWithPollUpdate;\n/**\n * Aggregates all poll updates in a poll.\n * @param msg the poll creation message\n * @param meId your jid\n * @returns A list of options & their voters\n */\nfunction getAggregateVotesInPollMessage({\n  message,\n  pollUpdates\n}, meId) {\n  var _a, _b, _c;\n  const opts = ((_a = message === null || message === void 0 ? void 0 : message.pollCreationMessage) === null || _a === void 0 ? void 0 : _a.options) || ((_b = message === null || message === void 0 ? void 0 : message.pollCreationMessageV2) === null || _b === void 0 ? void 0 : _b.options) || ((_c = message === null || message === void 0 ? void 0 : message.pollCreationMessageV3) === null || _c === void 0 ? void 0 : _c.options) || [];\n  const voteHashMap = opts.reduce((acc, opt) => {\n    const hash = (0, crypto_2.sha256)(Buffer.from(opt.optionName || '')).toString();\n    acc[hash] = {\n      name: opt.optionName || '',\n      voters: []\n    };\n    return acc;\n  }, {});\n  for (const update of pollUpdates || []) {\n    const {\n      vote\n    } = update;\n    if (!vote) {\n      continue;\n    }\n    for (const option of vote.selectedOptions || []) {\n      const hash = option.toString();\n      let data = voteHashMap[hash];\n      if (!data) {\n        voteHashMap[hash] = {\n          name: 'Unknown',\n          voters: []\n        };\n        data = voteHashMap[hash];\n      }\n      voteHashMap[hash].voters.push((0, generics_1.getKeyAuthor)(update.pollUpdateMessageKey, meId));\n    }\n  }\n  return Object.values(voteHashMap);\n}\nexports.getAggregateVotesInPollMessage = getAggregateVotesInPollMessage;\n/** Given a list of message keys, aggregates them by chat & sender. Useful for sending read receipts in bulk */\nconst aggregateMessageKeysNotFromMe = keys => {\n  const keyMap = {};\n  for (const {\n    remoteJid,\n    id,\n    participant,\n    fromMe\n  } of keys) {\n    if (!fromMe) {\n      const uqKey = `${remoteJid}:${participant || ''}`;\n      if (!keyMap[uqKey]) {\n        keyMap[uqKey] = {\n          jid: remoteJid,\n          participant: participant,\n          messageIds: []\n        };\n      }\n      keyMap[uqKey].messageIds.push(id);\n    }\n  }\n  return Object.values(keyMap);\n};\nexports.aggregateMessageKeysNotFromMe = aggregateMessageKeysNotFromMe;\nconst REUPLOAD_REQUIRED_STATUS = [410, 404];\n/**\n * Downloads the given message. Throws an error if it's not a media message\n */\nconst downloadMediaMessage = async (message, type, options, ctx) => {\n  const result = await downloadMsg().catch(async error => {\n    var _a;\n    if (ctx) {\n      if (axios_1.default.isAxiosError(error)) {\n        // check if the message requires a reupload\n        if (REUPLOAD_REQUIRED_STATUS.includes((_a = error.response) === null || _a === void 0 ? void 0 : _a.status)) {\n          ctx.logger.info({\n            key: message.key\n          }, 'sending reupload media request...');\n          // request reupload\n          message = await ctx.reuploadRequest(message);\n          const result = await downloadMsg();\n          return result;\n        }\n      }\n    }\n    throw error;\n  });\n  return result;\n  async function downloadMsg() {\n    const mContent = (0, exports.extractMessageContent)(message.message);\n    if (!mContent) {\n      throw new boom_1.Boom('No message present', {\n        statusCode: 400,\n        data: message\n      });\n    }\n    const contentType = (0, exports.getContentType)(mContent);\n    let mediaType = contentType === null || contentType === void 0 ? void 0 : contentType.replace('Message', '');\n    const media = mContent[contentType];\n    if (!media || typeof media !== 'object' || !('url' in media) && !('thumbnailDirectPath' in media)) {\n      throw new boom_1.Boom(`\"${contentType}\" message is not a media message`);\n    }\n    let download;\n    if ('thumbnailDirectPath' in media && !('url' in media)) {\n      download = {\n        directPath: media.thumbnailDirectPath,\n        mediaKey: media.mediaKey\n      };\n      mediaType = 'thumbnail-link';\n    } else {\n      download = media;\n    }\n    const stream = await (0, messages_media_1.downloadContentFromMessage)(download, mediaType, options);\n    if (type === 'buffer') {\n      const bufferArray = [];\n      for await (const chunk of stream) {\n        bufferArray.push(chunk);\n      }\n      return Buffer.concat(bufferArray);\n    }\n    return stream;\n  }\n};\nexports.downloadMediaMessage = downloadMediaMessage;\n/** Checks whether the given message is a media message; if it is returns the inner content */\nconst assertMediaContent = content => {\n  content = (0, exports.extractMessageContent)(content);\n  const mediaContent = (content === null || content === void 0 ? void 0 : content.documentMessage) || (content === null || content === void 0 ? void 0 : content.imageMessage) || (content === null || content === void 0 ? void 0 : content.videoMessage) || (content === null || content === void 0 ? void 0 : content.audioMessage) || (content === null || content === void 0 ? void 0 : content.stickerMessage);\n  if (!mediaContent) {\n    throw new boom_1.Boom('given message is not a media message', {\n      statusCode: 400,\n      data: content\n    });\n  }\n  return mediaContent;\n};\nexports.assertMediaContent = assertMediaContent;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","assertMediaContent","downloadMediaMessage","aggregateMessageKeysNotFromMe","getAggregateVotesInPollMessage","updateMessageWithPollUpdate","updateMessageWithReaction","updateMessageWithReceipt","getDevice","extractMessageContent","normalizeMessageContent","getContentType","generateWAMessage","generateWAMessageFromContent","generateWAMessageContent","generateForwardMessageContent","prepareDisappearingMessageSettingContent","prepareWAMessageMedia","generateLinkPreviewIfRequired","extractUrlFromText","boom_1","require","axios_1","crypto_1","fs_1","WAProto_1","Defaults_1","Types_1","WABinary_1","crypto_2","generics_1","messages_media_1","MIMETYPE_MAP","image","video","document","audio","sticker","MessageTypeProto","WAProto","Message","ImageMessage","VideoMessage","AudioMessage","StickerMessage","DocumentMessage","text","_a","match","URL_REGEX","getUrlInfo","logger","url","urlInfo","error","warn","trace","stack","assertColor","color","assertedColor","Number","hex","trim","replace","length","padStart","parseInt","message","options","mediaType","key","MEDIA_KEYS","Boom","statusCode","uploadData","media","cacheableKey","mediaCache","toString","fileName","mimetype","mediaBuff","get","debug","obj","decode","assign","undefined","requiresDurationComputation","seconds","requiresThumbnailComputation","requiresWaveformProcessing","ptt","requiresAudioBackground","backgroundColor","requiresOriginalForSomeProcessing","mediaKey","encWriteStream","bodyPath","fileEncSha256","fileSha256","fileLength","didSaveToTmpPath","encryptedStream","mediaTypeOverride","saveOriginalFileIfRequired","opts","fileEncSha256B64","mediaUrl","directPath","Promise","all","result","upload","timeoutMs","mediaUploadTimeoutMs","thumbnail","originalImageDimensions","generateThumbnail","jpegThumbnail","width","height","getAudioDuration","waveform","getAudioWaveform","backgroundArgb","finally","destroy","promises","unlink","fromObject","mediaKeyTimestamp","unixTimestampSeconds","ptv","ptvMessage","videoMessage","set","encode","finish","ephemeralExpiration","content","ephemeralMessage","protocolMessage","type","ProtocolMessage","Type","EPHEMERAL_SETTING","forceForward","proto","keys","score","contextInfo","forwardingScore","fromMe","extendedTextMessage","conversation","isForwarded","_b","_c","m","extContent","linkPreview","canonicalUrl","matchedText","description","title","previewType","img","highQualityThumbnail","thumbnailDirectPath","thumbnailWidth","thumbnailHeight","thumbnailSha256","thumbnailEncSha256","font","contactLen","contacts","contactMessage","ContactMessage","contactsArrayMessage","ContactsArrayMessage","locationMessage","LocationMessage","location","react","senderTimestampMs","Date","now","reactionMessage","ReactionMessage","delete","REVOKE","forward","force","exp","disappearingMessagesInChat","WA_DEFAULT_EPHEMERAL","groupInviteMessage","inviteCode","groupInvite","inviteExpiration","caption","groupJid","jid","groupName","subject","getProfilePicUrl","pfpUrl","resp","default","responseType","status","data","pinInChatMessage","messageContextInfo","pin","messageAddOnDurationInSecs","time","templateButtonReplyMessage","selectedDisplayText","buttonReply","displayText","selectedId","id","selectedIndex","index","buttonsResponseMessage","selectedButtonId","ButtonsResponseMessage","DISPLAY_TEXT","imageMessage","product","productImage","productMessage","ProductMessage","listResponseMessage","listReply","poll","selectableCount","toAnnouncementGroup","Array","isArray","values","messageSecret","randomBytes","pollCreationMessage","name","selectableOptionsCount","map","optionName","pollCreationMessageV2","pollCreationMessageV3","SHARE_PHONE_NUMBER","requestPhoneNumberMessage","viewOnce","viewOnceMessage","mentions","messageType","mentionedJid","edit","editedMessage","timestampMs","MESSAGE_EDIT","timestamp","innerMessage","quoted","userJid","participant","remoteJid","quotedMsg","msgType","quotedContent","jidNormalizedUser","stanzaId","quotedMessage","expiration","messageJSON","messageId","generateMessageID","messageTimestamp","messageStubParameters","isJidGroup","isJidStatusBroadcast","WAMessageStatus","PENDING","WebMessageInfo","child","msgId","find","k","includes","i","inner","getFutureProofMessage","documentWithCaptionMessage","viewOnceMessageV2","viewOnceMessageV2Extension","_d","_e","_f","extractFromTemplateMessage","msg","documentMessage","contentText","hydratedContentText","buttonsMessage","templateMessage","hydratedFourRowTemplate","hydratedTemplate","fourRowTemplate","test","receipt","userReceipt","recp","push","reaction","authorID","getKeyAuthor","reactions","filter","r","update","pollUpdateMessageKey","pollUpdates","vote","selectedOptions","meId","voteHashMap","reduce","acc","opt","hash","sha256","Buffer","from","voters","option","keyMap","uqKey","messageIds","REUPLOAD_REQUIRED_STATUS","ctx","downloadMsg","catch","isAxiosError","response","info","reuploadRequest","mContent","contentType","download","stream","downloadContentFromMessage","bufferArray","chunk","concat","mediaContent","audioMessage","stickerMessage"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Utils/messages.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertMediaContent = exports.downloadMediaMessage = exports.aggregateMessageKeysNotFromMe = exports.getAggregateVotesInPollMessage = exports.updateMessageWithPollUpdate = exports.updateMessageWithReaction = exports.updateMessageWithReceipt = exports.getDevice = exports.extractMessageContent = exports.normalizeMessageContent = exports.getContentType = exports.generateWAMessage = exports.generateWAMessageFromContent = exports.generateWAMessageContent = exports.generateForwardMessageContent = exports.prepareDisappearingMessageSettingContent = exports.prepareWAMessageMedia = exports.generateLinkPreviewIfRequired = exports.extractUrlFromText = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst axios_1 = __importDefault(require(\"axios\"));\nconst crypto_1 = require(\"crypto\");\nconst fs_1 = require(\"fs\");\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst Types_1 = require(\"../Types\");\nconst WABinary_1 = require(\"../WABinary\");\nconst crypto_2 = require(\"./crypto\");\nconst generics_1 = require(\"./generics\");\nconst messages_media_1 = require(\"./messages-media\");\nconst MIMETYPE_MAP = {\n    image: 'image/jpeg',\n    video: 'video/mp4',\n    document: 'application/pdf',\n    audio: 'audio/ogg; codecs=opus',\n    sticker: 'image/webp',\n    'product-catalog-image': 'image/jpeg',\n};\nconst MessageTypeProto = {\n    'image': Types_1.WAProto.Message.ImageMessage,\n    'video': Types_1.WAProto.Message.VideoMessage,\n    'audio': Types_1.WAProto.Message.AudioMessage,\n    'sticker': Types_1.WAProto.Message.StickerMessage,\n    'document': Types_1.WAProto.Message.DocumentMessage,\n};\n/**\n * Uses a regex to test whether the string contains a URL, and returns the URL if it does.\n * @param text eg. hello https://google.com\n * @returns the URL, eg. https://google.com\n */\nconst extractUrlFromText = (text) => { var _a; return (_a = text.match(Defaults_1.URL_REGEX)) === null || _a === void 0 ? void 0 : _a[0]; };\nexports.extractUrlFromText = extractUrlFromText;\nconst generateLinkPreviewIfRequired = async (text, getUrlInfo, logger) => {\n    const url = (0, exports.extractUrlFromText)(text);\n    if (!!getUrlInfo && url) {\n        try {\n            const urlInfo = await getUrlInfo(url);\n            return urlInfo;\n        }\n        catch (error) { // ignore if fails\n            logger === null || logger === void 0 ? void 0 : logger.warn({ trace: error.stack }, 'url generation failed');\n        }\n    }\n};\nexports.generateLinkPreviewIfRequired = generateLinkPreviewIfRequired;\nconst assertColor = async (color) => {\n    let assertedColor;\n    if (typeof color === 'number') {\n        assertedColor = color > 0 ? color : 0xffffffff + Number(color) + 1;\n    }\n    else {\n        let hex = color.trim().replace('#', '');\n        if (hex.length <= 6) {\n            hex = 'FF' + hex.padStart(6, '0');\n        }\n        assertedColor = parseInt(hex, 16);\n        return assertedColor;\n    }\n};\nconst prepareWAMessageMedia = async (message, options) => {\n    const logger = options.logger;\n    let mediaType;\n    for (const key of Defaults_1.MEDIA_KEYS) {\n        if (key in message) {\n            mediaType = key;\n        }\n    }\n    if (!mediaType) {\n        throw new boom_1.Boom('Invalid media type', { statusCode: 400 });\n    }\n    const uploadData = {\n        ...message,\n        media: message[mediaType]\n    };\n    delete uploadData[mediaType];\n    // check if cacheable + generate cache key\n    const cacheableKey = typeof uploadData.media === 'object' &&\n        ('url' in uploadData.media) &&\n        !!uploadData.media.url &&\n        !!options.mediaCache && (\n    // generate the key\n    mediaType + ':' + uploadData.media.url.toString());\n    if (mediaType === 'document' && !uploadData.fileName) {\n        uploadData.fileName = 'file';\n    }\n    if (!uploadData.mimetype) {\n        uploadData.mimetype = MIMETYPE_MAP[mediaType];\n    }\n    // check for cache hit\n    if (cacheableKey) {\n        const mediaBuff = options.mediaCache.get(cacheableKey);\n        if (mediaBuff) {\n            logger === null || logger === void 0 ? void 0 : logger.debug({ cacheableKey }, 'got media cache hit');\n            const obj = Types_1.WAProto.Message.decode(mediaBuff);\n            const key = `${mediaType}Message`;\n            Object.assign(obj[key], { ...uploadData, media: undefined });\n            return obj;\n        }\n    }\n    const requiresDurationComputation = mediaType === 'audio' && typeof uploadData.seconds === 'undefined';\n    const requiresThumbnailComputation = (mediaType === 'image' || mediaType === 'video') &&\n        (typeof uploadData['jpegThumbnail'] === 'undefined');\n    const requiresWaveformProcessing = mediaType === 'audio' && uploadData.ptt === true;\n    const requiresAudioBackground = options.backgroundColor && mediaType === 'audio' && uploadData.ptt === true;\n    const requiresOriginalForSomeProcessing = requiresDurationComputation || requiresThumbnailComputation;\n    const { mediaKey, encWriteStream, bodyPath, fileEncSha256, fileSha256, fileLength, didSaveToTmpPath } = await (0, messages_media_1.encryptedStream)(uploadData.media, options.mediaTypeOverride || mediaType, {\n        logger,\n        saveOriginalFileIfRequired: requiresOriginalForSomeProcessing,\n        opts: options.options\n    });\n    // url safe Base64 encode the SHA256 hash of the body\n    const fileEncSha256B64 = fileEncSha256.toString('base64');\n    const [{ mediaUrl, directPath }] = await Promise.all([\n        (async () => {\n            const result = await options.upload(encWriteStream, { fileEncSha256B64, mediaType, timeoutMs: options.mediaUploadTimeoutMs });\n            logger === null || logger === void 0 ? void 0 : logger.debug({ mediaType, cacheableKey }, 'uploaded media');\n            return result;\n        })(),\n        (async () => {\n            try {\n                if (requiresThumbnailComputation) {\n                    const { thumbnail, originalImageDimensions } = await (0, messages_media_1.generateThumbnail)(bodyPath, mediaType, options);\n                    uploadData.jpegThumbnail = thumbnail;\n                    if (!uploadData.width && originalImageDimensions) {\n                        uploadData.width = originalImageDimensions.width;\n                        uploadData.height = originalImageDimensions.height;\n                        logger === null || logger === void 0 ? void 0 : logger.debug('set dimensions');\n                    }\n                    logger === null || logger === void 0 ? void 0 : logger.debug('generated thumbnail');\n                }\n                if (requiresDurationComputation) {\n                    uploadData.seconds = await (0, messages_media_1.getAudioDuration)(bodyPath);\n                    logger === null || logger === void 0 ? void 0 : logger.debug('computed audio duration');\n                }\n                if (requiresWaveformProcessing) {\n                    uploadData.waveform = await (0, messages_media_1.getAudioWaveform)(bodyPath, logger);\n                    logger === null || logger === void 0 ? void 0 : logger.debug('processed waveform');\n                }\n                if (requiresWaveformProcessing) {\n                    uploadData.waveform = await (0, messages_media_1.getAudioWaveform)(bodyPath, logger);\n                    logger === null || logger === void 0 ? void 0 : logger.debug('processed waveform');\n                }\n                if (requiresAudioBackground) {\n                    uploadData.backgroundArgb = await assertColor(options.backgroundColor);\n                    logger === null || logger === void 0 ? void 0 : logger.debug('computed backgroundColor audio status');\n                }\n            }\n            catch (error) {\n                logger === null || logger === void 0 ? void 0 : logger.warn({ trace: error.stack }, 'failed to obtain extra info');\n            }\n        })(),\n    ])\n        .finally(async () => {\n        encWriteStream.destroy();\n        // remove tmp files\n        if (didSaveToTmpPath && bodyPath) {\n            await fs_1.promises.unlink(bodyPath);\n            logger === null || logger === void 0 ? void 0 : logger.debug('removed tmp files');\n        }\n    });\n    const obj = Types_1.WAProto.Message.fromObject({\n        [`${mediaType}Message`]: MessageTypeProto[mediaType].fromObject({\n            url: mediaUrl,\n            directPath,\n            mediaKey,\n            fileEncSha256,\n            fileSha256,\n            fileLength,\n            mediaKeyTimestamp: (0, generics_1.unixTimestampSeconds)(),\n            ...uploadData,\n            media: undefined\n        })\n    });\n    if (uploadData.ptv) {\n        obj.ptvMessage = obj.videoMessage;\n        delete obj.videoMessage;\n    }\n    if (cacheableKey) {\n        logger === null || logger === void 0 ? void 0 : logger.debug({ cacheableKey }, 'set cache');\n        options.mediaCache.set(cacheableKey, Types_1.WAProto.Message.encode(obj).finish());\n    }\n    return obj;\n};\nexports.prepareWAMessageMedia = prepareWAMessageMedia;\nconst prepareDisappearingMessageSettingContent = (ephemeralExpiration) => {\n    ephemeralExpiration = ephemeralExpiration || 0;\n    const content = {\n        ephemeralMessage: {\n            message: {\n                protocolMessage: {\n                    type: Types_1.WAProto.Message.ProtocolMessage.Type.EPHEMERAL_SETTING,\n                    ephemeralExpiration\n                }\n            }\n        }\n    };\n    return Types_1.WAProto.Message.fromObject(content);\n};\nexports.prepareDisappearingMessageSettingContent = prepareDisappearingMessageSettingContent;\n/**\n * Generate forwarded message content like WA does\n * @param message the message to forward\n * @param options.forceForward will show the message as forwarded even if it is from you\n */\nconst generateForwardMessageContent = (message, forceForward) => {\n    var _a;\n    let content = message.message;\n    if (!content) {\n        throw new boom_1.Boom('no content in message', { statusCode: 400 });\n    }\n    // hacky copy\n    content = (0, exports.normalizeMessageContent)(content);\n    content = WAProto_1.proto.Message.decode(WAProto_1.proto.Message.encode(content).finish());\n    let key = Object.keys(content)[0];\n    let score = ((_a = content[key].contextInfo) === null || _a === void 0 ? void 0 : _a.forwardingScore) || 0;\n    score += message.key.fromMe && !forceForward ? 0 : 1;\n    if (key === 'conversation') {\n        content.extendedTextMessage = { text: content[key] };\n        delete content.conversation;\n        key = 'extendedTextMessage';\n    }\n    if (score > 0) {\n        content[key].contextInfo = { forwardingScore: score, isForwarded: true };\n    }\n    else {\n        content[key].contextInfo = {};\n    }\n    return content;\n};\nexports.generateForwardMessageContent = generateForwardMessageContent;\nconst generateWAMessageContent = async (message, options) => {\n    var _a;\n    var _b, _c;\n    let m = {};\n    if ('text' in message) {\n        const extContent = { text: message.text };\n        let urlInfo = message.linkPreview;\n        if (typeof urlInfo === 'undefined') {\n            urlInfo = await (0, exports.generateLinkPreviewIfRequired)(message.text, options.getUrlInfo, options.logger);\n        }\n        if (urlInfo) {\n            extContent.canonicalUrl = urlInfo['canonical-url'];\n            extContent.matchedText = urlInfo['matched-text'];\n            extContent.jpegThumbnail = urlInfo.jpegThumbnail;\n            extContent.description = urlInfo.description;\n            extContent.title = urlInfo.title;\n            extContent.previewType = 0;\n            const img = urlInfo.highQualityThumbnail;\n            if (img) {\n                extContent.thumbnailDirectPath = img.directPath;\n                extContent.mediaKey = img.mediaKey;\n                extContent.mediaKeyTimestamp = img.mediaKeyTimestamp;\n                extContent.thumbnailWidth = img.width;\n                extContent.thumbnailHeight = img.height;\n                extContent.thumbnailSha256 = img.fileSha256;\n                extContent.thumbnailEncSha256 = img.fileEncSha256;\n            }\n        }\n        if (options.backgroundColor) {\n            extContent.backgroundArgb = await assertColor(options.backgroundColor);\n        }\n        if (options.font) {\n            extContent.font = options.font;\n        }\n        m.extendedTextMessage = extContent;\n    }\n    else if ('contacts' in message) {\n        const contactLen = message.contacts.contacts.length;\n        if (!contactLen) {\n            throw new boom_1.Boom('require atleast 1 contact', { statusCode: 400 });\n        }\n        if (contactLen === 1) {\n            m.contactMessage = Types_1.WAProto.Message.ContactMessage.fromObject(message.contacts.contacts[0]);\n        }\n        else {\n            m.contactsArrayMessage = Types_1.WAProto.Message.ContactsArrayMessage.fromObject(message.contacts);\n        }\n    }\n    else if ('location' in message) {\n        m.locationMessage = Types_1.WAProto.Message.LocationMessage.fromObject(message.location);\n    }\n    else if ('react' in message) {\n        if (!message.react.senderTimestampMs) {\n            message.react.senderTimestampMs = Date.now();\n        }\n        m.reactionMessage = Types_1.WAProto.Message.ReactionMessage.fromObject(message.react);\n    }\n    else if ('delete' in message) {\n        m.protocolMessage = {\n            key: message.delete,\n            type: Types_1.WAProto.Message.ProtocolMessage.Type.REVOKE\n        };\n    }\n    else if ('forward' in message) {\n        m = (0, exports.generateForwardMessageContent)(message.forward, message.force);\n    }\n    else if ('disappearingMessagesInChat' in message) {\n        const exp = typeof message.disappearingMessagesInChat === 'boolean' ?\n            (message.disappearingMessagesInChat ? Defaults_1.WA_DEFAULT_EPHEMERAL : 0) :\n            message.disappearingMessagesInChat;\n        m = (0, exports.prepareDisappearingMessageSettingContent)(exp);\n    }\n    else if ('groupInvite' in message) {\n        m.groupInviteMessage = {};\n        m.groupInviteMessage.inviteCode = message.groupInvite.inviteCode;\n        m.groupInviteMessage.inviteExpiration = message.groupInvite.inviteExpiration;\n        m.groupInviteMessage.caption = message.groupInvite.text;\n        m.groupInviteMessage.groupJid = message.groupInvite.jid;\n        m.groupInviteMessage.groupName = message.groupInvite.subject;\n        //TODO: use built-in interface and get disappearing mode info etc.\n        //TODO: cache / use store!?\n        if (options.getProfilePicUrl) {\n            const pfpUrl = await options.getProfilePicUrl(message.groupInvite.jid, 'preview');\n            if (pfpUrl) {\n                const resp = await axios_1.default.get(pfpUrl, { responseType: 'arraybuffer' });\n                if (resp.status === 200) {\n                    m.groupInviteMessage.jpegThumbnail = resp.data;\n                }\n            }\n        }\n    }\n    else if ('pin' in message) {\n        m.pinInChatMessage = {};\n        m.messageContextInfo = {};\n        m.pinInChatMessage.key = message.pin;\n        m.pinInChatMessage.type = message.type;\n        m.pinInChatMessage.senderTimestampMs = Date.now();\n        m.messageContextInfo.messageAddOnDurationInSecs = message.type === 1 ? message.time || 86400 : 0;\n    }\n    else if ('buttonReply' in message) {\n        switch (message.type) {\n            case 'template':\n                m.templateButtonReplyMessage = {\n                    selectedDisplayText: message.buttonReply.displayText,\n                    selectedId: message.buttonReply.id,\n                    selectedIndex: message.buttonReply.index,\n                };\n                break;\n            case 'plain':\n                m.buttonsResponseMessage = {\n                    selectedButtonId: message.buttonReply.id,\n                    selectedDisplayText: message.buttonReply.displayText,\n                    type: WAProto_1.proto.Message.ButtonsResponseMessage.Type.DISPLAY_TEXT,\n                };\n                break;\n        }\n    }\n    else if ('ptv' in message && message.ptv) {\n        const { videoMessage } = await (0, exports.prepareWAMessageMedia)({ video: message.video }, options);\n        m.ptvMessage = videoMessage;\n    }\n    else if ('product' in message) {\n        const { imageMessage } = await (0, exports.prepareWAMessageMedia)({ image: message.product.productImage }, options);\n        m.productMessage = Types_1.WAProto.Message.ProductMessage.fromObject({\n            ...message,\n            product: {\n                ...message.product,\n                productImage: imageMessage,\n            }\n        });\n    }\n    else if ('listReply' in message) {\n        m.listResponseMessage = { ...message.listReply };\n    }\n    else if ('poll' in message) {\n        (_b = message.poll).selectableCount || (_b.selectableCount = 0);\n        (_c = message.poll).toAnnouncementGroup || (_c.toAnnouncementGroup = false);\n        if (!Array.isArray(message.poll.values)) {\n            throw new boom_1.Boom('Invalid poll values', { statusCode: 400 });\n        }\n        if (message.poll.selectableCount < 0\n            || message.poll.selectableCount > message.poll.values.length) {\n            throw new boom_1.Boom(`poll.selectableCount in poll should be >= 0 and <= ${message.poll.values.length}`, { statusCode: 400 });\n        }\n        m.messageContextInfo = {\n            // encKey\n            messageSecret: message.poll.messageSecret || (0, crypto_1.randomBytes)(32),\n        };\n        const pollCreationMessage = {\n            name: message.poll.name,\n            selectableOptionsCount: message.poll.selectableCount,\n            options: message.poll.values.map(optionName => ({ optionName })),\n        };\n        if (message.poll.toAnnouncementGroup) {\n            // poll v2 is for community announcement groups (single select and multiple)\n            m.pollCreationMessageV2 = pollCreationMessage;\n        }\n        else {\n            if (message.poll.selectableCount > 0) {\n                //poll v3 is for single select polls\n                m.pollCreationMessageV3 = pollCreationMessage;\n            }\n            else {\n                // poll v3 for multiple choice polls\n                m.pollCreationMessage = pollCreationMessage;\n            }\n        }\n    }\n    else if ('sharePhoneNumber' in message) {\n        m.protocolMessage = {\n            type: WAProto_1.proto.Message.ProtocolMessage.Type.SHARE_PHONE_NUMBER\n        };\n    }\n    else if ('requestPhoneNumber' in message) {\n        m.requestPhoneNumberMessage = {};\n    }\n    else {\n        m = await (0, exports.prepareWAMessageMedia)(message, options);\n    }\n    if ('viewOnce' in message && !!message.viewOnce) {\n        m = { viewOnceMessage: { message: m } };\n    }\n    if ('mentions' in message && ((_a = message.mentions) === null || _a === void 0 ? void 0 : _a.length)) {\n        const [messageType] = Object.keys(m);\n        m[messageType].contextInfo = m[messageType] || {};\n        m[messageType].contextInfo.mentionedJid = message.mentions;\n    }\n    if ('edit' in message) {\n        m = {\n            protocolMessage: {\n                key: message.edit,\n                editedMessage: m,\n                timestampMs: Date.now(),\n                type: Types_1.WAProto.Message.ProtocolMessage.Type.MESSAGE_EDIT\n            }\n        };\n    }\n    if ('contextInfo' in message && !!message.contextInfo) {\n        const [messageType] = Object.keys(m);\n        m[messageType] = m[messageType] || {};\n        m[messageType].contextInfo = message.contextInfo;\n    }\n    return Types_1.WAProto.Message.fromObject(m);\n};\nexports.generateWAMessageContent = generateWAMessageContent;\nconst generateWAMessageFromContent = (jid, message, options) => {\n    // set timestamp to now\n    // if not specified\n    if (!options.timestamp) {\n        options.timestamp = new Date();\n    }\n    const innerMessage = (0, exports.normalizeMessageContent)(message);\n    const key = (0, exports.getContentType)(innerMessage);\n    const timestamp = (0, generics_1.unixTimestampSeconds)(options.timestamp);\n    const { quoted, userJid } = options;\n    if (quoted) {\n        const participant = quoted.key.fromMe ? userJid : (quoted.participant || quoted.key.participant || quoted.key.remoteJid);\n        let quotedMsg = (0, exports.normalizeMessageContent)(quoted.message);\n        const msgType = (0, exports.getContentType)(quotedMsg);\n        // strip any redundant properties\n        quotedMsg = WAProto_1.proto.Message.fromObject({ [msgType]: quotedMsg[msgType] });\n        const quotedContent = quotedMsg[msgType];\n        if (typeof quotedContent === 'object' && quotedContent && 'contextInfo' in quotedContent) {\n            delete quotedContent.contextInfo;\n        }\n        const contextInfo = innerMessage[key].contextInfo || {};\n        contextInfo.participant = (0, WABinary_1.jidNormalizedUser)(participant);\n        contextInfo.stanzaId = quoted.key.id;\n        contextInfo.quotedMessage = quotedMsg;\n        // if a participant is quoted, then it must be a group\n        // hence, remoteJid of group must also be entered\n        if (jid !== quoted.key.remoteJid) {\n            contextInfo.remoteJid = quoted.key.remoteJid;\n        }\n        innerMessage[key].contextInfo = contextInfo;\n    }\n    if (\n    // if we want to send a disappearing message\n    !!(options === null || options === void 0 ? void 0 : options.ephemeralExpiration) &&\n        // and it's not a protocol message -- delete, toggle disappear message\n        key !== 'protocolMessage' &&\n        // already not converted to disappearing message\n        key !== 'ephemeralMessage') {\n        innerMessage[key].contextInfo = {\n            ...(innerMessage[key].contextInfo || {}),\n            expiration: options.ephemeralExpiration || Defaults_1.WA_DEFAULT_EPHEMERAL,\n            //ephemeralSettingTimestamp: options.ephemeralOptions.eph_setting_ts?.toString()\n        };\n    }\n    message = Types_1.WAProto.Message.fromObject(message);\n    const messageJSON = {\n        key: {\n            remoteJid: jid,\n            fromMe: true,\n            id: (options === null || options === void 0 ? void 0 : options.messageId) || (0, generics_1.generateMessageID)(),\n        },\n        message: message,\n        messageTimestamp: timestamp,\n        messageStubParameters: [],\n        participant: (0, WABinary_1.isJidGroup)(jid) || (0, WABinary_1.isJidStatusBroadcast)(jid) ? userJid : undefined,\n        status: Types_1.WAMessageStatus.PENDING\n    };\n    return Types_1.WAProto.WebMessageInfo.fromObject(messageJSON);\n};\nexports.generateWAMessageFromContent = generateWAMessageFromContent;\nconst generateWAMessage = async (jid, content, options) => {\n    var _a;\n    // ensure msg ID is with every log\n    options.logger = (_a = options === null || options === void 0 ? void 0 : options.logger) === null || _a === void 0 ? void 0 : _a.child({ msgId: options.messageId });\n    return (0, exports.generateWAMessageFromContent)(jid, await (0, exports.generateWAMessageContent)(content, options), options);\n};\nexports.generateWAMessage = generateWAMessage;\n/** Get the key to access the true type of content */\nconst getContentType = (content) => {\n    if (content) {\n        const keys = Object.keys(content);\n        const key = keys.find(k => (k === 'conversation' || k.includes('Message')) && k !== 'senderKeyDistributionMessage');\n        return key;\n    }\n};\nexports.getContentType = getContentType;\n/**\n * Normalizes ephemeral, view once messages to regular message content\n * Eg. image messages in ephemeral messages, in view once messages etc.\n * @param content\n * @returns\n */\nconst normalizeMessageContent = (content) => {\n    if (!content) {\n        return undefined;\n    }\n    // set max iterations to prevent an infinite loop\n    for (let i = 0; i < 5; i++) {\n        const inner = getFutureProofMessage(content);\n        if (!inner) {\n            break;\n        }\n        content = inner.message;\n    }\n    return content;\n    function getFutureProofMessage(message) {\n        return ((message === null || message === void 0 ? void 0 : message.ephemeralMessage)\n            || (message === null || message === void 0 ? void 0 : message.viewOnceMessage)\n            || (message === null || message === void 0 ? void 0 : message.documentWithCaptionMessage)\n            || (message === null || message === void 0 ? void 0 : message.viewOnceMessageV2)\n            || (message === null || message === void 0 ? void 0 : message.viewOnceMessageV2Extension)\n            || (message === null || message === void 0 ? void 0 : message.editedMessage));\n    }\n};\nexports.normalizeMessageContent = normalizeMessageContent;\n/**\n * Extract the true message content from a message\n * Eg. extracts the inner message from a disappearing message/view once message\n */\nconst extractMessageContent = (content) => {\n    var _a, _b, _c, _d, _e, _f;\n    const extractFromTemplateMessage = (msg) => {\n        if (msg.imageMessage) {\n            return { imageMessage: msg.imageMessage };\n        }\n        else if (msg.documentMessage) {\n            return { documentMessage: msg.documentMessage };\n        }\n        else if (msg.videoMessage) {\n            return { videoMessage: msg.videoMessage };\n        }\n        else if (msg.locationMessage) {\n            return { locationMessage: msg.locationMessage };\n        }\n        else {\n            return {\n                conversation: 'contentText' in msg\n                    ? msg.contentText\n                    : ('hydratedContentText' in msg ? msg.hydratedContentText : '')\n            };\n        }\n    };\n    content = (0, exports.normalizeMessageContent)(content);\n    if (content === null || content === void 0 ? void 0 : content.buttonsMessage) {\n        return extractFromTemplateMessage(content.buttonsMessage);\n    }\n    if ((_a = content === null || content === void 0 ? void 0 : content.templateMessage) === null || _a === void 0 ? void 0 : _a.hydratedFourRowTemplate) {\n        return extractFromTemplateMessage((_b = content === null || content === void 0 ? void 0 : content.templateMessage) === null || _b === void 0 ? void 0 : _b.hydratedFourRowTemplate);\n    }\n    if ((_c = content === null || content === void 0 ? void 0 : content.templateMessage) === null || _c === void 0 ? void 0 : _c.hydratedTemplate) {\n        return extractFromTemplateMessage((_d = content === null || content === void 0 ? void 0 : content.templateMessage) === null || _d === void 0 ? void 0 : _d.hydratedTemplate);\n    }\n    if ((_e = content === null || content === void 0 ? void 0 : content.templateMessage) === null || _e === void 0 ? void 0 : _e.fourRowTemplate) {\n        return extractFromTemplateMessage((_f = content === null || content === void 0 ? void 0 : content.templateMessage) === null || _f === void 0 ? void 0 : _f.fourRowTemplate);\n    }\n    return content;\n};\nexports.extractMessageContent = extractMessageContent;\n/**\n * Returns the device predicted by message ID\n */\nconst getDevice = (id) => /^3A.{18}$/.test(id) ? 'ios' : /^3E.{20}$/.test(id) ? 'web' : /^(.{21}|.{32})$/.test(id) ? 'android' : /^.{18}$/.test(id) ? 'desktop' : 'unknown';\nexports.getDevice = getDevice;\n/** Upserts a receipt in the message */\nconst updateMessageWithReceipt = (msg, receipt) => {\n    msg.userReceipt = msg.userReceipt || [];\n    const recp = msg.userReceipt.find(m => m.userJid === receipt.userJid);\n    if (recp) {\n        Object.assign(recp, receipt);\n    }\n    else {\n        msg.userReceipt.push(receipt);\n    }\n};\nexports.updateMessageWithReceipt = updateMessageWithReceipt;\n/** Update the message with a new reaction */\nconst updateMessageWithReaction = (msg, reaction) => {\n    const authorID = (0, generics_1.getKeyAuthor)(reaction.key);\n    const reactions = (msg.reactions || [])\n        .filter(r => (0, generics_1.getKeyAuthor)(r.key) !== authorID);\n    if (reaction.text) {\n        reactions.push(reaction);\n    }\n    msg.reactions = reactions;\n};\nexports.updateMessageWithReaction = updateMessageWithReaction;\n/** Update the message with a new poll update */\nconst updateMessageWithPollUpdate = (msg, update) => {\n    var _a, _b;\n    const authorID = (0, generics_1.getKeyAuthor)(update.pollUpdateMessageKey);\n    const reactions = (msg.pollUpdates || [])\n        .filter(r => (0, generics_1.getKeyAuthor)(r.pollUpdateMessageKey) !== authorID);\n    if ((_b = (_a = update.vote) === null || _a === void 0 ? void 0 : _a.selectedOptions) === null || _b === void 0 ? void 0 : _b.length) {\n        reactions.push(update);\n    }\n    msg.pollUpdates = reactions;\n};\nexports.updateMessageWithPollUpdate = updateMessageWithPollUpdate;\n/**\n * Aggregates all poll updates in a poll.\n * @param msg the poll creation message\n * @param meId your jid\n * @returns A list of options & their voters\n */\nfunction getAggregateVotesInPollMessage({ message, pollUpdates }, meId) {\n    var _a, _b, _c;\n    const opts = ((_a = message === null || message === void 0 ? void 0 : message.pollCreationMessage) === null || _a === void 0 ? void 0 : _a.options) || ((_b = message === null || message === void 0 ? void 0 : message.pollCreationMessageV2) === null || _b === void 0 ? void 0 : _b.options) || ((_c = message === null || message === void 0 ? void 0 : message.pollCreationMessageV3) === null || _c === void 0 ? void 0 : _c.options) || [];\n    const voteHashMap = opts.reduce((acc, opt) => {\n        const hash = (0, crypto_2.sha256)(Buffer.from(opt.optionName || '')).toString();\n        acc[hash] = {\n            name: opt.optionName || '',\n            voters: []\n        };\n        return acc;\n    }, {});\n    for (const update of pollUpdates || []) {\n        const { vote } = update;\n        if (!vote) {\n            continue;\n        }\n        for (const option of vote.selectedOptions || []) {\n            const hash = option.toString();\n            let data = voteHashMap[hash];\n            if (!data) {\n                voteHashMap[hash] = {\n                    name: 'Unknown',\n                    voters: []\n                };\n                data = voteHashMap[hash];\n            }\n            voteHashMap[hash].voters.push((0, generics_1.getKeyAuthor)(update.pollUpdateMessageKey, meId));\n        }\n    }\n    return Object.values(voteHashMap);\n}\nexports.getAggregateVotesInPollMessage = getAggregateVotesInPollMessage;\n/** Given a list of message keys, aggregates them by chat & sender. Useful for sending read receipts in bulk */\nconst aggregateMessageKeysNotFromMe = (keys) => {\n    const keyMap = {};\n    for (const { remoteJid, id, participant, fromMe } of keys) {\n        if (!fromMe) {\n            const uqKey = `${remoteJid}:${participant || ''}`;\n            if (!keyMap[uqKey]) {\n                keyMap[uqKey] = {\n                    jid: remoteJid,\n                    participant: participant,\n                    messageIds: []\n                };\n            }\n            keyMap[uqKey].messageIds.push(id);\n        }\n    }\n    return Object.values(keyMap);\n};\nexports.aggregateMessageKeysNotFromMe = aggregateMessageKeysNotFromMe;\nconst REUPLOAD_REQUIRED_STATUS = [410, 404];\n/**\n * Downloads the given message. Throws an error if it's not a media message\n */\nconst downloadMediaMessage = async (message, type, options, ctx) => {\n    const result = await downloadMsg()\n        .catch(async (error) => {\n        var _a;\n        if (ctx) {\n            if (axios_1.default.isAxiosError(error)) {\n                // check if the message requires a reupload\n                if (REUPLOAD_REQUIRED_STATUS.includes((_a = error.response) === null || _a === void 0 ? void 0 : _a.status)) {\n                    ctx.logger.info({ key: message.key }, 'sending reupload media request...');\n                    // request reupload\n                    message = await ctx.reuploadRequest(message);\n                    const result = await downloadMsg();\n                    return result;\n                }\n            }\n        }\n        throw error;\n    });\n    return result;\n    async function downloadMsg() {\n        const mContent = (0, exports.extractMessageContent)(message.message);\n        if (!mContent) {\n            throw new boom_1.Boom('No message present', { statusCode: 400, data: message });\n        }\n        const contentType = (0, exports.getContentType)(mContent);\n        let mediaType = contentType === null || contentType === void 0 ? void 0 : contentType.replace('Message', '');\n        const media = mContent[contentType];\n        if (!media || typeof media !== 'object' || (!('url' in media) && !('thumbnailDirectPath' in media))) {\n            throw new boom_1.Boom(`\"${contentType}\" message is not a media message`);\n        }\n        let download;\n        if ('thumbnailDirectPath' in media && !('url' in media)) {\n            download = {\n                directPath: media.thumbnailDirectPath,\n                mediaKey: media.mediaKey\n            };\n            mediaType = 'thumbnail-link';\n        }\n        else {\n            download = media;\n        }\n        const stream = await (0, messages_media_1.downloadContentFromMessage)(download, mediaType, options);\n        if (type === 'buffer') {\n            const bufferArray = [];\n            for await (const chunk of stream) {\n                bufferArray.push(chunk);\n            }\n            return Buffer.concat(bufferArray);\n        }\n        return stream;\n    }\n};\nexports.downloadMediaMessage = downloadMediaMessage;\n/** Checks whether the given message is a media message; if it is returns the inner content */\nconst assertMediaContent = (content) => {\n    content = (0, exports.extractMessageContent)(content);\n    const mediaContent = (content === null || content === void 0 ? void 0 : content.documentMessage)\n        || (content === null || content === void 0 ? void 0 : content.imageMessage)\n        || (content === null || content === void 0 ? void 0 : content.videoMessage)\n        || (content === null || content === void 0 ? void 0 : content.audioMessage)\n        || (content === null || content === void 0 ? void 0 : content.stickerMessage);\n    if (!mediaContent) {\n        throw new boom_1.Boom('given message is not a media message', { statusCode: 400, data: content });\n    }\n    return mediaContent;\n};\nexports.assertMediaContent = assertMediaContent;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}