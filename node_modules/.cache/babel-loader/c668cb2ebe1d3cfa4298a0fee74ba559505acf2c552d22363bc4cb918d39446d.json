{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeSocket = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst crypto_1 = require(\"crypto\");\nconst url_1 = require(\"url\");\nconst util_1 = require(\"util\");\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst Types_1 = require(\"../Types\");\nconst Utils_1 = require(\"../Utils\");\nconst WABinary_1 = require(\"../WABinary\");\nconst Client_1 = require(\"./Client\");\n/**\n * Connects to WA servers and performs:\n * - simple queries (no retry mechanism, wait for connection establishment)\n * - listen to messages and emit events\n * - query phone connection\n */\nconst makeSocket = config => {\n  var _a, _b;\n  const {\n    waWebSocketUrl,\n    connectTimeoutMs,\n    logger,\n    keepAliveIntervalMs,\n    browser,\n    auth: authState,\n    printQRInTerminal,\n    defaultQueryTimeoutMs,\n    transactionOpts,\n    qrTimeout,\n    makeSignalRepository\n  } = config;\n  let url = typeof waWebSocketUrl === 'string' ? new url_1.URL(waWebSocketUrl) : waWebSocketUrl;\n  config.mobile = config.mobile || url.protocol === 'tcp:';\n  if (config.mobile && url.protocol !== 'tcp:') {\n    url = new url_1.URL(`tcp://${Defaults_1.MOBILE_ENDPOINT}:${Defaults_1.MOBILE_PORT}`);\n  }\n  if (!config.mobile && url.protocol === 'wss' && ((_a = authState === null || authState === void 0 ? void 0 : authState.creds) === null || _a === void 0 ? void 0 : _a.routingInfo)) {\n    url.searchParams.append('ED', authState.creds.routingInfo.toString('base64url'));\n  }\n  const ws = config.socket ? config.socket : config.mobile ? new Client_1.MobileSocketClient(url, config) : new Client_1.WebSocketClient(url, config);\n  ws.connect();\n  const ev = (0, Utils_1.makeEventBuffer)(logger);\n  /** ephemeral key pair used to encrypt/decrypt communication. Unique for each connection */\n  const ephemeralKeyPair = Utils_1.Curve.generateKeyPair();\n  /** WA noise protocol wrapper */\n  const noise = (0, Utils_1.makeNoiseHandler)({\n    keyPair: ephemeralKeyPair,\n    NOISE_HEADER: config.mobile ? Defaults_1.MOBILE_NOISE_HEADER : Defaults_1.NOISE_WA_HEADER,\n    mobile: config.mobile,\n    logger,\n    routingInfo: (_b = authState === null || authState === void 0 ? void 0 : authState.creds) === null || _b === void 0 ? void 0 : _b.routingInfo\n  });\n  const {\n    creds\n  } = authState;\n  // add transaction capability\n  const keys = (0, Utils_1.addTransactionCapability)(authState.keys, logger, transactionOpts);\n  const signalRepository = makeSignalRepository({\n    creds,\n    keys\n  });\n  let lastDateRecv;\n  let epoch = 1;\n  let keepAliveReq;\n  let qrTimer;\n  let closed = false;\n  const uqTagId = (0, Utils_1.generateMdTagPrefix)();\n  const generateMessageTag = () => `${uqTagId}${epoch++}`;\n  const sendPromise = (0, util_1.promisify)(ws.send);\n  /** send a raw buffer */\n  const sendRawMessage = async data => {\n    if (!ws.isOpen) {\n      throw new boom_1.Boom('Connection Closed', {\n        statusCode: Types_1.DisconnectReason.connectionClosed\n      });\n    }\n    const bytes = noise.encodeFrame(data);\n    await (0, Utils_1.promiseTimeout)(connectTimeoutMs, async (resolve, reject) => {\n      try {\n        await sendPromise.call(ws, bytes);\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  };\n  /** send a binary node */\n  const sendNode = frame => {\n    if (logger.level === 'trace') {\n      logger.trace({\n        xml: (0, WABinary_1.binaryNodeToString)(frame),\n        msg: 'xml send'\n      });\n    }\n    const buff = (0, WABinary_1.encodeBinaryNode)(frame);\n    return sendRawMessage(buff);\n  };\n  /** log & process any unexpected errors */\n  const onUnexpectedError = (err, msg) => {\n    logger.error({\n      err\n    }, `unexpected error in '${msg}'`);\n  };\n  /** await the next incoming message */\n  const awaitNextMessage = async sendMsg => {\n    if (!ws.isOpen) {\n      throw new boom_1.Boom('Connection Closed', {\n        statusCode: Types_1.DisconnectReason.connectionClosed\n      });\n    }\n    let onOpen;\n    let onClose;\n    const result = (0, Utils_1.promiseTimeout)(connectTimeoutMs, (resolve, reject) => {\n      onOpen = resolve;\n      onClose = mapWebSocketError(reject);\n      ws.on('frame', onOpen);\n      ws.on('close', onClose);\n      ws.on('error', onClose);\n    }).finally(() => {\n      ws.off('frame', onOpen);\n      ws.off('close', onClose);\n      ws.off('error', onClose);\n    });\n    if (sendMsg) {\n      sendRawMessage(sendMsg).catch(onClose);\n    }\n    return result;\n  };\n  /**\n   * Wait for a message with a certain tag to be received\n   * @param msgId the message tag to await\n   * @param timeoutMs timeout after which the promise will reject\n   */\n  const waitForMessage = async (msgId, timeoutMs = defaultQueryTimeoutMs) => {\n    let onRecv;\n    let onErr;\n    try {\n      return await (0, Utils_1.promiseTimeout)(timeoutMs, (resolve, reject) => {\n        onRecv = resolve;\n        onErr = err => {\n          reject(err || new boom_1.Boom('Connection Closed', {\n            statusCode: Types_1.DisconnectReason.connectionClosed\n          }));\n        };\n        ws.on(`TAG:${msgId}`, onRecv);\n        ws.on('close', onErr); // if the socket closes, you'll never receive the message\n        ws.off('error', onErr);\n      });\n    } finally {\n      ws.off(`TAG:${msgId}`, onRecv);\n      ws.off('close', onErr); // if the socket closes, you'll never receive the message\n      ws.off('error', onErr);\n    }\n  };\n  /** send a query, and wait for its response. auto-generates message ID if not provided */\n  const query = async (node, timeoutMs) => {\n    if (!node.attrs.id) {\n      node.attrs.id = generateMessageTag();\n    }\n    const msgId = node.attrs.id;\n    const wait = waitForMessage(msgId, timeoutMs);\n    await sendNode(node);\n    const result = await wait;\n    if ('tag' in result) {\n      (0, WABinary_1.assertNodeErrorFree)(result);\n    }\n    return result;\n  };\n  /** connection handshake */\n  const validateConnection = async () => {\n    let helloMsg = {\n      clientHello: {\n        ephemeral: ephemeralKeyPair.public\n      }\n    };\n    helloMsg = WAProto_1.proto.HandshakeMessage.fromObject(helloMsg);\n    logger.info({\n      browser,\n      helloMsg\n    }, 'connected to WA');\n    const init = WAProto_1.proto.HandshakeMessage.encode(helloMsg).finish();\n    const result = await awaitNextMessage(init);\n    const handshake = WAProto_1.proto.HandshakeMessage.decode(result);\n    logger.trace({\n      handshake\n    }, 'handshake recv from WA');\n    const keyEnc = noise.processHandshake(handshake, creds.noiseKey);\n    let node;\n    if (config.mobile) {\n      node = (0, Utils_1.generateMobileNode)(config);\n    } else if (!creds.me) {\n      node = (0, Utils_1.generateRegistrationNode)(creds, config);\n      logger.info({\n        node\n      }, 'not logged in, attempting registration...');\n    } else {\n      node = (0, Utils_1.generateLoginNode)(creds.me.id, config);\n      logger.info({\n        node\n      }, 'logging in...');\n    }\n    const payloadEnc = noise.encrypt(WAProto_1.proto.ClientPayload.encode(node).finish());\n    await sendRawMessage(WAProto_1.proto.HandshakeMessage.encode({\n      clientFinish: {\n        static: keyEnc,\n        payload: payloadEnc\n      }\n    }).finish());\n    noise.finishInit();\n    startKeepAliveRequest();\n  };\n  const getAvailablePreKeysOnServer = async () => {\n    const result = await query({\n      tag: 'iq',\n      attrs: {\n        id: generateMessageTag(),\n        xmlns: 'encrypt',\n        type: 'get',\n        to: WABinary_1.S_WHATSAPP_NET\n      },\n      content: [{\n        tag: 'count',\n        attrs: {}\n      }]\n    });\n    const countChild = (0, WABinary_1.getBinaryNodeChild)(result, 'count');\n    return +countChild.attrs.value;\n  };\n  /** generates and uploads a set of pre-keys to the server */\n  const uploadPreKeys = async (count = Defaults_1.INITIAL_PREKEY_COUNT) => {\n    await keys.transaction(async () => {\n      logger.info({\n        count\n      }, 'uploading pre-keys');\n      const {\n        update,\n        node\n      } = await (0, Utils_1.getNextPreKeysNode)({\n        creds,\n        keys\n      }, count);\n      await query(node);\n      ev.emit('creds.update', update);\n      logger.info({\n        count\n      }, 'uploaded pre-keys');\n    });\n  };\n  const uploadPreKeysToServerIfRequired = async () => {\n    const preKeyCount = await getAvailablePreKeysOnServer();\n    logger.info(`${preKeyCount} pre-keys found on server`);\n    if (preKeyCount <= Defaults_1.MIN_PREKEY_COUNT) {\n      await uploadPreKeys();\n    }\n  };\n  const onMessageReceived = data => {\n    noise.decodeFrame(data, frame => {\n      var _a;\n      // reset ping timeout\n      lastDateRecv = new Date();\n      let anyTriggered = false;\n      anyTriggered = ws.emit('frame', frame);\n      // if it's a binary node\n      if (!(frame instanceof Uint8Array)) {\n        const msgId = frame.attrs.id;\n        if (logger.level === 'trace') {\n          logger.trace({\n            xml: (0, WABinary_1.binaryNodeToString)(frame),\n            msg: 'recv xml'\n          });\n        }\n        /* Check if this is a response to a message we sent */\n        anyTriggered = ws.emit(`${Defaults_1.DEF_TAG_PREFIX}${msgId}`, frame) || anyTriggered;\n        /* Check if this is a response to a message we are expecting */\n        const l0 = frame.tag;\n        const l1 = frame.attrs || {};\n        const l2 = Array.isArray(frame.content) ? (_a = frame.content[0]) === null || _a === void 0 ? void 0 : _a.tag : '';\n        Object.keys(l1).forEach(key => {\n          anyTriggered = ws.emit(`${Defaults_1.DEF_CALLBACK_PREFIX}${l0},${key}:${l1[key]},${l2}`, frame) || anyTriggered;\n          anyTriggered = ws.emit(`${Defaults_1.DEF_CALLBACK_PREFIX}${l0},${key}:${l1[key]}`, frame) || anyTriggered;\n          anyTriggered = ws.emit(`${Defaults_1.DEF_CALLBACK_PREFIX}${l0},${key}`, frame) || anyTriggered;\n        });\n        anyTriggered = ws.emit(`${Defaults_1.DEF_CALLBACK_PREFIX}${l0},,${l2}`, frame) || anyTriggered;\n        anyTriggered = ws.emit(`${Defaults_1.DEF_CALLBACK_PREFIX}${l0}`, frame) || anyTriggered;\n        if (!anyTriggered && logger.level === 'debug') {\n          logger.debug({\n            unhandled: true,\n            msgId,\n            fromMe: false,\n            frame\n          }, 'communication recv');\n        }\n      }\n    });\n  };\n  const end = error => {\n    if (closed) {\n      logger.trace({\n        trace: error === null || error === void 0 ? void 0 : error.stack\n      }, 'connection already closed');\n      return;\n    }\n    closed = true;\n    logger.info({\n      trace: error === null || error === void 0 ? void 0 : error.stack\n    }, error ? 'connection errored' : 'connection closed');\n    clearInterval(keepAliveReq);\n    clearTimeout(qrTimer);\n    ws.removeAllListeners('close');\n    ws.removeAllListeners('error');\n    ws.removeAllListeners('open');\n    ws.removeAllListeners('message');\n    if (!ws.isClosed && !ws.isClosing) {\n      try {\n        ws.close();\n      } catch (_a) {}\n    }\n    ev.emit('connection.update', {\n      connection: 'close',\n      lastDisconnect: {\n        error,\n        date: new Date()\n      }\n    });\n    ev.removeAllListeners('connection.update');\n  };\n  const waitForSocketOpen = async () => {\n    if (ws.isOpen) {\n      return;\n    }\n    if (ws.isClosed || ws.isClosing) {\n      throw new boom_1.Boom('Connection Closed', {\n        statusCode: Types_1.DisconnectReason.connectionClosed\n      });\n    }\n    let onOpen;\n    let onClose;\n    await new Promise((resolve, reject) => {\n      onOpen = () => resolve(undefined);\n      onClose = mapWebSocketError(reject);\n      ws.on('open', onOpen);\n      ws.on('close', onClose);\n      ws.on('error', onClose);\n    }).finally(() => {\n      ws.off('open', onOpen);\n      ws.off('close', onClose);\n      ws.off('error', onClose);\n    });\n  };\n  const startKeepAliveRequest = () => keepAliveReq = setInterval(() => {\n    if (!lastDateRecv) {\n      lastDateRecv = new Date();\n    }\n    const diff = Date.now() - lastDateRecv.getTime();\n    /*\n        check if it's been a suspicious amount of time since the server responded with our last seen\n        it could be that the network is down\n    */\n    if (diff > keepAliveIntervalMs + 5000) {\n      end(new boom_1.Boom('Connection was lost', {\n        statusCode: Types_1.DisconnectReason.connectionLost\n      }));\n    } else if (ws.isOpen) {\n      // if its all good, send a keep alive request\n      query({\n        tag: 'iq',\n        attrs: {\n          id: generateMessageTag(),\n          to: WABinary_1.S_WHATSAPP_NET,\n          type: 'get',\n          xmlns: 'w:p'\n        },\n        content: [{\n          tag: 'ping',\n          attrs: {}\n        }]\n      }).catch(err => {\n        logger.error({\n          trace: err.stack\n        }, 'error in sending keep alive');\n      });\n    } else {\n      logger.warn('keep alive called when WS not open');\n    }\n  }, keepAliveIntervalMs);\n  /** i have no idea why this exists. pls enlighten me */\n  const sendPassiveIq = tag => query({\n    tag: 'iq',\n    attrs: {\n      to: WABinary_1.S_WHATSAPP_NET,\n      xmlns: 'passive',\n      type: 'set'\n    },\n    content: [{\n      tag,\n      attrs: {}\n    }]\n  });\n  /** logout & invalidate connection */\n  const logout = async msg => {\n    var _a;\n    const jid = (_a = authState.creds.me) === null || _a === void 0 ? void 0 : _a.id;\n    if (jid) {\n      await sendNode({\n        tag: 'iq',\n        attrs: {\n          to: WABinary_1.S_WHATSAPP_NET,\n          type: 'set',\n          id: generateMessageTag(),\n          xmlns: 'md'\n        },\n        content: [{\n          tag: 'remove-companion-device',\n          attrs: {\n            jid,\n            reason: 'user_initiated'\n          }\n        }]\n      });\n    }\n    end(new boom_1.Boom(msg || 'Intentional Logout', {\n      statusCode: Types_1.DisconnectReason.loggedOut\n    }));\n  };\n  const requestPairingCode = async phoneNumber => {\n    authState.creds.pairingCode = (0, Utils_1.bytesToCrockford)((0, crypto_1.randomBytes)(5));\n    authState.creds.me = {\n      id: (0, WABinary_1.jidEncode)(phoneNumber, 's.whatsapp.net'),\n      name: '~'\n    };\n    ev.emit('creds.update', authState.creds);\n    await sendNode({\n      tag: 'iq',\n      attrs: {\n        to: WABinary_1.S_WHATSAPP_NET,\n        type: 'set',\n        id: generateMessageTag(),\n        xmlns: 'md'\n      },\n      content: [{\n        tag: 'link_code_companion_reg',\n        attrs: {\n          jid: authState.creds.me.id,\n          stage: 'companion_hello',\n          // eslint-disable-next-line camelcase\n          should_show_push_notification: 'true'\n        },\n        content: [{\n          tag: 'link_code_pairing_wrapped_companion_ephemeral_pub',\n          attrs: {},\n          content: await generatePairingKey()\n        }, {\n          tag: 'companion_server_auth_key_pub',\n          attrs: {},\n          content: authState.creds.noiseKey.public\n        }, {\n          tag: 'companion_platform_id',\n          attrs: {},\n          content: (0, Utils_1.getPlatformId)(browser[1])\n        }, {\n          tag: 'companion_platform_display',\n          attrs: {},\n          content: `${browser[1]} (${browser[0]})`\n        }, {\n          tag: 'link_code_pairing_nonce',\n          attrs: {},\n          content: '0'\n        }]\n      }]\n    });\n    return authState.creds.pairingCode;\n  };\n  async function generatePairingKey() {\n    const salt = (0, crypto_1.randomBytes)(32);\n    const randomIv = (0, crypto_1.randomBytes)(16);\n    const key = await (0, Utils_1.derivePairingCodeKey)(authState.creds.pairingCode, salt);\n    const ciphered = (0, Utils_1.aesEncryptCTR)(authState.creds.pairingEphemeralKeyPair.public, key, randomIv);\n    return Buffer.concat([salt, randomIv, ciphered]);\n  }\n  const sendWAMBuffer = wamBuffer => {\n    return query({\n      tag: 'iq',\n      attrs: {\n        to: WABinary_1.S_WHATSAPP_NET,\n        id: generateMessageTag(),\n        xmlns: 'w:stats'\n      },\n      content: [{\n        tag: 'add',\n        attrs: {},\n        content: wamBuffer\n      }]\n    });\n  };\n  ws.on('message', onMessageReceived);\n  ws.on('open', async () => {\n    try {\n      await validateConnection();\n    } catch (err) {\n      logger.error({\n        err\n      }, 'error in validating connection');\n      end(err);\n    }\n  });\n  ws.on('error', mapWebSocketError(end));\n  ws.on('close', () => end(new boom_1.Boom('Connection Terminated', {\n    statusCode: Types_1.DisconnectReason.connectionClosed\n  })));\n  // the server terminated the connection\n  ws.on('CB:xmlstreamend', () => end(new boom_1.Boom('Connection Terminated by Server', {\n    statusCode: Types_1.DisconnectReason.connectionClosed\n  })));\n  // QR gen\n  ws.on('CB:iq,type:set,pair-device', async stanza => {\n    const iq = {\n      tag: 'iq',\n      attrs: {\n        to: WABinary_1.S_WHATSAPP_NET,\n        type: 'result',\n        id: stanza.attrs.id\n      }\n    };\n    await sendNode(iq);\n    const pairDeviceNode = (0, WABinary_1.getBinaryNodeChild)(stanza, 'pair-device');\n    const refNodes = (0, WABinary_1.getBinaryNodeChildren)(pairDeviceNode, 'ref');\n    const noiseKeyB64 = Buffer.from(creds.noiseKey.public).toString('base64');\n    const identityKeyB64 = Buffer.from(creds.signedIdentityKey.public).toString('base64');\n    const advB64 = creds.advSecretKey;\n    let qrMs = qrTimeout || 60000; // time to let a QR live\n    const genPairQR = () => {\n      if (!ws.isOpen) {\n        return;\n      }\n      const refNode = refNodes.shift();\n      if (!refNode) {\n        end(new boom_1.Boom('QR refs attempts ended', {\n          statusCode: Types_1.DisconnectReason.timedOut\n        }));\n        return;\n      }\n      const ref = refNode.content.toString('utf-8');\n      const qr = [ref, noiseKeyB64, identityKeyB64, advB64].join(',');\n      ev.emit('connection.update', {\n        qr\n      });\n      qrTimer = setTimeout(genPairQR, qrMs);\n      qrMs = qrTimeout || 20000; // shorter subsequent qrs\n    };\n    genPairQR();\n  });\n  // device paired for the first time\n  // if device pairs successfully, the server asks to restart the connection\n  ws.on('CB:iq,,pair-success', async stanza => {\n    logger.debug('pair success recv');\n    try {\n      const {\n        reply,\n        creds: updatedCreds\n      } = (0, Utils_1.configureSuccessfulPairing)(stanza, creds);\n      logger.info({\n        me: updatedCreds.me,\n        platform: updatedCreds.platform\n      }, 'pairing configured successfully, expect to restart the connection...');\n      ev.emit('creds.update', updatedCreds);\n      ev.emit('connection.update', {\n        isNewLogin: true,\n        qr: undefined\n      });\n      await sendNode(reply);\n    } catch (error) {\n      logger.info({\n        trace: error.stack\n      }, 'error in pairing');\n      end(error);\n    }\n  });\n  // login complete\n  ws.on('CB:success', async node => {\n    await uploadPreKeysToServerIfRequired();\n    await sendPassiveIq('active');\n    logger.info('opened connection to WA');\n    clearTimeout(qrTimer); // will never happen in all likelyhood -- but just in case WA sends success on first try\n    ev.emit('creds.update', {\n      me: {\n        ...authState.creds.me,\n        lid: node.attrs.lid\n      }\n    });\n    ev.emit('connection.update', {\n      connection: 'open'\n    });\n  });\n  ws.on('CB:stream:error', node => {\n    logger.error({\n      node\n    }, 'stream errored out');\n    const {\n      reason,\n      statusCode\n    } = (0, Utils_1.getErrorCodeFromStreamError)(node);\n    end(new boom_1.Boom(`Stream Errored (${reason})`, {\n      statusCode,\n      data: node\n    }));\n  });\n  // stream fail, possible logout\n  ws.on('CB:failure', node => {\n    const reason = +(node.attrs.reason || 500);\n    end(new boom_1.Boom('Connection Failure', {\n      statusCode: reason,\n      data: node.attrs\n    }));\n  });\n  ws.on('CB:ib,,downgrade_webclient', () => {\n    end(new boom_1.Boom('Multi-device beta not joined', {\n      statusCode: Types_1.DisconnectReason.multideviceMismatch\n    }));\n  });\n  ws.on('CB:ib,,edge_routing', node => {\n    const edgeRoutingNode = (0, WABinary_1.getBinaryNodeChild)(node, 'edge_routing');\n    const routingInfo = (0, WABinary_1.getBinaryNodeChild)(edgeRoutingNode, 'routing_info');\n    if (routingInfo === null || routingInfo === void 0 ? void 0 : routingInfo.content) {\n      authState.creds.routingInfo = Buffer.from(routingInfo === null || routingInfo === void 0 ? void 0 : routingInfo.content);\n      ev.emit('creds.update', authState.creds);\n    }\n  });\n  let didStartBuffer = false;\n  process.nextTick(() => {\n    var _a;\n    if ((_a = creds.me) === null || _a === void 0 ? void 0 : _a.id) {\n      // start buffering important events\n      // if we're logged in\n      ev.buffer();\n      didStartBuffer = true;\n    }\n    ev.emit('connection.update', {\n      connection: 'connecting',\n      receivedPendingNotifications: false,\n      qr: undefined\n    });\n  });\n  // called when all offline notifs are handled\n  ws.on('CB:ib,,offline', node => {\n    const child = (0, WABinary_1.getBinaryNodeChild)(node, 'offline');\n    const offlineNotifs = +((child === null || child === void 0 ? void 0 : child.attrs.count) || 0);\n    logger.info(`handled ${offlineNotifs} offline messages/notifications`);\n    if (didStartBuffer) {\n      ev.flush();\n      logger.trace('flushed events for initial buffer');\n    }\n    ev.emit('connection.update', {\n      receivedPendingNotifications: true\n    });\n  });\n  // update credentials when required\n  ev.on('creds.update', update => {\n    var _a, _b;\n    const name = (_a = update.me) === null || _a === void 0 ? void 0 : _a.name;\n    // if name has just been received\n    if (((_b = creds.me) === null || _b === void 0 ? void 0 : _b.name) !== name) {\n      logger.debug({\n        name\n      }, 'updated pushName');\n      sendNode({\n        tag: 'presence',\n        attrs: {\n          name: name\n        }\n      }).catch(err => {\n        logger.warn({\n          trace: err.stack\n        }, 'error in sending presence update on name change');\n      });\n    }\n    Object.assign(creds, update);\n  });\n  if (printQRInTerminal) {\n    (0, Utils_1.printQRIfNecessaryListener)(ev, logger);\n  }\n  return {\n    type: 'md',\n    ws,\n    ev,\n    authState: {\n      creds,\n      keys\n    },\n    signalRepository,\n    get user() {\n      return authState.creds.me;\n    },\n    generateMessageTag,\n    query,\n    waitForMessage,\n    waitForSocketOpen,\n    sendRawMessage,\n    sendNode,\n    logout,\n    end,\n    onUnexpectedError,\n    uploadPreKeys,\n    uploadPreKeysToServerIfRequired,\n    requestPairingCode,\n    /** Waits for the connection to WA to reach a state */\n    waitForConnectionUpdate: (0, Utils_1.bindWaitForConnectionUpdate)(ev),\n    sendWAMBuffer\n  };\n};\nexports.makeSocket = makeSocket;\n/**\n * map the websocket error to the right type\n * so it can be retried by the caller\n * */\nfunction mapWebSocketError(handler) {\n  return error => {\n    handler(new boom_1.Boom(`WebSocket Error (${error === null || error === void 0 ? void 0 : error.message})`, {\n      statusCode: (0, Utils_1.getCodeFromWSError)(error),\n      data: error\n    }));\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","makeSocket","boom_1","require","crypto_1","url_1","util_1","WAProto_1","Defaults_1","Types_1","Utils_1","WABinary_1","Client_1","config","_a","_b","waWebSocketUrl","connectTimeoutMs","logger","keepAliveIntervalMs","browser","auth","authState","printQRInTerminal","defaultQueryTimeoutMs","transactionOpts","qrTimeout","makeSignalRepository","url","URL","mobile","protocol","MOBILE_ENDPOINT","MOBILE_PORT","creds","routingInfo","searchParams","append","toString","ws","socket","MobileSocketClient","WebSocketClient","connect","ev","makeEventBuffer","ephemeralKeyPair","Curve","generateKeyPair","noise","makeNoiseHandler","keyPair","NOISE_HEADER","MOBILE_NOISE_HEADER","NOISE_WA_HEADER","keys","addTransactionCapability","signalRepository","lastDateRecv","epoch","keepAliveReq","qrTimer","closed","uqTagId","generateMdTagPrefix","generateMessageTag","sendPromise","promisify","send","sendRawMessage","data","isOpen","Boom","statusCode","DisconnectReason","connectionClosed","bytes","encodeFrame","promiseTimeout","resolve","reject","call","error","sendNode","frame","level","trace","xml","binaryNodeToString","msg","buff","encodeBinaryNode","onUnexpectedError","err","awaitNextMessage","sendMsg","onOpen","onClose","result","mapWebSocketError","on","finally","off","catch","waitForMessage","msgId","timeoutMs","onRecv","onErr","query","node","attrs","id","wait","assertNodeErrorFree","validateConnection","helloMsg","clientHello","ephemeral","public","proto","HandshakeMessage","fromObject","info","init","encode","finish","handshake","decode","keyEnc","processHandshake","noiseKey","generateMobileNode","me","generateRegistrationNode","generateLoginNode","payloadEnc","encrypt","ClientPayload","clientFinish","static","payload","finishInit","startKeepAliveRequest","getAvailablePreKeysOnServer","tag","xmlns","type","to","S_WHATSAPP_NET","content","countChild","getBinaryNodeChild","uploadPreKeys","count","INITIAL_PREKEY_COUNT","transaction","update","getNextPreKeysNode","emit","uploadPreKeysToServerIfRequired","preKeyCount","MIN_PREKEY_COUNT","onMessageReceived","decodeFrame","Date","anyTriggered","Uint8Array","DEF_TAG_PREFIX","l0","l1","l2","Array","isArray","forEach","key","DEF_CALLBACK_PREFIX","debug","unhandled","fromMe","end","stack","clearInterval","clearTimeout","removeAllListeners","isClosed","isClosing","close","connection","lastDisconnect","date","waitForSocketOpen","Promise","undefined","setInterval","diff","now","getTime","connectionLost","warn","sendPassiveIq","logout","jid","reason","loggedOut","requestPairingCode","phoneNumber","pairingCode","bytesToCrockford","randomBytes","jidEncode","name","stage","should_show_push_notification","generatePairingKey","getPlatformId","salt","randomIv","derivePairingCodeKey","ciphered","aesEncryptCTR","pairingEphemeralKeyPair","Buffer","concat","sendWAMBuffer","wamBuffer","stanza","iq","pairDeviceNode","refNodes","getBinaryNodeChildren","noiseKeyB64","from","identityKeyB64","signedIdentityKey","advB64","advSecretKey","qrMs","genPairQR","refNode","shift","timedOut","ref","qr","join","setTimeout","reply","updatedCreds","configureSuccessfulPairing","platform","isNewLogin","lid","getErrorCodeFromStreamError","multideviceMismatch","edgeRoutingNode","didStartBuffer","process","nextTick","buffer","receivedPendingNotifications","child","offlineNotifs","flush","assign","printQRIfNecessaryListener","user","waitForConnectionUpdate","bindWaitForConnectionUpdate","handler","message","getCodeFromWSError"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Socket/socket.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeSocket = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst crypto_1 = require(\"crypto\");\nconst url_1 = require(\"url\");\nconst util_1 = require(\"util\");\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst Types_1 = require(\"../Types\");\nconst Utils_1 = require(\"../Utils\");\nconst WABinary_1 = require(\"../WABinary\");\nconst Client_1 = require(\"./Client\");\n/**\n * Connects to WA servers and performs:\n * - simple queries (no retry mechanism, wait for connection establishment)\n * - listen to messages and emit events\n * - query phone connection\n */\nconst makeSocket = (config) => {\n    var _a, _b;\n    const { waWebSocketUrl, connectTimeoutMs, logger, keepAliveIntervalMs, browser, auth: authState, printQRInTerminal, defaultQueryTimeoutMs, transactionOpts, qrTimeout, makeSignalRepository, } = config;\n    let url = typeof waWebSocketUrl === 'string' ? new url_1.URL(waWebSocketUrl) : waWebSocketUrl;\n    config.mobile = config.mobile || url.protocol === 'tcp:';\n    if (config.mobile && url.protocol !== 'tcp:') {\n        url = new url_1.URL(`tcp://${Defaults_1.MOBILE_ENDPOINT}:${Defaults_1.MOBILE_PORT}`);\n    }\n    if (!config.mobile && url.protocol === 'wss' && ((_a = authState === null || authState === void 0 ? void 0 : authState.creds) === null || _a === void 0 ? void 0 : _a.routingInfo)) {\n        url.searchParams.append('ED', authState.creds.routingInfo.toString('base64url'));\n    }\n    const ws = config.socket ? config.socket : config.mobile ? new Client_1.MobileSocketClient(url, config) : new Client_1.WebSocketClient(url, config);\n    ws.connect();\n    const ev = (0, Utils_1.makeEventBuffer)(logger);\n    /** ephemeral key pair used to encrypt/decrypt communication. Unique for each connection */\n    const ephemeralKeyPair = Utils_1.Curve.generateKeyPair();\n    /** WA noise protocol wrapper */\n    const noise = (0, Utils_1.makeNoiseHandler)({\n        keyPair: ephemeralKeyPair,\n        NOISE_HEADER: config.mobile ? Defaults_1.MOBILE_NOISE_HEADER : Defaults_1.NOISE_WA_HEADER,\n        mobile: config.mobile,\n        logger,\n        routingInfo: (_b = authState === null || authState === void 0 ? void 0 : authState.creds) === null || _b === void 0 ? void 0 : _b.routingInfo\n    });\n    const { creds } = authState;\n    // add transaction capability\n    const keys = (0, Utils_1.addTransactionCapability)(authState.keys, logger, transactionOpts);\n    const signalRepository = makeSignalRepository({ creds, keys });\n    let lastDateRecv;\n    let epoch = 1;\n    let keepAliveReq;\n    let qrTimer;\n    let closed = false;\n    const uqTagId = (0, Utils_1.generateMdTagPrefix)();\n    const generateMessageTag = () => `${uqTagId}${epoch++}`;\n    const sendPromise = (0, util_1.promisify)(ws.send);\n    /** send a raw buffer */\n    const sendRawMessage = async (data) => {\n        if (!ws.isOpen) {\n            throw new boom_1.Boom('Connection Closed', { statusCode: Types_1.DisconnectReason.connectionClosed });\n        }\n        const bytes = noise.encodeFrame(data);\n        await (0, Utils_1.promiseTimeout)(connectTimeoutMs, async (resolve, reject) => {\n            try {\n                await sendPromise.call(ws, bytes);\n                resolve();\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    };\n    /** send a binary node */\n    const sendNode = (frame) => {\n        if (logger.level === 'trace') {\n            logger.trace({ xml: (0, WABinary_1.binaryNodeToString)(frame), msg: 'xml send' });\n        }\n        const buff = (0, WABinary_1.encodeBinaryNode)(frame);\n        return sendRawMessage(buff);\n    };\n    /** log & process any unexpected errors */\n    const onUnexpectedError = (err, msg) => {\n        logger.error({ err }, `unexpected error in '${msg}'`);\n    };\n    /** await the next incoming message */\n    const awaitNextMessage = async (sendMsg) => {\n        if (!ws.isOpen) {\n            throw new boom_1.Boom('Connection Closed', {\n                statusCode: Types_1.DisconnectReason.connectionClosed\n            });\n        }\n        let onOpen;\n        let onClose;\n        const result = (0, Utils_1.promiseTimeout)(connectTimeoutMs, (resolve, reject) => {\n            onOpen = resolve;\n            onClose = mapWebSocketError(reject);\n            ws.on('frame', onOpen);\n            ws.on('close', onClose);\n            ws.on('error', onClose);\n        })\n            .finally(() => {\n            ws.off('frame', onOpen);\n            ws.off('close', onClose);\n            ws.off('error', onClose);\n        });\n        if (sendMsg) {\n            sendRawMessage(sendMsg).catch(onClose);\n        }\n        return result;\n    };\n    /**\n     * Wait for a message with a certain tag to be received\n     * @param msgId the message tag to await\n     * @param timeoutMs timeout after which the promise will reject\n     */\n    const waitForMessage = async (msgId, timeoutMs = defaultQueryTimeoutMs) => {\n        let onRecv;\n        let onErr;\n        try {\n            return await (0, Utils_1.promiseTimeout)(timeoutMs, (resolve, reject) => {\n                onRecv = resolve;\n                onErr = err => {\n                    reject(err || new boom_1.Boom('Connection Closed', { statusCode: Types_1.DisconnectReason.connectionClosed }));\n                };\n                ws.on(`TAG:${msgId}`, onRecv);\n                ws.on('close', onErr); // if the socket closes, you'll never receive the message\n                ws.off('error', onErr);\n            });\n        }\n        finally {\n            ws.off(`TAG:${msgId}`, onRecv);\n            ws.off('close', onErr); // if the socket closes, you'll never receive the message\n            ws.off('error', onErr);\n        }\n    };\n    /** send a query, and wait for its response. auto-generates message ID if not provided */\n    const query = async (node, timeoutMs) => {\n        if (!node.attrs.id) {\n            node.attrs.id = generateMessageTag();\n        }\n        const msgId = node.attrs.id;\n        const wait = waitForMessage(msgId, timeoutMs);\n        await sendNode(node);\n        const result = await wait;\n        if ('tag' in result) {\n            (0, WABinary_1.assertNodeErrorFree)(result);\n        }\n        return result;\n    };\n    /** connection handshake */\n    const validateConnection = async () => {\n        let helloMsg = {\n            clientHello: { ephemeral: ephemeralKeyPair.public }\n        };\n        helloMsg = WAProto_1.proto.HandshakeMessage.fromObject(helloMsg);\n        logger.info({ browser, helloMsg }, 'connected to WA');\n        const init = WAProto_1.proto.HandshakeMessage.encode(helloMsg).finish();\n        const result = await awaitNextMessage(init);\n        const handshake = WAProto_1.proto.HandshakeMessage.decode(result);\n        logger.trace({ handshake }, 'handshake recv from WA');\n        const keyEnc = noise.processHandshake(handshake, creds.noiseKey);\n        let node;\n        if (config.mobile) {\n            node = (0, Utils_1.generateMobileNode)(config);\n        }\n        else if (!creds.me) {\n            node = (0, Utils_1.generateRegistrationNode)(creds, config);\n            logger.info({ node }, 'not logged in, attempting registration...');\n        }\n        else {\n            node = (0, Utils_1.generateLoginNode)(creds.me.id, config);\n            logger.info({ node }, 'logging in...');\n        }\n        const payloadEnc = noise.encrypt(WAProto_1.proto.ClientPayload.encode(node).finish());\n        await sendRawMessage(WAProto_1.proto.HandshakeMessage.encode({\n            clientFinish: {\n                static: keyEnc,\n                payload: payloadEnc,\n            },\n        }).finish());\n        noise.finishInit();\n        startKeepAliveRequest();\n    };\n    const getAvailablePreKeysOnServer = async () => {\n        const result = await query({\n            tag: 'iq',\n            attrs: {\n                id: generateMessageTag(),\n                xmlns: 'encrypt',\n                type: 'get',\n                to: WABinary_1.S_WHATSAPP_NET\n            },\n            content: [\n                { tag: 'count', attrs: {} }\n            ]\n        });\n        const countChild = (0, WABinary_1.getBinaryNodeChild)(result, 'count');\n        return +countChild.attrs.value;\n    };\n    /** generates and uploads a set of pre-keys to the server */\n    const uploadPreKeys = async (count = Defaults_1.INITIAL_PREKEY_COUNT) => {\n        await keys.transaction(async () => {\n            logger.info({ count }, 'uploading pre-keys');\n            const { update, node } = await (0, Utils_1.getNextPreKeysNode)({ creds, keys }, count);\n            await query(node);\n            ev.emit('creds.update', update);\n            logger.info({ count }, 'uploaded pre-keys');\n        });\n    };\n    const uploadPreKeysToServerIfRequired = async () => {\n        const preKeyCount = await getAvailablePreKeysOnServer();\n        logger.info(`${preKeyCount} pre-keys found on server`);\n        if (preKeyCount <= Defaults_1.MIN_PREKEY_COUNT) {\n            await uploadPreKeys();\n        }\n    };\n    const onMessageReceived = (data) => {\n        noise.decodeFrame(data, frame => {\n            var _a;\n            // reset ping timeout\n            lastDateRecv = new Date();\n            let anyTriggered = false;\n            anyTriggered = ws.emit('frame', frame);\n            // if it's a binary node\n            if (!(frame instanceof Uint8Array)) {\n                const msgId = frame.attrs.id;\n                if (logger.level === 'trace') {\n                    logger.trace({ xml: (0, WABinary_1.binaryNodeToString)(frame), msg: 'recv xml' });\n                }\n                /* Check if this is a response to a message we sent */\n                anyTriggered = ws.emit(`${Defaults_1.DEF_TAG_PREFIX}${msgId}`, frame) || anyTriggered;\n                /* Check if this is a response to a message we are expecting */\n                const l0 = frame.tag;\n                const l1 = frame.attrs || {};\n                const l2 = Array.isArray(frame.content) ? (_a = frame.content[0]) === null || _a === void 0 ? void 0 : _a.tag : '';\n                Object.keys(l1).forEach(key => {\n                    anyTriggered = ws.emit(`${Defaults_1.DEF_CALLBACK_PREFIX}${l0},${key}:${l1[key]},${l2}`, frame) || anyTriggered;\n                    anyTriggered = ws.emit(`${Defaults_1.DEF_CALLBACK_PREFIX}${l0},${key}:${l1[key]}`, frame) || anyTriggered;\n                    anyTriggered = ws.emit(`${Defaults_1.DEF_CALLBACK_PREFIX}${l0},${key}`, frame) || anyTriggered;\n                });\n                anyTriggered = ws.emit(`${Defaults_1.DEF_CALLBACK_PREFIX}${l0},,${l2}`, frame) || anyTriggered;\n                anyTriggered = ws.emit(`${Defaults_1.DEF_CALLBACK_PREFIX}${l0}`, frame) || anyTriggered;\n                if (!anyTriggered && logger.level === 'debug') {\n                    logger.debug({ unhandled: true, msgId, fromMe: false, frame }, 'communication recv');\n                }\n            }\n        });\n    };\n    const end = (error) => {\n        if (closed) {\n            logger.trace({ trace: error === null || error === void 0 ? void 0 : error.stack }, 'connection already closed');\n            return;\n        }\n        closed = true;\n        logger.info({ trace: error === null || error === void 0 ? void 0 : error.stack }, error ? 'connection errored' : 'connection closed');\n        clearInterval(keepAliveReq);\n        clearTimeout(qrTimer);\n        ws.removeAllListeners('close');\n        ws.removeAllListeners('error');\n        ws.removeAllListeners('open');\n        ws.removeAllListeners('message');\n        if (!ws.isClosed && !ws.isClosing) {\n            try {\n                ws.close();\n            }\n            catch (_a) { }\n        }\n        ev.emit('connection.update', {\n            connection: 'close',\n            lastDisconnect: {\n                error,\n                date: new Date()\n            }\n        });\n        ev.removeAllListeners('connection.update');\n    };\n    const waitForSocketOpen = async () => {\n        if (ws.isOpen) {\n            return;\n        }\n        if (ws.isClosed || ws.isClosing) {\n            throw new boom_1.Boom('Connection Closed', { statusCode: Types_1.DisconnectReason.connectionClosed });\n        }\n        let onOpen;\n        let onClose;\n        await new Promise((resolve, reject) => {\n            onOpen = () => resolve(undefined);\n            onClose = mapWebSocketError(reject);\n            ws.on('open', onOpen);\n            ws.on('close', onClose);\n            ws.on('error', onClose);\n        })\n            .finally(() => {\n            ws.off('open', onOpen);\n            ws.off('close', onClose);\n            ws.off('error', onClose);\n        });\n    };\n    const startKeepAliveRequest = () => (keepAliveReq = setInterval(() => {\n        if (!lastDateRecv) {\n            lastDateRecv = new Date();\n        }\n        const diff = Date.now() - lastDateRecv.getTime();\n        /*\n            check if it's been a suspicious amount of time since the server responded with our last seen\n            it could be that the network is down\n        */\n        if (diff > keepAliveIntervalMs + 5000) {\n            end(new boom_1.Boom('Connection was lost', { statusCode: Types_1.DisconnectReason.connectionLost }));\n        }\n        else if (ws.isOpen) {\n            // if its all good, send a keep alive request\n            query({\n                tag: 'iq',\n                attrs: {\n                    id: generateMessageTag(),\n                    to: WABinary_1.S_WHATSAPP_NET,\n                    type: 'get',\n                    xmlns: 'w:p',\n                },\n                content: [{ tag: 'ping', attrs: {} }]\n            })\n                .catch(err => {\n                logger.error({ trace: err.stack }, 'error in sending keep alive');\n            });\n        }\n        else {\n            logger.warn('keep alive called when WS not open');\n        }\n    }, keepAliveIntervalMs));\n    /** i have no idea why this exists. pls enlighten me */\n    const sendPassiveIq = (tag) => (query({\n        tag: 'iq',\n        attrs: {\n            to: WABinary_1.S_WHATSAPP_NET,\n            xmlns: 'passive',\n            type: 'set',\n        },\n        content: [\n            { tag, attrs: {} }\n        ]\n    }));\n    /** logout & invalidate connection */\n    const logout = async (msg) => {\n        var _a;\n        const jid = (_a = authState.creds.me) === null || _a === void 0 ? void 0 : _a.id;\n        if (jid) {\n            await sendNode({\n                tag: 'iq',\n                attrs: {\n                    to: WABinary_1.S_WHATSAPP_NET,\n                    type: 'set',\n                    id: generateMessageTag(),\n                    xmlns: 'md'\n                },\n                content: [\n                    {\n                        tag: 'remove-companion-device',\n                        attrs: {\n                            jid,\n                            reason: 'user_initiated'\n                        }\n                    }\n                ]\n            });\n        }\n        end(new boom_1.Boom(msg || 'Intentional Logout', { statusCode: Types_1.DisconnectReason.loggedOut }));\n    };\n    const requestPairingCode = async (phoneNumber) => {\n        authState.creds.pairingCode = (0, Utils_1.bytesToCrockford)((0, crypto_1.randomBytes)(5));\n        authState.creds.me = {\n            id: (0, WABinary_1.jidEncode)(phoneNumber, 's.whatsapp.net'),\n            name: '~'\n        };\n        ev.emit('creds.update', authState.creds);\n        await sendNode({\n            tag: 'iq',\n            attrs: {\n                to: WABinary_1.S_WHATSAPP_NET,\n                type: 'set',\n                id: generateMessageTag(),\n                xmlns: 'md'\n            },\n            content: [\n                {\n                    tag: 'link_code_companion_reg',\n                    attrs: {\n                        jid: authState.creds.me.id,\n                        stage: 'companion_hello',\n                        // eslint-disable-next-line camelcase\n                        should_show_push_notification: 'true'\n                    },\n                    content: [\n                        {\n                            tag: 'link_code_pairing_wrapped_companion_ephemeral_pub',\n                            attrs: {},\n                            content: await generatePairingKey()\n                        },\n                        {\n                            tag: 'companion_server_auth_key_pub',\n                            attrs: {},\n                            content: authState.creds.noiseKey.public\n                        },\n                        {\n                            tag: 'companion_platform_id',\n                            attrs: {},\n                            content: (0, Utils_1.getPlatformId)(browser[1])\n                        },\n                        {\n                            tag: 'companion_platform_display',\n                            attrs: {},\n                            content: `${browser[1]} (${browser[0]})`\n                        },\n                        {\n                            tag: 'link_code_pairing_nonce',\n                            attrs: {},\n                            content: '0'\n                        }\n                    ]\n                }\n            ]\n        });\n        return authState.creds.pairingCode;\n    };\n    async function generatePairingKey() {\n        const salt = (0, crypto_1.randomBytes)(32);\n        const randomIv = (0, crypto_1.randomBytes)(16);\n        const key = await (0, Utils_1.derivePairingCodeKey)(authState.creds.pairingCode, salt);\n        const ciphered = (0, Utils_1.aesEncryptCTR)(authState.creds.pairingEphemeralKeyPair.public, key, randomIv);\n        return Buffer.concat([salt, randomIv, ciphered]);\n    }\n    const sendWAMBuffer = (wamBuffer) => {\n        return query({\n            tag: 'iq',\n            attrs: {\n                to: WABinary_1.S_WHATSAPP_NET,\n                id: generateMessageTag(),\n                xmlns: 'w:stats'\n            },\n            content: [\n                {\n                    tag: 'add',\n                    attrs: {},\n                    content: wamBuffer\n                }\n            ]\n        });\n    };\n    ws.on('message', onMessageReceived);\n    ws.on('open', async () => {\n        try {\n            await validateConnection();\n        }\n        catch (err) {\n            logger.error({ err }, 'error in validating connection');\n            end(err);\n        }\n    });\n    ws.on('error', mapWebSocketError(end));\n    ws.on('close', () => end(new boom_1.Boom('Connection Terminated', { statusCode: Types_1.DisconnectReason.connectionClosed })));\n    // the server terminated the connection\n    ws.on('CB:xmlstreamend', () => end(new boom_1.Boom('Connection Terminated by Server', { statusCode: Types_1.DisconnectReason.connectionClosed })));\n    // QR gen\n    ws.on('CB:iq,type:set,pair-device', async (stanza) => {\n        const iq = {\n            tag: 'iq',\n            attrs: {\n                to: WABinary_1.S_WHATSAPP_NET,\n                type: 'result',\n                id: stanza.attrs.id,\n            }\n        };\n        await sendNode(iq);\n        const pairDeviceNode = (0, WABinary_1.getBinaryNodeChild)(stanza, 'pair-device');\n        const refNodes = (0, WABinary_1.getBinaryNodeChildren)(pairDeviceNode, 'ref');\n        const noiseKeyB64 = Buffer.from(creds.noiseKey.public).toString('base64');\n        const identityKeyB64 = Buffer.from(creds.signedIdentityKey.public).toString('base64');\n        const advB64 = creds.advSecretKey;\n        let qrMs = qrTimeout || 60000; // time to let a QR live\n        const genPairQR = () => {\n            if (!ws.isOpen) {\n                return;\n            }\n            const refNode = refNodes.shift();\n            if (!refNode) {\n                end(new boom_1.Boom('QR refs attempts ended', { statusCode: Types_1.DisconnectReason.timedOut }));\n                return;\n            }\n            const ref = refNode.content.toString('utf-8');\n            const qr = [ref, noiseKeyB64, identityKeyB64, advB64].join(',');\n            ev.emit('connection.update', { qr });\n            qrTimer = setTimeout(genPairQR, qrMs);\n            qrMs = qrTimeout || 20000; // shorter subsequent qrs\n        };\n        genPairQR();\n    });\n    // device paired for the first time\n    // if device pairs successfully, the server asks to restart the connection\n    ws.on('CB:iq,,pair-success', async (stanza) => {\n        logger.debug('pair success recv');\n        try {\n            const { reply, creds: updatedCreds } = (0, Utils_1.configureSuccessfulPairing)(stanza, creds);\n            logger.info({ me: updatedCreds.me, platform: updatedCreds.platform }, 'pairing configured successfully, expect to restart the connection...');\n            ev.emit('creds.update', updatedCreds);\n            ev.emit('connection.update', { isNewLogin: true, qr: undefined });\n            await sendNode(reply);\n        }\n        catch (error) {\n            logger.info({ trace: error.stack }, 'error in pairing');\n            end(error);\n        }\n    });\n    // login complete\n    ws.on('CB:success', async (node) => {\n        await uploadPreKeysToServerIfRequired();\n        await sendPassiveIq('active');\n        logger.info('opened connection to WA');\n        clearTimeout(qrTimer); // will never happen in all likelyhood -- but just in case WA sends success on first try\n        ev.emit('creds.update', { me: { ...authState.creds.me, lid: node.attrs.lid } });\n        ev.emit('connection.update', { connection: 'open' });\n    });\n    ws.on('CB:stream:error', (node) => {\n        logger.error({ node }, 'stream errored out');\n        const { reason, statusCode } = (0, Utils_1.getErrorCodeFromStreamError)(node);\n        end(new boom_1.Boom(`Stream Errored (${reason})`, { statusCode, data: node }));\n    });\n    // stream fail, possible logout\n    ws.on('CB:failure', (node) => {\n        const reason = +(node.attrs.reason || 500);\n        end(new boom_1.Boom('Connection Failure', { statusCode: reason, data: node.attrs }));\n    });\n    ws.on('CB:ib,,downgrade_webclient', () => {\n        end(new boom_1.Boom('Multi-device beta not joined', { statusCode: Types_1.DisconnectReason.multideviceMismatch }));\n    });\n    ws.on('CB:ib,,edge_routing', (node) => {\n        const edgeRoutingNode = (0, WABinary_1.getBinaryNodeChild)(node, 'edge_routing');\n        const routingInfo = (0, WABinary_1.getBinaryNodeChild)(edgeRoutingNode, 'routing_info');\n        if (routingInfo === null || routingInfo === void 0 ? void 0 : routingInfo.content) {\n            authState.creds.routingInfo = Buffer.from(routingInfo === null || routingInfo === void 0 ? void 0 : routingInfo.content);\n            ev.emit('creds.update', authState.creds);\n        }\n    });\n    let didStartBuffer = false;\n    process.nextTick(() => {\n        var _a;\n        if ((_a = creds.me) === null || _a === void 0 ? void 0 : _a.id) {\n            // start buffering important events\n            // if we're logged in\n            ev.buffer();\n            didStartBuffer = true;\n        }\n        ev.emit('connection.update', { connection: 'connecting', receivedPendingNotifications: false, qr: undefined });\n    });\n    // called when all offline notifs are handled\n    ws.on('CB:ib,,offline', (node) => {\n        const child = (0, WABinary_1.getBinaryNodeChild)(node, 'offline');\n        const offlineNotifs = +((child === null || child === void 0 ? void 0 : child.attrs.count) || 0);\n        logger.info(`handled ${offlineNotifs} offline messages/notifications`);\n        if (didStartBuffer) {\n            ev.flush();\n            logger.trace('flushed events for initial buffer');\n        }\n        ev.emit('connection.update', { receivedPendingNotifications: true });\n    });\n    // update credentials when required\n    ev.on('creds.update', update => {\n        var _a, _b;\n        const name = (_a = update.me) === null || _a === void 0 ? void 0 : _a.name;\n        // if name has just been received\n        if (((_b = creds.me) === null || _b === void 0 ? void 0 : _b.name) !== name) {\n            logger.debug({ name }, 'updated pushName');\n            sendNode({\n                tag: 'presence',\n                attrs: { name: name }\n            })\n                .catch(err => {\n                logger.warn({ trace: err.stack }, 'error in sending presence update on name change');\n            });\n        }\n        Object.assign(creds, update);\n    });\n    if (printQRInTerminal) {\n        (0, Utils_1.printQRIfNecessaryListener)(ev, logger);\n    }\n    return {\n        type: 'md',\n        ws,\n        ev,\n        authState: { creds, keys },\n        signalRepository,\n        get user() {\n            return authState.creds.me;\n        },\n        generateMessageTag,\n        query,\n        waitForMessage,\n        waitForSocketOpen,\n        sendRawMessage,\n        sendNode,\n        logout,\n        end,\n        onUnexpectedError,\n        uploadPreKeys,\n        uploadPreKeysToServerIfRequired,\n        requestPairingCode,\n        /** Waits for the connection to WA to reach a state */\n        waitForConnectionUpdate: (0, Utils_1.bindWaitForConnectionUpdate)(ev),\n        sendWAMBuffer,\n    };\n};\nexports.makeSocket = makeSocket;\n/**\n * map the websocket error to the right type\n * so it can be retried by the caller\n * */\nfunction mapWebSocketError(handler) {\n    return (error) => {\n        handler(new boom_1.Boom(`WebSocket Error (${error === null || error === void 0 ? void 0 : error.message})`, { statusCode: (0, Utils_1.getCodeFromWSError)(error), data: error }));\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}