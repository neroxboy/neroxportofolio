{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DsdiffParser = void 0;\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst DsdiffToken_1 = require(\"./DsdiffToken\");\nconst debug = (0, debug_1.default)('music-metadata:parser:aiff');\n/**\n * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)\n *\n * Ref:\n * - http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\n */\nclass DsdiffParser extends BasicParser_1.BasicParser {\n  async parse() {\n    const header = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n    if (header.chunkID !== 'FRM8') throw new Error('Unexpected chunk-ID');\n    const type = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n    switch (type) {\n      case 'DSD':\n        this.metadata.setFormat('container', `DSDIFF/${type}`);\n        this.metadata.setFormat('lossless', true);\n        return this.readFmt8Chunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));\n      default:\n        throw Error(`Unsupported DSDIFF type: ${type}`);\n    }\n  }\n  async readFmt8Chunks(remainingSize) {\n    while (remainingSize >= DsdiffToken_1.ChunkHeader64.len) {\n      const chunkHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n      //  If the data is an odd number of bytes in length, a pad byte must be added at the end\n      debug(`Chunk id=${chunkHeader.chunkID}`);\n      await this.readData(chunkHeader);\n      remainingSize -= BigInt(DsdiffToken_1.ChunkHeader64.len) + chunkHeader.chunkSize;\n    }\n  }\n  async readData(header) {\n    debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n    const p0 = this.tokenizer.position;\n    switch (header.chunkID.trim()) {\n      case 'FVER':\n        // 3.1 FORMAT VERSION CHUNK\n        const version = await this.tokenizer.readToken(Token.UINT32_LE);\n        debug(`DSDIFF version=${version}`);\n        break;\n      case 'PROP':\n        // 3.2 PROPERTY CHUNK\n        const propType = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        if (propType !== 'SND ') throw new Error('Unexpected PROP-chunk ID');\n        await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));\n        break;\n      case 'ID3':\n        // Unofficial ID3 tag support\n        const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(Number(header.chunkSize)));\n        const rst = strtok3.fromBuffer(id3_data);\n        await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n        break;\n      default:\n        debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n        break;\n      case 'DSD':\n        this.metadata.setFormat('numberOfSamples', Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));\n        this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n        break;\n    }\n    const remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);\n    if (remaining > 0) {\n      debug(`After Parsing chunk, remaining ${remaining} bytes`);\n      await this.tokenizer.ignore(Number(remaining));\n    }\n  }\n  async handleSoundPropertyChunks(remainingSize) {\n    debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n    while (remainingSize > 0) {\n      const sndPropHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n      debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n      const p0 = this.tokenizer.position;\n      switch (sndPropHeader.chunkID.trim()) {\n        case 'FS':\n          // 3.2.1 Sample Rate Chunk\n          const sampleRate = await this.tokenizer.readToken(Token.UINT32_BE);\n          this.metadata.setFormat('sampleRate', sampleRate);\n          break;\n        case 'CHNL':\n          // 3.2.2 Channels Chunk\n          const numChannels = await this.tokenizer.readToken(Token.UINT16_BE);\n          this.metadata.setFormat('numberOfChannels', numChannels);\n          await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(Token.UINT16_BE.len));\n          break;\n        case 'CMPR':\n          // 3.2.3 Compression Type Chunk\n          const compressionIdCode = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n          const count = await this.tokenizer.readToken(Token.UINT8);\n          const compressionName = await this.tokenizer.readToken(new Token.StringType(count, 'ascii'));\n          if (compressionIdCode === 'DSD') {\n            this.metadata.setFormat('lossless', true);\n            this.metadata.setFormat('bitsPerSample', 1);\n          }\n          this.metadata.setFormat('codec', `${compressionIdCode} (${compressionName})`);\n          break;\n        case 'ABSS':\n          // 3.2.4 Absolute Start Time Chunk\n          const hours = await this.tokenizer.readToken(Token.UINT16_BE);\n          const minutes = await this.tokenizer.readToken(Token.UINT8);\n          const seconds = await this.tokenizer.readToken(Token.UINT8);\n          const samples = await this.tokenizer.readToken(Token.UINT32_BE);\n          debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);\n          break;\n        case 'LSCO':\n          // 3.2.5 Loudspeaker Configuration Chunk\n          const lsConfig = await this.tokenizer.readToken(Token.UINT16_BE);\n          debug(`LSCO lsConfig=${lsConfig}`);\n          break;\n        case 'COMT':\n        default:\n          debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n          await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));\n      }\n      const remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);\n      if (remaining > 0) {\n        debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);\n        await this.tokenizer.ignore(Number(remaining));\n      }\n      remainingSize -= BigInt(DsdiffToken_1.ChunkHeader64.len) + sndPropHeader.chunkSize;\n      debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n    }\n    if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {\n      const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;\n      this.metadata.setFormat('bitrate', bitrate);\n    }\n  }\n  async handleChannelChunks(remainingSize) {\n    debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);\n    const channels = [];\n    while (remainingSize >= FourCC_1.FourCcToken.len) {\n      const channelId = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n      debug(`Channel[ID=${channelId}]`);\n      channels.push(channelId);\n      remainingSize -= BigInt(FourCC_1.FourCcToken.len);\n    }\n    debug(`Channels: ${channels.join(', ')}`);\n    return channels;\n  }\n}\nexports.DsdiffParser = DsdiffParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","DsdiffParser","Token","require","debug_1","strtok3","FourCC_1","BasicParser_1","ID3v2Parser_1","DsdiffToken_1","debug","default","BasicParser","parse","header","tokenizer","readToken","ChunkHeader64","chunkID","Error","type","FourCcToken","trim","metadata","setFormat","readFmt8Chunks","chunkSize","BigInt","len","remainingSize","chunkHeader","readData","p0","position","version","UINT32_LE","propType","handleSoundPropertyChunks","id3_data","Uint8ArrayType","Number","rst","fromBuffer","ID3v2Parser","options","format","numberOfChannels","numberOfSamples","sampleRate","remaining","ignore","sndPropHeader","UINT32_BE","numChannels","UINT16_BE","handleChannelChunks","compressionIdCode","count","UINT8","compressionName","StringType","hours","minutes","seconds","samples","lsConfig","lossless","bitsPerSample","bitrate","channels","channelId","push","join"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/dsdiff/DsdiffParser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DsdiffParser = void 0;\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst DsdiffToken_1 = require(\"./DsdiffToken\");\nconst debug = (0, debug_1.default)('music-metadata:parser:aiff');\n/**\n * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)\n *\n * Ref:\n * - http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\n */\nclass DsdiffParser extends BasicParser_1.BasicParser {\n    async parse() {\n        const header = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n        if (header.chunkID !== 'FRM8')\n            throw new Error('Unexpected chunk-ID');\n        const type = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n        switch (type) {\n            case 'DSD':\n                this.metadata.setFormat('container', `DSDIFF/${type}`);\n                this.metadata.setFormat('lossless', true);\n                return this.readFmt8Chunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));\n            default:\n                throw Error(`Unsupported DSDIFF type: ${type}`);\n        }\n    }\n    async readFmt8Chunks(remainingSize) {\n        while (remainingSize >= DsdiffToken_1.ChunkHeader64.len) {\n            const chunkHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n            //  If the data is an odd number of bytes in length, a pad byte must be added at the end\n            debug(`Chunk id=${chunkHeader.chunkID}`);\n            await this.readData(chunkHeader);\n            remainingSize -= (BigInt(DsdiffToken_1.ChunkHeader64.len) + chunkHeader.chunkSize);\n        }\n    }\n    async readData(header) {\n        debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n        const p0 = this.tokenizer.position;\n        switch (header.chunkID.trim()) {\n            case 'FVER': // 3.1 FORMAT VERSION CHUNK\n                const version = await this.tokenizer.readToken(Token.UINT32_LE);\n                debug(`DSDIFF version=${version}`);\n                break;\n            case 'PROP': // 3.2 PROPERTY CHUNK\n                const propType = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n                if (propType !== 'SND ')\n                    throw new Error('Unexpected PROP-chunk ID');\n                await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));\n                break;\n            case 'ID3': // Unofficial ID3 tag support\n                const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(Number(header.chunkSize)));\n                const rst = strtok3.fromBuffer(id3_data);\n                await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n                break;\n            default:\n                debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n                break;\n            case 'DSD':\n                this.metadata.setFormat('numberOfSamples', Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));\n                this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n                break;\n        }\n        const remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);\n        if (remaining > 0) {\n            debug(`After Parsing chunk, remaining ${remaining} bytes`);\n            await this.tokenizer.ignore(Number(remaining));\n        }\n    }\n    async handleSoundPropertyChunks(remainingSize) {\n        debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n        while (remainingSize > 0) {\n            const sndPropHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n            debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n            const p0 = this.tokenizer.position;\n            switch (sndPropHeader.chunkID.trim()) {\n                case 'FS': // 3.2.1 Sample Rate Chunk\n                    const sampleRate = await this.tokenizer.readToken(Token.UINT32_BE);\n                    this.metadata.setFormat('sampleRate', sampleRate);\n                    break;\n                case 'CHNL': // 3.2.2 Channels Chunk\n                    const numChannels = await this.tokenizer.readToken(Token.UINT16_BE);\n                    this.metadata.setFormat('numberOfChannels', numChannels);\n                    await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(Token.UINT16_BE.len));\n                    break;\n                case 'CMPR': // 3.2.3 Compression Type Chunk\n                    const compressionIdCode = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n                    const count = await this.tokenizer.readToken(Token.UINT8);\n                    const compressionName = await this.tokenizer.readToken(new Token.StringType(count, 'ascii'));\n                    if (compressionIdCode === 'DSD') {\n                        this.metadata.setFormat('lossless', true);\n                        this.metadata.setFormat('bitsPerSample', 1);\n                    }\n                    this.metadata.setFormat('codec', `${compressionIdCode} (${compressionName})`);\n                    break;\n                case 'ABSS': // 3.2.4 Absolute Start Time Chunk\n                    const hours = await this.tokenizer.readToken(Token.UINT16_BE);\n                    const minutes = await this.tokenizer.readToken(Token.UINT8);\n                    const seconds = await this.tokenizer.readToken(Token.UINT8);\n                    const samples = await this.tokenizer.readToken(Token.UINT32_BE);\n                    debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);\n                    break;\n                case 'LSCO': // 3.2.5 Loudspeaker Configuration Chunk\n                    const lsConfig = await this.tokenizer.readToken(Token.UINT16_BE);\n                    debug(`LSCO lsConfig=${lsConfig}`);\n                    break;\n                case 'COMT':\n                default:\n                    debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n                    await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));\n            }\n            const remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);\n            if (remaining > 0) {\n                debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);\n                await this.tokenizer.ignore(Number(remaining));\n            }\n            remainingSize -= BigInt(DsdiffToken_1.ChunkHeader64.len) + sndPropHeader.chunkSize;\n            debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n        }\n        if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {\n            const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;\n            this.metadata.setFormat('bitrate', bitrate);\n        }\n    }\n    async handleChannelChunks(remainingSize) {\n        debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);\n        const channels = [];\n        while (remainingSize >= FourCC_1.FourCcToken.len) {\n            const channelId = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n            debug(`Channel[ID=${channelId}]`);\n            channels.push(channelId);\n            remainingSize -= BigInt(FourCC_1.FourCcToken.len);\n        }\n        debug(`Channels: ${channels.join(', ')}`);\n        return channels;\n    }\n}\nexports.DsdiffParser = DsdiffParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}