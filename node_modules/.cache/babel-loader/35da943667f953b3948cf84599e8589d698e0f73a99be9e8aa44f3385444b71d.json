{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamReader = void 0;\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst util = require(\"../../common/Util\");\nconst debug = (0, debug_1.default)('music-metadata:parser:musepack:sv8');\nconst PacketKey = new Token.StringType(2, 'binary');\n/**\n * Stream Header Packet part 1\n * Ref: http://trac.musepack.net/musepack/wiki/SV8Specification#StreamHeaderPacket\n */\nconst SH_part1 = {\n  len: 5,\n  get: (buf, off) => {\n    return {\n      crc: Token.UINT32_LE.get(buf, off),\n      streamVersion: Token.UINT8.get(buf, off + 4)\n    };\n  }\n};\n/**\n * Stream Header Packet part 3\n * Ref: http://trac.musepack.net/musepack/wiki/SV8Specification#StreamHeaderPacket\n */\nconst SH_part3 = {\n  len: 2,\n  get: (buf, off) => {\n    return {\n      sampleFrequency: [44100, 48000, 37800, 32000][util.getBitAllignedNumber(buf, off, 0, 3)],\n      maxUsedBands: util.getBitAllignedNumber(buf, off, 3, 5),\n      channelCount: util.getBitAllignedNumber(buf, off + 1, 0, 4) + 1,\n      msUsed: util.isBitSet(buf, off + 1, 4),\n      audioBlockFrames: util.getBitAllignedNumber(buf, off + 1, 5, 3)\n    };\n  }\n};\nclass StreamReader {\n  constructor(tokenizer) {\n    this.tokenizer = tokenizer;\n  }\n  async readPacketHeader() {\n    const key = await this.tokenizer.readToken(PacketKey);\n    const size = await this.readVariableSizeField();\n    return {\n      key,\n      payloadLength: size.value - 2 - size.len\n    };\n  }\n  async readStreamHeader(size) {\n    const streamHeader = {};\n    debug(`Reading SH at offset=${this.tokenizer.position}`);\n    const part1 = await this.tokenizer.readToken(SH_part1);\n    size -= SH_part1.len;\n    Object.assign(streamHeader, part1);\n    debug(`SH.streamVersion = ${part1.streamVersion}`);\n    const sampleCount = await this.readVariableSizeField();\n    size -= sampleCount.len;\n    streamHeader.sampleCount = sampleCount.value;\n    const bs = await this.readVariableSizeField();\n    size -= bs.len;\n    streamHeader.beginningOfSilence = bs.value;\n    const part3 = await this.tokenizer.readToken(SH_part3);\n    size -= SH_part3.len;\n    Object.assign(streamHeader, part3);\n    // assert.equal(size, 0);\n    await this.tokenizer.ignore(size);\n    return streamHeader;\n  }\n  async readVariableSizeField(len = 1, hb = 0) {\n    let n = await this.tokenizer.readNumber(Token.UINT8);\n    if ((n & 0x80) === 0) {\n      return {\n        len,\n        value: hb + n\n      };\n    }\n    n &= 0x7F;\n    n += hb;\n    return this.readVariableSizeField(len + 1, n << 7);\n  }\n}\nexports.StreamReader = StreamReader;","map":{"version":3,"names":["Object","defineProperty","exports","value","StreamReader","Token","require","debug_1","util","debug","default","PacketKey","StringType","SH_part1","len","get","buf","off","crc","UINT32_LE","streamVersion","UINT8","SH_part3","sampleFrequency","getBitAllignedNumber","maxUsedBands","channelCount","msUsed","isBitSet","audioBlockFrames","constructor","tokenizer","readPacketHeader","key","readToken","size","readVariableSizeField","payloadLength","readStreamHeader","streamHeader","position","part1","assign","sampleCount","bs","beginningOfSilence","part3","ignore","hb","n","readNumber"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/musepack/sv8/StreamVersion8.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StreamReader = void 0;\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst util = require(\"../../common/Util\");\nconst debug = (0, debug_1.default)('music-metadata:parser:musepack:sv8');\nconst PacketKey = new Token.StringType(2, 'binary');\n/**\n * Stream Header Packet part 1\n * Ref: http://trac.musepack.net/musepack/wiki/SV8Specification#StreamHeaderPacket\n */\nconst SH_part1 = {\n    len: 5,\n    get: (buf, off) => {\n        return {\n            crc: Token.UINT32_LE.get(buf, off),\n            streamVersion: Token.UINT8.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Stream Header Packet part 3\n * Ref: http://trac.musepack.net/musepack/wiki/SV8Specification#StreamHeaderPacket\n */\nconst SH_part3 = {\n    len: 2,\n    get: (buf, off) => {\n        return {\n            sampleFrequency: [44100, 48000, 37800, 32000][util.getBitAllignedNumber(buf, off, 0, 3)],\n            maxUsedBands: util.getBitAllignedNumber(buf, off, 3, 5),\n            channelCount: util.getBitAllignedNumber(buf, off + 1, 0, 4) + 1,\n            msUsed: util.isBitSet(buf, off + 1, 4),\n            audioBlockFrames: util.getBitAllignedNumber(buf, off + 1, 5, 3)\n        };\n    }\n};\nclass StreamReader {\n    constructor(tokenizer) {\n        this.tokenizer = tokenizer;\n    }\n    async readPacketHeader() {\n        const key = await this.tokenizer.readToken(PacketKey);\n        const size = await this.readVariableSizeField();\n        return {\n            key,\n            payloadLength: size.value - 2 - size.len\n        };\n    }\n    async readStreamHeader(size) {\n        const streamHeader = {};\n        debug(`Reading SH at offset=${this.tokenizer.position}`);\n        const part1 = await this.tokenizer.readToken(SH_part1);\n        size -= SH_part1.len;\n        Object.assign(streamHeader, part1);\n        debug(`SH.streamVersion = ${part1.streamVersion}`);\n        const sampleCount = await this.readVariableSizeField();\n        size -= sampleCount.len;\n        streamHeader.sampleCount = sampleCount.value;\n        const bs = await this.readVariableSizeField();\n        size -= bs.len;\n        streamHeader.beginningOfSilence = bs.value;\n        const part3 = await this.tokenizer.readToken(SH_part3);\n        size -= SH_part3.len;\n        Object.assign(streamHeader, part3);\n        // assert.equal(size, 0);\n        await this.tokenizer.ignore(size);\n        return streamHeader;\n    }\n    async readVariableSizeField(len = 1, hb = 0) {\n        let n = await this.tokenizer.readNumber(Token.UINT8);\n        if ((n & 0x80) === 0) {\n            return { len, value: hb + n };\n        }\n        n &= 0x7F;\n        n += hb;\n        return this.readVariableSizeField(len + 1, n << 7);\n    }\n}\nexports.StreamReader = StreamReader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}