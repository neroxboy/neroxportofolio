{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scanAppendingHeaders = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = exports.parseStream = void 0;\nconst strtok3 = require(\"strtok3/lib/core\");\nconst ParserFactory_1 = require(\"./ParserFactory\");\nconst RandomUint8ArrayReader_1 = require(\"./common/RandomUint8ArrayReader\");\nconst APEv2Parser_1 = require(\"./apev2/APEv2Parser\");\nconst ID3v1Parser_1 = require(\"./id3v1/ID3v1Parser\");\nconst Lyrics3_1 = require(\"./lyrics3/Lyrics3\");\n/**\n * Parse audio from Node Stream.Readable\n * @param stream - Stream to read the audio track from\n * @param options - Parsing options\n * @param fileInfo - File information object or MIME-type string\n * @returns Metadata\n */\nfunction parseStream(stream, fileInfo, options = {}) {\n  return parseFromTokenizer(strtok3.fromStream(stream, typeof fileInfo === 'string' ? {\n    mimeType: fileInfo\n  } : fileInfo), options);\n}\nexports.parseStream = parseStream;\n/**\n * Parse audio from Node Buffer\n * @param uint8Array - Uint8Array holding audio data\n * @param fileInfo - File information object or MIME-type string\n * @param options - Parsing options\n * @returns Metadata\n * Ref: https://github.com/Borewit/strtok3/blob/e6938c81ff685074d5eb3064a11c0b03ca934c1d/src/index.ts#L15\n */\nasync function parseBuffer(uint8Array, fileInfo, options = {}) {\n  const bufferReader = new RandomUint8ArrayReader_1.RandomUint8ArrayReader(uint8Array);\n  await scanAppendingHeaders(bufferReader, options);\n  const tokenizer = strtok3.fromBuffer(uint8Array, typeof fileInfo === 'string' ? {\n    mimeType: fileInfo\n  } : fileInfo);\n  return parseFromTokenizer(tokenizer, options);\n}\nexports.parseBuffer = parseBuffer;\n/**\n * Parse audio from ITokenizer source\n * @param tokenizer - Audio source implementing the tokenizer interface\n * @param options - Parsing options\n * @returns Metadata\n */\nfunction parseFromTokenizer(tokenizer, options) {\n  return ParserFactory_1.ParserFactory.parseOnContentType(tokenizer, options);\n}\nexports.parseFromTokenizer = parseFromTokenizer;\n/**\n * Create a dictionary ordered by their tag id (key)\n * @param nativeTags list of tags\n * @returns tags indexed by id\n */\nfunction orderTags(nativeTags) {\n  const tags = {};\n  for (const tag of nativeTags) {\n    (tags[tag.id] = tags[tag.id] || []).push(tag.value);\n  }\n  return tags;\n}\nexports.orderTags = orderTags;\n/**\n * Convert rating to 1-5 star rating\n * @param rating: Normalized rating [0..1] (common.rating[n].rating)\n * @returns Number of stars: 1, 2, 3, 4 or 5 stars\n */\nfunction ratingToStars(rating) {\n  return rating === undefined ? 0 : 1 + Math.round(rating * 4);\n}\nexports.ratingToStars = ratingToStars;\n/**\n * Select most likely cover image.\n * @param pictures Usually metadata.common.picture\n * @return Cover image, if any, otherwise null\n */\nfunction selectCover(pictures) {\n  return pictures ? pictures.reduce((acc, cur) => {\n    if (cur.name && cur.name.toLowerCase() in ['front', 'cover', 'cover (front)']) return cur;\n    return acc;\n  }) : null;\n}\nexports.selectCover = selectCover;\nasync function scanAppendingHeaders(randomReader, options = {}) {\n  let apeOffset = randomReader.fileSize;\n  if (await (0, ID3v1Parser_1.hasID3v1Header)(randomReader)) {\n    apeOffset -= 128;\n    const lyricsLen = await (0, Lyrics3_1.getLyricsHeaderLength)(randomReader);\n    apeOffset -= lyricsLen;\n  }\n  options.apeHeader = await APEv2Parser_1.APEv2Parser.findApeFooterOffset(randomReader, apeOffset);\n}\nexports.scanAppendingHeaders = scanAppendingHeaders;","map":{"version":3,"names":["Object","defineProperty","exports","value","scanAppendingHeaders","selectCover","ratingToStars","orderTags","parseFromTokenizer","parseBuffer","parseStream","strtok3","require","ParserFactory_1","RandomUint8ArrayReader_1","APEv2Parser_1","ID3v1Parser_1","Lyrics3_1","stream","fileInfo","options","fromStream","mimeType","uint8Array","bufferReader","RandomUint8ArrayReader","tokenizer","fromBuffer","ParserFactory","parseOnContentType","nativeTags","tags","tag","id","push","rating","undefined","Math","round","pictures","reduce","acc","cur","name","toLowerCase","randomReader","apeOffset","fileSize","hasID3v1Header","lyricsLen","getLyricsHeaderLength","apeHeader","APEv2Parser","findApeFooterOffset"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/core.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.scanAppendingHeaders = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = exports.parseStream = void 0;\nconst strtok3 = require(\"strtok3/lib/core\");\nconst ParserFactory_1 = require(\"./ParserFactory\");\nconst RandomUint8ArrayReader_1 = require(\"./common/RandomUint8ArrayReader\");\nconst APEv2Parser_1 = require(\"./apev2/APEv2Parser\");\nconst ID3v1Parser_1 = require(\"./id3v1/ID3v1Parser\");\nconst Lyrics3_1 = require(\"./lyrics3/Lyrics3\");\n/**\n * Parse audio from Node Stream.Readable\n * @param stream - Stream to read the audio track from\n * @param options - Parsing options\n * @param fileInfo - File information object or MIME-type string\n * @returns Metadata\n */\nfunction parseStream(stream, fileInfo, options = {}) {\n    return parseFromTokenizer(strtok3.fromStream(stream, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo), options);\n}\nexports.parseStream = parseStream;\n/**\n * Parse audio from Node Buffer\n * @param uint8Array - Uint8Array holding audio data\n * @param fileInfo - File information object or MIME-type string\n * @param options - Parsing options\n * @returns Metadata\n * Ref: https://github.com/Borewit/strtok3/blob/e6938c81ff685074d5eb3064a11c0b03ca934c1d/src/index.ts#L15\n */\nasync function parseBuffer(uint8Array, fileInfo, options = {}) {\n    const bufferReader = new RandomUint8ArrayReader_1.RandomUint8ArrayReader(uint8Array);\n    await scanAppendingHeaders(bufferReader, options);\n    const tokenizer = strtok3.fromBuffer(uint8Array, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo);\n    return parseFromTokenizer(tokenizer, options);\n}\nexports.parseBuffer = parseBuffer;\n/**\n * Parse audio from ITokenizer source\n * @param tokenizer - Audio source implementing the tokenizer interface\n * @param options - Parsing options\n * @returns Metadata\n */\nfunction parseFromTokenizer(tokenizer, options) {\n    return ParserFactory_1.ParserFactory.parseOnContentType(tokenizer, options);\n}\nexports.parseFromTokenizer = parseFromTokenizer;\n/**\n * Create a dictionary ordered by their tag id (key)\n * @param nativeTags list of tags\n * @returns tags indexed by id\n */\nfunction orderTags(nativeTags) {\n    const tags = {};\n    for (const tag of nativeTags) {\n        (tags[tag.id] = (tags[tag.id] || [])).push(tag.value);\n    }\n    return tags;\n}\nexports.orderTags = orderTags;\n/**\n * Convert rating to 1-5 star rating\n * @param rating: Normalized rating [0..1] (common.rating[n].rating)\n * @returns Number of stars: 1, 2, 3, 4 or 5 stars\n */\nfunction ratingToStars(rating) {\n    return rating === undefined ? 0 : 1 + Math.round(rating * 4);\n}\nexports.ratingToStars = ratingToStars;\n/**\n * Select most likely cover image.\n * @param pictures Usually metadata.common.picture\n * @return Cover image, if any, otherwise null\n */\nfunction selectCover(pictures) {\n    return pictures ? pictures.reduce((acc, cur) => {\n        if (cur.name && cur.name.toLowerCase() in ['front', 'cover', 'cover (front)'])\n            return cur;\n        return acc;\n    }) : null;\n}\nexports.selectCover = selectCover;\nasync function scanAppendingHeaders(randomReader, options = {}) {\n    let apeOffset = randomReader.fileSize;\n    if (await (0, ID3v1Parser_1.hasID3v1Header)(randomReader)) {\n        apeOffset -= 128;\n        const lyricsLen = await (0, Lyrics3_1.getLyricsHeaderLength)(randomReader);\n        apeOffset -= lyricsLen;\n    }\n    options.apeHeader = await APEv2Parser_1.APEv2Parser.findApeFooterOffset(randomReader, apeOffset);\n}\nexports.scanAppendingHeaders = scanAppendingHeaders;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}