{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeChatsSocket = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst node_cache_1 = __importDefault(require(\"node-cache\"));\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst Types_1 = require(\"../Types\");\nconst Utils_1 = require(\"../Utils\");\nconst make_mutex_1 = require(\"../Utils/make-mutex\");\nconst process_message_1 = __importDefault(require(\"../Utils/process-message\"));\nconst WABinary_1 = require(\"../WABinary\");\nconst socket_1 = require(\"./socket\");\nconst MAX_SYNC_ATTEMPTS = 2;\nconst makeChatsSocket = config => {\n  const {\n    logger,\n    markOnlineOnConnect,\n    fireInitQueries,\n    appStateMacVerification,\n    shouldIgnoreJid,\n    shouldSyncHistoryMessage\n  } = config;\n  const sock = (0, socket_1.makeSocket)(config);\n  const {\n    ev,\n    ws,\n    authState,\n    generateMessageTag,\n    sendNode,\n    query,\n    onUnexpectedError\n  } = sock;\n  let privacySettings;\n  let needToFlushWithAppStateSync = false;\n  let pendingAppStateSync = false;\n  /** this mutex ensures that the notifications (receipts, messages etc.) are processed in order */\n  const processingMutex = (0, make_mutex_1.makeMutex)();\n  const placeholderResendCache = config.placeholderResendCache || new node_cache_1.default({\n    stdTTL: Defaults_1.DEFAULT_CACHE_TTLS.MSG_RETRY,\n    useClones: false\n  });\n  if (!config.placeholderResendCache) {\n    config.placeholderResendCache = placeholderResendCache;\n  }\n  /** helper function to fetch the given app state sync key */\n  const getAppStateSyncKey = async keyId => {\n    const {\n      [keyId]: key\n    } = await authState.keys.get('app-state-sync-key', [keyId]);\n    return key;\n  };\n  const fetchPrivacySettings = async (force = false) => {\n    if (!privacySettings || force) {\n      const {\n        content\n      } = await query({\n        tag: 'iq',\n        attrs: {\n          xmlns: 'privacy',\n          to: WABinary_1.S_WHATSAPP_NET,\n          type: 'get'\n        },\n        content: [{\n          tag: 'privacy',\n          attrs: {}\n        }]\n      });\n      privacySettings = (0, WABinary_1.reduceBinaryNodeToDictionary)(content === null || content === void 0 ? void 0 : content[0], 'category');\n    }\n    return privacySettings;\n  };\n  /** helper function to run a privacy IQ query */\n  const privacyQuery = async (name, value) => {\n    await query({\n      tag: 'iq',\n      attrs: {\n        xmlns: 'privacy',\n        to: WABinary_1.S_WHATSAPP_NET,\n        type: 'set'\n      },\n      content: [{\n        tag: 'privacy',\n        attrs: {},\n        content: [{\n          tag: 'category',\n          attrs: {\n            name,\n            value\n          }\n        }]\n      }]\n    });\n  };\n  const updateCallPrivacy = async value => {\n    await privacyQuery('calladd', value);\n  };\n  const updateLastSeenPrivacy = async value => {\n    await privacyQuery('last', value);\n  };\n  const updateOnlinePrivacy = async value => {\n    await privacyQuery('online', value);\n  };\n  const updateProfilePicturePrivacy = async value => {\n    await privacyQuery('profile', value);\n  };\n  const updateStatusPrivacy = async value => {\n    await privacyQuery('status', value);\n  };\n  const updateReadReceiptsPrivacy = async value => {\n    await privacyQuery('readreceipts', value);\n  };\n  const updateGroupsAddPrivacy = async value => {\n    await privacyQuery('groupadd', value);\n  };\n  const updateDefaultDisappearingMode = async duration => {\n    await query({\n      tag: 'iq',\n      attrs: {\n        xmlns: 'disappearing_mode',\n        to: WABinary_1.S_WHATSAPP_NET,\n        type: 'set'\n      },\n      content: [{\n        tag: 'disappearing_mode',\n        attrs: {\n          duration: duration.toString()\n        }\n      }]\n    });\n  };\n  /** helper function to run a generic IQ query */\n  const interactiveQuery = async (userNodes, queryNode) => {\n    const result = await query({\n      tag: 'iq',\n      attrs: {\n        to: WABinary_1.S_WHATSAPP_NET,\n        type: 'get',\n        xmlns: 'usync'\n      },\n      content: [{\n        tag: 'usync',\n        attrs: {\n          sid: generateMessageTag(),\n          mode: 'query',\n          last: 'true',\n          index: '0',\n          context: 'interactive'\n        },\n        content: [{\n          tag: 'query',\n          attrs: {},\n          content: [queryNode]\n        }, {\n          tag: 'list',\n          attrs: {},\n          content: userNodes\n        }]\n      }]\n    });\n    const usyncNode = (0, WABinary_1.getBinaryNodeChild)(result, 'usync');\n    const listNode = (0, WABinary_1.getBinaryNodeChild)(usyncNode, 'list');\n    const users = (0, WABinary_1.getBinaryNodeChildren)(listNode, 'user');\n    return users;\n  };\n  const onWhatsApp = async (...jids) => {\n    const query = {\n      tag: 'contact',\n      attrs: {}\n    };\n    const list = jids.map(jid => {\n      // insures only 1 + is there\n      const content = `+${jid.replace('+', '')}`;\n      return {\n        tag: 'user',\n        attrs: {},\n        content: [{\n          tag: 'contact',\n          attrs: {},\n          content\n        }]\n      };\n    });\n    const results = await interactiveQuery(list, query);\n    return results.map(user => {\n      const contact = (0, WABinary_1.getBinaryNodeChild)(user, 'contact');\n      return {\n        exists: (contact === null || contact === void 0 ? void 0 : contact.attrs.type) === 'in',\n        jid: user.attrs.jid\n      };\n    }).filter(item => item.exists);\n  };\n  const fetchStatus = async jid => {\n    const [result] = await interactiveQuery([{\n      tag: 'user',\n      attrs: {\n        jid\n      }\n    }], {\n      tag: 'status',\n      attrs: {}\n    });\n    if (result) {\n      const status = (0, WABinary_1.getBinaryNodeChild)(result, 'status');\n      return {\n        status: status === null || status === void 0 ? void 0 : status.content.toString(),\n        setAt: new Date(+((status === null || status === void 0 ? void 0 : status.attrs.t) || 0) * 1000)\n      };\n    }\n  };\n  /** update the profile picture for yourself or a group */\n  const updateProfilePicture = async (jid, content) => {\n    let targetJid = '';\n    if (!jid) {\n      throw new boom_1.Boom('Illegal no-jid profile update. Please specify either your ID or the ID of the chat you wish to update');\n    }\n    if ((0, WABinary_1.jidNormalizedUser)(jid) !== (0, WABinary_1.jidNormalizedUser)(authState.creds.me.id)) {\n      targetJid = jid; // in case it is someone other than us\n    }\n    const {\n      img\n    } = await (0, Utils_1.generateProfilePicture)(content);\n    await query({\n      tag: 'iq',\n      attrs: {\n        target: targetJid,\n        to: WABinary_1.S_WHATSAPP_NET,\n        type: 'set',\n        xmlns: 'w:profile:picture'\n      },\n      content: [{\n        tag: 'picture',\n        attrs: {\n          type: 'image'\n        },\n        content: img\n      }]\n    });\n  };\n  /** remove the profile picture for yourself or a group */\n  const removeProfilePicture = async jid => {\n    let targetJid = '';\n    if (!jid) {\n      throw new boom_1.Boom('Illegal no-jid profile update. Please specify either your ID or the ID of the chat you wish to update');\n    }\n    if ((0, WABinary_1.jidNormalizedUser)(jid) !== (0, WABinary_1.jidNormalizedUser)(authState.creds.me.id)) {\n      targetJid = jid; // in case it is someone other than us\n    }\n    await query({\n      tag: 'iq',\n      attrs: {\n        target: targetJid,\n        to: WABinary_1.S_WHATSAPP_NET,\n        type: 'set',\n        xmlns: 'w:profile:picture'\n      }\n    });\n  };\n  /** update the profile status for yourself */\n  const updateProfileStatus = async status => {\n    await query({\n      tag: 'iq',\n      attrs: {\n        to: WABinary_1.S_WHATSAPP_NET,\n        type: 'set',\n        xmlns: 'status'\n      },\n      content: [{\n        tag: 'status',\n        attrs: {},\n        content: Buffer.from(status, 'utf-8')\n      }]\n    });\n  };\n  const updateProfileName = async name => {\n    await chatModify({\n      pushNameSetting: name\n    }, '');\n  };\n  const fetchBlocklist = async () => {\n    const result = await query({\n      tag: 'iq',\n      attrs: {\n        xmlns: 'blocklist',\n        to: WABinary_1.S_WHATSAPP_NET,\n        type: 'get'\n      }\n    });\n    const listNode = (0, WABinary_1.getBinaryNodeChild)(result, 'list');\n    return (0, WABinary_1.getBinaryNodeChildren)(listNode, 'item').map(n => n.attrs.jid);\n  };\n  const updateBlockStatus = async (jid, action) => {\n    await query({\n      tag: 'iq',\n      attrs: {\n        xmlns: 'blocklist',\n        to: WABinary_1.S_WHATSAPP_NET,\n        type: 'set'\n      },\n      content: [{\n        tag: 'item',\n        attrs: {\n          action,\n          jid\n        }\n      }]\n    });\n  };\n  const getBusinessProfile = async jid => {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const results = await query({\n      tag: 'iq',\n      attrs: {\n        to: 's.whatsapp.net',\n        xmlns: 'w:biz',\n        type: 'get'\n      },\n      content: [{\n        tag: 'business_profile',\n        attrs: {\n          v: '244'\n        },\n        content: [{\n          tag: 'profile',\n          attrs: {\n            jid\n          }\n        }]\n      }]\n    });\n    const profileNode = (0, WABinary_1.getBinaryNodeChild)(results, 'business_profile');\n    const profiles = (0, WABinary_1.getBinaryNodeChild)(profileNode, 'profile');\n    if (profiles) {\n      const address = (0, WABinary_1.getBinaryNodeChild)(profiles, 'address');\n      const description = (0, WABinary_1.getBinaryNodeChild)(profiles, 'description');\n      const website = (0, WABinary_1.getBinaryNodeChild)(profiles, 'website');\n      const email = (0, WABinary_1.getBinaryNodeChild)(profiles, 'email');\n      const category = (0, WABinary_1.getBinaryNodeChild)((0, WABinary_1.getBinaryNodeChild)(profiles, 'categories'), 'category');\n      const businessHours = (0, WABinary_1.getBinaryNodeChild)(profiles, 'business_hours');\n      const businessHoursConfig = businessHours ? (0, WABinary_1.getBinaryNodeChildren)(businessHours, 'business_hours_config') : undefined;\n      const websiteStr = (_a = website === null || website === void 0 ? void 0 : website.content) === null || _a === void 0 ? void 0 : _a.toString();\n      return {\n        wid: (_b = profiles.attrs) === null || _b === void 0 ? void 0 : _b.jid,\n        address: (_c = address === null || address === void 0 ? void 0 : address.content) === null || _c === void 0 ? void 0 : _c.toString(),\n        description: ((_d = description === null || description === void 0 ? void 0 : description.content) === null || _d === void 0 ? void 0 : _d.toString()) || '',\n        website: websiteStr ? [websiteStr] : [],\n        email: (_e = email === null || email === void 0 ? void 0 : email.content) === null || _e === void 0 ? void 0 : _e.toString(),\n        category: (_f = category === null || category === void 0 ? void 0 : category.content) === null || _f === void 0 ? void 0 : _f.toString(),\n        'business_hours': {\n          timezone: (_g = businessHours === null || businessHours === void 0 ? void 0 : businessHours.attrs) === null || _g === void 0 ? void 0 : _g.timezone,\n          'business_config': businessHoursConfig === null || businessHoursConfig === void 0 ? void 0 : businessHoursConfig.map(({\n            attrs\n          }) => attrs)\n        }\n      };\n    }\n  };\n  const cleanDirtyBits = async (type, fromTimestamp) => {\n    logger.info({\n      fromTimestamp\n    }, 'clean dirty bits ' + type);\n    await sendNode({\n      tag: 'iq',\n      attrs: {\n        to: WABinary_1.S_WHATSAPP_NET,\n        type: 'set',\n        xmlns: 'urn:xmpp:whatsapp:dirty',\n        id: generateMessageTag()\n      },\n      content: [{\n        tag: 'clean',\n        attrs: {\n          type,\n          ...(fromTimestamp ? {\n            timestamp: fromTimestamp.toString()\n          } : null)\n        }\n      }]\n    });\n  };\n  const newAppStateChunkHandler = isInitialSync => {\n    return {\n      onMutation(mutation) {\n        (0, Utils_1.processSyncAction)(mutation, ev, authState.creds.me, isInitialSync ? {\n          accountSettings: authState.creds.accountSettings\n        } : undefined, logger);\n      }\n    };\n  };\n  const resyncAppState = ev.createBufferedFunction(async (collections, isInitialSync) => {\n    // we use this to determine which events to fire\n    // otherwise when we resync from scratch -- all notifications will fire\n    const initialVersionMap = {};\n    const globalMutationMap = {};\n    await authState.keys.transaction(async () => {\n      var _a;\n      const collectionsToHandle = new Set(collections);\n      // in case something goes wrong -- ensure we don't enter a loop that cannot be exited from\n      const attemptsMap = {};\n      // keep executing till all collections are done\n      // sometimes a single patch request will not return all the patches (God knows why)\n      // so we fetch till they're all done (this is determined by the \"has_more_patches\" flag)\n      while (collectionsToHandle.size) {\n        const states = {};\n        const nodes = [];\n        for (const name of collectionsToHandle) {\n          const result = await authState.keys.get('app-state-sync-version', [name]);\n          let state = result[name];\n          if (state) {\n            if (typeof initialVersionMap[name] === 'undefined') {\n              initialVersionMap[name] = state.version;\n            }\n          } else {\n            state = (0, Utils_1.newLTHashState)();\n          }\n          states[name] = state;\n          logger.info(`resyncing ${name} from v${state.version}`);\n          nodes.push({\n            tag: 'collection',\n            attrs: {\n              name,\n              version: state.version.toString(),\n              // return snapshot if being synced from scratch\n              'return_snapshot': (!state.version).toString()\n            }\n          });\n        }\n        const result = await query({\n          tag: 'iq',\n          attrs: {\n            to: WABinary_1.S_WHATSAPP_NET,\n            xmlns: 'w:sync:app:state',\n            type: 'set'\n          },\n          content: [{\n            tag: 'sync',\n            attrs: {},\n            content: nodes\n          }]\n        });\n        // extract from binary node\n        const decoded = await (0, Utils_1.extractSyncdPatches)(result, config === null || config === void 0 ? void 0 : config.options);\n        for (const key in decoded) {\n          const name = key;\n          const {\n            patches,\n            hasMorePatches,\n            snapshot\n          } = decoded[name];\n          try {\n            if (snapshot) {\n              const {\n                state: newState,\n                mutationMap\n              } = await (0, Utils_1.decodeSyncdSnapshot)(name, snapshot, getAppStateSyncKey, initialVersionMap[name], appStateMacVerification.snapshot);\n              states[name] = newState;\n              Object.assign(globalMutationMap, mutationMap);\n              logger.info(`restored state of ${name} from snapshot to v${newState.version} with mutations`);\n              await authState.keys.set({\n                'app-state-sync-version': {\n                  [name]: newState\n                }\n              });\n            }\n            // only process if there are syncd patches\n            if (patches.length) {\n              const {\n                state: newState,\n                mutationMap\n              } = await (0, Utils_1.decodePatches)(name, patches, states[name], getAppStateSyncKey, config.options, initialVersionMap[name], logger, appStateMacVerification.patch);\n              await authState.keys.set({\n                'app-state-sync-version': {\n                  [name]: newState\n                }\n              });\n              logger.info(`synced ${name} to v${newState.version}`);\n              initialVersionMap[name] = newState.version;\n              Object.assign(globalMutationMap, mutationMap);\n            }\n            if (hasMorePatches) {\n              logger.info(`${name} has more patches...`);\n            } else {\n              // collection is done with sync\n              collectionsToHandle.delete(name);\n            }\n          } catch (error) {\n            // if retry attempts overshoot\n            // or key not found\n            const isIrrecoverableError = attemptsMap[name] >= MAX_SYNC_ATTEMPTS || ((_a = error.output) === null || _a === void 0 ? void 0 : _a.statusCode) === 404 || error.name === 'TypeError';\n            logger.info({\n              name,\n              error: error.stack\n            }, `failed to sync state from version${isIrrecoverableError ? '' : ', removing and trying from scratch'}`);\n            await authState.keys.set({\n              'app-state-sync-version': {\n                [name]: null\n              }\n            });\n            // increment number of retries\n            attemptsMap[name] = (attemptsMap[name] || 0) + 1;\n            if (isIrrecoverableError) {\n              // stop retrying\n              collectionsToHandle.delete(name);\n            }\n          }\n        }\n      }\n    });\n    const {\n      onMutation\n    } = newAppStateChunkHandler(isInitialSync);\n    for (const key in globalMutationMap) {\n      onMutation(globalMutationMap[key]);\n    }\n  });\n  /**\n   * fetch the profile picture of a user/group\n   * type = \"preview\" for a low res picture\n   * type = \"image for the high res picture\"\n   */\n  const profilePictureUrl = async (jid, type = 'preview', timeoutMs) => {\n    var _a;\n    jid = (0, WABinary_1.jidNormalizedUser)(jid);\n    const result = await query({\n      tag: 'iq',\n      attrs: {\n        target: jid,\n        to: WABinary_1.S_WHATSAPP_NET,\n        type: 'get',\n        xmlns: 'w:profile:picture'\n      },\n      content: [{\n        tag: 'picture',\n        attrs: {\n          type,\n          query: 'url'\n        }\n      }]\n    }, timeoutMs);\n    const child = (0, WABinary_1.getBinaryNodeChild)(result, 'picture');\n    return (_a = child === null || child === void 0 ? void 0 : child.attrs) === null || _a === void 0 ? void 0 : _a.url;\n  };\n  const sendPresenceUpdate = async (type, toJid) => {\n    const me = authState.creds.me;\n    if (type === 'available' || type === 'unavailable') {\n      if (!me.name) {\n        logger.warn('no name present, ignoring presence update request...');\n        return;\n      }\n      ev.emit('connection.update', {\n        isOnline: type === 'available'\n      });\n      await sendNode({\n        tag: 'presence',\n        attrs: {\n          name: me.name,\n          type\n        }\n      });\n    } else {\n      await sendNode({\n        tag: 'chatstate',\n        attrs: {\n          from: me.id,\n          to: toJid\n        },\n        content: [{\n          tag: type === 'recording' ? 'composing' : type,\n          attrs: type === 'recording' ? {\n            media: 'audio'\n          } : {}\n        }]\n      });\n    }\n  };\n  /**\n   * @param toJid the jid to subscribe to\n   * @param tcToken token for subscription, use if present\n   */\n  const presenceSubscribe = (toJid, tcToken) => sendNode({\n    tag: 'presence',\n    attrs: {\n      to: toJid,\n      id: generateMessageTag(),\n      type: 'subscribe'\n    },\n    content: tcToken ? [{\n      tag: 'tctoken',\n      attrs: {},\n      content: tcToken\n    }] : undefined\n  });\n  const handlePresenceUpdate = ({\n    tag,\n    attrs,\n    content\n  }) => {\n    var _a;\n    let presence;\n    const jid = attrs.from;\n    const participant = attrs.participant || attrs.from;\n    if (shouldIgnoreJid(jid) && jid !== '@s.whatsapp.net') {\n      return;\n    }\n    if (tag === 'presence') {\n      presence = {\n        lastKnownPresence: attrs.type === 'unavailable' ? 'unavailable' : 'available',\n        lastSeen: attrs.last && attrs.last !== 'deny' ? +attrs.last : undefined\n      };\n    } else if (Array.isArray(content)) {\n      const [firstChild] = content;\n      let type = firstChild.tag;\n      if (type === 'paused') {\n        type = 'available';\n      }\n      if (((_a = firstChild.attrs) === null || _a === void 0 ? void 0 : _a.media) === 'audio') {\n        type = 'recording';\n      }\n      presence = {\n        lastKnownPresence: type\n      };\n    } else {\n      logger.error({\n        tag,\n        attrs,\n        content\n      }, 'recv invalid presence node');\n    }\n    if (presence) {\n      ev.emit('presence.update', {\n        id: jid,\n        presences: {\n          [participant]: presence\n        }\n      });\n    }\n  };\n  const appPatch = async patchCreate => {\n    const name = patchCreate.type;\n    const myAppStateKeyId = authState.creds.myAppStateKeyId;\n    if (!myAppStateKeyId) {\n      throw new boom_1.Boom('App state key not present!', {\n        statusCode: 400\n      });\n    }\n    let initial;\n    let encodeResult;\n    await processingMutex.mutex(async () => {\n      await authState.keys.transaction(async () => {\n        logger.debug({\n          patch: patchCreate\n        }, 'applying app patch');\n        await resyncAppState([name], false);\n        const {\n          [name]: currentSyncVersion\n        } = await authState.keys.get('app-state-sync-version', [name]);\n        initial = currentSyncVersion || (0, Utils_1.newLTHashState)();\n        encodeResult = await (0, Utils_1.encodeSyncdPatch)(patchCreate, myAppStateKeyId, initial, getAppStateSyncKey);\n        const {\n          patch,\n          state\n        } = encodeResult;\n        const node = {\n          tag: 'iq',\n          attrs: {\n            to: WABinary_1.S_WHATSAPP_NET,\n            type: 'set',\n            xmlns: 'w:sync:app:state'\n          },\n          content: [{\n            tag: 'sync',\n            attrs: {},\n            content: [{\n              tag: 'collection',\n              attrs: {\n                name,\n                version: (state.version - 1).toString(),\n                'return_snapshot': 'false'\n              },\n              content: [{\n                tag: 'patch',\n                attrs: {},\n                content: WAProto_1.proto.SyncdPatch.encode(patch).finish()\n              }]\n            }]\n          }]\n        };\n        await query(node);\n        await authState.keys.set({\n          'app-state-sync-version': {\n            [name]: state\n          }\n        });\n      });\n    });\n    if (config.emitOwnEvents) {\n      const {\n        onMutation\n      } = newAppStateChunkHandler(false);\n      const {\n        mutationMap\n      } = await (0, Utils_1.decodePatches)(name, [{\n        ...encodeResult.patch,\n        version: {\n          version: encodeResult.state.version\n        }\n      }], initial, getAppStateSyncKey, config.options, undefined, logger);\n      for (const key in mutationMap) {\n        onMutation(mutationMap[key]);\n      }\n    }\n  };\n  /** sending non-abt props may fix QR scan fail if server expects */\n  const fetchProps = async () => {\n    var _a, _b;\n    const resultNode = await query({\n      tag: 'iq',\n      attrs: {\n        to: WABinary_1.S_WHATSAPP_NET,\n        xmlns: 'w',\n        type: 'get'\n      },\n      content: [{\n        tag: 'props',\n        attrs: {\n          protocol: '2',\n          hash: ((_a = authState === null || authState === void 0 ? void 0 : authState.creds) === null || _a === void 0 ? void 0 : _a.lastPropHash) || ''\n        }\n      }]\n    });\n    const propsNode = (0, WABinary_1.getBinaryNodeChild)(resultNode, 'props');\n    let props = {};\n    if (propsNode) {\n      authState.creds.lastPropHash = (_b = propsNode === null || propsNode === void 0 ? void 0 : propsNode.attrs) === null || _b === void 0 ? void 0 : _b.hash;\n      ev.emit('creds.update', authState.creds);\n      props = (0, WABinary_1.reduceBinaryNodeToDictionary)(propsNode, 'prop');\n    }\n    logger.debug('fetched props');\n    return props;\n  };\n  /**\n   * modify a chat -- mark unread, read etc.\n   * lastMessages must be sorted in reverse chronologically\n   * requires the last messages till the last message received; required for archive & unread\n  */\n  const chatModify = (mod, jid) => {\n    const patch = (0, Utils_1.chatModificationToAppPatch)(mod, jid);\n    return appPatch(patch);\n  };\n  /**\n   * Star or Unstar a message\n   */\n  const star = (jid, messages, star) => {\n    return chatModify({\n      star: {\n        messages,\n        star\n      }\n    }, jid);\n  };\n  /**\n   * Adds label\n   */\n  const addLabel = (jid, labels) => {\n    return chatModify({\n      addLabel: {\n        ...labels\n      }\n    }, jid);\n  };\n  /**\n   * Adds label for the chats\n   */\n  const addChatLabel = (jid, labelId) => {\n    return chatModify({\n      addChatLabel: {\n        labelId\n      }\n    }, jid);\n  };\n  /**\n   * Removes label for the chat\n   */\n  const removeChatLabel = (jid, labelId) => {\n    return chatModify({\n      removeChatLabel: {\n        labelId\n      }\n    }, jid);\n  };\n  /**\n   * Adds label for the message\n   */\n  const addMessageLabel = (jid, messageId, labelId) => {\n    return chatModify({\n      addMessageLabel: {\n        messageId,\n        labelId\n      }\n    }, jid);\n  };\n  /**\n   * Removes label for the message\n   */\n  const removeMessageLabel = (jid, messageId, labelId) => {\n    return chatModify({\n      removeMessageLabel: {\n        messageId,\n        labelId\n      }\n    }, jid);\n  };\n  /**\n   * queries need to be fired on connection open\n   * help ensure parity with WA Web\n   * */\n  const executeInitQueries = async () => {\n    await Promise.all([fetchProps(), fetchBlocklist(), fetchPrivacySettings()]);\n  };\n  const upsertMessage = ev.createBufferedFunction(async (msg, type) => {\n    var _a, _b, _c;\n    ev.emit('messages.upsert', {\n      messages: [msg],\n      type\n    });\n    if (!!msg.pushName) {\n      let jid = msg.key.fromMe ? authState.creds.me.id : msg.key.participant || msg.key.remoteJid;\n      jid = (0, WABinary_1.jidNormalizedUser)(jid);\n      if (!msg.key.fromMe) {\n        ev.emit('contacts.update', [{\n          id: jid,\n          notify: msg.pushName,\n          verifiedName: msg.verifiedBizName\n        }]);\n      }\n      // update our pushname too\n      if (msg.key.fromMe && msg.pushName && ((_a = authState.creds.me) === null || _a === void 0 ? void 0 : _a.name) !== msg.pushName) {\n        ev.emit('creds.update', {\n          me: {\n            ...authState.creds.me,\n            name: msg.pushName\n          }\n        });\n      }\n    }\n    const historyMsg = (0, Utils_1.getHistoryMsg)(msg.message);\n    const shouldProcessHistoryMsg = historyMsg ? shouldSyncHistoryMessage(historyMsg) && Defaults_1.PROCESSABLE_HISTORY_TYPES.includes(historyMsg.syncType) : false;\n    if (historyMsg && !authState.creds.myAppStateKeyId) {\n      logger.warn('skipping app state sync, as myAppStateKeyId is not set');\n      pendingAppStateSync = true;\n    }\n    await Promise.all([(async () => {\n      if (historyMsg && authState.creds.myAppStateKeyId) {\n        pendingAppStateSync = false;\n        await doAppStateSync();\n      }\n    })(), (0, process_message_1.default)(msg, {\n      shouldProcessHistoryMsg,\n      placeholderResendCache,\n      ev,\n      creds: authState.creds,\n      keyStore: authState.keys,\n      logger,\n      options: config.options,\n      getMessage: config.getMessage\n    })]);\n    if (((_c = (_b = msg.message) === null || _b === void 0 ? void 0 : _b.protocolMessage) === null || _c === void 0 ? void 0 : _c.appStateSyncKeyShare) && pendingAppStateSync) {\n      await doAppStateSync();\n      pendingAppStateSync = false;\n    }\n    async function doAppStateSync() {\n      if (!authState.creds.accountSyncCounter) {\n        logger.info('doing initial app state sync');\n        await resyncAppState(Types_1.ALL_WA_PATCH_NAMES, true);\n        const accountSyncCounter = (authState.creds.accountSyncCounter || 0) + 1;\n        ev.emit('creds.update', {\n          accountSyncCounter\n        });\n        if (needToFlushWithAppStateSync) {\n          logger.debug('flushing with app state sync');\n          ev.flush();\n        }\n      }\n    }\n  });\n  ws.on('CB:presence', handlePresenceUpdate);\n  ws.on('CB:chatstate', handlePresenceUpdate);\n  ws.on('CB:ib,,dirty', async node => {\n    const {\n      attrs\n    } = (0, WABinary_1.getBinaryNodeChild)(node, 'dirty');\n    const type = attrs.type;\n    switch (type) {\n      case 'account_sync':\n        if (attrs.timestamp) {\n          let {\n            lastAccountSyncTimestamp\n          } = authState.creds;\n          if (lastAccountSyncTimestamp) {\n            await cleanDirtyBits('account_sync', lastAccountSyncTimestamp);\n          }\n          lastAccountSyncTimestamp = +attrs.timestamp;\n          ev.emit('creds.update', {\n            lastAccountSyncTimestamp\n          });\n        }\n        break;\n      case 'groups':\n        // handled in groups.ts\n        break;\n      default:\n        logger.info({\n          node\n        }, 'received unknown sync');\n        break;\n    }\n  });\n  ev.on('connection.update', ({\n    connection,\n    receivedPendingNotifications\n  }) => {\n    var _a;\n    if (connection === 'open') {\n      if (fireInitQueries) {\n        executeInitQueries().catch(error => onUnexpectedError(error, 'init queries'));\n      }\n      sendPresenceUpdate(markOnlineOnConnect ? 'available' : 'unavailable').catch(error => onUnexpectedError(error, 'presence update requests'));\n    }\n    if (receivedPendingNotifications) {\n      // if we don't have the app state key\n      // we keep buffering events until we finally have\n      // the key and can sync the messages\n      if (!((_a = authState.creds) === null || _a === void 0 ? void 0 : _a.myAppStateKeyId) && !config.mobile) {\n        ev.buffer();\n        needToFlushWithAppStateSync = true;\n      }\n    }\n  });\n  return {\n    ...sock,\n    processingMutex,\n    fetchPrivacySettings,\n    upsertMessage,\n    appPatch,\n    sendPresenceUpdate,\n    presenceSubscribe,\n    profilePictureUrl,\n    onWhatsApp,\n    fetchBlocklist,\n    fetchStatus,\n    updateProfilePicture,\n    removeProfilePicture,\n    updateProfileStatus,\n    updateProfileName,\n    updateBlockStatus,\n    updateCallPrivacy,\n    updateLastSeenPrivacy,\n    updateOnlinePrivacy,\n    updateProfilePicturePrivacy,\n    updateStatusPrivacy,\n    updateReadReceiptsPrivacy,\n    updateGroupsAddPrivacy,\n    updateDefaultDisappearingMode,\n    getBusinessProfile,\n    resyncAppState,\n    chatModify,\n    cleanDirtyBits,\n    addLabel,\n    addChatLabel,\n    removeChatLabel,\n    addMessageLabel,\n    removeMessageLabel,\n    star\n  };\n};\nexports.makeChatsSocket = makeChatsSocket;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","makeChatsSocket","boom_1","require","node_cache_1","WAProto_1","Defaults_1","Types_1","Utils_1","make_mutex_1","process_message_1","WABinary_1","socket_1","MAX_SYNC_ATTEMPTS","config","logger","markOnlineOnConnect","fireInitQueries","appStateMacVerification","shouldIgnoreJid","shouldSyncHistoryMessage","sock","makeSocket","ev","ws","authState","generateMessageTag","sendNode","query","onUnexpectedError","privacySettings","needToFlushWithAppStateSync","pendingAppStateSync","processingMutex","makeMutex","placeholderResendCache","default","stdTTL","DEFAULT_CACHE_TTLS","MSG_RETRY","useClones","getAppStateSyncKey","keyId","key","keys","get","fetchPrivacySettings","force","content","tag","attrs","xmlns","to","S_WHATSAPP_NET","type","reduceBinaryNodeToDictionary","privacyQuery","name","updateCallPrivacy","updateLastSeenPrivacy","updateOnlinePrivacy","updateProfilePicturePrivacy","updateStatusPrivacy","updateReadReceiptsPrivacy","updateGroupsAddPrivacy","updateDefaultDisappearingMode","duration","toString","interactiveQuery","userNodes","queryNode","result","sid","mode","last","index","context","usyncNode","getBinaryNodeChild","listNode","users","getBinaryNodeChildren","onWhatsApp","jids","list","map","jid","replace","results","user","contact","exists","filter","item","fetchStatus","status","setAt","Date","t","updateProfilePicture","targetJid","Boom","jidNormalizedUser","creds","me","id","img","generateProfilePicture","target","removeProfilePicture","updateProfileStatus","Buffer","from","updateProfileName","chatModify","pushNameSetting","fetchBlocklist","n","updateBlockStatus","action","getBusinessProfile","_a","_b","_c","_d","_e","_f","_g","v","profileNode","profiles","address","description","website","email","category","businessHours","businessHoursConfig","undefined","websiteStr","wid","timezone","cleanDirtyBits","fromTimestamp","info","timestamp","newAppStateChunkHandler","isInitialSync","onMutation","mutation","processSyncAction","accountSettings","resyncAppState","createBufferedFunction","collections","initialVersionMap","globalMutationMap","transaction","collectionsToHandle","Set","attemptsMap","size","states","nodes","state","version","newLTHashState","push","decoded","extractSyncdPatches","options","patches","hasMorePatches","snapshot","newState","mutationMap","decodeSyncdSnapshot","assign","set","length","decodePatches","patch","delete","error","isIrrecoverableError","output","statusCode","stack","profilePictureUrl","timeoutMs","child","url","sendPresenceUpdate","toJid","warn","emit","isOnline","media","presenceSubscribe","tcToken","handlePresenceUpdate","presence","participant","lastKnownPresence","lastSeen","Array","isArray","firstChild","presences","appPatch","patchCreate","myAppStateKeyId","initial","encodeResult","mutex","debug","currentSyncVersion","encodeSyncdPatch","node","proto","SyncdPatch","encode","finish","emitOwnEvents","fetchProps","resultNode","protocol","hash","lastPropHash","propsNode","props","chatModificationToAppPatch","star","messages","addLabel","labels","addChatLabel","labelId","removeChatLabel","addMessageLabel","messageId","removeMessageLabel","executeInitQueries","Promise","all","upsertMessage","msg","pushName","fromMe","remoteJid","notify","verifiedName","verifiedBizName","historyMsg","getHistoryMsg","message","shouldProcessHistoryMsg","PROCESSABLE_HISTORY_TYPES","includes","syncType","doAppStateSync","keyStore","getMessage","protocolMessage","appStateSyncKeyShare","accountSyncCounter","ALL_WA_PATCH_NAMES","flush","on","lastAccountSyncTimestamp","connection","receivedPendingNotifications","catch","mobile","buffer"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Socket/chats.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeChatsSocket = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst node_cache_1 = __importDefault(require(\"node-cache\"));\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst Types_1 = require(\"../Types\");\nconst Utils_1 = require(\"../Utils\");\nconst make_mutex_1 = require(\"../Utils/make-mutex\");\nconst process_message_1 = __importDefault(require(\"../Utils/process-message\"));\nconst WABinary_1 = require(\"../WABinary\");\nconst socket_1 = require(\"./socket\");\nconst MAX_SYNC_ATTEMPTS = 2;\nconst makeChatsSocket = (config) => {\n    const { logger, markOnlineOnConnect, fireInitQueries, appStateMacVerification, shouldIgnoreJid, shouldSyncHistoryMessage, } = config;\n    const sock = (0, socket_1.makeSocket)(config);\n    const { ev, ws, authState, generateMessageTag, sendNode, query, onUnexpectedError, } = sock;\n    let privacySettings;\n    let needToFlushWithAppStateSync = false;\n    let pendingAppStateSync = false;\n    /** this mutex ensures that the notifications (receipts, messages etc.) are processed in order */\n    const processingMutex = (0, make_mutex_1.makeMutex)();\n    const placeholderResendCache = config.placeholderResendCache || new node_cache_1.default({\n        stdTTL: Defaults_1.DEFAULT_CACHE_TTLS.MSG_RETRY,\n        useClones: false\n    });\n    if (!config.placeholderResendCache) {\n        config.placeholderResendCache = placeholderResendCache;\n    }\n    /** helper function to fetch the given app state sync key */\n    const getAppStateSyncKey = async (keyId) => {\n        const { [keyId]: key } = await authState.keys.get('app-state-sync-key', [keyId]);\n        return key;\n    };\n    const fetchPrivacySettings = async (force = false) => {\n        if (!privacySettings || force) {\n            const { content } = await query({\n                tag: 'iq',\n                attrs: {\n                    xmlns: 'privacy',\n                    to: WABinary_1.S_WHATSAPP_NET,\n                    type: 'get'\n                },\n                content: [\n                    { tag: 'privacy', attrs: {} }\n                ]\n            });\n            privacySettings = (0, WABinary_1.reduceBinaryNodeToDictionary)(content === null || content === void 0 ? void 0 : content[0], 'category');\n        }\n        return privacySettings;\n    };\n    /** helper function to run a privacy IQ query */\n    const privacyQuery = async (name, value) => {\n        await query({\n            tag: 'iq',\n            attrs: {\n                xmlns: 'privacy',\n                to: WABinary_1.S_WHATSAPP_NET,\n                type: 'set'\n            },\n            content: [{\n                    tag: 'privacy',\n                    attrs: {},\n                    content: [\n                        {\n                            tag: 'category',\n                            attrs: { name, value }\n                        }\n                    ]\n                }]\n        });\n    };\n    const updateCallPrivacy = async (value) => {\n        await privacyQuery('calladd', value);\n    };\n    const updateLastSeenPrivacy = async (value) => {\n        await privacyQuery('last', value);\n    };\n    const updateOnlinePrivacy = async (value) => {\n        await privacyQuery('online', value);\n    };\n    const updateProfilePicturePrivacy = async (value) => {\n        await privacyQuery('profile', value);\n    };\n    const updateStatusPrivacy = async (value) => {\n        await privacyQuery('status', value);\n    };\n    const updateReadReceiptsPrivacy = async (value) => {\n        await privacyQuery('readreceipts', value);\n    };\n    const updateGroupsAddPrivacy = async (value) => {\n        await privacyQuery('groupadd', value);\n    };\n    const updateDefaultDisappearingMode = async (duration) => {\n        await query({\n            tag: 'iq',\n            attrs: {\n                xmlns: 'disappearing_mode',\n                to: WABinary_1.S_WHATSAPP_NET,\n                type: 'set'\n            },\n            content: [{\n                    tag: 'disappearing_mode',\n                    attrs: {\n                        duration: duration.toString()\n                    }\n                }]\n        });\n    };\n    /** helper function to run a generic IQ query */\n    const interactiveQuery = async (userNodes, queryNode) => {\n        const result = await query({\n            tag: 'iq',\n            attrs: {\n                to: WABinary_1.S_WHATSAPP_NET,\n                type: 'get',\n                xmlns: 'usync',\n            },\n            content: [\n                {\n                    tag: 'usync',\n                    attrs: {\n                        sid: generateMessageTag(),\n                        mode: 'query',\n                        last: 'true',\n                        index: '0',\n                        context: 'interactive',\n                    },\n                    content: [\n                        {\n                            tag: 'query',\n                            attrs: {},\n                            content: [queryNode]\n                        },\n                        {\n                            tag: 'list',\n                            attrs: {},\n                            content: userNodes\n                        }\n                    ]\n                }\n            ],\n        });\n        const usyncNode = (0, WABinary_1.getBinaryNodeChild)(result, 'usync');\n        const listNode = (0, WABinary_1.getBinaryNodeChild)(usyncNode, 'list');\n        const users = (0, WABinary_1.getBinaryNodeChildren)(listNode, 'user');\n        return users;\n    };\n    const onWhatsApp = async (...jids) => {\n        const query = { tag: 'contact', attrs: {} };\n        const list = jids.map((jid) => {\n            // insures only 1 + is there\n            const content = `+${jid.replace('+', '')}`;\n            return {\n                tag: 'user',\n                attrs: {},\n                content: [{\n                        tag: 'contact',\n                        attrs: {},\n                        content,\n                    }],\n            };\n        });\n        const results = await interactiveQuery(list, query);\n        return results.map(user => {\n            const contact = (0, WABinary_1.getBinaryNodeChild)(user, 'contact');\n            return { exists: (contact === null || contact === void 0 ? void 0 : contact.attrs.type) === 'in', jid: user.attrs.jid };\n        }).filter(item => item.exists);\n    };\n    const fetchStatus = async (jid) => {\n        const [result] = await interactiveQuery([{ tag: 'user', attrs: { jid } }], { tag: 'status', attrs: {} });\n        if (result) {\n            const status = (0, WABinary_1.getBinaryNodeChild)(result, 'status');\n            return {\n                status: status === null || status === void 0 ? void 0 : status.content.toString(),\n                setAt: new Date(+((status === null || status === void 0 ? void 0 : status.attrs.t) || 0) * 1000)\n            };\n        }\n    };\n    /** update the profile picture for yourself or a group */\n    const updateProfilePicture = async (jid, content) => {\n        let targetJid = '';\n        if (!jid) {\n            throw new boom_1.Boom('Illegal no-jid profile update. Please specify either your ID or the ID of the chat you wish to update');\n        }\n        if ((0, WABinary_1.jidNormalizedUser)(jid) !== (0, WABinary_1.jidNormalizedUser)(authState.creds.me.id)) {\n            targetJid = jid; // in case it is someone other than us\n        }\n        const { img } = await (0, Utils_1.generateProfilePicture)(content);\n        await query({\n            tag: 'iq',\n            attrs: {\n                target: targetJid,\n                to: WABinary_1.S_WHATSAPP_NET,\n                type: 'set',\n                xmlns: 'w:profile:picture'\n            },\n            content: [\n                {\n                    tag: 'picture',\n                    attrs: { type: 'image' },\n                    content: img\n                }\n            ]\n        });\n    };\n    /** remove the profile picture for yourself or a group */\n    const removeProfilePicture = async (jid) => {\n        let targetJid = '';\n        if (!jid) {\n            throw new boom_1.Boom('Illegal no-jid profile update. Please specify either your ID or the ID of the chat you wish to update');\n        }\n        if ((0, WABinary_1.jidNormalizedUser)(jid) !== (0, WABinary_1.jidNormalizedUser)(authState.creds.me.id)) {\n            targetJid = jid; // in case it is someone other than us\n        }\n        await query({\n            tag: 'iq',\n            attrs: {\n                target: targetJid,\n                to: WABinary_1.S_WHATSAPP_NET,\n                type: 'set',\n                xmlns: 'w:profile:picture'\n            }\n        });\n    };\n    /** update the profile status for yourself */\n    const updateProfileStatus = async (status) => {\n        await query({\n            tag: 'iq',\n            attrs: {\n                to: WABinary_1.S_WHATSAPP_NET,\n                type: 'set',\n                xmlns: 'status'\n            },\n            content: [\n                {\n                    tag: 'status',\n                    attrs: {},\n                    content: Buffer.from(status, 'utf-8')\n                }\n            ]\n        });\n    };\n    const updateProfileName = async (name) => {\n        await chatModify({ pushNameSetting: name }, '');\n    };\n    const fetchBlocklist = async () => {\n        const result = await query({\n            tag: 'iq',\n            attrs: {\n                xmlns: 'blocklist',\n                to: WABinary_1.S_WHATSAPP_NET,\n                type: 'get'\n            }\n        });\n        const listNode = (0, WABinary_1.getBinaryNodeChild)(result, 'list');\n        return (0, WABinary_1.getBinaryNodeChildren)(listNode, 'item')\n            .map(n => n.attrs.jid);\n    };\n    const updateBlockStatus = async (jid, action) => {\n        await query({\n            tag: 'iq',\n            attrs: {\n                xmlns: 'blocklist',\n                to: WABinary_1.S_WHATSAPP_NET,\n                type: 'set'\n            },\n            content: [\n                {\n                    tag: 'item',\n                    attrs: {\n                        action,\n                        jid\n                    }\n                }\n            ]\n        });\n    };\n    const getBusinessProfile = async (jid) => {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const results = await query({\n            tag: 'iq',\n            attrs: {\n                to: 's.whatsapp.net',\n                xmlns: 'w:biz',\n                type: 'get'\n            },\n            content: [{\n                    tag: 'business_profile',\n                    attrs: { v: '244' },\n                    content: [{\n                            tag: 'profile',\n                            attrs: { jid }\n                        }]\n                }]\n        });\n        const profileNode = (0, WABinary_1.getBinaryNodeChild)(results, 'business_profile');\n        const profiles = (0, WABinary_1.getBinaryNodeChild)(profileNode, 'profile');\n        if (profiles) {\n            const address = (0, WABinary_1.getBinaryNodeChild)(profiles, 'address');\n            const description = (0, WABinary_1.getBinaryNodeChild)(profiles, 'description');\n            const website = (0, WABinary_1.getBinaryNodeChild)(profiles, 'website');\n            const email = (0, WABinary_1.getBinaryNodeChild)(profiles, 'email');\n            const category = (0, WABinary_1.getBinaryNodeChild)((0, WABinary_1.getBinaryNodeChild)(profiles, 'categories'), 'category');\n            const businessHours = (0, WABinary_1.getBinaryNodeChild)(profiles, 'business_hours');\n            const businessHoursConfig = businessHours\n                ? (0, WABinary_1.getBinaryNodeChildren)(businessHours, 'business_hours_config')\n                : undefined;\n            const websiteStr = (_a = website === null || website === void 0 ? void 0 : website.content) === null || _a === void 0 ? void 0 : _a.toString();\n            return {\n                wid: (_b = profiles.attrs) === null || _b === void 0 ? void 0 : _b.jid,\n                address: (_c = address === null || address === void 0 ? void 0 : address.content) === null || _c === void 0 ? void 0 : _c.toString(),\n                description: ((_d = description === null || description === void 0 ? void 0 : description.content) === null || _d === void 0 ? void 0 : _d.toString()) || '',\n                website: websiteStr ? [websiteStr] : [],\n                email: (_e = email === null || email === void 0 ? void 0 : email.content) === null || _e === void 0 ? void 0 : _e.toString(),\n                category: (_f = category === null || category === void 0 ? void 0 : category.content) === null || _f === void 0 ? void 0 : _f.toString(),\n                'business_hours': {\n                    timezone: (_g = businessHours === null || businessHours === void 0 ? void 0 : businessHours.attrs) === null || _g === void 0 ? void 0 : _g.timezone,\n                    'business_config': businessHoursConfig === null || businessHoursConfig === void 0 ? void 0 : businessHoursConfig.map(({ attrs }) => attrs)\n                }\n            };\n        }\n    };\n    const cleanDirtyBits = async (type, fromTimestamp) => {\n        logger.info({ fromTimestamp }, 'clean dirty bits ' + type);\n        await sendNode({\n            tag: 'iq',\n            attrs: {\n                to: WABinary_1.S_WHATSAPP_NET,\n                type: 'set',\n                xmlns: 'urn:xmpp:whatsapp:dirty',\n                id: generateMessageTag(),\n            },\n            content: [\n                {\n                    tag: 'clean',\n                    attrs: {\n                        type,\n                        ...(fromTimestamp ? { timestamp: fromTimestamp.toString() } : null),\n                    }\n                }\n            ]\n        });\n    };\n    const newAppStateChunkHandler = (isInitialSync) => {\n        return {\n            onMutation(mutation) {\n                (0, Utils_1.processSyncAction)(mutation, ev, authState.creds.me, isInitialSync ? { accountSettings: authState.creds.accountSettings } : undefined, logger);\n            }\n        };\n    };\n    const resyncAppState = ev.createBufferedFunction(async (collections, isInitialSync) => {\n        // we use this to determine which events to fire\n        // otherwise when we resync from scratch -- all notifications will fire\n        const initialVersionMap = {};\n        const globalMutationMap = {};\n        await authState.keys.transaction(async () => {\n            var _a;\n            const collectionsToHandle = new Set(collections);\n            // in case something goes wrong -- ensure we don't enter a loop that cannot be exited from\n            const attemptsMap = {};\n            // keep executing till all collections are done\n            // sometimes a single patch request will not return all the patches (God knows why)\n            // so we fetch till they're all done (this is determined by the \"has_more_patches\" flag)\n            while (collectionsToHandle.size) {\n                const states = {};\n                const nodes = [];\n                for (const name of collectionsToHandle) {\n                    const result = await authState.keys.get('app-state-sync-version', [name]);\n                    let state = result[name];\n                    if (state) {\n                        if (typeof initialVersionMap[name] === 'undefined') {\n                            initialVersionMap[name] = state.version;\n                        }\n                    }\n                    else {\n                        state = (0, Utils_1.newLTHashState)();\n                    }\n                    states[name] = state;\n                    logger.info(`resyncing ${name} from v${state.version}`);\n                    nodes.push({\n                        tag: 'collection',\n                        attrs: {\n                            name,\n                            version: state.version.toString(),\n                            // return snapshot if being synced from scratch\n                            'return_snapshot': (!state.version).toString()\n                        }\n                    });\n                }\n                const result = await query({\n                    tag: 'iq',\n                    attrs: {\n                        to: WABinary_1.S_WHATSAPP_NET,\n                        xmlns: 'w:sync:app:state',\n                        type: 'set'\n                    },\n                    content: [\n                        {\n                            tag: 'sync',\n                            attrs: {},\n                            content: nodes\n                        }\n                    ]\n                });\n                // extract from binary node\n                const decoded = await (0, Utils_1.extractSyncdPatches)(result, config === null || config === void 0 ? void 0 : config.options);\n                for (const key in decoded) {\n                    const name = key;\n                    const { patches, hasMorePatches, snapshot } = decoded[name];\n                    try {\n                        if (snapshot) {\n                            const { state: newState, mutationMap } = await (0, Utils_1.decodeSyncdSnapshot)(name, snapshot, getAppStateSyncKey, initialVersionMap[name], appStateMacVerification.snapshot);\n                            states[name] = newState;\n                            Object.assign(globalMutationMap, mutationMap);\n                            logger.info(`restored state of ${name} from snapshot to v${newState.version} with mutations`);\n                            await authState.keys.set({ 'app-state-sync-version': { [name]: newState } });\n                        }\n                        // only process if there are syncd patches\n                        if (patches.length) {\n                            const { state: newState, mutationMap } = await (0, Utils_1.decodePatches)(name, patches, states[name], getAppStateSyncKey, config.options, initialVersionMap[name], logger, appStateMacVerification.patch);\n                            await authState.keys.set({ 'app-state-sync-version': { [name]: newState } });\n                            logger.info(`synced ${name} to v${newState.version}`);\n                            initialVersionMap[name] = newState.version;\n                            Object.assign(globalMutationMap, mutationMap);\n                        }\n                        if (hasMorePatches) {\n                            logger.info(`${name} has more patches...`);\n                        }\n                        else { // collection is done with sync\n                            collectionsToHandle.delete(name);\n                        }\n                    }\n                    catch (error) {\n                        // if retry attempts overshoot\n                        // or key not found\n                        const isIrrecoverableError = attemptsMap[name] >= MAX_SYNC_ATTEMPTS\n                            || ((_a = error.output) === null || _a === void 0 ? void 0 : _a.statusCode) === 404\n                            || error.name === 'TypeError';\n                        logger.info({ name, error: error.stack }, `failed to sync state from version${isIrrecoverableError ? '' : ', removing and trying from scratch'}`);\n                        await authState.keys.set({ 'app-state-sync-version': { [name]: null } });\n                        // increment number of retries\n                        attemptsMap[name] = (attemptsMap[name] || 0) + 1;\n                        if (isIrrecoverableError) {\n                            // stop retrying\n                            collectionsToHandle.delete(name);\n                        }\n                    }\n                }\n            }\n        });\n        const { onMutation } = newAppStateChunkHandler(isInitialSync);\n        for (const key in globalMutationMap) {\n            onMutation(globalMutationMap[key]);\n        }\n    });\n    /**\n     * fetch the profile picture of a user/group\n     * type = \"preview\" for a low res picture\n     * type = \"image for the high res picture\"\n     */\n    const profilePictureUrl = async (jid, type = 'preview', timeoutMs) => {\n        var _a;\n        jid = (0, WABinary_1.jidNormalizedUser)(jid);\n        const result = await query({\n            tag: 'iq',\n            attrs: {\n                target: jid,\n                to: WABinary_1.S_WHATSAPP_NET,\n                type: 'get',\n                xmlns: 'w:profile:picture'\n            },\n            content: [\n                { tag: 'picture', attrs: { type, query: 'url' } }\n            ]\n        }, timeoutMs);\n        const child = (0, WABinary_1.getBinaryNodeChild)(result, 'picture');\n        return (_a = child === null || child === void 0 ? void 0 : child.attrs) === null || _a === void 0 ? void 0 : _a.url;\n    };\n    const sendPresenceUpdate = async (type, toJid) => {\n        const me = authState.creds.me;\n        if (type === 'available' || type === 'unavailable') {\n            if (!me.name) {\n                logger.warn('no name present, ignoring presence update request...');\n                return;\n            }\n            ev.emit('connection.update', { isOnline: type === 'available' });\n            await sendNode({\n                tag: 'presence',\n                attrs: {\n                    name: me.name,\n                    type\n                }\n            });\n        }\n        else {\n            await sendNode({\n                tag: 'chatstate',\n                attrs: {\n                    from: me.id,\n                    to: toJid,\n                },\n                content: [\n                    {\n                        tag: type === 'recording' ? 'composing' : type,\n                        attrs: type === 'recording' ? { media: 'audio' } : {}\n                    }\n                ]\n            });\n        }\n    };\n    /**\n     * @param toJid the jid to subscribe to\n     * @param tcToken token for subscription, use if present\n     */\n    const presenceSubscribe = (toJid, tcToken) => (sendNode({\n        tag: 'presence',\n        attrs: {\n            to: toJid,\n            id: generateMessageTag(),\n            type: 'subscribe'\n        },\n        content: tcToken\n            ? [\n                {\n                    tag: 'tctoken',\n                    attrs: {},\n                    content: tcToken\n                }\n            ]\n            : undefined\n    }));\n    const handlePresenceUpdate = ({ tag, attrs, content }) => {\n        var _a;\n        let presence;\n        const jid = attrs.from;\n        const participant = attrs.participant || attrs.from;\n        if (shouldIgnoreJid(jid) && jid !== '@s.whatsapp.net') {\n            return;\n        }\n        if (tag === 'presence') {\n            presence = {\n                lastKnownPresence: attrs.type === 'unavailable' ? 'unavailable' : 'available',\n                lastSeen: attrs.last && attrs.last !== 'deny' ? +attrs.last : undefined\n            };\n        }\n        else if (Array.isArray(content)) {\n            const [firstChild] = content;\n            let type = firstChild.tag;\n            if (type === 'paused') {\n                type = 'available';\n            }\n            if (((_a = firstChild.attrs) === null || _a === void 0 ? void 0 : _a.media) === 'audio') {\n                type = 'recording';\n            }\n            presence = { lastKnownPresence: type };\n        }\n        else {\n            logger.error({ tag, attrs, content }, 'recv invalid presence node');\n        }\n        if (presence) {\n            ev.emit('presence.update', { id: jid, presences: { [participant]: presence } });\n        }\n    };\n    const appPatch = async (patchCreate) => {\n        const name = patchCreate.type;\n        const myAppStateKeyId = authState.creds.myAppStateKeyId;\n        if (!myAppStateKeyId) {\n            throw new boom_1.Boom('App state key not present!', { statusCode: 400 });\n        }\n        let initial;\n        let encodeResult;\n        await processingMutex.mutex(async () => {\n            await authState.keys.transaction(async () => {\n                logger.debug({ patch: patchCreate }, 'applying app patch');\n                await resyncAppState([name], false);\n                const { [name]: currentSyncVersion } = await authState.keys.get('app-state-sync-version', [name]);\n                initial = currentSyncVersion || (0, Utils_1.newLTHashState)();\n                encodeResult = await (0, Utils_1.encodeSyncdPatch)(patchCreate, myAppStateKeyId, initial, getAppStateSyncKey);\n                const { patch, state } = encodeResult;\n                const node = {\n                    tag: 'iq',\n                    attrs: {\n                        to: WABinary_1.S_WHATSAPP_NET,\n                        type: 'set',\n                        xmlns: 'w:sync:app:state'\n                    },\n                    content: [\n                        {\n                            tag: 'sync',\n                            attrs: {},\n                            content: [\n                                {\n                                    tag: 'collection',\n                                    attrs: {\n                                        name,\n                                        version: (state.version - 1).toString(),\n                                        'return_snapshot': 'false'\n                                    },\n                                    content: [\n                                        {\n                                            tag: 'patch',\n                                            attrs: {},\n                                            content: WAProto_1.proto.SyncdPatch.encode(patch).finish()\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n                    ]\n                };\n                await query(node);\n                await authState.keys.set({ 'app-state-sync-version': { [name]: state } });\n            });\n        });\n        if (config.emitOwnEvents) {\n            const { onMutation } = newAppStateChunkHandler(false);\n            const { mutationMap } = await (0, Utils_1.decodePatches)(name, [{ ...encodeResult.patch, version: { version: encodeResult.state.version }, }], initial, getAppStateSyncKey, config.options, undefined, logger);\n            for (const key in mutationMap) {\n                onMutation(mutationMap[key]);\n            }\n        }\n    };\n    /** sending non-abt props may fix QR scan fail if server expects */\n    const fetchProps = async () => {\n        var _a, _b;\n        const resultNode = await query({\n            tag: 'iq',\n            attrs: {\n                to: WABinary_1.S_WHATSAPP_NET,\n                xmlns: 'w',\n                type: 'get',\n            },\n            content: [\n                { tag: 'props', attrs: {\n                        protocol: '2',\n                        hash: ((_a = authState === null || authState === void 0 ? void 0 : authState.creds) === null || _a === void 0 ? void 0 : _a.lastPropHash) || ''\n                    } }\n            ]\n        });\n        const propsNode = (0, WABinary_1.getBinaryNodeChild)(resultNode, 'props');\n        let props = {};\n        if (propsNode) {\n            authState.creds.lastPropHash = (_b = propsNode === null || propsNode === void 0 ? void 0 : propsNode.attrs) === null || _b === void 0 ? void 0 : _b.hash;\n            ev.emit('creds.update', authState.creds);\n            props = (0, WABinary_1.reduceBinaryNodeToDictionary)(propsNode, 'prop');\n        }\n        logger.debug('fetched props');\n        return props;\n    };\n    /**\n     * modify a chat -- mark unread, read etc.\n     * lastMessages must be sorted in reverse chronologically\n     * requires the last messages till the last message received; required for archive & unread\n    */\n    const chatModify = (mod, jid) => {\n        const patch = (0, Utils_1.chatModificationToAppPatch)(mod, jid);\n        return appPatch(patch);\n    };\n    /**\n     * Star or Unstar a message\n     */\n    const star = (jid, messages, star) => {\n        return chatModify({\n            star: {\n                messages,\n                star\n            }\n        }, jid);\n    };\n    /**\n     * Adds label\n     */\n    const addLabel = (jid, labels) => {\n        return chatModify({\n            addLabel: {\n                ...labels\n            }\n        }, jid);\n    };\n    /**\n     * Adds label for the chats\n     */\n    const addChatLabel = (jid, labelId) => {\n        return chatModify({\n            addChatLabel: {\n                labelId\n            }\n        }, jid);\n    };\n    /**\n     * Removes label for the chat\n     */\n    const removeChatLabel = (jid, labelId) => {\n        return chatModify({\n            removeChatLabel: {\n                labelId\n            }\n        }, jid);\n    };\n    /**\n     * Adds label for the message\n     */\n    const addMessageLabel = (jid, messageId, labelId) => {\n        return chatModify({\n            addMessageLabel: {\n                messageId,\n                labelId\n            }\n        }, jid);\n    };\n    /**\n     * Removes label for the message\n     */\n    const removeMessageLabel = (jid, messageId, labelId) => {\n        return chatModify({\n            removeMessageLabel: {\n                messageId,\n                labelId\n            }\n        }, jid);\n    };\n    /**\n     * queries need to be fired on connection open\n     * help ensure parity with WA Web\n     * */\n    const executeInitQueries = async () => {\n        await Promise.all([\n            fetchProps(),\n            fetchBlocklist(),\n            fetchPrivacySettings(),\n        ]);\n    };\n    const upsertMessage = ev.createBufferedFunction(async (msg, type) => {\n        var _a, _b, _c;\n        ev.emit('messages.upsert', { messages: [msg], type });\n        if (!!msg.pushName) {\n            let jid = msg.key.fromMe ? authState.creds.me.id : (msg.key.participant || msg.key.remoteJid);\n            jid = (0, WABinary_1.jidNormalizedUser)(jid);\n            if (!msg.key.fromMe) {\n                ev.emit('contacts.update', [{ id: jid, notify: msg.pushName, verifiedName: msg.verifiedBizName }]);\n            }\n            // update our pushname too\n            if (msg.key.fromMe && msg.pushName && ((_a = authState.creds.me) === null || _a === void 0 ? void 0 : _a.name) !== msg.pushName) {\n                ev.emit('creds.update', { me: { ...authState.creds.me, name: msg.pushName } });\n            }\n        }\n        const historyMsg = (0, Utils_1.getHistoryMsg)(msg.message);\n        const shouldProcessHistoryMsg = historyMsg\n            ? (shouldSyncHistoryMessage(historyMsg)\n                && Defaults_1.PROCESSABLE_HISTORY_TYPES.includes(historyMsg.syncType))\n            : false;\n        if (historyMsg && !authState.creds.myAppStateKeyId) {\n            logger.warn('skipping app state sync, as myAppStateKeyId is not set');\n            pendingAppStateSync = true;\n        }\n        await Promise.all([\n            (async () => {\n                if (historyMsg\n                    && authState.creds.myAppStateKeyId) {\n                    pendingAppStateSync = false;\n                    await doAppStateSync();\n                }\n            })(),\n            (0, process_message_1.default)(msg, {\n                shouldProcessHistoryMsg,\n                placeholderResendCache,\n                ev,\n                creds: authState.creds,\n                keyStore: authState.keys,\n                logger,\n                options: config.options,\n                getMessage: config.getMessage,\n            })\n        ]);\n        if (((_c = (_b = msg.message) === null || _b === void 0 ? void 0 : _b.protocolMessage) === null || _c === void 0 ? void 0 : _c.appStateSyncKeyShare)\n            && pendingAppStateSync) {\n            await doAppStateSync();\n            pendingAppStateSync = false;\n        }\n        async function doAppStateSync() {\n            if (!authState.creds.accountSyncCounter) {\n                logger.info('doing initial app state sync');\n                await resyncAppState(Types_1.ALL_WA_PATCH_NAMES, true);\n                const accountSyncCounter = (authState.creds.accountSyncCounter || 0) + 1;\n                ev.emit('creds.update', { accountSyncCounter });\n                if (needToFlushWithAppStateSync) {\n                    logger.debug('flushing with app state sync');\n                    ev.flush();\n                }\n            }\n        }\n    });\n    ws.on('CB:presence', handlePresenceUpdate);\n    ws.on('CB:chatstate', handlePresenceUpdate);\n    ws.on('CB:ib,,dirty', async (node) => {\n        const { attrs } = (0, WABinary_1.getBinaryNodeChild)(node, 'dirty');\n        const type = attrs.type;\n        switch (type) {\n            case 'account_sync':\n                if (attrs.timestamp) {\n                    let { lastAccountSyncTimestamp } = authState.creds;\n                    if (lastAccountSyncTimestamp) {\n                        await cleanDirtyBits('account_sync', lastAccountSyncTimestamp);\n                    }\n                    lastAccountSyncTimestamp = +attrs.timestamp;\n                    ev.emit('creds.update', { lastAccountSyncTimestamp });\n                }\n                break;\n            case 'groups':\n                // handled in groups.ts\n                break;\n            default:\n                logger.info({ node }, 'received unknown sync');\n                break;\n        }\n    });\n    ev.on('connection.update', ({ connection, receivedPendingNotifications }) => {\n        var _a;\n        if (connection === 'open') {\n            if (fireInitQueries) {\n                executeInitQueries()\n                    .catch(error => onUnexpectedError(error, 'init queries'));\n            }\n            sendPresenceUpdate(markOnlineOnConnect ? 'available' : 'unavailable')\n                .catch(error => onUnexpectedError(error, 'presence update requests'));\n        }\n        if (receivedPendingNotifications) {\n            // if we don't have the app state key\n            // we keep buffering events until we finally have\n            // the key and can sync the messages\n            if (!((_a = authState.creds) === null || _a === void 0 ? void 0 : _a.myAppStateKeyId) && !config.mobile) {\n                ev.buffer();\n                needToFlushWithAppStateSync = true;\n            }\n        }\n    });\n    return {\n        ...sock,\n        processingMutex,\n        fetchPrivacySettings,\n        upsertMessage,\n        appPatch,\n        sendPresenceUpdate,\n        presenceSubscribe,\n        profilePictureUrl,\n        onWhatsApp,\n        fetchBlocklist,\n        fetchStatus,\n        updateProfilePicture,\n        removeProfilePicture,\n        updateProfileStatus,\n        updateProfileName,\n        updateBlockStatus,\n        updateCallPrivacy,\n        updateLastSeenPrivacy,\n        updateOnlinePrivacy,\n        updateProfilePicturePrivacy,\n        updateStatusPrivacy,\n        updateReadReceiptsPrivacy,\n        updateGroupsAddPrivacy,\n        updateDefaultDisappearingMode,\n        getBusinessProfile,\n        resyncAppState,\n        chatModify,\n        cleanDirtyBits,\n        addLabel,\n        addChatLabel,\n        removeChatLabel,\n        addMessageLabel,\n        removeMessageLabel,\n        star\n    };\n};\nexports.makeChatsSocket = makeChatsSocket;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}