{"ast":null,"code":"'use strict';\n\nconst BaseKeyType = require('./base_key_type');\nconst ChainType = require('./chain_type');\nconst SessionRecord = require('./session_record');\nconst crypto = require('./crypto');\nconst curve = require('./curve');\nconst errors = require('./errors');\nconst queueJob = require('./queue_job');\nclass SessionBuilder {\n  constructor(storage, protocolAddress) {\n    this.addr = protocolAddress;\n    this.storage = storage;\n  }\n  async initOutgoing(device) {\n    const fqAddr = this.addr.toString();\n    return await queueJob(fqAddr, async () => {\n      if (!(await this.storage.isTrustedIdentity(this.addr.id, device.identityKey))) {\n        throw new errors.UntrustedIdentityKeyError(this.addr.id, device.identityKey);\n      }\n      curve.verifySignature(device.identityKey, device.signedPreKey.publicKey, device.signedPreKey.signature);\n      const baseKey = curve.generateKeyPair();\n      const devicePreKey = device.preKey && device.preKey.publicKey;\n      const session = await this.initSession(true, baseKey, undefined, device.identityKey, devicePreKey, device.signedPreKey.publicKey, device.registrationId);\n      session.pendingPreKey = {\n        signedKeyId: device.signedPreKey.keyId,\n        baseKey: baseKey.pubKey\n      };\n      if (device.preKey) {\n        session.pendingPreKey.preKeyId = device.preKey.keyId;\n      }\n      let record = await this.storage.loadSession(fqAddr);\n      if (!record) {\n        record = new SessionRecord();\n      } else {\n        const openSession = record.getOpenSession();\n        if (openSession) {\n          console.warn(\"Closing stale open session for new outgoing prekey bundle\");\n          record.closeSession(openSession);\n        }\n      }\n      record.setSession(session);\n      await this.storage.storeSession(fqAddr, record);\n    });\n  }\n  async initIncoming(record, message) {\n    const fqAddr = this.addr.toString();\n    if (!(await this.storage.isTrustedIdentity(fqAddr, message.identityKey))) {\n      throw new errors.UntrustedIdentityKeyError(this.addr.id, message.identityKey);\n    }\n    if (record.getSession(message.baseKey)) {\n      // This just means we haven't replied.\n      return;\n    }\n    const preKeyPair = await this.storage.loadPreKey(message.preKeyId);\n    if (message.preKeyId && !preKeyPair) {\n      throw new errors.PreKeyError('Invalid PreKey ID');\n    }\n    const signedPreKeyPair = await this.storage.loadSignedPreKey(message.signedPreKeyId);\n    if (!signedPreKeyPair) {\n      throw new errors.PreKeyError(\"Missing SignedPreKey\");\n    }\n    const existingOpenSession = record.getOpenSession();\n    if (existingOpenSession) {\n      console.warn(\"Closing open session in favor of incoming prekey bundle\");\n      record.closeSession(existingOpenSession);\n    }\n    record.setSession(await this.initSession(false, preKeyPair, signedPreKeyPair, message.identityKey, message.baseKey, undefined, message.registrationId));\n    return message.preKeyId;\n  }\n  async initSession(isInitiator, ourEphemeralKey, ourSignedKey, theirIdentityPubKey, theirEphemeralPubKey, theirSignedPubKey, registrationId) {\n    if (isInitiator) {\n      if (ourSignedKey) {\n        throw new Error(\"Invalid call to initSession\");\n      }\n      ourSignedKey = ourEphemeralKey;\n    } else {\n      if (theirSignedPubKey) {\n        throw new Error(\"Invalid call to initSession\");\n      }\n      theirSignedPubKey = theirEphemeralPubKey;\n    }\n    let sharedSecret;\n    if (!ourEphemeralKey || !theirEphemeralPubKey) {\n      sharedSecret = new Uint8Array(32 * 4);\n    } else {\n      sharedSecret = new Uint8Array(32 * 5);\n    }\n    for (var i = 0; i < 32; i++) {\n      sharedSecret[i] = 0xff;\n    }\n    const ourIdentityKey = await this.storage.getOurIdentity();\n    const a1 = curve.calculateAgreement(theirSignedPubKey, ourIdentityKey.privKey);\n    const a2 = curve.calculateAgreement(theirIdentityPubKey, ourSignedKey.privKey);\n    const a3 = curve.calculateAgreement(theirSignedPubKey, ourSignedKey.privKey);\n    if (isInitiator) {\n      sharedSecret.set(new Uint8Array(a1), 32);\n      sharedSecret.set(new Uint8Array(a2), 32 * 2);\n    } else {\n      sharedSecret.set(new Uint8Array(a1), 32 * 2);\n      sharedSecret.set(new Uint8Array(a2), 32);\n    }\n    sharedSecret.set(new Uint8Array(a3), 32 * 3);\n    if (ourEphemeralKey && theirEphemeralPubKey) {\n      const a4 = curve.calculateAgreement(theirEphemeralPubKey, ourEphemeralKey.privKey);\n      sharedSecret.set(new Uint8Array(a4), 32 * 4);\n    }\n    const masterKey = crypto.deriveSecrets(Buffer.from(sharedSecret), Buffer.alloc(32), Buffer.from(\"WhisperText\"));\n    const session = SessionRecord.createEntry();\n    session.registrationId = registrationId;\n    session.currentRatchet = {\n      rootKey: masterKey[0],\n      ephemeralKeyPair: isInitiator ? curve.generateKeyPair() : ourSignedKey,\n      lastRemoteEphemeralKey: theirSignedPubKey,\n      previousCounter: 0\n    };\n    session.indexInfo = {\n      created: Date.now(),\n      used: Date.now(),\n      remoteIdentityKey: theirIdentityPubKey,\n      baseKey: isInitiator ? ourEphemeralKey.pubKey : theirEphemeralPubKey,\n      baseKeyType: isInitiator ? BaseKeyType.OURS : BaseKeyType.THEIRS,\n      closed: -1\n    };\n    if (isInitiator) {\n      // If we're initiating we go ahead and set our first sending ephemeral key now,\n      // otherwise we figure it out when we first maybeStepRatchet with the remote's\n      // ephemeral key\n      this.calculateSendingRatchet(session, theirSignedPubKey);\n    }\n    return session;\n  }\n  calculateSendingRatchet(session, remoteKey) {\n    const ratchet = session.currentRatchet;\n    const sharedSecret = curve.calculateAgreement(remoteKey, ratchet.ephemeralKeyPair.privKey);\n    const masterKey = crypto.deriveSecrets(sharedSecret, ratchet.rootKey, Buffer.from(\"WhisperRatchet\"));\n    session.addChain(ratchet.ephemeralKeyPair.pubKey, {\n      messageKeys: {},\n      chainKey: {\n        counter: -1,\n        key: masterKey[1]\n      },\n      chainType: ChainType.SENDING\n    });\n    ratchet.rootKey = masterKey[0];\n  }\n}\nmodule.exports = SessionBuilder;","map":{"version":3,"names":["BaseKeyType","require","ChainType","SessionRecord","crypto","curve","errors","queueJob","SessionBuilder","constructor","storage","protocolAddress","addr","initOutgoing","device","fqAddr","toString","isTrustedIdentity","id","identityKey","UntrustedIdentityKeyError","verifySignature","signedPreKey","publicKey","signature","baseKey","generateKeyPair","devicePreKey","preKey","session","initSession","undefined","registrationId","pendingPreKey","signedKeyId","keyId","pubKey","preKeyId","record","loadSession","openSession","getOpenSession","console","warn","closeSession","setSession","storeSession","initIncoming","message","getSession","preKeyPair","loadPreKey","PreKeyError","signedPreKeyPair","loadSignedPreKey","signedPreKeyId","existingOpenSession","isInitiator","ourEphemeralKey","ourSignedKey","theirIdentityPubKey","theirEphemeralPubKey","theirSignedPubKey","Error","sharedSecret","Uint8Array","i","ourIdentityKey","getOurIdentity","a1","calculateAgreement","privKey","a2","a3","set","a4","masterKey","deriveSecrets","Buffer","from","alloc","createEntry","currentRatchet","rootKey","ephemeralKeyPair","lastRemoteEphemeralKey","previousCounter","indexInfo","created","Date","now","used","remoteIdentityKey","baseKeyType","OURS","THEIRS","closed","calculateSendingRatchet","remoteKey","ratchet","addChain","messageKeys","chainKey","counter","key","chainType","SENDING","module","exports"],"sources":["C:/Users/vanitas/node_modules/libsignal/src/session_builder.js"],"sourcesContent":["\n'use strict';\n\nconst BaseKeyType = require('./base_key_type');\nconst ChainType = require('./chain_type');\nconst SessionRecord = require('./session_record');\nconst crypto = require('./crypto');\nconst curve = require('./curve');\nconst errors = require('./errors');\nconst queueJob = require('./queue_job');\n\n\nclass SessionBuilder {\n\n    constructor(storage, protocolAddress) {\n        this.addr = protocolAddress;\n        this.storage = storage;\n    }\n\n    async initOutgoing(device) {\n        const fqAddr = this.addr.toString();\n        return await queueJob(fqAddr, async () => {\n            if (!await this.storage.isTrustedIdentity(this.addr.id, device.identityKey)) {\n                throw new errors.UntrustedIdentityKeyError(this.addr.id, device.identityKey);\n            }\n            curve.verifySignature(device.identityKey, device.signedPreKey.publicKey,\n                                  device.signedPreKey.signature);\n            const baseKey = curve.generateKeyPair();\n            const devicePreKey = device.preKey && device.preKey.publicKey;\n            const session = await this.initSession(true, baseKey, undefined, device.identityKey,\n                                                   devicePreKey, device.signedPreKey.publicKey,\n                                                   device.registrationId);\n            session.pendingPreKey = {\n                signedKeyId: device.signedPreKey.keyId,\n                baseKey: baseKey.pubKey\n            };\n            if (device.preKey) {\n                session.pendingPreKey.preKeyId = device.preKey.keyId;\n            }\n            let record = await this.storage.loadSession(fqAddr);\n            if (!record) {\n                record = new SessionRecord();\n            } else {\n                const openSession = record.getOpenSession();\n                if (openSession) {\n                    console.warn(\"Closing stale open session for new outgoing prekey bundle\");\n                    record.closeSession(openSession);\n                }\n            }\n            record.setSession(session);\n            await this.storage.storeSession(fqAddr, record);\n        });\n    }\n\n    async initIncoming(record, message) {\n        const fqAddr = this.addr.toString();\n        if (!await this.storage.isTrustedIdentity(fqAddr, message.identityKey)) {\n            throw new errors.UntrustedIdentityKeyError(this.addr.id, message.identityKey);\n        }\n        if (record.getSession(message.baseKey)) {\n            // This just means we haven't replied.\n            return;\n        }\n        const preKeyPair = await this.storage.loadPreKey(message.preKeyId);\n        if (message.preKeyId && !preKeyPair) {\n            throw new errors.PreKeyError('Invalid PreKey ID');\n        }   \n        const signedPreKeyPair = await this.storage.loadSignedPreKey(message.signedPreKeyId);\n        if (!signedPreKeyPair) { \n            throw new errors.PreKeyError(\"Missing SignedPreKey\");\n        }   \n        const existingOpenSession = record.getOpenSession();\n        if (existingOpenSession) {\n            console.warn(\"Closing open session in favor of incoming prekey bundle\");\n            record.closeSession(existingOpenSession);\n        }\n        record.setSession(await this.initSession(false, preKeyPair, signedPreKeyPair,\n                                                 message.identityKey, message.baseKey,\n                                                 undefined, message.registrationId));\n        return message.preKeyId;\n    }\n\n    async initSession(isInitiator, ourEphemeralKey, ourSignedKey, theirIdentityPubKey,\n                      theirEphemeralPubKey, theirSignedPubKey, registrationId) {\n        if (isInitiator) {\n            if (ourSignedKey) {\n                throw new Error(\"Invalid call to initSession\");\n            }\n            ourSignedKey = ourEphemeralKey;\n        } else {\n            if (theirSignedPubKey) {\n                throw new Error(\"Invalid call to initSession\");\n            }\n            theirSignedPubKey = theirEphemeralPubKey;\n        }\n        let sharedSecret;\n        if (!ourEphemeralKey || !theirEphemeralPubKey) {\n            sharedSecret = new Uint8Array(32 * 4);\n        } else {\n            sharedSecret = new Uint8Array(32 * 5);\n        }\n        for (var i = 0; i < 32; i++) {\n            sharedSecret[i] = 0xff;\n        }\n        const ourIdentityKey = await this.storage.getOurIdentity();\n        const a1 = curve.calculateAgreement(theirSignedPubKey, ourIdentityKey.privKey);\n        const a2 = curve.calculateAgreement(theirIdentityPubKey, ourSignedKey.privKey);\n        const a3 = curve.calculateAgreement(theirSignedPubKey, ourSignedKey.privKey);\n        if (isInitiator) {\n            sharedSecret.set(new Uint8Array(a1), 32);\n            sharedSecret.set(new Uint8Array(a2), 32 * 2);\n        } else {\n            sharedSecret.set(new Uint8Array(a1), 32 * 2);\n            sharedSecret.set(new Uint8Array(a2), 32);\n        }\n        sharedSecret.set(new Uint8Array(a3), 32 * 3);\n        if (ourEphemeralKey && theirEphemeralPubKey) {\n            const a4 = curve.calculateAgreement(theirEphemeralPubKey, ourEphemeralKey.privKey);\n            sharedSecret.set(new Uint8Array(a4), 32 * 4);\n        }\n        const masterKey = crypto.deriveSecrets(Buffer.from(sharedSecret), Buffer.alloc(32),\n                                               Buffer.from(\"WhisperText\"));\n        const session = SessionRecord.createEntry();\n        session.registrationId = registrationId;\n        session.currentRatchet = {\n            rootKey: masterKey[0],\n            ephemeralKeyPair: isInitiator ? curve.generateKeyPair() : ourSignedKey,\n            lastRemoteEphemeralKey: theirSignedPubKey,\n            previousCounter: 0\n        };\n        session.indexInfo = {\n            created: Date.now(),\n            used: Date.now(),\n            remoteIdentityKey: theirIdentityPubKey,\n            baseKey: isInitiator ? ourEphemeralKey.pubKey : theirEphemeralPubKey,\n            baseKeyType: isInitiator ? BaseKeyType.OURS : BaseKeyType.THEIRS,\n            closed: -1\n        };\n        if (isInitiator) {\n            // If we're initiating we go ahead and set our first sending ephemeral key now,\n            // otherwise we figure it out when we first maybeStepRatchet with the remote's\n            // ephemeral key\n            this.calculateSendingRatchet(session, theirSignedPubKey);\n        }\n        return session;\n    }\n\n    calculateSendingRatchet(session, remoteKey) {\n        const ratchet = session.currentRatchet;\n        const sharedSecret = curve.calculateAgreement(remoteKey, ratchet.ephemeralKeyPair.privKey);\n        const masterKey = crypto.deriveSecrets(sharedSecret, ratchet.rootKey, Buffer.from(\"WhisperRatchet\"));\n        session.addChain(ratchet.ephemeralKeyPair.pubKey, {\n            messageKeys: {},\n            chainKey: {\n                counter: -1,\n                key: masterKey[1]\n            },\n            chainType: ChainType.SENDING\n        });\n        ratchet.rootKey = masterKey[0];\n    }\n}\n\nmodule.exports = SessionBuilder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}