{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toRatio = exports.dbToRatio = exports.ratioToDb = exports.a2hex = exports.isBitSet = exports.getBitAllignedNumber = exports.stripNulls = exports.decodeString = exports.trimRightNull = exports.findZero = exports.getBit = void 0;\nfunction getBit(buf, off, bit) {\n  return (buf[off] & 1 << bit) !== 0;\n}\nexports.getBit = getBit;\n/**\n * Found delimiting zero in uint8Array\n * @param uint8Array Uint8Array to find the zero delimiter in\n * @param start Offset in uint8Array\n * @param end Last position to parse in uint8Array\n * @param encoding The string encoding used\n * @return Absolute position on uint8Array where zero found\n */\nfunction findZero(uint8Array, start, end, encoding) {\n  let i = start;\n  if (encoding === 'utf16le') {\n    while (uint8Array[i] !== 0 || uint8Array[i + 1] !== 0) {\n      if (i >= end) return end;\n      i += 2;\n    }\n    return i;\n  } else {\n    while (uint8Array[i] !== 0) {\n      if (i >= end) return end;\n      i++;\n    }\n    return i;\n  }\n}\nexports.findZero = findZero;\nfunction trimRightNull(x) {\n  const pos0 = x.indexOf('\\0');\n  return pos0 === -1 ? x : x.substr(0, pos0);\n}\nexports.trimRightNull = trimRightNull;\nfunction swapBytes(uint8Array) {\n  const l = uint8Array.length;\n  if ((l & 1) !== 0) throw new Error('Buffer length must be even');\n  for (let i = 0; i < l; i += 2) {\n    const a = uint8Array[i];\n    uint8Array[i] = uint8Array[i + 1];\n    uint8Array[i + 1] = a;\n  }\n  return uint8Array;\n}\n/**\n * Decode string\n */\nfunction decodeString(uint8Array, encoding) {\n  // annoying workaround for a double BOM issue\n  // https://github.com/leetreveil/musicmetadata/issues/84\n  if (uint8Array[0] === 0xFF && uint8Array[1] === 0xFE) {\n    // little endian\n    return decodeString(uint8Array.subarray(2), encoding);\n  } else if (encoding === 'utf16le' && uint8Array[0] === 0xFE && uint8Array[1] === 0xFF) {\n    // BOM, indicating big endian decoding\n    if ((uint8Array.length & 1) !== 0) throw new Error('Expected even number of octets for 16-bit unicode string');\n    return decodeString(swapBytes(uint8Array), encoding);\n  }\n  return Buffer.from(uint8Array).toString(encoding);\n}\nexports.decodeString = decodeString;\nfunction stripNulls(str) {\n  str = str.replace(/^\\x00+/g, '');\n  str = str.replace(/\\x00+$/g, '');\n  return str;\n}\nexports.stripNulls = stripNulls;\n/**\n * Read bit-aligned number start from buffer\n * Total offset in bits = byteOffset * 8 + bitOffset\n * @param source Byte buffer\n * @param byteOffset Starting offset in bytes\n * @param bitOffset Starting offset in bits: 0 = lsb\n * @param len Length of number in bits\n * @return Decoded bit aligned number\n */\nfunction getBitAllignedNumber(source, byteOffset, bitOffset, len) {\n  const byteOff = byteOffset + ~~(bitOffset / 8);\n  const bitOff = bitOffset % 8;\n  let value = source[byteOff];\n  value &= 0xff >> bitOff;\n  const bitsRead = 8 - bitOff;\n  const bitsLeft = len - bitsRead;\n  if (bitsLeft < 0) {\n    value >>= 8 - bitOff - len;\n  } else if (bitsLeft > 0) {\n    value <<= bitsLeft;\n    value |= getBitAllignedNumber(source, byteOffset, bitOffset + bitsRead, bitsLeft);\n  }\n  return value;\n}\nexports.getBitAllignedNumber = getBitAllignedNumber;\n/**\n * Read bit-aligned number start from buffer\n * Total offset in bits = byteOffset * 8 + bitOffset\n * @param source Byte Uint8Array\n * @param byteOffset Starting offset in bytes\n * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is the least significant bit\n * @return True if bit is set\n */\nfunction isBitSet(source, byteOffset, bitOffset) {\n  return getBitAllignedNumber(source, byteOffset, bitOffset, 1) === 1;\n}\nexports.isBitSet = isBitSet;\nfunction a2hex(str) {\n  const arr = [];\n  for (let i = 0, l = str.length; i < l; i++) {\n    const hex = Number(str.charCodeAt(i)).toString(16);\n    arr.push(hex.length === 1 ? '0' + hex : hex);\n  }\n  return arr.join(' ');\n}\nexports.a2hex = a2hex;\n/**\n * Convert power ratio to DB\n * ratio: [0..1]\n */\nfunction ratioToDb(ratio) {\n  return 10 * Math.log10(ratio);\n}\nexports.ratioToDb = ratioToDb;\n/**\n * Convert dB to ratio\n * db Decibels\n */\nfunction dbToRatio(dB) {\n  return Math.pow(10, dB / 10);\n}\nexports.dbToRatio = dbToRatio;\n/**\n * Convert replay gain to ratio and Decibel\n * @param value string holding a ratio like '0.034' or '-7.54 dB'\n */\nfunction toRatio(value) {\n  const ps = value.split(' ').map(p => p.trim().toLowerCase());\n  // @ts-ignore\n  if (ps.length >= 1) {\n    const v = parseFloat(ps[0]);\n    return ps.length === 2 && ps[1] === 'db' ? {\n      dB: v,\n      ratio: dbToRatio(v)\n    } : {\n      dB: ratioToDb(v),\n      ratio: v\n    };\n  }\n}\nexports.toRatio = toRatio;","map":{"version":3,"names":["Object","defineProperty","exports","value","toRatio","dbToRatio","ratioToDb","a2hex","isBitSet","getBitAllignedNumber","stripNulls","decodeString","trimRightNull","findZero","getBit","buf","off","bit","uint8Array","start","end","encoding","i","x","pos0","indexOf","substr","swapBytes","l","length","Error","a","subarray","Buffer","from","toString","str","replace","source","byteOffset","bitOffset","len","byteOff","bitOff","bitsRead","bitsLeft","arr","hex","Number","charCodeAt","push","join","ratio","Math","log10","dB","pow","ps","split","map","p","trim","toLowerCase","v","parseFloat"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/common/Util.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toRatio = exports.dbToRatio = exports.ratioToDb = exports.a2hex = exports.isBitSet = exports.getBitAllignedNumber = exports.stripNulls = exports.decodeString = exports.trimRightNull = exports.findZero = exports.getBit = void 0;\nfunction getBit(buf, off, bit) {\n    return (buf[off] & (1 << bit)) !== 0;\n}\nexports.getBit = getBit;\n/**\n * Found delimiting zero in uint8Array\n * @param uint8Array Uint8Array to find the zero delimiter in\n * @param start Offset in uint8Array\n * @param end Last position to parse in uint8Array\n * @param encoding The string encoding used\n * @return Absolute position on uint8Array where zero found\n */\nfunction findZero(uint8Array, start, end, encoding) {\n    let i = start;\n    if (encoding === 'utf16le') {\n        while (uint8Array[i] !== 0 || uint8Array[i + 1] !== 0) {\n            if (i >= end)\n                return end;\n            i += 2;\n        }\n        return i;\n    }\n    else {\n        while (uint8Array[i] !== 0) {\n            if (i >= end)\n                return end;\n            i++;\n        }\n        return i;\n    }\n}\nexports.findZero = findZero;\nfunction trimRightNull(x) {\n    const pos0 = x.indexOf('\\0');\n    return pos0 === -1 ? x : x.substr(0, pos0);\n}\nexports.trimRightNull = trimRightNull;\nfunction swapBytes(uint8Array) {\n    const l = uint8Array.length;\n    if ((l & 1) !== 0)\n        throw new Error('Buffer length must be even');\n    for (let i = 0; i < l; i += 2) {\n        const a = uint8Array[i];\n        uint8Array[i] = uint8Array[i + 1];\n        uint8Array[i + 1] = a;\n    }\n    return uint8Array;\n}\n/**\n * Decode string\n */\nfunction decodeString(uint8Array, encoding) {\n    // annoying workaround for a double BOM issue\n    // https://github.com/leetreveil/musicmetadata/issues/84\n    if (uint8Array[0] === 0xFF && uint8Array[1] === 0xFE) { // little endian\n        return decodeString(uint8Array.subarray(2), encoding);\n    }\n    else if (encoding === 'utf16le' && uint8Array[0] === 0xFE && uint8Array[1] === 0xFF) {\n        // BOM, indicating big endian decoding\n        if ((uint8Array.length & 1) !== 0)\n            throw new Error('Expected even number of octets for 16-bit unicode string');\n        return decodeString(swapBytes(uint8Array), encoding);\n    }\n    return Buffer.from(uint8Array).toString(encoding);\n}\nexports.decodeString = decodeString;\nfunction stripNulls(str) {\n    str = str.replace(/^\\x00+/g, '');\n    str = str.replace(/\\x00+$/g, '');\n    return str;\n}\nexports.stripNulls = stripNulls;\n/**\n * Read bit-aligned number start from buffer\n * Total offset in bits = byteOffset * 8 + bitOffset\n * @param source Byte buffer\n * @param byteOffset Starting offset in bytes\n * @param bitOffset Starting offset in bits: 0 = lsb\n * @param len Length of number in bits\n * @return Decoded bit aligned number\n */\nfunction getBitAllignedNumber(source, byteOffset, bitOffset, len) {\n    const byteOff = byteOffset + ~~(bitOffset / 8);\n    const bitOff = bitOffset % 8;\n    let value = source[byteOff];\n    value &= 0xff >> bitOff;\n    const bitsRead = 8 - bitOff;\n    const bitsLeft = len - bitsRead;\n    if (bitsLeft < 0) {\n        value >>= (8 - bitOff - len);\n    }\n    else if (bitsLeft > 0) {\n        value <<= bitsLeft;\n        value |= getBitAllignedNumber(source, byteOffset, bitOffset + bitsRead, bitsLeft);\n    }\n    return value;\n}\nexports.getBitAllignedNumber = getBitAllignedNumber;\n/**\n * Read bit-aligned number start from buffer\n * Total offset in bits = byteOffset * 8 + bitOffset\n * @param source Byte Uint8Array\n * @param byteOffset Starting offset in bytes\n * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is the least significant bit\n * @return True if bit is set\n */\nfunction isBitSet(source, byteOffset, bitOffset) {\n    return getBitAllignedNumber(source, byteOffset, bitOffset, 1) === 1;\n}\nexports.isBitSet = isBitSet;\nfunction a2hex(str) {\n    const arr = [];\n    for (let i = 0, l = str.length; i < l; i++) {\n        const hex = Number(str.charCodeAt(i)).toString(16);\n        arr.push(hex.length === 1 ? '0' + hex : hex);\n    }\n    return arr.join(' ');\n}\nexports.a2hex = a2hex;\n/**\n * Convert power ratio to DB\n * ratio: [0..1]\n */\nfunction ratioToDb(ratio) {\n    return 10 * Math.log10(ratio);\n}\nexports.ratioToDb = ratioToDb;\n/**\n * Convert dB to ratio\n * db Decibels\n */\nfunction dbToRatio(dB) {\n    return Math.pow(10, dB / 10);\n}\nexports.dbToRatio = dbToRatio;\n/**\n * Convert replay gain to ratio and Decibel\n * @param value string holding a ratio like '0.034' or '-7.54 dB'\n */\nfunction toRatio(value) {\n    const ps = value.split(' ').map(p => p.trim().toLowerCase());\n    // @ts-ignore\n    if (ps.length >= 1) {\n        const v = parseFloat(ps[0]);\n        return ps.length === 2 && ps[1] === 'db' ? {\n            dB: v,\n            ratio: dbToRatio(v)\n        } : {\n            dB: ratioToDb(v),\n            ratio: v\n        };\n    }\n}\nexports.toRatio = toRatio;\n//# sourceMappingURL=Util.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}