{"ast":null,"code":"import { WASMAudioDecoderCommon } from \"@wasm-audio-decoders/common\";\nimport { OpusDecoder } from \"opus-decoder\";\nimport CodecParser, { codecFrames, header, channels, streamCount, coupledStreamCount, channelMappingTable, preSkip, isLastPage, absoluteGranulePosition, samples, data } from \"codec-parser\";\nexport default class OggOpusDecoder {\n  constructor(options = {}) {\n    this._sampleRate = options.sampleRate || 48000;\n    this._forceStereo = options.forceStereo !== undefined ? options.forceStereo : false;\n    this._onCodec = codec => {\n      if (codec !== \"opus\") throw new Error(\"ogg-opus-decoder does not support this codec \" + codec);\n    };\n\n    // instantiate to create static properties\n    new WASMAudioDecoderCommon();\n    this._decoderClass = OpusDecoder;\n    this._init();\n  }\n  _init() {\n    if (this._decoder) this._decoder.free();\n    this._decoder = null;\n    this._ready = Promise.resolve();\n    this._codecParser = new CodecParser(\"application/ogg\", {\n      onCodec: this._onCodec,\n      enableFrameCRC32: false\n    });\n  }\n  async _instantiateDecoder(header) {\n    this._totalSamplesDecoded = 0;\n    this._preSkip = header[preSkip];\n    this._channels = this._forceStereo ? 2 : header[channels];\n    this._beginningSampleOffset = null;\n    this._decoder = new this._decoderClass({\n      channels: header[channels],\n      streamCount: header[streamCount],\n      coupledStreamCount: header[coupledStreamCount],\n      channelMappingTable: header[channelMappingTable],\n      preSkip: Math.round(this._preSkip / 48000 * this._sampleRate),\n      sampleRate: this._sampleRate,\n      forceStereo: this._forceStereo\n    });\n    await this._decoder.ready;\n  }\n  get ready() {\n    return this._ready;\n  }\n  async reset() {\n    this._init();\n  }\n  free() {\n    this._init();\n  }\n  async _decode(oggPages) {\n    let allErrors = [],\n      allChannelData = [],\n      samplesThisDecode = 0;\n    for await (const oggPage of oggPages) {\n      // only decode Ogg pages that have codec frames\n      const frames = oggPage[codecFrames].map(f => f[data]);\n      if (frames.length) {\n        // wait until there is an Opus header before instantiating\n        if (!this._decoder) await this._instantiateDecoder(oggPage[codecFrames][0][header]);\n        const {\n          channelData,\n          samplesDecoded,\n          errors\n        } = await this._decoder.decodeFrames(frames);\n        this._totalSamplesDecoded += samplesDecoded;\n\n        // record beginning sample offset for absoluteGranulePosition logic\n        if (this._beginningSampleOffset === null && Number(oggPage[absoluteGranulePosition]) > -1) {\n          this._beginningSampleOffset = oggPage[absoluteGranulePosition] - BigInt(oggPage[samples]) + BigInt(this._preSkip);\n        }\n        if (oggPage[isLastPage]) {\n          // in cases where BigInt isn't supported, don't do any absoluteGranulePosition logic (i.e. old iOS versions)\n          if (oggPage[absoluteGranulePosition] !== undefined) {\n            const totalDecodedSamples_48000 = this._totalSamplesDecoded / this._sampleRate * 48000;\n            const totalOggSamples_48000 = Number(oggPage[absoluteGranulePosition] - this._beginningSampleOffset);\n\n            // trim any extra samples that are decoded beyond the absoluteGranulePosition, relative to where we started in the stream\n            const samplesToTrim = Math.round((totalDecodedSamples_48000 - totalOggSamples_48000) / 48000 * this._sampleRate);\n            for (let i = 0; i < channelData.length; i++) {\n              channelData[i] = channelData[i].subarray(0, samplesDecoded - samplesToTrim);\n            }\n            samplesThisDecode -= samplesToTrim;\n          }\n          // reached the end of an ogg stream, reset the decoder\n          this._init();\n        }\n        allErrors.push(...errors);\n        allChannelData.push(channelData);\n        samplesThisDecode += samplesDecoded;\n      }\n    }\n    return [allErrors, allChannelData, this._channels, samplesThisDecode, this._sampleRate, 16];\n  }\n  _parse(oggOpusData) {\n    return [...this._codecParser.parseChunk(oggOpusData)];\n  }\n  _flush() {\n    return [...this._codecParser.flush()];\n  }\n  async decode(oggOpusData) {\n    const decoded = await this._decode(this._parse(oggOpusData));\n    return WASMAudioDecoderCommon.getDecodedAudioMultiChannel(...decoded);\n  }\n  async decodeFile(oggOpusData) {\n    const decoded = await this._decode([...this._parse(oggOpusData), ...this._flush()]);\n    this._init();\n    return WASMAudioDecoderCommon.getDecodedAudioMultiChannel(...decoded);\n  }\n  async flush() {\n    const decoded = await this._decode(this._flush());\n    this._init();\n    return WASMAudioDecoderCommon.getDecodedAudioMultiChannel(...decoded);\n  }\n}","map":{"version":3,"names":["WASMAudioDecoderCommon","OpusDecoder","CodecParser","codecFrames","header","channels","streamCount","coupledStreamCount","channelMappingTable","preSkip","isLastPage","absoluteGranulePosition","samples","data","OggOpusDecoder","constructor","options","_sampleRate","sampleRate","_forceStereo","forceStereo","undefined","_onCodec","codec","Error","_decoderClass","_init","_decoder","free","_ready","Promise","resolve","_codecParser","onCodec","enableFrameCRC32","_instantiateDecoder","_totalSamplesDecoded","_preSkip","_channels","_beginningSampleOffset","Math","round","ready","reset","_decode","oggPages","allErrors","allChannelData","samplesThisDecode","oggPage","frames","map","f","length","channelData","samplesDecoded","errors","decodeFrames","Number","BigInt","totalDecodedSamples_48000","totalOggSamples_48000","samplesToTrim","i","subarray","push","_parse","oggOpusData","parseChunk","_flush","flush","decode","decoded","getDecodedAudioMultiChannel","decodeFile"],"sources":["C:/Users/vanitas/node_modules/ogg-opus-decoder/src/OggOpusDecoder.js"],"sourcesContent":["import { WASMAudioDecoderCommon } from \"@wasm-audio-decoders/common\";\nimport { OpusDecoder } from \"opus-decoder\";\nimport CodecParser, {\n  codecFrames,\n  header,\n  channels,\n  streamCount,\n  coupledStreamCount,\n  channelMappingTable,\n  preSkip,\n  isLastPage,\n  absoluteGranulePosition,\n  samples,\n  data,\n} from \"codec-parser\";\n\nexport default class OggOpusDecoder {\n  constructor(options = {}) {\n    this._sampleRate = options.sampleRate || 48000;\n    this._forceStereo =\n      options.forceStereo !== undefined ? options.forceStereo : false;\n\n    this._onCodec = (codec) => {\n      if (codec !== \"opus\")\n        throw new Error(\n          \"ogg-opus-decoder does not support this codec \" + codec,\n        );\n    };\n\n    // instantiate to create static properties\n    new WASMAudioDecoderCommon();\n    this._decoderClass = OpusDecoder;\n\n    this._init();\n  }\n\n  _init() {\n    if (this._decoder) this._decoder.free();\n    this._decoder = null;\n    this._ready = Promise.resolve();\n\n    this._codecParser = new CodecParser(\"application/ogg\", {\n      onCodec: this._onCodec,\n      enableFrameCRC32: false,\n    });\n  }\n\n  async _instantiateDecoder(header) {\n    this._totalSamplesDecoded = 0;\n    this._preSkip = header[preSkip];\n    this._channels = this._forceStereo ? 2 : header[channels];\n    this._beginningSampleOffset = null;\n\n    this._decoder = new this._decoderClass({\n      channels: header[channels],\n      streamCount: header[streamCount],\n      coupledStreamCount: header[coupledStreamCount],\n      channelMappingTable: header[channelMappingTable],\n      preSkip: Math.round((this._preSkip / 48000) * this._sampleRate),\n      sampleRate: this._sampleRate,\n      forceStereo: this._forceStereo,\n    });\n    await this._decoder.ready;\n  }\n\n  get ready() {\n    return this._ready;\n  }\n\n  async reset() {\n    this._init();\n  }\n\n  free() {\n    this._init();\n  }\n\n  async _decode(oggPages) {\n    let allErrors = [],\n      allChannelData = [],\n      samplesThisDecode = 0;\n\n    for await (const oggPage of oggPages) {\n      // only decode Ogg pages that have codec frames\n      const frames = oggPage[codecFrames].map((f) => f[data]);\n\n      if (frames.length) {\n        // wait until there is an Opus header before instantiating\n        if (!this._decoder)\n          await this._instantiateDecoder(oggPage[codecFrames][0][header]);\n\n        const { channelData, samplesDecoded, errors } =\n          await this._decoder.decodeFrames(frames);\n\n        this._totalSamplesDecoded += samplesDecoded;\n\n        // record beginning sample offset for absoluteGranulePosition logic\n        if (\n          this._beginningSampleOffset === null &&\n          Number(oggPage[absoluteGranulePosition]) > -1\n        ) {\n          this._beginningSampleOffset =\n            oggPage[absoluteGranulePosition] -\n            BigInt(oggPage[samples]) +\n            BigInt(this._preSkip);\n        }\n\n        if (oggPage[isLastPage]) {\n          // in cases where BigInt isn't supported, don't do any absoluteGranulePosition logic (i.e. old iOS versions)\n          if (oggPage[absoluteGranulePosition] !== undefined) {\n            const totalDecodedSamples_48000 =\n              (this._totalSamplesDecoded / this._sampleRate) * 48000;\n            const totalOggSamples_48000 = Number(\n              oggPage[absoluteGranulePosition] - this._beginningSampleOffset,\n            );\n\n            // trim any extra samples that are decoded beyond the absoluteGranulePosition, relative to where we started in the stream\n            const samplesToTrim = Math.round(\n              ((totalDecodedSamples_48000 - totalOggSamples_48000) / 48000) *\n                this._sampleRate,\n            );\n\n            for (let i = 0; i < channelData.length; i++) {\n              channelData[i] = channelData[i].subarray(\n                0,\n                samplesDecoded - samplesToTrim,\n              );\n            }\n\n            samplesThisDecode -= samplesToTrim;\n          }\n          // reached the end of an ogg stream, reset the decoder\n          this._init();\n        }\n\n        allErrors.push(...errors);\n        allChannelData.push(channelData);\n        samplesThisDecode += samplesDecoded;\n      }\n    }\n\n    return [\n      allErrors,\n      allChannelData,\n      this._channels,\n      samplesThisDecode,\n      this._sampleRate,\n      16,\n    ];\n  }\n\n  _parse(oggOpusData) {\n    return [...this._codecParser.parseChunk(oggOpusData)];\n  }\n\n  _flush() {\n    return [...this._codecParser.flush()];\n  }\n\n  async decode(oggOpusData) {\n    const decoded = await this._decode(this._parse(oggOpusData));\n\n    return WASMAudioDecoderCommon.getDecodedAudioMultiChannel(...decoded);\n  }\n\n  async decodeFile(oggOpusData) {\n    const decoded = await this._decode([\n      ...this._parse(oggOpusData),\n      ...this._flush(),\n    ]);\n    this._init();\n\n    return WASMAudioDecoderCommon.getDecodedAudioMultiChannel(...decoded);\n  }\n\n  async flush() {\n    const decoded = await this._decode(this._flush());\n    this._init();\n\n    return WASMAudioDecoderCommon.getDecodedAudioMultiChannel(...decoded);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}