{"ast":null,"code":"/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { crc32Function, concatBuffers } from \"./utilities.js\";\nimport { header, sampleRate, bitrate, length, frameNumber, data, samples, codec, codecFrames, totalBytesOut, totalSamples, totalDuration, crc32, duration, subarray, readRawData, incrementRawData, mapCodecFrameStats, mapFrameStats, logWarning, logError, parseFrame, checkCodecUpdate, reset } from \"./constants.js\";\nimport HeaderCache from \"./codecs/HeaderCache.js\";\nimport MPEGParser from \"./codecs/mpeg/MPEGParser.js\";\nimport AACParser from \"./codecs/aac/AACParser.js\";\nimport FLACParser from \"./codecs/flac/FLACParser.js\";\nimport OggParser from \"./containers/ogg/OggParser.js\";\nconst noOp = () => {};\nexport default class CodecParser {\n  constructor(mimeType, {\n    onCodec,\n    onCodecHeader,\n    onCodecUpdate,\n    enableLogging = false,\n    enableFrameCRC32 = true\n  } = {}) {\n    this._inputMimeType = mimeType;\n    this._onCodec = onCodec || noOp;\n    this._onCodecHeader = onCodecHeader || noOp;\n    this._onCodecUpdate = onCodecUpdate;\n    this._enableLogging = enableLogging;\n    this._crc32 = enableFrameCRC32 ? crc32Function : noOp;\n    this[reset]();\n  }\n\n  /**\n   * @public\n   * @returns The detected codec\n   */\n  get [codec]() {\n    return this._parser ? this._parser[codec] : \"\";\n  }\n  [reset]() {\n    this._headerCache = new HeaderCache(this._onCodecHeader, this._onCodecUpdate);\n    this._generator = this._getGenerator();\n    this._generator.next();\n  }\n\n  /**\n   * @public\n   * @description Generator function that yields any buffered CodecFrames and resets the CodecParser\n   * @returns {Iterable<CodecFrame|OggPage>} Iterator that operates over the codec data.\n   * @yields {CodecFrame|OggPage} Parsed codec or ogg page data\n   */\n  *flush() {\n    this._flushing = true;\n    for (let i = this._generator.next(); i.value; i = this._generator.next()) {\n      yield i.value;\n    }\n    this._flushing = false;\n    this[reset]();\n  }\n\n  /**\n   * @public\n   * @description Generator function takes in a Uint8Array of data and returns a CodecFrame from the data for each iteration\n   * @param {Uint8Array} chunk Next chunk of codec data to read\n   * @returns {Iterable<CodecFrame|OggPage>} Iterator that operates over the codec data.\n   * @yields {CodecFrame|OggPage} Parsed codec or ogg page data\n   */\n  *parseChunk(chunk) {\n    for (let i = this._generator.next(chunk); i.value; i = this._generator.next()) {\n      yield i.value;\n    }\n  }\n\n  /**\n   * @public\n   * @description Parses an entire file and returns all of the contained frames.\n   * @param {Uint8Array} fileData Coded data to read\n   * @returns {Array<CodecFrame|OggPage>} CodecFrames\n   */\n  parseAll(fileData) {\n    return [...this.parseChunk(fileData), ...this.flush()];\n  }\n\n  /**\n   * @private\n   */\n  *_getGenerator() {\n    if (this._inputMimeType.match(/aac/)) {\n      this._parser = new AACParser(this, this._headerCache, this._onCodec);\n    } else if (this._inputMimeType.match(/mpeg/)) {\n      this._parser = new MPEGParser(this, this._headerCache, this._onCodec);\n    } else if (this._inputMimeType.match(/flac/)) {\n      this._parser = new FLACParser(this, this._headerCache, this._onCodec);\n    } else if (this._inputMimeType.match(/ogg/)) {\n      this._parser = new OggParser(this, this._headerCache, this._onCodec);\n    } else {\n      throw new Error(`Unsupported Codec ${mimeType}`);\n    }\n    this._frameNumber = 0;\n    this._currentReadPosition = 0;\n    this._totalBytesIn = 0;\n    this._totalBytesOut = 0;\n    this._totalSamples = 0;\n    this._sampleRate = undefined;\n    this._rawData = new Uint8Array(0);\n\n    // start parsing out frames\n    while (true) {\n      const frame = yield* this._parser[parseFrame]();\n      if (frame) yield frame;\n    }\n  }\n\n  /**\n   * @protected\n   * @param {number} minSize Minimum bytes to have present in buffer\n   * @returns {Uint8Array} rawData\n   */\n  *[readRawData](minSize = 0, readOffset = 0) {\n    let rawData;\n    while (this._rawData[length] <= minSize + readOffset) {\n      rawData = yield;\n      if (this._flushing) return this._rawData[subarray](readOffset);\n      if (rawData) {\n        this._totalBytesIn += rawData[length];\n        this._rawData = concatBuffers(this._rawData, rawData);\n      }\n    }\n    return this._rawData[subarray](readOffset);\n  }\n\n  /**\n   * @protected\n   * @param {number} increment Bytes to increment codec data\n   */\n  [incrementRawData](increment) {\n    this._currentReadPosition += increment;\n    this._rawData = this._rawData[subarray](increment);\n  }\n\n  /**\n   * @protected\n   */\n  [mapCodecFrameStats](frame) {\n    this._sampleRate = frame[header][sampleRate];\n    frame[header][bitrate] = frame[duration] > 0 ? Math.round(frame[data][length] / frame[duration]) * 8 : 0;\n    frame[frameNumber] = this._frameNumber++;\n    frame[totalBytesOut] = this._totalBytesOut;\n    frame[totalSamples] = this._totalSamples;\n    frame[totalDuration] = this._totalSamples / this._sampleRate * 1000;\n    frame[crc32] = this._crc32(frame[data]);\n    this._headerCache[checkCodecUpdate](frame[header][bitrate], frame[totalDuration]);\n    this._totalBytesOut += frame[data][length];\n    this._totalSamples += frame[samples];\n  }\n\n  /**\n   * @protected\n   */\n  [mapFrameStats](frame) {\n    if (frame[codecFrames]) {\n      // Ogg container\n      frame[codecFrames].forEach(codecFrame => {\n        frame[duration] += codecFrame[duration];\n        frame[samples] += codecFrame[samples];\n        this[mapCodecFrameStats](codecFrame);\n      });\n      frame[totalSamples] = this._totalSamples;\n      frame[totalDuration] = this._totalSamples / this._sampleRate * 1000 || 0;\n      frame[totalBytesOut] = this._totalBytesOut;\n    } else {\n      this[mapCodecFrameStats](frame);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _log(logger, messages) {\n    if (this._enableLogging) {\n      const stats = [`${codec}:         ${this[codec]}`, `inputMimeType: ${this._inputMimeType}`, `readPosition:  ${this._currentReadPosition}`, `totalBytesIn:  ${this._totalBytesIn}`, `${totalBytesOut}: ${this._totalBytesOut}`];\n      const width = Math.max(...stats.map(s => s[length]));\n      messages.push(`--stats--${\"-\".repeat(width - 9)}`, ...stats, \"-\".repeat(width));\n      logger(\"codec-parser\", messages.reduce((acc, message) => acc + \"\\n  \" + message, \"\"));\n    }\n  }\n\n  /**\n   * @protected\n   */\n  [logWarning](...messages) {\n    this._log(console.warn, messages);\n  }\n\n  /**\n   * @protected\n   */\n  [logError](...messages) {\n    this._log(console.error, messages);\n  }\n}","map":{"version":3,"names":["crc32Function","concatBuffers","header","sampleRate","bitrate","length","frameNumber","data","samples","codec","codecFrames","totalBytesOut","totalSamples","totalDuration","crc32","duration","subarray","readRawData","incrementRawData","mapCodecFrameStats","mapFrameStats","logWarning","logError","parseFrame","checkCodecUpdate","reset","HeaderCache","MPEGParser","AACParser","FLACParser","OggParser","noOp","CodecParser","constructor","mimeType","onCodec","onCodecHeader","onCodecUpdate","enableLogging","enableFrameCRC32","_inputMimeType","_onCodec","_onCodecHeader","_onCodecUpdate","_enableLogging","_crc32","_parser","_headerCache","_generator","_getGenerator","next","flush","_flushing","i","value","parseChunk","chunk","parseAll","fileData","match","Error","_frameNumber","_currentReadPosition","_totalBytesIn","_totalBytesOut","_totalSamples","_sampleRate","undefined","_rawData","Uint8Array","frame","minSize","readOffset","rawData","increment","Math","round","forEach","codecFrame","_log","logger","messages","stats","width","max","map","s","push","repeat","reduce","acc","message","console","warn","error"],"sources":["C:/Users/vanitas/node_modules/codec-parser/src/CodecParser.js"],"sourcesContent":["/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { crc32Function, concatBuffers } from \"./utilities.js\";\nimport {\n  header,\n  sampleRate,\n  bitrate,\n  length,\n  frameNumber,\n  data,\n  samples,\n  codec,\n  codecFrames,\n  totalBytesOut,\n  totalSamples,\n  totalDuration,\n  crc32,\n  duration,\n  subarray,\n  readRawData,\n  incrementRawData,\n  mapCodecFrameStats,\n  mapFrameStats,\n  logWarning,\n  logError,\n  parseFrame,\n  checkCodecUpdate,\n  reset,\n} from \"./constants.js\";\nimport HeaderCache from \"./codecs/HeaderCache.js\";\nimport MPEGParser from \"./codecs/mpeg/MPEGParser.js\";\nimport AACParser from \"./codecs/aac/AACParser.js\";\nimport FLACParser from \"./codecs/flac/FLACParser.js\";\nimport OggParser from \"./containers/ogg/OggParser.js\";\n\nconst noOp = () => {};\n\nexport default class CodecParser {\n  constructor(\n    mimeType,\n    {\n      onCodec,\n      onCodecHeader,\n      onCodecUpdate,\n      enableLogging = false,\n      enableFrameCRC32 = true,\n    } = {},\n  ) {\n    this._inputMimeType = mimeType;\n    this._onCodec = onCodec || noOp;\n    this._onCodecHeader = onCodecHeader || noOp;\n    this._onCodecUpdate = onCodecUpdate;\n    this._enableLogging = enableLogging;\n    this._crc32 = enableFrameCRC32 ? crc32Function : noOp;\n\n    this[reset]();\n  }\n\n  /**\n   * @public\n   * @returns The detected codec\n   */\n  get [codec]() {\n    return this._parser ? this._parser[codec] : \"\";\n  }\n\n  [reset]() {\n    this._headerCache = new HeaderCache(\n      this._onCodecHeader,\n      this._onCodecUpdate,\n    );\n\n    this._generator = this._getGenerator();\n    this._generator.next();\n  }\n\n  /**\n   * @public\n   * @description Generator function that yields any buffered CodecFrames and resets the CodecParser\n   * @returns {Iterable<CodecFrame|OggPage>} Iterator that operates over the codec data.\n   * @yields {CodecFrame|OggPage} Parsed codec or ogg page data\n   */\n  *flush() {\n    this._flushing = true;\n\n    for (let i = this._generator.next(); i.value; i = this._generator.next()) {\n      yield i.value;\n    }\n\n    this._flushing = false;\n\n    this[reset]();\n  }\n\n  /**\n   * @public\n   * @description Generator function takes in a Uint8Array of data and returns a CodecFrame from the data for each iteration\n   * @param {Uint8Array} chunk Next chunk of codec data to read\n   * @returns {Iterable<CodecFrame|OggPage>} Iterator that operates over the codec data.\n   * @yields {CodecFrame|OggPage} Parsed codec or ogg page data\n   */\n  *parseChunk(chunk) {\n    for (\n      let i = this._generator.next(chunk);\n      i.value;\n      i = this._generator.next()\n    ) {\n      yield i.value;\n    }\n  }\n\n  /**\n   * @public\n   * @description Parses an entire file and returns all of the contained frames.\n   * @param {Uint8Array} fileData Coded data to read\n   * @returns {Array<CodecFrame|OggPage>} CodecFrames\n   */\n  parseAll(fileData) {\n    return [...this.parseChunk(fileData), ...this.flush()];\n  }\n\n  /**\n   * @private\n   */\n  *_getGenerator() {\n    if (this._inputMimeType.match(/aac/)) {\n      this._parser = new AACParser(this, this._headerCache, this._onCodec);\n    } else if (this._inputMimeType.match(/mpeg/)) {\n      this._parser = new MPEGParser(this, this._headerCache, this._onCodec);\n    } else if (this._inputMimeType.match(/flac/)) {\n      this._parser = new FLACParser(this, this._headerCache, this._onCodec);\n    } else if (this._inputMimeType.match(/ogg/)) {\n      this._parser = new OggParser(this, this._headerCache, this._onCodec);\n    } else {\n      throw new Error(`Unsupported Codec ${mimeType}`);\n    }\n\n    this._frameNumber = 0;\n    this._currentReadPosition = 0;\n    this._totalBytesIn = 0;\n    this._totalBytesOut = 0;\n    this._totalSamples = 0;\n    this._sampleRate = undefined;\n\n    this._rawData = new Uint8Array(0);\n\n    // start parsing out frames\n    while (true) {\n      const frame = yield* this._parser[parseFrame]();\n      if (frame) yield frame;\n    }\n  }\n\n  /**\n   * @protected\n   * @param {number} minSize Minimum bytes to have present in buffer\n   * @returns {Uint8Array} rawData\n   */\n  *[readRawData](minSize = 0, readOffset = 0) {\n    let rawData;\n\n    while (this._rawData[length] <= minSize + readOffset) {\n      rawData = yield;\n\n      if (this._flushing) return this._rawData[subarray](readOffset);\n\n      if (rawData) {\n        this._totalBytesIn += rawData[length];\n        this._rawData = concatBuffers(this._rawData, rawData);\n      }\n    }\n\n    return this._rawData[subarray](readOffset);\n  }\n\n  /**\n   * @protected\n   * @param {number} increment Bytes to increment codec data\n   */\n  [incrementRawData](increment) {\n    this._currentReadPosition += increment;\n    this._rawData = this._rawData[subarray](increment);\n  }\n\n  /**\n   * @protected\n   */\n  [mapCodecFrameStats](frame) {\n    this._sampleRate = frame[header][sampleRate];\n\n    frame[header][bitrate] =\n      frame[duration] > 0\n        ? Math.round(frame[data][length] / frame[duration]) * 8\n        : 0;\n    frame[frameNumber] = this._frameNumber++;\n    frame[totalBytesOut] = this._totalBytesOut;\n    frame[totalSamples] = this._totalSamples;\n    frame[totalDuration] = (this._totalSamples / this._sampleRate) * 1000;\n    frame[crc32] = this._crc32(frame[data]);\n\n    this._headerCache[checkCodecUpdate](\n      frame[header][bitrate],\n      frame[totalDuration],\n    );\n\n    this._totalBytesOut += frame[data][length];\n    this._totalSamples += frame[samples];\n  }\n\n  /**\n   * @protected\n   */\n  [mapFrameStats](frame) {\n    if (frame[codecFrames]) {\n      // Ogg container\n      frame[codecFrames].forEach((codecFrame) => {\n        frame[duration] += codecFrame[duration];\n        frame[samples] += codecFrame[samples];\n        this[mapCodecFrameStats](codecFrame);\n      });\n\n      frame[totalSamples] = this._totalSamples;\n      frame[totalDuration] =\n        (this._totalSamples / this._sampleRate) * 1000 || 0;\n      frame[totalBytesOut] = this._totalBytesOut;\n    } else {\n      this[mapCodecFrameStats](frame);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _log(logger, messages) {\n    if (this._enableLogging) {\n      const stats = [\n        `${codec}:         ${this[codec]}`,\n        `inputMimeType: ${this._inputMimeType}`,\n        `readPosition:  ${this._currentReadPosition}`,\n        `totalBytesIn:  ${this._totalBytesIn}`,\n        `${totalBytesOut}: ${this._totalBytesOut}`,\n      ];\n\n      const width = Math.max(...stats.map((s) => s[length]));\n\n      messages.push(\n        `--stats--${\"-\".repeat(width - 9)}`,\n        ...stats,\n        \"-\".repeat(width),\n      );\n\n      logger(\n        \"codec-parser\",\n        messages.reduce((acc, message) => acc + \"\\n  \" + message, \"\"),\n      );\n    }\n  }\n\n  /**\n   * @protected\n   */\n  [logWarning](...messages) {\n    this._log(console.warn, messages);\n  }\n\n  /**\n   * @protected\n   */\n  [logError](...messages) {\n    this._log(console.error, messages);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}