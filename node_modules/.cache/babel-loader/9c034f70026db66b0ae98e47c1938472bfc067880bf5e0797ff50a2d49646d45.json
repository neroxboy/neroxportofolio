{"ast":null,"code":"/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { frameStore } from \"../globals.js\";\nimport { frame, length, incrementRawData, mapFrameStats, logWarning, syncFrame, fixedLengthFrameSync, getFrame, getHeader, reset, enable } from \"../constants.js\";\n\n/**\n * @abstract\n * @description Abstract class containing methods for parsing codec frames\n */\nexport default class Parser {\n  constructor(codecParser, headerCache) {\n    this._codecParser = codecParser;\n    this._headerCache = headerCache;\n  }\n  *[syncFrame]() {\n    let frameData;\n    do {\n      frameData = yield* this.Frame[getFrame](this._codecParser, this._headerCache, 0);\n      if (frameData) return frameData;\n      this._codecParser[incrementRawData](1); // increment to continue syncing\n    } while (true);\n  }\n\n  /**\n   * @description Searches for Frames within bytes containing a sequence of known codec frames.\n   * @param {boolean} ignoreNextFrame Set to true to return frames even if the next frame may not exist at the expected location\n   * @returns {Frame}\n   */\n  *[fixedLengthFrameSync](ignoreNextFrame) {\n    let frameData = yield* this[syncFrame]();\n    const frameLength = frameStore.get(frameData)[length];\n    if (ignoreNextFrame || this._codecParser._flushing || (\n    // check if there is a frame right after this one\n    yield* this.Header[getHeader](this._codecParser, this._headerCache, frameLength))) {\n      this._headerCache[enable](); // start caching when synced\n\n      this._codecParser[incrementRawData](frameLength); // increment to the next frame\n      this._codecParser[mapFrameStats](frameData);\n      return frameData;\n    }\n    this._codecParser[logWarning](`Missing ${frame} at ${frameLength} bytes from current position.`, `Dropping current ${frame} and trying again.`);\n    this._headerCache[reset](); // frame is invalid and must re-sync and clear cache\n    this._codecParser[incrementRawData](1); // increment to invalidate the current frame\n  }\n}","map":{"version":3,"names":["frameStore","frame","length","incrementRawData","mapFrameStats","logWarning","syncFrame","fixedLengthFrameSync","getFrame","getHeader","reset","enable","Parser","constructor","codecParser","headerCache","_codecParser","_headerCache","frameData","Frame","ignoreNextFrame","frameLength","get","_flushing","Header"],"sources":["C:/Users/vanitas/node_modules/codec-parser/src/codecs/Parser.js"],"sourcesContent":["/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { frameStore } from \"../globals.js\";\nimport {\n  frame,\n  length,\n  incrementRawData,\n  mapFrameStats,\n  logWarning,\n  syncFrame,\n  fixedLengthFrameSync,\n  getFrame,\n  getHeader,\n  reset,\n  enable,\n} from \"../constants.js\";\n\n/**\n * @abstract\n * @description Abstract class containing methods for parsing codec frames\n */\nexport default class Parser {\n  constructor(codecParser, headerCache) {\n    this._codecParser = codecParser;\n    this._headerCache = headerCache;\n  }\n\n  *[syncFrame]() {\n    let frameData;\n\n    do {\n      frameData = yield* this.Frame[getFrame](\n        this._codecParser,\n        this._headerCache,\n        0,\n      );\n      if (frameData) return frameData;\n      this._codecParser[incrementRawData](1); // increment to continue syncing\n    } while (true);\n  }\n\n  /**\n   * @description Searches for Frames within bytes containing a sequence of known codec frames.\n   * @param {boolean} ignoreNextFrame Set to true to return frames even if the next frame may not exist at the expected location\n   * @returns {Frame}\n   */\n  *[fixedLengthFrameSync](ignoreNextFrame) {\n    let frameData = yield* this[syncFrame]();\n    const frameLength = frameStore.get(frameData)[length];\n\n    if (\n      ignoreNextFrame ||\n      this._codecParser._flushing ||\n      // check if there is a frame right after this one\n      (yield* this.Header[getHeader](\n        this._codecParser,\n        this._headerCache,\n        frameLength,\n      ))\n    ) {\n      this._headerCache[enable](); // start caching when synced\n\n      this._codecParser[incrementRawData](frameLength); // increment to the next frame\n      this._codecParser[mapFrameStats](frameData);\n      return frameData;\n    }\n\n    this._codecParser[logWarning](\n      `Missing ${frame} at ${frameLength} bytes from current position.`,\n      `Dropping current ${frame} and trying again.`,\n    );\n    this._headerCache[reset](); // frame is invalid and must re-sync and clear cache\n    this._codecParser[incrementRawData](1); // increment to invalidate the current frame\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,UAAU,QAAQ,eAAe;AAC1C,SACEC,KAAK,EACLC,MAAM,EACNC,gBAAgB,EAChBC,aAAa,EACbC,UAAU,EACVC,SAAS,EACTC,oBAAoB,EACpBC,QAAQ,EACRC,SAAS,EACTC,KAAK,EACLC,MAAM,QACD,iBAAiB;;AAExB;AACA;AACA;AACA;AACA,eAAe,MAAMC,MAAM,CAAC;EAC1BC,WAAWA,CAACC,WAAW,EAAEC,WAAW,EAAE;IACpC,IAAI,CAACC,YAAY,GAAGF,WAAW;IAC/B,IAAI,CAACG,YAAY,GAAGF,WAAW;EACjC;EAEA,EAAET,SAAS,IAAI;IACb,IAAIY,SAAS;IAEb,GAAG;MACDA,SAAS,GAAG,OAAO,IAAI,CAACC,KAAK,CAACX,QAAQ,CAAC,CACrC,IAAI,CAACQ,YAAY,EACjB,IAAI,CAACC,YAAY,EACjB,CACF,CAAC;MACD,IAAIC,SAAS,EAAE,OAAOA,SAAS;MAC/B,IAAI,CAACF,YAAY,CAACb,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1C,CAAC,QAAQ,IAAI;EACf;;EAEA;AACF;AACA;AACA;AACA;EACE,EAAEI,oBAAoB,EAAEa,eAAe,EAAE;IACvC,IAAIF,SAAS,GAAG,OAAO,IAAI,CAACZ,SAAS,CAAC,CAAC,CAAC;IACxC,MAAMe,WAAW,GAAGrB,UAAU,CAACsB,GAAG,CAACJ,SAAS,CAAC,CAAChB,MAAM,CAAC;IAErD,IACEkB,eAAe,IACf,IAAI,CAACJ,YAAY,CAACO,SAAS;IAC3B;IACC,OAAO,IAAI,CAACC,MAAM,CAACf,SAAS,CAAC,CAC5B,IAAI,CAACO,YAAY,EACjB,IAAI,CAACC,YAAY,EACjBI,WACF,CAAC,CAAC,EACF;MACA,IAAI,CAACJ,YAAY,CAACN,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;;MAE7B,IAAI,CAACK,YAAY,CAACb,gBAAgB,CAAC,CAACkB,WAAW,CAAC,CAAC,CAAC;MAClD,IAAI,CAACL,YAAY,CAACZ,aAAa,CAAC,CAACc,SAAS,CAAC;MAC3C,OAAOA,SAAS;IAClB;IAEA,IAAI,CAACF,YAAY,CAACX,UAAU,CAAC,CAC3B,WAAWJ,KAAK,OAAOoB,WAAW,+BAA+B,EACjE,oBAAoBpB,KAAK,oBAC3B,CAAC;IACD,IAAI,CAACgB,YAAY,CAACP,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5B,IAAI,CAACM,YAAY,CAACb,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAC1C;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}