{"ast":null,"code":"import { BitInputStream } from \"@thi.ng/bitstream\";\nimport { qoa_lms_predict, qoa_lms_update, qoa_clamp, qoa_dequant_tab, LMS, QOA_MIN_FILESIZE, QOA_SLICE_LEN, QOA_MAGIC, QOA_LMS_LEN } from \"./lib/common.js\";\nfunction decodeHeader(stream) {\n  const magic = stream.read(32);\n  if (magic !== QOA_MAGIC) {\n    throw new Error(`Not a QOA file; expected magic number 'qoaf'`);\n  }\n\n  // peek first frame to get audio file data\n  const header = {\n    samples: stream.read(32),\n    channels: stream.read(8),\n    sampleRate: stream.read(24)\n  };\n\n  // go back to end of header\n  stream.seek(64);\n\n  // return data\n  return header;\n}\nfunction qoa_decode_frame(stream, audio, lmses, channelData, sampleOffset) {\n  const channels = stream.read(8);\n  const sampleRate = stream.read(24);\n  const samples = stream.read(16); // frame samples\n  const frameSize = stream.read(16);\n  const dataSize = Math.floor(frameSize - 8 - QOA_LMS_LEN * 4 * channels);\n  const numSlices = Math.floor(dataSize / 8);\n  const maxTotalSamples = numSlices * QOA_SLICE_LEN;\n  if (channels != audio.channels || sampleRate != audio.sampleRate || samples * channels > maxTotalSamples) {\n    throw new Error(`invalid frame header data`);\n  }\n\n  // decode LMS history and weights\n  for (let c = 0; c < channels; c++) {\n    const lms = lmses[c];\n    for (let i = 0; i < QOA_LMS_LEN; i++) {\n      let h = stream.read(16);\n      lms.history[i] = h;\n    }\n    for (let i = 0; i < QOA_LMS_LEN; i++) {\n      let w = stream.read(16);\n      lms.weights[i] = w;\n    }\n  }\n  for (let sample_index = 0; sample_index < samples; sample_index += QOA_SLICE_LEN) {\n    for (let c = 0; c < channels; c++) {\n      const scalefactor = stream.read(4);\n      const table = qoa_dequant_tab[scalefactor];\n      const slice_start = sample_index;\n      const slice_end = Math.min(sample_index + QOA_SLICE_LEN, samples);\n      const slice_count = slice_end - slice_start;\n      const lms = lmses[c];\n      const sampleData = channelData[c];\n      let idx = sampleOffset + slice_start;\n      const weights = lms.weights;\n      const history = lms.history;\n      let bitsRemaining = 60;\n      // note: this loop is a hot code path and could be optimized\n      for (let i = 0; i < slice_count; i++) {\n        const predicted = qoa_lms_predict(weights, history);\n        const quantized = stream.read(3);\n        const dequantized = table[quantized];\n        const reconstructed = qoa_clamp(predicted + dequantized, -32768, 32767);\n        const sample = reconstructed < 0 ? reconstructed / 32768 : reconstructed / 32767;\n        sampleData[idx++] = sample;\n        qoa_lms_update(weights, history, reconstructed, dequantized);\n        bitsRemaining -= 3;\n      }\n      // skip stream if needed\n      if (bitsRemaining > 0) {\n        stream.read(bitsRemaining);\n      }\n    }\n  }\n  return samples;\n}\nexport default function decode(data) {\n  if (data.byteLength < QOA_MIN_FILESIZE) {\n    throw new Error(`QOA file size must be >= ${QOA_MIN_FILESIZE}`);\n  }\n  const stream = new BitInputStream(data);\n  const audio = decodeHeader(stream);\n  const channelData = [];\n  const lmses = [];\n  for (let c = 0; c < audio.channels; c++) {\n    const d = new Float32Array(audio.samples);\n    channelData.push(d);\n    lmses.push(LMS());\n  }\n  let sampleIndex = 0;\n  let frameLen = 0;\n  do {\n    frameLen = qoa_decode_frame(stream, audio, lmses, channelData, sampleIndex);\n    sampleIndex += frameLen;\n  } while (frameLen && sampleIndex < audio.samples);\n  return {\n    ...audio,\n    channelData\n  };\n}","map":{"version":3,"names":["BitInputStream","qoa_lms_predict","qoa_lms_update","qoa_clamp","qoa_dequant_tab","LMS","QOA_MIN_FILESIZE","QOA_SLICE_LEN","QOA_MAGIC","QOA_LMS_LEN","decodeHeader","stream","magic","read","Error","header","samples","channels","sampleRate","seek","qoa_decode_frame","audio","lmses","channelData","sampleOffset","frameSize","dataSize","Math","floor","numSlices","maxTotalSamples","c","lms","i","h","history","w","weights","sample_index","scalefactor","table","slice_start","slice_end","min","slice_count","sampleData","idx","bitsRemaining","predicted","quantized","dequantized","reconstructed","sample","decode","data","byteLength","d","Float32Array","push","sampleIndex","frameLen"],"sources":["C:/Users/vanitas/node_modules/qoa-format/decode.js"],"sourcesContent":["import { BitInputStream } from \"@thi.ng/bitstream\";\nimport {\n  qoa_lms_predict,\n  qoa_lms_update,\n  qoa_clamp,\n  qoa_dequant_tab,\n  LMS,\n  QOA_MIN_FILESIZE,\n  QOA_SLICE_LEN,\n  QOA_MAGIC,\n  QOA_LMS_LEN,\n} from \"./lib/common.js\";\n\nfunction decodeHeader(stream) {\n  const magic = stream.read(32);\n  if (magic !== QOA_MAGIC) {\n    throw new Error(`Not a QOA file; expected magic number 'qoaf'`);\n  }\n\n  // peek first frame to get audio file data\n  const header = {\n    samples: stream.read(32),\n    channels: stream.read(8),\n    sampleRate: stream.read(24),\n  };\n\n  // go back to end of header\n  stream.seek(64);\n\n  // return data\n  return header;\n}\n\nfunction qoa_decode_frame(stream, audio, lmses, channelData, sampleOffset) {\n  const channels = stream.read(8);\n  const sampleRate = stream.read(24);\n  const samples = stream.read(16); // frame samples\n  const frameSize = stream.read(16);\n\n  const dataSize = Math.floor(frameSize - 8 - QOA_LMS_LEN * 4 * channels);\n  const numSlices = Math.floor(dataSize / 8);\n  const maxTotalSamples = numSlices * QOA_SLICE_LEN;\n\n  if (\n    channels != audio.channels ||\n    sampleRate != audio.sampleRate ||\n    samples * channels > maxTotalSamples\n  ) {\n    throw new Error(`invalid frame header data`);\n  }\n\n  // decode LMS history and weights\n  for (let c = 0; c < channels; c++) {\n    const lms = lmses[c];\n    for (let i = 0; i < QOA_LMS_LEN; i++) {\n      let h = stream.read(16);\n      lms.history[i] = h;\n    }\n    for (let i = 0; i < QOA_LMS_LEN; i++) {\n      let w = stream.read(16);\n      lms.weights[i] = w;\n    }\n  }\n\n  for (\n    let sample_index = 0;\n    sample_index < samples;\n    sample_index += QOA_SLICE_LEN\n  ) {\n    for (let c = 0; c < channels; c++) {\n      const scalefactor = stream.read(4);\n      const table = qoa_dequant_tab[scalefactor];\n      const slice_start = sample_index;\n      const slice_end = Math.min(sample_index + QOA_SLICE_LEN, samples);\n      const slice_count = slice_end - slice_start;\n      const lms = lmses[c];\n      const sampleData = channelData[c];\n      let idx = sampleOffset + slice_start;\n      const weights = lms.weights;\n      const history = lms.history;\n      let bitsRemaining = 60;\n      // note: this loop is a hot code path and could be optimized\n      for (let i = 0; i < slice_count; i++) {\n        const predicted = qoa_lms_predict(weights, history);\n        const quantized = stream.read(3);\n        const dequantized = table[quantized];\n        const reconstructed = qoa_clamp(predicted + dequantized, -32768, 32767);\n        const sample =\n          reconstructed < 0 ? reconstructed / 32768 : reconstructed / 32767;\n        sampleData[idx++] = sample;\n        qoa_lms_update(weights, history, reconstructed, dequantized);\n        bitsRemaining -= 3;\n      }\n      // skip stream if needed\n      if (bitsRemaining > 0) {\n        stream.read(bitsRemaining);\n      }\n    }\n  }\n\n  return samples;\n}\n\nexport default function decode(data) {\n  if (data.byteLength < QOA_MIN_FILESIZE) {\n    throw new Error(`QOA file size must be >= ${QOA_MIN_FILESIZE}`);\n  }\n\n  const stream = new BitInputStream(data);\n  const audio = decodeHeader(stream);\n\n  const channelData = [];\n  const lmses = [];\n  for (let c = 0; c < audio.channels; c++) {\n    const d = new Float32Array(audio.samples);\n    channelData.push(d);\n    lmses.push(LMS());\n  }\n\n  let sampleIndex = 0;\n  let frameLen = 0;\n  do {\n    frameLen = qoa_decode_frame(stream, audio, lmses, channelData, sampleIndex);\n    sampleIndex += frameLen;\n  } while (frameLen && sampleIndex < audio.samples);\n\n  return {\n    ...audio,\n    channelData,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}