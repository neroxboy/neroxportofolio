{"ast":null,"code":"import NodeWorker from \"@eshaz/web-worker\";\nimport WASMAudioDecoderCommon from \"./WASMAudioDecoderCommon.js\";\nconst getWorker = () => globalThis.Worker || NodeWorker;\nexport default class WASMAudioDecoderWorker extends getWorker() {\n  constructor(options, name, Decoder, EmscriptenWASM) {\n    if (!WASMAudioDecoderCommon.modules) new WASMAudioDecoderCommon();\n    let source = WASMAudioDecoderCommon.modules.get(Decoder);\n    if (!source) {\n      let type = \"text/javascript\",\n        isNode,\n        webworkerSourceCode = \"'use strict';\" +\n        // dependencies need to be manually resolved when stringifying this function\n        `(${((_Decoder, _WASMAudioDecoderCommon, _EmscriptenWASM) => {\n          // We're in a Web Worker\n\n          // setup Promise that will be resolved once the WebAssembly Module is received\n          let decoder,\n            moduleResolve,\n            modulePromise = new Promise(resolve => {\n              moduleResolve = resolve;\n            });\n          self.onmessage = ({\n            data: {\n              id,\n              command,\n              data\n            }\n          }) => {\n            let messagePromise = modulePromise,\n              messagePayload = {\n                id\n              },\n              transferList;\n            if (command === \"init\") {\n              Object.defineProperties(_Decoder, {\n                WASMAudioDecoderCommon: {\n                  value: _WASMAudioDecoderCommon\n                },\n                EmscriptenWASM: {\n                  value: _EmscriptenWASM\n                },\n                module: {\n                  value: data.module\n                },\n                isWebWorker: {\n                  value: true\n                }\n              });\n              decoder = new _Decoder(data.options);\n              moduleResolve();\n            } else if (command === \"free\") {\n              decoder.free();\n            } else if (command === \"ready\") {\n              messagePromise = messagePromise.then(() => decoder.ready);\n            } else if (command === \"reset\") {\n              messagePromise = messagePromise.then(() => decoder.reset());\n            } else {\n              // \"decode\":\n              // \"decodeFrame\":\n              // \"decodeFrames\":\n              Object.assign(messagePayload, decoder[command](\n              // detach buffers\n              Array.isArray(data) ? data.map(data => new Uint8Array(data)) : new Uint8Array(data)));\n              // The \"transferList\" parameter transfers ownership of channel data to main thread,\n              // which avoids copying memory.\n              transferList = messagePayload.channelData ? messagePayload.channelData.map(channel => channel.buffer) : [];\n            }\n            messagePromise.then(() => self.postMessage(messagePayload, transferList));\n          };\n        }).toString()})(${Decoder}, ${WASMAudioDecoderCommon}, ${EmscriptenWASM})`;\n      try {\n        isNode = typeof process.versions.node !== \"undefined\";\n      } catch {}\n      source = isNode ? `data:${type};base64,${Buffer.from(webworkerSourceCode).toString(\"base64\")}` : URL.createObjectURL(new Blob([webworkerSourceCode], {\n        type\n      }));\n      WASMAudioDecoderCommon.modules.set(Decoder, source);\n    }\n    super(source, {\n      name\n    });\n    this._id = Number.MIN_SAFE_INTEGER;\n    this._enqueuedOperations = new Map();\n    this.onmessage = ({\n      data\n    }) => {\n      const {\n        id,\n        ...rest\n      } = data;\n      this._enqueuedOperations.get(id)(rest);\n      this._enqueuedOperations.delete(id);\n    };\n    new EmscriptenWASM(WASMAudioDecoderCommon).getModule().then(module => {\n      this.postToDecoder(\"init\", {\n        module,\n        options\n      });\n    });\n  }\n  async postToDecoder(command, data) {\n    return new Promise(resolve => {\n      this.postMessage({\n        command,\n        id: this._id,\n        data\n      });\n      this._enqueuedOperations.set(this._id++, resolve);\n    });\n  }\n  get ready() {\n    return this.postToDecoder(\"ready\");\n  }\n  async free() {\n    await this.postToDecoder(\"free\").finally(() => {\n      this.terminate();\n    });\n  }\n  async reset() {\n    await this.postToDecoder(\"reset\");\n  }\n}","map":{"version":3,"names":["NodeWorker","WASMAudioDecoderCommon","getWorker","globalThis","Worker","WASMAudioDecoderWorker","constructor","options","name","Decoder","EmscriptenWASM","modules","source","get","type","isNode","webworkerSourceCode","_Decoder","_WASMAudioDecoderCommon","_EmscriptenWASM","decoder","moduleResolve","modulePromise","Promise","resolve","self","onmessage","data","id","command","messagePromise","messagePayload","transferList","Object","defineProperties","value","module","isWebWorker","free","then","ready","reset","assign","Array","isArray","map","Uint8Array","channelData","channel","buffer","postMessage","toString","process","versions","node","Buffer","from","URL","createObjectURL","Blob","set","_id","Number","MIN_SAFE_INTEGER","_enqueuedOperations","Map","rest","delete","getModule","postToDecoder","finally","terminate"],"sources":["C:/Users/vanitas/node_modules/@wasm-audio-decoders/common/src/WASMAudioDecoderWorker.js"],"sourcesContent":["import NodeWorker from \"@eshaz/web-worker\";\nimport WASMAudioDecoderCommon from \"./WASMAudioDecoderCommon.js\";\n\nconst getWorker = () => globalThis.Worker || NodeWorker;\n\nexport default class WASMAudioDecoderWorker extends getWorker() {\n  constructor(options, name, Decoder, EmscriptenWASM) {\n    if (!WASMAudioDecoderCommon.modules) new WASMAudioDecoderCommon();\n\n    let source = WASMAudioDecoderCommon.modules.get(Decoder);\n\n    if (!source) {\n      let type = \"text/javascript\",\n        isNode,\n        webworkerSourceCode =\n          \"'use strict';\" +\n          // dependencies need to be manually resolved when stringifying this function\n          `(${((_Decoder, _WASMAudioDecoderCommon, _EmscriptenWASM) => {\n            // We're in a Web Worker\n\n            // setup Promise that will be resolved once the WebAssembly Module is received\n            let decoder,\n              moduleResolve,\n              modulePromise = new Promise((resolve) => {\n                moduleResolve = resolve;\n              });\n\n            self.onmessage = ({ data: { id, command, data } }) => {\n              let messagePromise = modulePromise,\n                messagePayload = { id },\n                transferList;\n\n              if (command === \"init\") {\n                Object.defineProperties(_Decoder, {\n                  WASMAudioDecoderCommon: { value: _WASMAudioDecoderCommon },\n                  EmscriptenWASM: { value: _EmscriptenWASM },\n                  module: { value: data.module },\n                  isWebWorker: { value: true },\n                });\n\n                decoder = new _Decoder(data.options);\n                moduleResolve();\n              } else if (command === \"free\") {\n                decoder.free();\n              } else if (command === \"ready\") {\n                messagePromise = messagePromise.then(() => decoder.ready);\n              } else if (command === \"reset\") {\n                messagePromise = messagePromise.then(() => decoder.reset());\n              } else {\n                // \"decode\":\n                // \"decodeFrame\":\n                // \"decodeFrames\":\n                Object.assign(\n                  messagePayload,\n                  decoder[command](\n                    // detach buffers\n                    Array.isArray(data)\n                      ? data.map((data) => new Uint8Array(data))\n                      : new Uint8Array(data),\n                  ),\n                );\n                // The \"transferList\" parameter transfers ownership of channel data to main thread,\n                // which avoids copying memory.\n                transferList = messagePayload.channelData\n                  ? messagePayload.channelData.map((channel) => channel.buffer)\n                  : [];\n              }\n\n              messagePromise.then(() =>\n                self.postMessage(messagePayload, transferList),\n              );\n            };\n          }).toString()})(${Decoder}, ${WASMAudioDecoderCommon}, ${EmscriptenWASM})`;\n\n      try {\n        isNode = typeof process.versions.node !== \"undefined\";\n      } catch {}\n\n      source = isNode\n        ? `data:${type};base64,${Buffer.from(webworkerSourceCode).toString(\n            \"base64\",\n          )}`\n        : URL.createObjectURL(new Blob([webworkerSourceCode], { type }));\n\n      WASMAudioDecoderCommon.modules.set(Decoder, source);\n    }\n\n    super(source, { name });\n\n    this._id = Number.MIN_SAFE_INTEGER;\n    this._enqueuedOperations = new Map();\n\n    this.onmessage = ({ data }) => {\n      const { id, ...rest } = data;\n      this._enqueuedOperations.get(id)(rest);\n      this._enqueuedOperations.delete(id);\n    };\n\n    new EmscriptenWASM(WASMAudioDecoderCommon).getModule().then((module) => {\n      this.postToDecoder(\"init\", { module, options });\n    });\n  }\n\n  async postToDecoder(command, data) {\n    return new Promise((resolve) => {\n      this.postMessage({\n        command,\n        id: this._id,\n        data,\n      });\n\n      this._enqueuedOperations.set(this._id++, resolve);\n    });\n  }\n\n  get ready() {\n    return this.postToDecoder(\"ready\");\n  }\n\n  async free() {\n    await this.postToDecoder(\"free\").finally(() => {\n      this.terminate();\n    });\n  }\n\n  async reset() {\n    await this.postToDecoder(\"reset\");\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}