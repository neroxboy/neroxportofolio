{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isBitSet = exports.parseTagFlags = exports.TagField = exports.TagItemHeader = exports.TagFooter = exports.Header = exports.DescriptorParser = exports.DataType = void 0;\nconst Token = require(\"token-types\");\nconst FourCC_1 = require(\"../common/FourCC\");\nvar DataType;\n(function (DataType) {\n  DataType[DataType[\"text_utf8\"] = 0] = \"text_utf8\";\n  DataType[DataType[\"binary\"] = 1] = \"binary\";\n  DataType[DataType[\"external_info\"] = 2] = \"external_info\";\n  DataType[DataType[\"reserved\"] = 3] = \"reserved\";\n})(DataType = exports.DataType || (exports.DataType = {}));\n/**\n * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\n */\nexports.DescriptorParser = {\n  len: 52,\n  get: (buf, off) => {\n    return {\n      // should equal 'MAC '\n      ID: FourCC_1.FourCcToken.get(buf, off),\n      // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\n      version: Token.UINT32_LE.get(buf, off + 4) / 1000,\n      // the number of descriptor bytes (allows later expansion of this header)\n      descriptorBytes: Token.UINT32_LE.get(buf, off + 8),\n      // the number of header APE_HEADER bytes\n      headerBytes: Token.UINT32_LE.get(buf, off + 12),\n      // the number of header APE_HEADER bytes\n      seekTableBytes: Token.UINT32_LE.get(buf, off + 16),\n      // the number of header data bytes (from original file)\n      headerDataBytes: Token.UINT32_LE.get(buf, off + 20),\n      // the number of bytes of APE frame data\n      apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),\n      // the high order number of APE frame data bytes\n      apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),\n      // the terminating data of the file (not including tag data)\n      terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),\n      // the MD5 hash of the file (see notes for usage... it's a little tricky)\n      fileMD5: new Token.Uint8ArrayType(16).get(buf, off + 36)\n    };\n  }\n};\n/**\n * APE_HEADER: describes all of the necessary information about the APE file\n */\nexports.Header = {\n  len: 24,\n  get: (buf, off) => {\n    return {\n      // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\n      compressionLevel: Token.UINT16_LE.get(buf, off),\n      // any format flags (for future use)\n      formatFlags: Token.UINT16_LE.get(buf, off + 2),\n      // the number of audio blocks in one frame\n      blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),\n      // the number of audio blocks in the final frame\n      finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),\n      // the total number of frames\n      totalFrames: Token.UINT32_LE.get(buf, off + 12),\n      // the bits per sample (typically 16)\n      bitsPerSample: Token.UINT16_LE.get(buf, off + 16),\n      // the number of channels (1 or 2)\n      channel: Token.UINT16_LE.get(buf, off + 18),\n      // the sample rate (typically 44100)\n      sampleRate: Token.UINT32_LE.get(buf, off + 20)\n    };\n  }\n};\n/**\n * APE Tag Header/Footer Version 2.0\n * TAG: describes all the properties of the file [optional]\n */\nexports.TagFooter = {\n  len: 32,\n  get: (buf, off) => {\n    return {\n      // should equal 'APETAGEX'\n      ID: new Token.StringType(8, 'ascii').get(buf, off),\n      // equals CURRENT_APE_TAG_VERSION\n      version: Token.UINT32_LE.get(buf, off + 8),\n      // the complete size of the tag, including this footer (excludes header)\n      size: Token.UINT32_LE.get(buf, off + 12),\n      // the number of fields in the tag\n      fields: Token.UINT32_LE.get(buf, off + 16),\n      // reserved for later use (must be zero),\n      flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 20))\n    };\n  }\n};\n/**\n * APE Tag v2.0 Item Header\n */\nexports.TagItemHeader = {\n  len: 8,\n  get: (buf, off) => {\n    return {\n      // Length of assigned value in bytes\n      size: Token.UINT32_LE.get(buf, off),\n      // reserved for later use (must be zero),\n      flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 4))\n    };\n  }\n};\nconst TagField = footer => {\n  return new Token.Uint8ArrayType(footer.size - exports.TagFooter.len);\n};\nexports.TagField = TagField;\nfunction parseTagFlags(flags) {\n  return {\n    containsHeader: isBitSet(flags, 31),\n    containsFooter: isBitSet(flags, 30),\n    isHeader: isBitSet(flags, 31),\n    readOnly: isBitSet(flags, 0),\n    dataType: (flags & 6) >> 1\n  };\n}\nexports.parseTagFlags = parseTagFlags;\n/**\n * @param num {number}\n * @param bit 0 is least significant bit (LSB)\n * @return {boolean} true if bit is 1; otherwise false\n */\nfunction isBitSet(num, bit) {\n  return (num & 1 << bit) !== 0;\n}\nexports.isBitSet = isBitSet;","map":{"version":3,"names":["Object","defineProperty","exports","value","isBitSet","parseTagFlags","TagField","TagItemHeader","TagFooter","Header","DescriptorParser","DataType","Token","require","FourCC_1","len","get","buf","off","ID","FourCcToken","version","UINT32_LE","descriptorBytes","headerBytes","seekTableBytes","headerDataBytes","apeFrameDataBytes","apeFrameDataBytesHigh","terminatingDataBytes","fileMD5","Uint8ArrayType","compressionLevel","UINT16_LE","formatFlags","blocksPerFrame","finalFrameBlocks","totalFrames","bitsPerSample","channel","sampleRate","StringType","size","fields","flags","footer","containsHeader","containsFooter","isHeader","readOnly","dataType","num","bit"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/apev2/APEv2Token.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isBitSet = exports.parseTagFlags = exports.TagField = exports.TagItemHeader = exports.TagFooter = exports.Header = exports.DescriptorParser = exports.DataType = void 0;\nconst Token = require(\"token-types\");\nconst FourCC_1 = require(\"../common/FourCC\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"text_utf8\"] = 0] = \"text_utf8\";\n    DataType[DataType[\"binary\"] = 1] = \"binary\";\n    DataType[DataType[\"external_info\"] = 2] = \"external_info\";\n    DataType[DataType[\"reserved\"] = 3] = \"reserved\";\n})(DataType = exports.DataType || (exports.DataType = {}));\n/**\n * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\n */\nexports.DescriptorParser = {\n    len: 52,\n    get: (buf, off) => {\n        return {\n            // should equal 'MAC '\n            ID: FourCC_1.FourCcToken.get(buf, off),\n            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\n            version: Token.UINT32_LE.get(buf, off + 4) / 1000,\n            // the number of descriptor bytes (allows later expansion of this header)\n            descriptorBytes: Token.UINT32_LE.get(buf, off + 8),\n            // the number of header APE_HEADER bytes\n            headerBytes: Token.UINT32_LE.get(buf, off + 12),\n            // the number of header APE_HEADER bytes\n            seekTableBytes: Token.UINT32_LE.get(buf, off + 16),\n            // the number of header data bytes (from original file)\n            headerDataBytes: Token.UINT32_LE.get(buf, off + 20),\n            // the number of bytes of APE frame data\n            apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),\n            // the high order number of APE frame data bytes\n            apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),\n            // the terminating data of the file (not including tag data)\n            terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),\n            // the MD5 hash of the file (see notes for usage... it's a little tricky)\n            fileMD5: new Token.Uint8ArrayType(16).get(buf, off + 36)\n        };\n    }\n};\n/**\n * APE_HEADER: describes all of the necessary information about the APE file\n */\nexports.Header = {\n    len: 24,\n    get: (buf, off) => {\n        return {\n            // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\n            compressionLevel: Token.UINT16_LE.get(buf, off),\n            // any format flags (for future use)\n            formatFlags: Token.UINT16_LE.get(buf, off + 2),\n            // the number of audio blocks in one frame\n            blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),\n            // the number of audio blocks in the final frame\n            finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),\n            // the total number of frames\n            totalFrames: Token.UINT32_LE.get(buf, off + 12),\n            // the bits per sample (typically 16)\n            bitsPerSample: Token.UINT16_LE.get(buf, off + 16),\n            // the number of channels (1 or 2)\n            channel: Token.UINT16_LE.get(buf, off + 18),\n            // the sample rate (typically 44100)\n            sampleRate: Token.UINT32_LE.get(buf, off + 20)\n        };\n    }\n};\n/**\n * APE Tag Header/Footer Version 2.0\n * TAG: describes all the properties of the file [optional]\n */\nexports.TagFooter = {\n    len: 32,\n    get: (buf, off) => {\n        return {\n            // should equal 'APETAGEX'\n            ID: new Token.StringType(8, 'ascii').get(buf, off),\n            // equals CURRENT_APE_TAG_VERSION\n            version: Token.UINT32_LE.get(buf, off + 8),\n            // the complete size of the tag, including this footer (excludes header)\n            size: Token.UINT32_LE.get(buf, off + 12),\n            // the number of fields in the tag\n            fields: Token.UINT32_LE.get(buf, off + 16),\n            // reserved for later use (must be zero),\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 20))\n        };\n    }\n};\n/**\n * APE Tag v2.0 Item Header\n */\nexports.TagItemHeader = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            // Length of assigned value in bytes\n            size: Token.UINT32_LE.get(buf, off),\n            // reserved for later use (must be zero),\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 4))\n        };\n    }\n};\nconst TagField = footer => {\n    return new Token.Uint8ArrayType(footer.size - exports.TagFooter.len);\n};\nexports.TagField = TagField;\nfunction parseTagFlags(flags) {\n    return {\n        containsHeader: isBitSet(flags, 31),\n        containsFooter: isBitSet(flags, 30),\n        isHeader: isBitSet(flags, 31),\n        readOnly: isBitSet(flags, 0),\n        dataType: (flags & 6) >> 1\n    };\n}\nexports.parseTagFlags = parseTagFlags;\n/**\n * @param num {number}\n * @param bit 0 is least significant bit (LSB)\n * @return {boolean} true if bit is 1; otherwise false\n */\nfunction isBitSet(num, bit) {\n    return (num & 1 << bit) !== 0;\n}\nexports.isBitSet = isBitSet;\n//# sourceMappingURL=APEv2Token.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}