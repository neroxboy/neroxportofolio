{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultWrapOptions = void 0;\nexports.caching = caching;\nexports.createCache = createCache;\nconst eventemitter3_1 = __importDefault(require(\"eventemitter3\"));\nconst promise_coalesce_1 = require(\"promise-coalesce\");\nconst index_js_1 = require(\"./stores/index.js\");\nconst utils_js_1 = require(\"./utils.js\");\nexports.defaultWrapOptions = {\n  nonBlockingSet: false\n};\n/**\n * Generic caching interface that wraps any caching library with a compatible interface.\n */\nasync function caching(factory, arguments_) {\n  if (factory === 'memory') {\n    const store = (0, index_js_1.memoryStore)(arguments_);\n    return createCache(store, arguments_);\n  }\n  if (typeof factory === 'function') {\n    const store = await factory(arguments_);\n    return createCache(store, arguments_);\n  }\n  const store = factory;\n  return createCache(store, arguments_);\n}\nlet cacheIndex = 0;\n/**\n * Create cache instance by store (non-async).\n */\nfunction createCache(store, arguments_) {\n  const eventEmitter = new eventemitter3_1.default();\n  const coalescePrefix = `cache-manager-index-${cacheIndex++}`;\n  return {\n    /**\n     * Wraps a function in cache. I.e., the first time the function is run,\n     * its results are stored in cache so subsequent calls retrieve from cache\n     * instead of calling the function.\n      * @example\n     * const result = await cache.wrap('key', () => Promise.resolve(1));\n     *\n     */\n    // eslint-disable-next-line max-params\n    async wrap(key, function_, ttl, refreshThreshold, options = {}) {\n      const options_ = {\n        ...exports.defaultWrapOptions,\n        ...options\n      };\n      const refreshThresholdConfig = refreshThreshold ?? arguments_?.refreshThreshold ?? 0;\n      return (0, promise_coalesce_1.coalesceAsync)(`${coalescePrefix}:${key}`, async () => {\n        const value = await store.get(key).catch(error => {\n          const errorEvent = {\n            error,\n            key,\n            operation: 'get'\n          };\n          eventEmitter.emit('error', errorEvent);\n        });\n        if (value === undefined) {\n          const result = await function_();\n          const cacheTtl = typeof ttl === 'function' ? ttl(result) : ttl;\n          await (0, utils_js_1.conditionalAwait)(async () => store.set(key, result, cacheTtl).catch(error => {\n            const errorEvent = {\n              error,\n              key,\n              operation: 'set',\n              data: result\n            };\n            eventEmitter.emit('error', errorEvent);\n          }), !options_.nonBlockingSet);\n          return result;\n        }\n        if (refreshThresholdConfig) {\n          const cacheTtl = typeof ttl === 'function' ? ttl(value) : ttl;\n          const remainingTtl = await store.ttl(key);\n          if (remainingTtl !== -1 && remainingTtl < refreshThresholdConfig) {\n            (0, promise_coalesce_1.coalesceAsync)(`+++${coalescePrefix}:${key}`, function_).then(async result => store.set(key, result, cacheTtl)).catch(async error => {\n              const errorEvent = {\n                error,\n                key,\n                operation: 'set',\n                data: value\n              };\n              eventEmitter.emit('error', errorEvent);\n              eventEmitter.emit('onBackgroundRefreshError', error);\n              if (arguments_?.onBackgroundRefreshError) {\n                arguments_.onBackgroundRefreshError(error);\n              } else {\n                throw error;\n              }\n            });\n          }\n        }\n        return value;\n      });\n    },\n    store,\n    del: async key => store.del(key),\n    get: async key => store.get(key),\n    set: async (key, value, ttl) => store.set(key, value, ttl),\n    reset: async () => store.reset(),\n    on: (event, handler) => eventEmitter.on('error', handler),\n    removeListener: (event, handler) => eventEmitter.removeListener(event, handler)\n  };\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","defaultWrapOptions","caching","createCache","eventemitter3_1","require","promise_coalesce_1","index_js_1","utils_js_1","nonBlockingSet","factory","arguments_","store","memoryStore","cacheIndex","eventEmitter","default","coalescePrefix","wrap","key","function_","ttl","refreshThreshold","options","options_","refreshThresholdConfig","coalesceAsync","get","catch","error","errorEvent","operation","emit","undefined","result","cacheTtl","conditionalAwait","set","data","remainingTtl","then","onBackgroundRefreshError","del","reset","on","event","handler","removeListener"],"sources":["C:/Users/vanitas/node_modules/cache-manager/dist/caching.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultWrapOptions = void 0;\nexports.caching = caching;\nexports.createCache = createCache;\nconst eventemitter3_1 = __importDefault(require(\"eventemitter3\"));\nconst promise_coalesce_1 = require(\"promise-coalesce\");\nconst index_js_1 = require(\"./stores/index.js\");\nconst utils_js_1 = require(\"./utils.js\");\nexports.defaultWrapOptions = {\n    nonBlockingSet: false,\n};\n/**\n * Generic caching interface that wraps any caching library with a compatible interface.\n */\nasync function caching(factory, arguments_) {\n    if (factory === 'memory') {\n        const store = (0, index_js_1.memoryStore)(arguments_);\n        return createCache(store, arguments_);\n    }\n    if (typeof factory === 'function') {\n        const store = await factory(arguments_);\n        return createCache(store, arguments_);\n    }\n    const store = factory;\n    return createCache(store, arguments_);\n}\nlet cacheIndex = 0;\n/**\n * Create cache instance by store (non-async).\n */\nfunction createCache(store, arguments_) {\n    const eventEmitter = new eventemitter3_1.default();\n    const coalescePrefix = `cache-manager-index-${cacheIndex++}`;\n    return {\n        /**\n         * Wraps a function in cache. I.e., the first time the function is run,\n         * its results are stored in cache so subsequent calls retrieve from cache\n         * instead of calling the function.\n\n         * @example\n         * const result = await cache.wrap('key', () => Promise.resolve(1));\n         *\n         */\n        // eslint-disable-next-line max-params\n        async wrap(key, function_, ttl, refreshThreshold, options = {}) {\n            const options_ = { ...exports.defaultWrapOptions, ...options };\n            const refreshThresholdConfig = refreshThreshold ?? arguments_?.refreshThreshold ?? 0;\n            return (0, promise_coalesce_1.coalesceAsync)(`${coalescePrefix}:${key}`, async () => {\n                const value = await store.get(key).catch(error => {\n                    const errorEvent = { error, key, operation: 'get' };\n                    eventEmitter.emit('error', errorEvent);\n                });\n                if (value === undefined) {\n                    const result = await function_();\n                    const cacheTtl = typeof ttl === 'function' ? ttl(result) : ttl;\n                    await (0, utils_js_1.conditionalAwait)(async () => store.set(key, result, cacheTtl).catch(error => {\n                        const errorEvent = {\n                            error, key, operation: 'set', data: result,\n                        };\n                        eventEmitter.emit('error', errorEvent);\n                    }), !options_.nonBlockingSet);\n                    return result;\n                }\n                if (refreshThresholdConfig) {\n                    const cacheTtl = typeof ttl === 'function' ? ttl(value) : ttl;\n                    const remainingTtl = await store.ttl(key);\n                    if (remainingTtl !== -1 && remainingTtl < refreshThresholdConfig) {\n                        (0, promise_coalesce_1.coalesceAsync)(`+++${coalescePrefix}:${key}`, function_)\n                            .then(async (result) => store.set(key, result, cacheTtl))\n                            .catch(async (error) => {\n                            const errorEvent = {\n                                error, key, operation: 'set', data: value,\n                            };\n                            eventEmitter.emit('error', errorEvent);\n                            eventEmitter.emit('onBackgroundRefreshError', error);\n                            if (arguments_?.onBackgroundRefreshError) {\n                                arguments_.onBackgroundRefreshError(error);\n                            }\n                            else {\n                                throw error;\n                            }\n                        });\n                    }\n                }\n                return value;\n            });\n        },\n        store,\n        del: async (key) => store.del(key),\n        get: async (key) => store.get(key),\n        set: async (key, value, ttl) => store.set(key, value, ttl),\n        reset: async () => store.reset(),\n        on: (event, handler) => eventEmitter.on('error', handler),\n        removeListener: (event, handler) => eventEmitter.removeListener(event, handler),\n    };\n}\n//# sourceMappingURL=caching.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}