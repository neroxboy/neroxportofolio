{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.waLabelAssociationKey = exports.waMessageID = exports.waChatKey = void 0;\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst LabelAssociation_1 = require(\"../Types/LabelAssociation\");\nconst Utils_1 = require(\"../Utils\");\nconst WABinary_1 = require(\"../WABinary\");\nconst make_ordered_dictionary_1 = __importDefault(require(\"./make-ordered-dictionary\"));\nconst object_repository_1 = require(\"./object-repository\");\nconst waChatKey = pin => ({\n  key: c => (pin ? c.pinned ? '1' : '0' : '') + (c.archived ? '0' : '1') + (c.conversationTimestamp ? c.conversationTimestamp.toString(16).padStart(8, '0') : '') + c.id,\n  compare: (k1, k2) => k2.localeCompare(k1)\n});\nexports.waChatKey = waChatKey;\nconst waMessageID = m => m.key.id || '';\nexports.waMessageID = waMessageID;\nexports.waLabelAssociationKey = {\n  key: la => la.type === LabelAssociation_1.LabelAssociationType.Chat ? la.chatId + la.labelId : la.chatId + la.messageId + la.labelId,\n  compare: (k1, k2) => k2.localeCompare(k1)\n};\nconst makeMessagesDictionary = () => (0, make_ordered_dictionary_1.default)(exports.waMessageID);\nexports.default = config => {\n  const socket = config.socket;\n  const chatKey = config.chatKey || (0, exports.waChatKey)(true);\n  const labelAssociationKey = config.labelAssociationKey || exports.waLabelAssociationKey;\n  const logger = config.logger || Defaults_1.DEFAULT_CONNECTION_CONFIG.logger.child({\n    stream: 'in-mem-store'\n  });\n  const KeyedDB = require('@adiwajshing/keyed-db').default;\n  const chats = new KeyedDB(chatKey, c => c.id);\n  const messages = {};\n  const contacts = {};\n  const groupMetadata = {};\n  const presences = {};\n  const state = {\n    connection: 'close'\n  };\n  const labels = new object_repository_1.ObjectRepository();\n  const labelAssociations = new KeyedDB(labelAssociationKey, labelAssociationKey.key);\n  const assertMessageList = jid => {\n    if (!messages[jid]) {\n      messages[jid] = makeMessagesDictionary();\n    }\n    return messages[jid];\n  };\n  const contactsUpsert = newContacts => {\n    const oldContacts = new Set(Object.keys(contacts));\n    for (const contact of newContacts) {\n      oldContacts.delete(contact.id);\n      contacts[contact.id] = Object.assign(contacts[contact.id] || {}, contact);\n    }\n    return oldContacts;\n  };\n  const labelsUpsert = newLabels => {\n    for (const label of newLabels) {\n      labels.upsertById(label.id, label);\n    }\n  };\n  /**\n   * binds to a BaileysEventEmitter.\n   * It listens to all events and constructs a state that you can query accurate data from.\n   * Eg. can use the store to fetch chats, contacts, messages etc.\n   * @param ev typically the event emitter from the socket connection\n   */\n  const bind = ev => {\n    ev.on('connection.update', update => {\n      Object.assign(state, update);\n    });\n    ev.on('messaging-history.set', ({\n      chats: newChats,\n      contacts: newContacts,\n      messages: newMessages,\n      isLatest,\n      syncType\n    }) => {\n      if (syncType === WAProto_1.proto.HistorySync.HistorySyncType.ON_DEMAND) {\n        return; // FOR NOW,\n        //TODO: HANDLE\n      }\n      if (isLatest) {\n        chats.clear();\n        for (const id in messages) {\n          delete messages[id];\n        }\n      }\n      const chatsAdded = chats.insertIfAbsent(...newChats).length;\n      logger.debug({\n        chatsAdded\n      }, 'synced chats');\n      const oldContacts = contactsUpsert(newContacts);\n      if (isLatest) {\n        for (const jid of oldContacts) {\n          delete contacts[jid];\n        }\n      }\n      logger.debug({\n        deletedContacts: isLatest ? oldContacts.size : 0,\n        newContacts\n      }, 'synced contacts');\n      for (const msg of newMessages) {\n        const jid = msg.key.remoteJid;\n        const list = assertMessageList(jid);\n        list.upsert(msg, 'prepend');\n      }\n      logger.debug({\n        messages: newMessages.length\n      }, 'synced messages');\n    });\n    ev.on('contacts.upsert', contacts => {\n      contactsUpsert(contacts);\n    });\n    ev.on('contacts.update', async updates => {\n      var _a;\n      for (const update of updates) {\n        let contact;\n        if (contacts[update.id]) {\n          contact = contacts[update.id];\n        } else {\n          const contactHashes = await Promise.all(Object.keys(contacts).map(async contactId => {\n            const {\n              user\n            } = (0, WABinary_1.jidDecode)(contactId);\n            return [contactId, (await (0, Utils_1.md5)(Buffer.from(user + 'WA_ADD_NOTIF', 'utf8'))).toString('base64').slice(0, 3)];\n          }));\n          contact = contacts[((_a = contactHashes.find(([, b]) => b === update.id)) === null || _a === void 0 ? void 0 : _a[0]) || '']; // find contact by attrs.hash, when user is not saved as a contact\n        }\n        if (contact) {\n          if (update.imgUrl === 'changed') {\n            contact.imgUrl = socket ? await (socket === null || socket === void 0 ? void 0 : socket.profilePictureUrl(contact.id)) : undefined;\n          } else if (update.imgUrl === 'removed') {\n            delete contact.imgUrl;\n          }\n        } else {\n          return logger.debug({\n            update\n          }, 'got update for non-existant contact');\n        }\n        Object.assign(contacts[contact.id], contact);\n      }\n    });\n    ev.on('chats.upsert', newChats => {\n      chats.upsert(...newChats);\n    });\n    ev.on('chats.update', updates => {\n      for (let update of updates) {\n        const result = chats.update(update.id, chat => {\n          if (update.unreadCount > 0) {\n            update = {\n              ...update\n            };\n            update.unreadCount = (chat.unreadCount || 0) + update.unreadCount;\n          }\n          Object.assign(chat, update);\n        });\n        if (!result) {\n          logger.debug({\n            update\n          }, 'got update for non-existant chat');\n        }\n      }\n    });\n    ev.on('labels.edit', label => {\n      if (label.deleted) {\n        return labels.deleteById(label.id);\n      }\n      // WhatsApp can store only up to 20 labels\n      if (labels.count() < 20) {\n        return labels.upsertById(label.id, label);\n      }\n      logger.error('Labels count exceed');\n    });\n    ev.on('labels.association', ({\n      type,\n      association\n    }) => {\n      switch (type) {\n        case 'add':\n          labelAssociations.upsert(association);\n          break;\n        case 'remove':\n          labelAssociations.delete(association);\n          break;\n        default:\n          console.error(`unknown operation type [${type}]`);\n      }\n    });\n    ev.on('presence.update', ({\n      id,\n      presences: update\n    }) => {\n      presences[id] = presences[id] || {};\n      Object.assign(presences[id], update);\n    });\n    ev.on('chats.delete', deletions => {\n      for (const item of deletions) {\n        if (chats.get(item)) {\n          chats.deleteById(item);\n        }\n      }\n    });\n    ev.on('messages.upsert', ({\n      messages: newMessages,\n      type\n    }) => {\n      switch (type) {\n        case 'append':\n        case 'notify':\n          for (const msg of newMessages) {\n            const jid = (0, WABinary_1.jidNormalizedUser)(msg.key.remoteJid);\n            const list = assertMessageList(jid);\n            list.upsert(msg, 'append');\n            if (type === 'notify') {\n              if (!chats.get(jid)) {\n                ev.emit('chats.upsert', [{\n                  id: jid,\n                  conversationTimestamp: (0, Utils_1.toNumber)(msg.messageTimestamp),\n                  unreadCount: 1\n                }]);\n              }\n            }\n          }\n          break;\n      }\n    });\n    ev.on('messages.update', updates => {\n      var _a;\n      for (const {\n        update,\n        key\n      } of updates) {\n        const list = assertMessageList((0, WABinary_1.jidNormalizedUser)(key.remoteJid));\n        if (update === null || update === void 0 ? void 0 : update.status) {\n          const listStatus = (_a = list.get(key.id)) === null || _a === void 0 ? void 0 : _a.status;\n          if (listStatus && (update === null || update === void 0 ? void 0 : update.status) <= listStatus) {\n            logger.debug({\n              update,\n              storedStatus: listStatus\n            }, 'status stored newer then update');\n            delete update.status;\n            logger.debug({\n              update\n            }, 'new update object');\n          }\n        }\n        const result = list.updateAssign(key.id, update);\n        if (!result) {\n          logger.debug({\n            update\n          }, 'got update for non-existent message');\n        }\n      }\n    });\n    ev.on('messages.delete', item => {\n      if ('all' in item) {\n        const list = messages[item.jid];\n        list === null || list === void 0 ? void 0 : list.clear();\n      } else {\n        const jid = item.keys[0].remoteJid;\n        const list = messages[jid];\n        if (list) {\n          const idSet = new Set(item.keys.map(k => k.id));\n          list.filter(m => !idSet.has(m.key.id));\n        }\n      }\n    });\n    ev.on('groups.update', updates => {\n      for (const update of updates) {\n        const id = update.id;\n        if (groupMetadata[id]) {\n          Object.assign(groupMetadata[id], update);\n        } else {\n          logger.debug({\n            update\n          }, 'got update for non-existant group metadata');\n        }\n      }\n    });\n    ev.on('group-participants.update', ({\n      id,\n      participants,\n      action\n    }) => {\n      const metadata = groupMetadata[id];\n      if (metadata) {\n        switch (action) {\n          case 'add':\n            metadata.participants.push(...participants.map(id => ({\n              id,\n              isAdmin: false,\n              isSuperAdmin: false\n            })));\n            break;\n          case 'demote':\n          case 'promote':\n            for (const participant of metadata.participants) {\n              if (participants.includes(participant.id)) {\n                participant.isAdmin = action === 'promote';\n              }\n            }\n            break;\n          case 'remove':\n            metadata.participants = metadata.participants.filter(p => !participants.includes(p.id));\n            break;\n        }\n      }\n    });\n    ev.on('message-receipt.update', updates => {\n      for (const {\n        key,\n        receipt\n      } of updates) {\n        const obj = messages[key.remoteJid];\n        const msg = obj === null || obj === void 0 ? void 0 : obj.get(key.id);\n        if (msg) {\n          (0, Utils_1.updateMessageWithReceipt)(msg, receipt);\n        }\n      }\n    });\n    ev.on('messages.reaction', reactions => {\n      for (const {\n        key,\n        reaction\n      } of reactions) {\n        const obj = messages[key.remoteJid];\n        const msg = obj === null || obj === void 0 ? void 0 : obj.get(key.id);\n        if (msg) {\n          (0, Utils_1.updateMessageWithReaction)(msg, reaction);\n        }\n      }\n    });\n  };\n  const toJSON = () => ({\n    chats,\n    contacts,\n    messages,\n    labels,\n    labelAssociations\n  });\n  const fromJSON = json => {\n    chats.upsert(...json.chats);\n    labelAssociations.upsert(...(json.labelAssociations || []));\n    contactsUpsert(Object.values(json.contacts));\n    labelsUpsert(Object.values(json.labels || {}));\n    for (const jid in json.messages) {\n      const list = assertMessageList(jid);\n      for (const msg of json.messages[jid]) {\n        list.upsert(WAProto_1.proto.WebMessageInfo.fromObject(msg), 'append');\n      }\n    }\n  };\n  return {\n    chats,\n    contacts,\n    messages,\n    groupMetadata,\n    state,\n    presences,\n    labels,\n    labelAssociations,\n    bind,\n    /** loads messages from the store, if not found -- uses the legacy connection */\n    loadMessages: async (jid, count, cursor) => {\n      const list = assertMessageList(jid);\n      const mode = !cursor || 'before' in cursor ? 'before' : 'after';\n      const cursorKey = !!cursor ? 'before' in cursor ? cursor.before : cursor.after : undefined;\n      const cursorValue = cursorKey ? list.get(cursorKey.id) : undefined;\n      let messages;\n      if (list && mode === 'before' && (!cursorKey || cursorValue)) {\n        if (cursorValue) {\n          const msgIdx = list.array.findIndex(m => m.key.id === (cursorKey === null || cursorKey === void 0 ? void 0 : cursorKey.id));\n          messages = list.array.slice(0, msgIdx);\n        } else {\n          messages = list.array;\n        }\n        const diff = count - messages.length;\n        if (diff < 0) {\n          messages = messages.slice(-count); // get the last X messages\n        }\n      } else {\n        messages = [];\n      }\n      return messages;\n    },\n    /**\n     * Get all available labels for profile\n     *\n     * Keep in mind that the list is formed from predefined tags and tags\n     * that were \"caught\" during their editing.\n     */\n    getLabels: () => {\n      return labels;\n    },\n    /**\n     * Get labels for chat\n     *\n     * @returns Label IDs\n     **/\n    getChatLabels: chatId => {\n      return labelAssociations.filter(la => la.chatId === chatId).all();\n    },\n    /**\n     * Get labels for message\n     *\n     * @returns Label IDs\n     **/\n    getMessageLabels: messageId => {\n      const associations = labelAssociations.filter(la => la.messageId === messageId).all();\n      return associations.map(({\n        labelId\n      }) => labelId);\n    },\n    loadMessage: async (jid, id) => {\n      var _a;\n      return (_a = messages[jid]) === null || _a === void 0 ? void 0 : _a.get(id);\n    },\n    mostRecentMessage: async jid => {\n      var _a;\n      const message = (_a = messages[jid]) === null || _a === void 0 ? void 0 : _a.array.slice(-1)[0];\n      return message;\n    },\n    fetchImageUrl: async (jid, sock) => {\n      const contact = contacts[jid];\n      if (!contact) {\n        return sock === null || sock === void 0 ? void 0 : sock.profilePictureUrl(jid);\n      }\n      if (typeof contact.imgUrl === 'undefined') {\n        contact.imgUrl = await (sock === null || sock === void 0 ? void 0 : sock.profilePictureUrl(jid));\n      }\n      return contact.imgUrl;\n    },\n    fetchGroupMetadata: async (jid, sock) => {\n      if (!groupMetadata[jid]) {\n        const metadata = await (sock === null || sock === void 0 ? void 0 : sock.groupMetadata(jid));\n        if (metadata) {\n          groupMetadata[jid] = metadata;\n        }\n      }\n      return groupMetadata[jid];\n    },\n    // fetchBroadcastListInfo: async(jid: string, sock: WASocket | undefined) => {\n    // \tif(!groupMetadata[jid]) {\n    // \t\tconst metadata = await sock?.getBroadcastListInfo(jid)\n    // \t\tif(metadata) {\n    // \t\t\tgroupMetadata[jid] = metadata\n    // \t\t}\n    // \t}\n    // \treturn groupMetadata[jid]\n    // },\n    fetchMessageReceipts: async ({\n      remoteJid,\n      id\n    }) => {\n      const list = messages[remoteJid];\n      const msg = list === null || list === void 0 ? void 0 : list.get(id);\n      return msg === null || msg === void 0 ? void 0 : msg.userReceipt;\n    },\n    toJSON,\n    fromJSON,\n    writeToFile: path => {\n      // require fs here so that in case \"fs\" is not available -- the app does not crash\n      const {\n        writeFileSync\n      } = require('fs');\n      writeFileSync(path, JSON.stringify(toJSON()));\n    },\n    readFromFile: path => {\n      // require fs here so that in case \"fs\" is not available -- the app does not crash\n      const {\n        readFileSync,\n        existsSync\n      } = require('fs');\n      if (existsSync(path)) {\n        logger.debug({\n          path\n        }, 'reading from file');\n        const jsonStr = readFileSync(path, {\n          encoding: 'utf-8'\n        });\n        const json = JSON.parse(jsonStr);\n        fromJSON(json);\n      }\n    }\n  };\n};","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","waLabelAssociationKey","waMessageID","waChatKey","WAProto_1","require","Defaults_1","LabelAssociation_1","Utils_1","WABinary_1","make_ordered_dictionary_1","object_repository_1","pin","key","c","pinned","archived","conversationTimestamp","toString","padStart","id","compare","k1","k2","localeCompare","m","la","type","LabelAssociationType","Chat","chatId","labelId","messageId","makeMessagesDictionary","default","config","socket","chatKey","labelAssociationKey","logger","DEFAULT_CONNECTION_CONFIG","child","stream","KeyedDB","chats","messages","contacts","groupMetadata","presences","state","connection","labels","ObjectRepository","labelAssociations","assertMessageList","jid","contactsUpsert","newContacts","oldContacts","Set","keys","contact","delete","assign","labelsUpsert","newLabels","label","upsertById","bind","ev","on","update","newChats","newMessages","isLatest","syncType","proto","HistorySync","HistorySyncType","ON_DEMAND","clear","chatsAdded","insertIfAbsent","length","debug","deletedContacts","size","msg","remoteJid","list","upsert","updates","_a","contactHashes","Promise","all","map","contactId","user","jidDecode","md5","Buffer","from","slice","find","b","imgUrl","profilePictureUrl","undefined","result","chat","unreadCount","deleted","deleteById","count","error","association","console","deletions","item","get","jidNormalizedUser","emit","toNumber","messageTimestamp","status","listStatus","storedStatus","updateAssign","idSet","k","filter","has","participants","action","metadata","push","isAdmin","isSuperAdmin","participant","includes","p","receipt","obj","updateMessageWithReceipt","reactions","reaction","updateMessageWithReaction","toJSON","fromJSON","json","values","WebMessageInfo","fromObject","loadMessages","cursor","mode","cursorKey","before","after","cursorValue","msgIdx","array","findIndex","diff","getLabels","getChatLabels","getMessageLabels","associations","loadMessage","mostRecentMessage","message","fetchImageUrl","sock","fetchGroupMetadata","fetchMessageReceipts","userReceipt","writeToFile","path","writeFileSync","JSON","stringify","readFromFile","readFileSync","existsSync","jsonStr","encoding","parse"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Store/make-in-memory-store.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.waLabelAssociationKey = exports.waMessageID = exports.waChatKey = void 0;\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst LabelAssociation_1 = require(\"../Types/LabelAssociation\");\nconst Utils_1 = require(\"../Utils\");\nconst WABinary_1 = require(\"../WABinary\");\nconst make_ordered_dictionary_1 = __importDefault(require(\"./make-ordered-dictionary\"));\nconst object_repository_1 = require(\"./object-repository\");\nconst waChatKey = (pin) => ({\n    key: (c) => (pin ? (c.pinned ? '1' : '0') : '') + (c.archived ? '0' : '1') + (c.conversationTimestamp ? c.conversationTimestamp.toString(16).padStart(8, '0') : '') + c.id,\n    compare: (k1, k2) => k2.localeCompare(k1)\n});\nexports.waChatKey = waChatKey;\nconst waMessageID = (m) => m.key.id || '';\nexports.waMessageID = waMessageID;\nexports.waLabelAssociationKey = {\n    key: (la) => (la.type === LabelAssociation_1.LabelAssociationType.Chat ? la.chatId + la.labelId : la.chatId + la.messageId + la.labelId),\n    compare: (k1, k2) => k2.localeCompare(k1)\n};\nconst makeMessagesDictionary = () => (0, make_ordered_dictionary_1.default)(exports.waMessageID);\nexports.default = (config) => {\n    const socket = config.socket;\n    const chatKey = config.chatKey || (0, exports.waChatKey)(true);\n    const labelAssociationKey = config.labelAssociationKey || exports.waLabelAssociationKey;\n    const logger = config.logger || Defaults_1.DEFAULT_CONNECTION_CONFIG.logger.child({ stream: 'in-mem-store' });\n    const KeyedDB = require('@adiwajshing/keyed-db').default;\n    const chats = new KeyedDB(chatKey, c => c.id);\n    const messages = {};\n    const contacts = {};\n    const groupMetadata = {};\n    const presences = {};\n    const state = { connection: 'close' };\n    const labels = new object_repository_1.ObjectRepository();\n    const labelAssociations = new KeyedDB(labelAssociationKey, labelAssociationKey.key);\n    const assertMessageList = (jid) => {\n        if (!messages[jid]) {\n            messages[jid] = makeMessagesDictionary();\n        }\n        return messages[jid];\n    };\n    const contactsUpsert = (newContacts) => {\n        const oldContacts = new Set(Object.keys(contacts));\n        for (const contact of newContacts) {\n            oldContacts.delete(contact.id);\n            contacts[contact.id] = Object.assign(contacts[contact.id] || {}, contact);\n        }\n        return oldContacts;\n    };\n    const labelsUpsert = (newLabels) => {\n        for (const label of newLabels) {\n            labels.upsertById(label.id, label);\n        }\n    };\n    /**\n     * binds to a BaileysEventEmitter.\n     * It listens to all events and constructs a state that you can query accurate data from.\n     * Eg. can use the store to fetch chats, contacts, messages etc.\n     * @param ev typically the event emitter from the socket connection\n     */\n    const bind = (ev) => {\n        ev.on('connection.update', update => {\n            Object.assign(state, update);\n        });\n        ev.on('messaging-history.set', ({ chats: newChats, contacts: newContacts, messages: newMessages, isLatest, syncType }) => {\n            if (syncType === WAProto_1.proto.HistorySync.HistorySyncType.ON_DEMAND) {\n                return; // FOR NOW,\n                //TODO: HANDLE\n            }\n            if (isLatest) {\n                chats.clear();\n                for (const id in messages) {\n                    delete messages[id];\n                }\n            }\n            const chatsAdded = chats.insertIfAbsent(...newChats).length;\n            logger.debug({ chatsAdded }, 'synced chats');\n            const oldContacts = contactsUpsert(newContacts);\n            if (isLatest) {\n                for (const jid of oldContacts) {\n                    delete contacts[jid];\n                }\n            }\n            logger.debug({ deletedContacts: isLatest ? oldContacts.size : 0, newContacts }, 'synced contacts');\n            for (const msg of newMessages) {\n                const jid = msg.key.remoteJid;\n                const list = assertMessageList(jid);\n                list.upsert(msg, 'prepend');\n            }\n            logger.debug({ messages: newMessages.length }, 'synced messages');\n        });\n        ev.on('contacts.upsert', contacts => {\n            contactsUpsert(contacts);\n        });\n        ev.on('contacts.update', async (updates) => {\n            var _a;\n            for (const update of updates) {\n                let contact;\n                if (contacts[update.id]) {\n                    contact = contacts[update.id];\n                }\n                else {\n                    const contactHashes = await Promise.all(Object.keys(contacts).map(async (contactId) => {\n                        const { user } = (0, WABinary_1.jidDecode)(contactId);\n                        return [contactId, (await (0, Utils_1.md5)(Buffer.from(user + 'WA_ADD_NOTIF', 'utf8'))).toString('base64').slice(0, 3)];\n                    }));\n                    contact = contacts[((_a = contactHashes.find(([, b]) => b === update.id)) === null || _a === void 0 ? void 0 : _a[0]) || '']; // find contact by attrs.hash, when user is not saved as a contact\n                }\n                if (contact) {\n                    if (update.imgUrl === 'changed') {\n                        contact.imgUrl = socket ? await (socket === null || socket === void 0 ? void 0 : socket.profilePictureUrl(contact.id)) : undefined;\n                    }\n                    else if (update.imgUrl === 'removed') {\n                        delete contact.imgUrl;\n                    }\n                }\n                else {\n                    return logger.debug({ update }, 'got update for non-existant contact');\n                }\n                Object.assign(contacts[contact.id], contact);\n            }\n        });\n        ev.on('chats.upsert', newChats => {\n            chats.upsert(...newChats);\n        });\n        ev.on('chats.update', updates => {\n            for (let update of updates) {\n                const result = chats.update(update.id, chat => {\n                    if (update.unreadCount > 0) {\n                        update = { ...update };\n                        update.unreadCount = (chat.unreadCount || 0) + update.unreadCount;\n                    }\n                    Object.assign(chat, update);\n                });\n                if (!result) {\n                    logger.debug({ update }, 'got update for non-existant chat');\n                }\n            }\n        });\n        ev.on('labels.edit', (label) => {\n            if (label.deleted) {\n                return labels.deleteById(label.id);\n            }\n            // WhatsApp can store only up to 20 labels\n            if (labels.count() < 20) {\n                return labels.upsertById(label.id, label);\n            }\n            logger.error('Labels count exceed');\n        });\n        ev.on('labels.association', ({ type, association }) => {\n            switch (type) {\n                case 'add':\n                    labelAssociations.upsert(association);\n                    break;\n                case 'remove':\n                    labelAssociations.delete(association);\n                    break;\n                default:\n                    console.error(`unknown operation type [${type}]`);\n            }\n        });\n        ev.on('presence.update', ({ id, presences: update }) => {\n            presences[id] = presences[id] || {};\n            Object.assign(presences[id], update);\n        });\n        ev.on('chats.delete', deletions => {\n            for (const item of deletions) {\n                if (chats.get(item)) {\n                    chats.deleteById(item);\n                }\n            }\n        });\n        ev.on('messages.upsert', ({ messages: newMessages, type }) => {\n            switch (type) {\n                case 'append':\n                case 'notify':\n                    for (const msg of newMessages) {\n                        const jid = (0, WABinary_1.jidNormalizedUser)(msg.key.remoteJid);\n                        const list = assertMessageList(jid);\n                        list.upsert(msg, 'append');\n                        if (type === 'notify') {\n                            if (!chats.get(jid)) {\n                                ev.emit('chats.upsert', [\n                                    {\n                                        id: jid,\n                                        conversationTimestamp: (0, Utils_1.toNumber)(msg.messageTimestamp),\n                                        unreadCount: 1\n                                    }\n                                ]);\n                            }\n                        }\n                    }\n                    break;\n            }\n        });\n        ev.on('messages.update', updates => {\n            var _a;\n            for (const { update, key } of updates) {\n                const list = assertMessageList((0, WABinary_1.jidNormalizedUser)(key.remoteJid));\n                if (update === null || update === void 0 ? void 0 : update.status) {\n                    const listStatus = (_a = list.get(key.id)) === null || _a === void 0 ? void 0 : _a.status;\n                    if (listStatus && (update === null || update === void 0 ? void 0 : update.status) <= listStatus) {\n                        logger.debug({ update, storedStatus: listStatus }, 'status stored newer then update');\n                        delete update.status;\n                        logger.debug({ update }, 'new update object');\n                    }\n                }\n                const result = list.updateAssign(key.id, update);\n                if (!result) {\n                    logger.debug({ update }, 'got update for non-existent message');\n                }\n            }\n        });\n        ev.on('messages.delete', item => {\n            if ('all' in item) {\n                const list = messages[item.jid];\n                list === null || list === void 0 ? void 0 : list.clear();\n            }\n            else {\n                const jid = item.keys[0].remoteJid;\n                const list = messages[jid];\n                if (list) {\n                    const idSet = new Set(item.keys.map(k => k.id));\n                    list.filter(m => !idSet.has(m.key.id));\n                }\n            }\n        });\n        ev.on('groups.update', updates => {\n            for (const update of updates) {\n                const id = update.id;\n                if (groupMetadata[id]) {\n                    Object.assign(groupMetadata[id], update);\n                }\n                else {\n                    logger.debug({ update }, 'got update for non-existant group metadata');\n                }\n            }\n        });\n        ev.on('group-participants.update', ({ id, participants, action }) => {\n            const metadata = groupMetadata[id];\n            if (metadata) {\n                switch (action) {\n                    case 'add':\n                        metadata.participants.push(...participants.map(id => ({ id, isAdmin: false, isSuperAdmin: false })));\n                        break;\n                    case 'demote':\n                    case 'promote':\n                        for (const participant of metadata.participants) {\n                            if (participants.includes(participant.id)) {\n                                participant.isAdmin = action === 'promote';\n                            }\n                        }\n                        break;\n                    case 'remove':\n                        metadata.participants = metadata.participants.filter(p => !participants.includes(p.id));\n                        break;\n                }\n            }\n        });\n        ev.on('message-receipt.update', updates => {\n            for (const { key, receipt } of updates) {\n                const obj = messages[key.remoteJid];\n                const msg = obj === null || obj === void 0 ? void 0 : obj.get(key.id);\n                if (msg) {\n                    (0, Utils_1.updateMessageWithReceipt)(msg, receipt);\n                }\n            }\n        });\n        ev.on('messages.reaction', (reactions) => {\n            for (const { key, reaction } of reactions) {\n                const obj = messages[key.remoteJid];\n                const msg = obj === null || obj === void 0 ? void 0 : obj.get(key.id);\n                if (msg) {\n                    (0, Utils_1.updateMessageWithReaction)(msg, reaction);\n                }\n            }\n        });\n    };\n    const toJSON = () => ({\n        chats,\n        contacts,\n        messages,\n        labels,\n        labelAssociations\n    });\n    const fromJSON = (json) => {\n        chats.upsert(...json.chats);\n        labelAssociations.upsert(...json.labelAssociations || []);\n        contactsUpsert(Object.values(json.contacts));\n        labelsUpsert(Object.values(json.labels || {}));\n        for (const jid in json.messages) {\n            const list = assertMessageList(jid);\n            for (const msg of json.messages[jid]) {\n                list.upsert(WAProto_1.proto.WebMessageInfo.fromObject(msg), 'append');\n            }\n        }\n    };\n    return {\n        chats,\n        contacts,\n        messages,\n        groupMetadata,\n        state,\n        presences,\n        labels,\n        labelAssociations,\n        bind,\n        /** loads messages from the store, if not found -- uses the legacy connection */\n        loadMessages: async (jid, count, cursor) => {\n            const list = assertMessageList(jid);\n            const mode = !cursor || 'before' in cursor ? 'before' : 'after';\n            const cursorKey = !!cursor ? ('before' in cursor ? cursor.before : cursor.after) : undefined;\n            const cursorValue = cursorKey ? list.get(cursorKey.id) : undefined;\n            let messages;\n            if (list && mode === 'before' && (!cursorKey || cursorValue)) {\n                if (cursorValue) {\n                    const msgIdx = list.array.findIndex(m => m.key.id === (cursorKey === null || cursorKey === void 0 ? void 0 : cursorKey.id));\n                    messages = list.array.slice(0, msgIdx);\n                }\n                else {\n                    messages = list.array;\n                }\n                const diff = count - messages.length;\n                if (diff < 0) {\n                    messages = messages.slice(-count); // get the last X messages\n                }\n            }\n            else {\n                messages = [];\n            }\n            return messages;\n        },\n        /**\n         * Get all available labels for profile\n         *\n         * Keep in mind that the list is formed from predefined tags and tags\n         * that were \"caught\" during their editing.\n         */\n        getLabels: () => {\n            return labels;\n        },\n        /**\n         * Get labels for chat\n         *\n         * @returns Label IDs\n         **/\n        getChatLabels: (chatId) => {\n            return labelAssociations.filter((la) => la.chatId === chatId).all();\n        },\n        /**\n         * Get labels for message\n         *\n         * @returns Label IDs\n         **/\n        getMessageLabels: (messageId) => {\n            const associations = labelAssociations\n                .filter((la) => la.messageId === messageId)\n                .all();\n            return associations.map(({ labelId }) => labelId);\n        },\n        loadMessage: async (jid, id) => { var _a; return (_a = messages[jid]) === null || _a === void 0 ? void 0 : _a.get(id); },\n        mostRecentMessage: async (jid) => {\n            var _a;\n            const message = (_a = messages[jid]) === null || _a === void 0 ? void 0 : _a.array.slice(-1)[0];\n            return message;\n        },\n        fetchImageUrl: async (jid, sock) => {\n            const contact = contacts[jid];\n            if (!contact) {\n                return sock === null || sock === void 0 ? void 0 : sock.profilePictureUrl(jid);\n            }\n            if (typeof contact.imgUrl === 'undefined') {\n                contact.imgUrl = await (sock === null || sock === void 0 ? void 0 : sock.profilePictureUrl(jid));\n            }\n            return contact.imgUrl;\n        },\n        fetchGroupMetadata: async (jid, sock) => {\n            if (!groupMetadata[jid]) {\n                const metadata = await (sock === null || sock === void 0 ? void 0 : sock.groupMetadata(jid));\n                if (metadata) {\n                    groupMetadata[jid] = metadata;\n                }\n            }\n            return groupMetadata[jid];\n        },\n        // fetchBroadcastListInfo: async(jid: string, sock: WASocket | undefined) => {\n        // \tif(!groupMetadata[jid]) {\n        // \t\tconst metadata = await sock?.getBroadcastListInfo(jid)\n        // \t\tif(metadata) {\n        // \t\t\tgroupMetadata[jid] = metadata\n        // \t\t}\n        // \t}\n        // \treturn groupMetadata[jid]\n        // },\n        fetchMessageReceipts: async ({ remoteJid, id }) => {\n            const list = messages[remoteJid];\n            const msg = list === null || list === void 0 ? void 0 : list.get(id);\n            return msg === null || msg === void 0 ? void 0 : msg.userReceipt;\n        },\n        toJSON,\n        fromJSON,\n        writeToFile: (path) => {\n            // require fs here so that in case \"fs\" is not available -- the app does not crash\n            const { writeFileSync } = require('fs');\n            writeFileSync(path, JSON.stringify(toJSON()));\n        },\n        readFromFile: (path) => {\n            // require fs here so that in case \"fs\" is not available -- the app does not crash\n            const { readFileSync, existsSync } = require('fs');\n            if (existsSync(path)) {\n                logger.debug({ path }, 'reading from file');\n                const jsonStr = readFileSync(path, { encoding: 'utf-8' });\n                const json = JSON.parse(jsonStr);\n                fromJSON(json);\n            }\n        }\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}