{"ast":null,"code":"/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\n/*\nhttps://xiph.org/flac/format.html\n\nAAAAAAAA AAAAAABC DDDDEEEE FFFFGGGH \n(IIIIIIII...)\n(JJJJJJJJ|JJJJJJJJ)\n(KKKKKKKK|KKKKKKKK)\nLLLLLLLLL\n\nFLAC Frame Header\nLetter  Length (bits)  Description\nA   13  11111111|11111\nB   1   Reserved 0 - mandatory, 1 - reserved\nC   1   Blocking strategy, 0 - fixed, 1 - variable\nD   4   Block size in inter-channel samples\nE   4   Sample rate\nF   4   Channel assignment\nG   3   Sample size in bits\nH   1   Reserved 0 - mandatory, 1 - reserved\nI   ?   if(variable blocksize)\n           <8-56>:\"UTF-8\" coded sample number (decoded number is 36 bits) [4]\n        else\n           <8-48>:\"UTF-8\" coded frame number (decoded number is 31 bits) [4]\nJ   ?   if(blocksize bits == 011x)\n            8/16 bit (blocksize-1)\nK   ?   if(sample rate bits == 11xx)\n            8/16 bit sample rate\nL   8   CRC-8 (polynomial = x^8 + x^2 + x^1 + x^0, initialized with 0) of everything before the crc, including the sync code\n        \n*/\n\nimport { reserved, bad, rate88200, rate176400, rate192000, rate8000, rate16000, rate22050, rate24000, rate32000, rate44100, rate48000, rate96000, channelMappings, getChannelMapping, monophonic, stereo, lfe, bitDepth, channelMode, sampleRate, channels, length, crc16, blockingStrategy, blockSize, frameNumber, sampleNumber, streamInfo, description, samples, sampleRateBits, blockingStrategyBits, blockSizeBits, crc, subarray, readRawData, getHeader, setHeader, getHeaderFromUint8Array } from \"../../constants.js\";\nimport { bytesToString, crc8 } from \"../../utilities.js\";\nimport CodecHeader from \"../CodecHeader.js\";\nconst getFromStreamInfo = \"get from STREAMINFO metadata block\";\nconst blockingStrategyValues = {\n  0b00000000: \"Fixed\",\n  0b00000001: \"Variable\"\n};\nconst blockSizeValues = {\n  0b00000000: reserved,\n  0b00010000: 192\n  // 0b00100000: 576,\n  // 0b00110000: 1152,\n  // 0b01000000: 2304,\n  // 0b01010000: 4608,\n  // 0b01100000: \"8-bit (blocksize-1) from end of header\",\n  // 0b01110000: \"16-bit (blocksize-1) from end of header\",\n  // 0b10000000: 256,\n  // 0b10010000: 512,\n  // 0b10100000: 1024,\n  // 0b10110000: 2048,\n  // 0b11000000: 4096,\n  // 0b11010000: 8192,\n  // 0b11100000: 16384,\n  // 0b11110000: 32768,\n};\nfor (let i = 2; i < 16; i++) blockSizeValues[i << 4] = i < 6 ? 576 * 2 ** (i - 2) : 2 ** i;\nconst sampleRateValues = {\n  0b00000000: getFromStreamInfo,\n  0b00000001: rate88200,\n  0b00000010: rate176400,\n  0b00000011: rate192000,\n  0b00000100: rate8000,\n  0b00000101: rate16000,\n  0b00000110: rate22050,\n  0b00000111: rate24000,\n  0b00001000: rate32000,\n  0b00001001: rate44100,\n  0b00001010: rate48000,\n  0b00001011: rate96000,\n  // 0b00001100: \"8-bit sample rate (in kHz) from end of header\",\n  // 0b00001101: \"16-bit sample rate (in Hz) from end of header\",\n  // 0b00001110: \"16-bit sample rate (in tens of Hz) from end of header\",\n  0b00001111: bad\n};\n\n/* prettier-ignore */\nconst channelAssignments = {\n  /*'\n  'monophonic (mono)'\n  'stereo (left, right)'\n  'linear surround (left, right, center)'\n  'quadraphonic (front left, front right, rear left, rear right)'\n  '5.0 surround (front left, front right, front center, rear left, rear right)'\n  '5.1 surround (front left, front right, front center, LFE, rear left, rear right)'\n  '6.1 surround (front left, front right, front center, LFE, rear center, side left, side right)'\n  '7.1 surround (front left, front right, front center, LFE, rear left, rear right, side left, side right)'\n  */\n  0b00000000: {\n    [channels]: 1,\n    [description]: monophonic\n  },\n  0b00010000: {\n    [channels]: 2,\n    [description]: getChannelMapping(2, channelMappings[0][0])\n  },\n  0b00100000: {\n    [channels]: 3,\n    [description]: getChannelMapping(3, channelMappings[0][1])\n  },\n  0b00110000: {\n    [channels]: 4,\n    [description]: getChannelMapping(4, channelMappings[1][0], channelMappings[3][0])\n  },\n  0b01000000: {\n    [channels]: 5,\n    [description]: getChannelMapping(5, channelMappings[1][1], channelMappings[3][0])\n  },\n  0b01010000: {\n    [channels]: 6,\n    [description]: getChannelMapping(6, channelMappings[1][1], lfe, channelMappings[3][0])\n  },\n  0b01100000: {\n    [channels]: 7,\n    [description]: getChannelMapping(7, channelMappings[1][1], lfe, channelMappings[3][4], channelMappings[2][0])\n  },\n  0b01110000: {\n    [channels]: 8,\n    [description]: getChannelMapping(8, channelMappings[1][1], lfe, channelMappings[3][0], channelMappings[2][0])\n  },\n  0b10000000: {\n    [channels]: 2,\n    [description]: `${stereo} (left, diff)`\n  },\n  0b10010000: {\n    [channels]: 2,\n    [description]: `${stereo} (diff, right)`\n  },\n  0b10100000: {\n    [channels]: 2,\n    [description]: `${stereo} (avg, diff)`\n  },\n  0b10110000: reserved,\n  0b11000000: reserved,\n  0b11010000: reserved,\n  0b11100000: reserved,\n  0b11110000: reserved\n};\nconst bitDepthValues = {\n  0b00000000: getFromStreamInfo,\n  0b00000010: 8,\n  0b00000100: 12,\n  0b00000110: reserved,\n  0b00001000: 16,\n  0b00001010: 20,\n  0b00001100: 24,\n  0b00001110: reserved\n};\nexport default class FLACHeader extends CodecHeader {\n  // https://datatracker.ietf.org/doc/html/rfc3629#section-3\n  //    Char. number range  |        UTF-8 octet sequence\n  //    (hexadecimal)    |              (binary)\n  // --------------------+---------------------------------------------\n  // 0000 0000-0000 007F | 0xxxxxxx\n  // 0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n  // 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n  // 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n  static _decodeUTF8Int(data) {\n    if (data[0] > 0xfe) {\n      return null; // length byte must have at least one zero as the lsb\n    }\n    if (data[0] < 0x80) return {\n      value: data[0],\n      length: 1\n    };\n\n    // get length by counting the number of msb that are set to 1\n    let length = 1;\n    for (let zeroMask = 0x40; zeroMask & data[0]; zeroMask >>= 1) length++;\n    let idx = length - 1,\n      value = 0,\n      shift = 0;\n\n    // sum together the encoded bits in bytes 2 to length\n    // 1110xxxx 10[cccccc] 10[bbbbbb] 10[aaaaaa]\n    //\n    //    value = [cccccc] | [bbbbbb] | [aaaaaa]\n    for (; idx > 0; shift += 6, idx--) {\n      if ((data[idx] & 0xc0) !== 0x80) {\n        return null; // each byte should have leading 10xxxxxx\n      }\n      value |= (data[idx] & 0x3f) << shift; // add the encoded bits\n    }\n\n    // read the final encoded bits in byte 1\n    //     1110[dddd] 10[cccccc] 10[bbbbbb] 10[aaaaaa]\n    //\n    // value = [dddd] | [cccccc] | [bbbbbb] | [aaaaaa]\n    value |= (data[idx] & 0x7f >> length) << shift;\n    return {\n      value,\n      length\n    };\n  }\n  static [getHeaderFromUint8Array](data, headerCache) {\n    const codecParserStub = {\n      [readRawData]: function* () {\n        return data;\n      }\n    };\n    return FLACHeader[getHeader](codecParserStub, headerCache, 0).next().value;\n  }\n  static *[getHeader](codecParser, headerCache, readOffset) {\n    // Must be at least 6 bytes.\n    let data = yield* codecParser[readRawData](6, readOffset);\n\n    // Bytes (1-2 of 6)\n    // * `11111111|111110..`: Frame sync\n    // * `........|......0.`: Reserved 0 - mandatory, 1 - reserved\n    if (data[0] !== 0xff || !(data[1] === 0xf8 || data[1] === 0xf9)) {\n      return null;\n    }\n    const header = {};\n\n    // Check header cache\n    const key = bytesToString(data[subarray](0, 4));\n    const cachedHeader = headerCache[getHeader](key);\n    if (!cachedHeader) {\n      // Byte (2 of 6)\n      // * `.......C`: Blocking strategy, 0 - fixed, 1 - variable\n      header[blockingStrategyBits] = data[1] & 0b00000001;\n      header[blockingStrategy] = blockingStrategyValues[header[blockingStrategyBits]];\n\n      // Byte (3 of 6)\n      // * `DDDD....`: Block size in inter-channel samples\n      // * `....EEEE`: Sample rate\n      header[blockSizeBits] = data[2] & 0b11110000;\n      header[sampleRateBits] = data[2] & 0b00001111;\n      header[blockSize] = blockSizeValues[header[blockSizeBits]];\n      if (header[blockSize] === reserved) {\n        return null;\n      }\n      header[sampleRate] = sampleRateValues[header[sampleRateBits]];\n      if (header[sampleRate] === bad) {\n        return null;\n      }\n\n      // Byte (4 of 6)\n      // * `FFFF....`: Channel assignment\n      // * `....GGG.`: Sample size in bits\n      // * `.......H`: Reserved 0 - mandatory, 1 - reserved\n      if (data[3] & 0b00000001) {\n        return null;\n      }\n      const channelAssignment = channelAssignments[data[3] & 0b11110000];\n      if (channelAssignment === reserved) {\n        return null;\n      }\n      header[channels] = channelAssignment[channels];\n      header[channelMode] = channelAssignment[description];\n      header[bitDepth] = bitDepthValues[data[3] & 0b00001110];\n      if (header[bitDepth] === reserved) {\n        return null;\n      }\n    } else {\n      Object.assign(header, cachedHeader);\n    }\n\n    // Byte (5...)\n    // * `IIIIIIII|...`: VBR block size ? sample number : frame number\n    header[length] = 5;\n\n    // check if there is enough data to parse UTF8\n    data = yield* codecParser[readRawData](header[length] + 8, readOffset);\n    const decodedUtf8 = FLACHeader._decodeUTF8Int(data[subarray](4));\n    if (!decodedUtf8) {\n      return null;\n    }\n    if (header[blockingStrategyBits]) {\n      header[sampleNumber] = decodedUtf8.value;\n    } else {\n      header[frameNumber] = decodedUtf8.value;\n    }\n    header[length] += decodedUtf8[length];\n\n    // Byte (...)\n    // * `JJJJJJJJ|(JJJJJJJJ)`: Blocksize (8/16bit custom value)\n    if (header[blockSizeBits] === 0b01100000) {\n      // 8 bit\n      if (data[length] < header[length]) data = yield* codecParser[readRawData](header[length], readOffset);\n      header[blockSize] = data[header[length] - 1] + 1;\n      header[length] += 1;\n    } else if (header[blockSizeBits] === 0b01110000) {\n      // 16 bit\n      if (data[length] < header[length]) data = yield* codecParser[readRawData](header[length], readOffset);\n      header[blockSize] = (data[header[length] - 1] << 8) + data[header[length]] + 1;\n      header[length] += 2;\n    }\n    header[samples] = header[blockSize];\n\n    // Byte (...)\n    // * `KKKKKKKK|(KKKKKKKK)`: Sample rate (8/16bit custom value)\n    if (header[sampleRateBits] === 0b00001100) {\n      // 8 bit\n      if (data[length] < header[length]) data = yield* codecParser[readRawData](header[length], readOffset);\n      header[sampleRate] = data[header[length] - 1] * 1000;\n      header[length] += 1;\n    } else if (header[sampleRateBits] === 0b00001101) {\n      // 16 bit\n      if (data[length] < header[length]) data = yield* codecParser[readRawData](header[length], readOffset);\n      header[sampleRate] = (data[header[length] - 1] << 8) + data[header[length]];\n      header[length] += 2;\n    } else if (header[sampleRateBits] === 0b00001110) {\n      // 16 bit\n      if (data[length] < header[length]) data = yield* codecParser[readRawData](header[length], readOffset);\n      header[sampleRate] = ((data[header[length] - 1] << 8) + data[header[length]]) * 10;\n      header[length] += 2;\n    }\n\n    // Byte (...)\n    // * `LLLLLLLL`: CRC-8\n    if (data[length] < header[length]) data = yield* codecParser[readRawData](header[length], readOffset);\n    header[crc] = data[header[length] - 1];\n    if (header[crc] !== crc8(data[subarray](0, header[length] - 1))) {\n      return null;\n    }\n    {\n      if (!cachedHeader) {\n        const {\n          blockingStrategyBits,\n          frameNumber,\n          sampleNumber,\n          samples,\n          sampleRateBits,\n          blockSizeBits,\n          crc,\n          length,\n          ...codecUpdateFields\n        } = header;\n        headerCache[setHeader](key, header, codecUpdateFields);\n      }\n    }\n    return new FLACHeader(header);\n  }\n\n  /**\n   * @private\n   * Call FLACHeader.getHeader(Array<Uint8>) to get instance\n   */\n  constructor(header) {\n    super(header);\n    this[crc16] = null; // set in FLACFrame\n    this[blockingStrategy] = header[blockingStrategy];\n    this[blockSize] = header[blockSize];\n    this[frameNumber] = header[frameNumber];\n    this[sampleNumber] = header[sampleNumber];\n    this[streamInfo] = null; // set during ogg parsing\n  }\n}","map":{"version":3,"names":["reserved","bad","rate88200","rate176400","rate192000","rate8000","rate16000","rate22050","rate24000","rate32000","rate44100","rate48000","rate96000","channelMappings","getChannelMapping","monophonic","stereo","lfe","bitDepth","channelMode","sampleRate","channels","length","crc16","blockingStrategy","blockSize","frameNumber","sampleNumber","streamInfo","description","samples","sampleRateBits","blockingStrategyBits","blockSizeBits","crc","subarray","readRawData","getHeader","setHeader","getHeaderFromUint8Array","bytesToString","crc8","CodecHeader","getFromStreamInfo","blockingStrategyValues","blockSizeValues","i","sampleRateValues","channelAssignments","bitDepthValues","FLACHeader","_decodeUTF8Int","data","value","zeroMask","idx","shift","headerCache","codecParserStub","next","codecParser","readOffset","header","key","cachedHeader","channelAssignment","Object","assign","decodedUtf8","codecUpdateFields","constructor"],"sources":["C:/Users/vanitas/node_modules/codec-parser/src/codecs/flac/FLACHeader.js"],"sourcesContent":["/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\n/*\nhttps://xiph.org/flac/format.html\n\nAAAAAAAA AAAAAABC DDDDEEEE FFFFGGGH \n(IIIIIIII...)\n(JJJJJJJJ|JJJJJJJJ)\n(KKKKKKKK|KKKKKKKK)\nLLLLLLLLL\n\nFLAC Frame Header\nLetter  Length (bits)  Description\nA   13  11111111|11111\nB   1   Reserved 0 - mandatory, 1 - reserved\nC   1   Blocking strategy, 0 - fixed, 1 - variable\nD   4   Block size in inter-channel samples\nE   4   Sample rate\nF   4   Channel assignment\nG   3   Sample size in bits\nH   1   Reserved 0 - mandatory, 1 - reserved\nI   ?   if(variable blocksize)\n           <8-56>:\"UTF-8\" coded sample number (decoded number is 36 bits) [4]\n        else\n           <8-48>:\"UTF-8\" coded frame number (decoded number is 31 bits) [4]\nJ   ?   if(blocksize bits == 011x)\n            8/16 bit (blocksize-1)\nK   ?   if(sample rate bits == 11xx)\n            8/16 bit sample rate\nL   8   CRC-8 (polynomial = x^8 + x^2 + x^1 + x^0, initialized with 0) of everything before the crc, including the sync code\n        \n*/\n\nimport {\n  reserved,\n  bad,\n  rate88200,\n  rate176400,\n  rate192000,\n  rate8000,\n  rate16000,\n  rate22050,\n  rate24000,\n  rate32000,\n  rate44100,\n  rate48000,\n  rate96000,\n  channelMappings,\n  getChannelMapping,\n  monophonic,\n  stereo,\n  lfe,\n  bitDepth,\n  channelMode,\n  sampleRate,\n  channels,\n  length,\n  crc16,\n  blockingStrategy,\n  blockSize,\n  frameNumber,\n  sampleNumber,\n  streamInfo,\n  description,\n  samples,\n  sampleRateBits,\n  blockingStrategyBits,\n  blockSizeBits,\n  crc,\n  subarray,\n  readRawData,\n  getHeader,\n  setHeader,\n  getHeaderFromUint8Array,\n} from \"../../constants.js\";\nimport { bytesToString, crc8 } from \"../../utilities.js\";\nimport CodecHeader from \"../CodecHeader.js\";\n\nconst getFromStreamInfo = \"get from STREAMINFO metadata block\";\n\nconst blockingStrategyValues = {\n  0b00000000: \"Fixed\",\n  0b00000001: \"Variable\",\n};\n\nconst blockSizeValues = {\n  0b00000000: reserved,\n  0b00010000: 192,\n  // 0b00100000: 576,\n  // 0b00110000: 1152,\n  // 0b01000000: 2304,\n  // 0b01010000: 4608,\n  // 0b01100000: \"8-bit (blocksize-1) from end of header\",\n  // 0b01110000: \"16-bit (blocksize-1) from end of header\",\n  // 0b10000000: 256,\n  // 0b10010000: 512,\n  // 0b10100000: 1024,\n  // 0b10110000: 2048,\n  // 0b11000000: 4096,\n  // 0b11010000: 8192,\n  // 0b11100000: 16384,\n  // 0b11110000: 32768,\n};\nfor (let i = 2; i < 16; i++)\n  blockSizeValues[i << 4] = i < 6 ? 576 * 2 ** (i - 2) : 2 ** i;\n\nconst sampleRateValues = {\n  0b00000000: getFromStreamInfo,\n  0b00000001: rate88200,\n  0b00000010: rate176400,\n  0b00000011: rate192000,\n  0b00000100: rate8000,\n  0b00000101: rate16000,\n  0b00000110: rate22050,\n  0b00000111: rate24000,\n  0b00001000: rate32000,\n  0b00001001: rate44100,\n  0b00001010: rate48000,\n  0b00001011: rate96000,\n  // 0b00001100: \"8-bit sample rate (in kHz) from end of header\",\n  // 0b00001101: \"16-bit sample rate (in Hz) from end of header\",\n  // 0b00001110: \"16-bit sample rate (in tens of Hz) from end of header\",\n  0b00001111: bad,\n};\n\n/* prettier-ignore */\nconst channelAssignments = {\n  /*'\n  'monophonic (mono)'\n  'stereo (left, right)'\n  'linear surround (left, right, center)'\n  'quadraphonic (front left, front right, rear left, rear right)'\n  '5.0 surround (front left, front right, front center, rear left, rear right)'\n  '5.1 surround (front left, front right, front center, LFE, rear left, rear right)'\n  '6.1 surround (front left, front right, front center, LFE, rear center, side left, side right)'\n  '7.1 surround (front left, front right, front center, LFE, rear left, rear right, side left, side right)'\n  */\n  0b00000000: {[channels]: 1, [description]: monophonic},\n  0b00010000: {[channels]: 2, [description]: getChannelMapping(2,channelMappings[0][0])},\n  0b00100000: {[channels]: 3, [description]: getChannelMapping(3,channelMappings[0][1])},\n  0b00110000: {[channels]: 4, [description]: getChannelMapping(4,channelMappings[1][0],channelMappings[3][0])},\n  0b01000000: {[channels]: 5, [description]: getChannelMapping(5,channelMappings[1][1],channelMappings[3][0])},\n  0b01010000: {[channels]: 6, [description]: getChannelMapping(6,channelMappings[1][1],lfe,channelMappings[3][0])},\n  0b01100000: {[channels]: 7, [description]: getChannelMapping(7,channelMappings[1][1],lfe,channelMappings[3][4],channelMappings[2][0])},\n  0b01110000: {[channels]: 8, [description]: getChannelMapping(8,channelMappings[1][1],lfe,channelMappings[3][0],channelMappings[2][0])},\n  0b10000000: {[channels]: 2, [description]: `${stereo} (left, diff)`},\n  0b10010000: {[channels]: 2, [description]: `${stereo} (diff, right)`},\n  0b10100000: {[channels]: 2, [description]: `${stereo} (avg, diff)`},\n  0b10110000: reserved,\n  0b11000000: reserved,\n  0b11010000: reserved,\n  0b11100000: reserved,\n  0b11110000: reserved,\n}\n\nconst bitDepthValues = {\n  0b00000000: getFromStreamInfo,\n  0b00000010: 8,\n  0b00000100: 12,\n  0b00000110: reserved,\n  0b00001000: 16,\n  0b00001010: 20,\n  0b00001100: 24,\n  0b00001110: reserved,\n};\n\nexport default class FLACHeader extends CodecHeader {\n  // https://datatracker.ietf.org/doc/html/rfc3629#section-3\n  //    Char. number range  |        UTF-8 octet sequence\n  //    (hexadecimal)    |              (binary)\n  // --------------------+---------------------------------------------\n  // 0000 0000-0000 007F | 0xxxxxxx\n  // 0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n  // 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n  // 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n  static _decodeUTF8Int(data) {\n    if (data[0] > 0xfe) {\n      return null; // length byte must have at least one zero as the lsb\n    }\n\n    if (data[0] < 0x80) return { value: data[0], length: 1 };\n\n    // get length by counting the number of msb that are set to 1\n    let length = 1;\n    for (let zeroMask = 0x40; zeroMask & data[0]; zeroMask >>= 1) length++;\n\n    let idx = length - 1,\n      value = 0,\n      shift = 0;\n\n    // sum together the encoded bits in bytes 2 to length\n    // 1110xxxx 10[cccccc] 10[bbbbbb] 10[aaaaaa]\n    //\n    //    value = [cccccc] | [bbbbbb] | [aaaaaa]\n    for (; idx > 0; shift += 6, idx--) {\n      if ((data[idx] & 0xc0) !== 0x80) {\n        return null; // each byte should have leading 10xxxxxx\n      }\n      value |= (data[idx] & 0x3f) << shift; // add the encoded bits\n    }\n\n    // read the final encoded bits in byte 1\n    //     1110[dddd] 10[cccccc] 10[bbbbbb] 10[aaaaaa]\n    //\n    // value = [dddd] | [cccccc] | [bbbbbb] | [aaaaaa]\n    value |= (data[idx] & (0x7f >> length)) << shift;\n\n    return { value, length };\n  }\n\n  static [getHeaderFromUint8Array](data, headerCache) {\n    const codecParserStub = {\n      [readRawData]: function* () {\n        return data;\n      },\n    };\n\n    return FLACHeader[getHeader](codecParserStub, headerCache, 0).next().value;\n  }\n\n  static *[getHeader](codecParser, headerCache, readOffset) {\n    // Must be at least 6 bytes.\n    let data = yield* codecParser[readRawData](6, readOffset);\n\n    // Bytes (1-2 of 6)\n    // * `11111111|111110..`: Frame sync\n    // * `........|......0.`: Reserved 0 - mandatory, 1 - reserved\n    if (data[0] !== 0xff || !(data[1] === 0xf8 || data[1] === 0xf9)) {\n      return null;\n    }\n\n    const header = {};\n\n    // Check header cache\n    const key = bytesToString(data[subarray](0, 4));\n    const cachedHeader = headerCache[getHeader](key);\n\n    if (!cachedHeader) {\n      // Byte (2 of 6)\n      // * `.......C`: Blocking strategy, 0 - fixed, 1 - variable\n      header[blockingStrategyBits] = data[1] & 0b00000001;\n      header[blockingStrategy] =\n        blockingStrategyValues[header[blockingStrategyBits]];\n\n      // Byte (3 of 6)\n      // * `DDDD....`: Block size in inter-channel samples\n      // * `....EEEE`: Sample rate\n      header[blockSizeBits] = data[2] & 0b11110000;\n      header[sampleRateBits] = data[2] & 0b00001111;\n\n      header[blockSize] = blockSizeValues[header[blockSizeBits]];\n      if (header[blockSize] === reserved) {\n        return null;\n      }\n\n      header[sampleRate] = sampleRateValues[header[sampleRateBits]];\n      if (header[sampleRate] === bad) {\n        return null;\n      }\n\n      // Byte (4 of 6)\n      // * `FFFF....`: Channel assignment\n      // * `....GGG.`: Sample size in bits\n      // * `.......H`: Reserved 0 - mandatory, 1 - reserved\n      if (data[3] & 0b00000001) {\n        return null;\n      }\n\n      const channelAssignment = channelAssignments[data[3] & 0b11110000];\n      if (channelAssignment === reserved) {\n        return null;\n      }\n\n      header[channels] = channelAssignment[channels];\n      header[channelMode] = channelAssignment[description];\n\n      header[bitDepth] = bitDepthValues[data[3] & 0b00001110];\n      if (header[bitDepth] === reserved) {\n        return null;\n      }\n    } else {\n      Object.assign(header, cachedHeader);\n    }\n\n    // Byte (5...)\n    // * `IIIIIIII|...`: VBR block size ? sample number : frame number\n    header[length] = 5;\n\n    // check if there is enough data to parse UTF8\n    data = yield* codecParser[readRawData](header[length] + 8, readOffset);\n\n    const decodedUtf8 = FLACHeader._decodeUTF8Int(data[subarray](4));\n    if (!decodedUtf8) {\n      return null;\n    }\n\n    if (header[blockingStrategyBits]) {\n      header[sampleNumber] = decodedUtf8.value;\n    } else {\n      header[frameNumber] = decodedUtf8.value;\n    }\n\n    header[length] += decodedUtf8[length];\n\n    // Byte (...)\n    // * `JJJJJJJJ|(JJJJJJJJ)`: Blocksize (8/16bit custom value)\n    if (header[blockSizeBits] === 0b01100000) {\n      // 8 bit\n      if (data[length] < header[length])\n        data = yield* codecParser[readRawData](header[length], readOffset);\n\n      header[blockSize] = data[header[length] - 1] + 1;\n      header[length] += 1;\n    } else if (header[blockSizeBits] === 0b01110000) {\n      // 16 bit\n      if (data[length] < header[length])\n        data = yield* codecParser[readRawData](header[length], readOffset);\n\n      header[blockSize] =\n        (data[header[length] - 1] << 8) + data[header[length]] + 1;\n      header[length] += 2;\n    }\n\n    header[samples] = header[blockSize];\n\n    // Byte (...)\n    // * `KKKKKKKK|(KKKKKKKK)`: Sample rate (8/16bit custom value)\n    if (header[sampleRateBits] === 0b00001100) {\n      // 8 bit\n      if (data[length] < header[length])\n        data = yield* codecParser[readRawData](header[length], readOffset);\n\n      header[sampleRate] = data[header[length] - 1] * 1000;\n      header[length] += 1;\n    } else if (header[sampleRateBits] === 0b00001101) {\n      // 16 bit\n      if (data[length] < header[length])\n        data = yield* codecParser[readRawData](header[length], readOffset);\n\n      header[sampleRate] =\n        (data[header[length] - 1] << 8) + data[header[length]];\n      header[length] += 2;\n    } else if (header[sampleRateBits] === 0b00001110) {\n      // 16 bit\n      if (data[length] < header[length])\n        data = yield* codecParser[readRawData](header[length], readOffset);\n\n      header[sampleRate] =\n        ((data[header[length] - 1] << 8) + data[header[length]]) * 10;\n      header[length] += 2;\n    }\n\n    // Byte (...)\n    // * `LLLLLLLL`: CRC-8\n    if (data[length] < header[length])\n      data = yield* codecParser[readRawData](header[length], readOffset);\n\n    header[crc] = data[header[length] - 1];\n    if (header[crc] !== crc8(data[subarray](0, header[length] - 1))) {\n      return null;\n    }\n\n    {\n      if (!cachedHeader) {\n        const {\n          blockingStrategyBits,\n          frameNumber,\n          sampleNumber,\n          samples,\n          sampleRateBits,\n          blockSizeBits,\n          crc,\n          length,\n          ...codecUpdateFields\n        } = header;\n        headerCache[setHeader](key, header, codecUpdateFields);\n      }\n    }\n    return new FLACHeader(header);\n  }\n\n  /**\n   * @private\n   * Call FLACHeader.getHeader(Array<Uint8>) to get instance\n   */\n  constructor(header) {\n    super(header);\n\n    this[crc16] = null; // set in FLACFrame\n    this[blockingStrategy] = header[blockingStrategy];\n    this[blockSize] = header[blockSize];\n    this[frameNumber] = header[frameNumber];\n    this[sampleNumber] = header[sampleNumber];\n    this[streamInfo] = null; // set during ogg parsing\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}