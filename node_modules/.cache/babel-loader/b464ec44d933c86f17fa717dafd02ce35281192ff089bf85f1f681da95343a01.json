{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WaveParser = void 0;\nconst strtok3 = require(\"strtok3/lib/core\");\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst riff = require(\"../riff/RiffChunk\");\nconst WaveChunk = require(\"./../wav/WaveChunk\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst util = require(\"../common/Util\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst BwfChunk_1 = require(\"../wav/BwfChunk\");\nconst debug = (0, debug_1.default)('music-metadata:parser:RIFF');\n/**\n * Resource Interchange File Format (RIFF) Parser\n *\n * WAVE PCM soundfile format\n *\n * Ref:\n * - http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\n * - http://soundfile.sapp.org/doc/WaveFormat\n *\n * ToDo: Split WAVE part from RIFF parser\n */\nclass WaveParser extends BasicParser_1.BasicParser {\n  async parse() {\n    const riffHeader = await this.tokenizer.readToken(riff.Header);\n    debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\n    if (riffHeader.chunkID !== 'RIFF') return; // Not RIFF format\n    return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\n      if (!(err instanceof strtok3.EndOfStreamError)) {\n        throw err;\n      }\n    });\n  }\n  async parseRiffChunk(chunkSize) {\n    const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n    this.metadata.setFormat('container', type);\n    switch (type) {\n      case 'WAVE':\n        return this.readWaveChunk(chunkSize - FourCC_1.FourCcToken.len);\n      default:\n        throw new Error(`Unsupported RIFF format: RIFF/${type}`);\n    }\n  }\n  async readWaveChunk(remaining) {\n    while (remaining >= riff.Header.len) {\n      const header = await this.tokenizer.readToken(riff.Header);\n      remaining -= riff.Header.len + header.chunkSize;\n      if (header.chunkSize > remaining) {\n        this.metadata.addWarning('Data chunk size exceeds file size');\n      }\n      this.header = header;\n      debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\n      switch (header.chunkID) {\n        case 'LIST':\n          await this.parseListTag(header);\n          break;\n        case 'fact':\n          // extended Format chunk,\n          this.metadata.setFormat('lossless', false);\n          this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\n          break;\n        case 'fmt ':\n          // The Util Chunk, non-PCM Formats\n          const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\n          let subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];\n          if (!subFormat) {\n            debug('WAVE/non-PCM format=' + fmt.wFormatTag);\n            subFormat = 'non-PCM (' + fmt.wFormatTag + ')';\n          }\n          this.metadata.setFormat('codec', subFormat);\n          this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\n          this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\n          this.metadata.setFormat('numberOfChannels', fmt.nChannels);\n          this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\n          this.blockAlign = fmt.nBlockAlign;\n          break;\n        case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\n        case 'ID3 ':\n          // The way Mp3Tags stores ID3 meta-data\n          const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\n          const rst = strtok3.fromBuffer(id3_data);\n          await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n          break;\n        case 'data':\n          // PCM-data\n          if (this.metadata.format.lossless !== false) {\n            this.metadata.setFormat('lossless', true);\n          }\n          let chunkSize = header.chunkSize;\n          if (this.tokenizer.fileInfo.size) {\n            const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;\n            if (calcRemaining < chunkSize) {\n              this.metadata.addWarning('data chunk length exceeding file length');\n              chunkSize = calcRemaining;\n            }\n          }\n          const numberOfSamples = this.fact ? this.fact.dwSampleLength : chunkSize === 0xffffffff ? undefined : chunkSize / this.blockAlign;\n          if (numberOfSamples) {\n            this.metadata.setFormat('numberOfSamples', numberOfSamples);\n            this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\n          }\n          if (this.metadata.format.codec === 'ADPCM') {\n            // ADPCM is 4 bits lossy encoding resulting in 352kbps\n            this.metadata.setFormat('bitrate', 352000);\n          } else {\n            this.metadata.setFormat('bitrate', this.blockAlign * this.metadata.format.sampleRate * 8);\n          }\n          await this.tokenizer.ignore(header.chunkSize);\n          break;\n        case 'bext':\n          // Broadcast Audio Extension chunk\thttps://tech.ebu.ch/docs/tech/tech3285.pdf\n          const bext = await this.tokenizer.readToken(BwfChunk_1.BroadcastAudioExtensionChunk);\n          Object.keys(bext).forEach(key => {\n            this.metadata.addTag('exif', 'bext.' + key, bext[key]);\n          });\n          const bextRemaining = header.chunkSize - BwfChunk_1.BroadcastAudioExtensionChunk.len;\n          await this.tokenizer.ignore(bextRemaining);\n          break;\n        case '\\x00\\x00\\x00\\x00':\n          // padding ??\n          debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n          this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);\n          await this.tokenizer.ignore(header.chunkSize);\n          break;\n        default:\n          debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n          this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);\n          await this.tokenizer.ignore(header.chunkSize);\n      }\n      if (this.header.chunkSize % 2 === 1) {\n        debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\n        await this.tokenizer.ignore(1);\n      }\n    }\n  }\n  async parseListTag(listHeader) {\n    const listType = await this.tokenizer.readToken(new Token.StringType(4, 'binary'));\n    debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\n    switch (listType) {\n      case 'INFO':\n        return this.parseRiffInfoTags(listHeader.chunkSize - 4);\n      case 'adtl':\n      default:\n        this.metadata.addWarning('Ignore chunk: RIFF/WAVE/LIST/' + listType);\n        debug('Ignoring chunkID=RIFF/WAVE/LIST/' + listType);\n        return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\n    }\n  }\n  async parseRiffInfoTags(chunkSize) {\n    while (chunkSize >= 8) {\n      const header = await this.tokenizer.readToken(riff.Header);\n      const valueToken = new riff.ListInfoTagValue(header);\n      const value = await this.tokenizer.readToken(valueToken);\n      this.addTag(header.chunkID, util.stripNulls(value));\n      chunkSize -= 8 + valueToken.len;\n    }\n    if (chunkSize !== 0) {\n      throw Error('Illegal remaining size: ' + chunkSize);\n    }\n  }\n  addTag(id, value) {\n    this.metadata.addTag('exif', id, value);\n  }\n}\nexports.WaveParser = WaveParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","WaveParser","strtok3","require","Token","debug_1","riff","WaveChunk","ID3v2Parser_1","util","FourCC_1","BasicParser_1","BwfChunk_1","debug","default","BasicParser","parse","riffHeader","tokenizer","readToken","Header","position","chunkID","parseRiffChunk","chunkSize","catch","err","EndOfStreamError","type","FourCcToken","metadata","setFormat","readWaveChunk","len","Error","remaining","header","addWarning","parseListTag","fact","FactChunk","fmt","Format","subFormat","WaveFormat","wFormatTag","wBitsPerSample","nSamplesPerSec","nChannels","nBlockAlign","blockAlign","id3_data","Uint8ArrayType","rst","fromBuffer","ID3v2Parser","options","format","lossless","fileInfo","size","calcRemaining","numberOfSamples","dwSampleLength","undefined","sampleRate","codec","ignore","bext","BroadcastAudioExtensionChunk","keys","forEach","key","addTag","bextRemaining","listHeader","listType","StringType","parseRiffInfoTags","then","valueToken","ListInfoTagValue","stripNulls","id"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/wav/WaveParser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WaveParser = void 0;\nconst strtok3 = require(\"strtok3/lib/core\");\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst riff = require(\"../riff/RiffChunk\");\nconst WaveChunk = require(\"./../wav/WaveChunk\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst util = require(\"../common/Util\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst BwfChunk_1 = require(\"../wav/BwfChunk\");\nconst debug = (0, debug_1.default)('music-metadata:parser:RIFF');\n/**\n * Resource Interchange File Format (RIFF) Parser\n *\n * WAVE PCM soundfile format\n *\n * Ref:\n * - http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\n * - http://soundfile.sapp.org/doc/WaveFormat\n *\n * ToDo: Split WAVE part from RIFF parser\n */\nclass WaveParser extends BasicParser_1.BasicParser {\n    async parse() {\n        const riffHeader = await this.tokenizer.readToken(riff.Header);\n        debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\n        if (riffHeader.chunkID !== 'RIFF')\n            return; // Not RIFF format\n        return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\n            if (!(err instanceof strtok3.EndOfStreamError)) {\n                throw err;\n            }\n        });\n    }\n    async parseRiffChunk(chunkSize) {\n        const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        this.metadata.setFormat('container', type);\n        switch (type) {\n            case 'WAVE':\n                return this.readWaveChunk(chunkSize - FourCC_1.FourCcToken.len);\n            default:\n                throw new Error(`Unsupported RIFF format: RIFF/${type}`);\n        }\n    }\n    async readWaveChunk(remaining) {\n        while (remaining >= riff.Header.len) {\n            const header = await this.tokenizer.readToken(riff.Header);\n            remaining -= riff.Header.len + header.chunkSize;\n            if (header.chunkSize > remaining) {\n                this.metadata.addWarning('Data chunk size exceeds file size');\n            }\n            this.header = header;\n            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\n            switch (header.chunkID) {\n                case 'LIST':\n                    await this.parseListTag(header);\n                    break;\n                case 'fact': // extended Format chunk,\n                    this.metadata.setFormat('lossless', false);\n                    this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\n                    break;\n                case 'fmt ': // The Util Chunk, non-PCM Formats\n                    const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\n                    let subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];\n                    if (!subFormat) {\n                        debug('WAVE/non-PCM format=' + fmt.wFormatTag);\n                        subFormat = 'non-PCM (' + fmt.wFormatTag + ')';\n                    }\n                    this.metadata.setFormat('codec', subFormat);\n                    this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\n                    this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\n                    this.metadata.setFormat('numberOfChannels', fmt.nChannels);\n                    this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\n                    this.blockAlign = fmt.nBlockAlign;\n                    break;\n                case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\n                case 'ID3 ': // The way Mp3Tags stores ID3 meta-data\n                    const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\n                    const rst = strtok3.fromBuffer(id3_data);\n                    await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n                    break;\n                case 'data': // PCM-data\n                    if (this.metadata.format.lossless !== false) {\n                        this.metadata.setFormat('lossless', true);\n                    }\n                    let chunkSize = header.chunkSize;\n                    if (this.tokenizer.fileInfo.size) {\n                        const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;\n                        if (calcRemaining < chunkSize) {\n                            this.metadata.addWarning('data chunk length exceeding file length');\n                            chunkSize = calcRemaining;\n                        }\n                    }\n                    const numberOfSamples = this.fact ? this.fact.dwSampleLength : (chunkSize === 0xffffffff ? undefined : chunkSize / this.blockAlign);\n                    if (numberOfSamples) {\n                        this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                        this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\n                    }\n                    if (this.metadata.format.codec === 'ADPCM') { // ADPCM is 4 bits lossy encoding resulting in 352kbps\n                        this.metadata.setFormat('bitrate', 352000);\n                    }\n                    else {\n                        this.metadata.setFormat('bitrate', this.blockAlign * this.metadata.format.sampleRate * 8);\n                    }\n                    await this.tokenizer.ignore(header.chunkSize);\n                    break;\n                case 'bext': // Broadcast Audio Extension chunk\thttps://tech.ebu.ch/docs/tech/tech3285.pdf\n                    const bext = await this.tokenizer.readToken(BwfChunk_1.BroadcastAudioExtensionChunk);\n                    Object.keys(bext).forEach(key => {\n                        this.metadata.addTag('exif', 'bext.' + key, bext[key]);\n                    });\n                    const bextRemaining = header.chunkSize - BwfChunk_1.BroadcastAudioExtensionChunk.len;\n                    await this.tokenizer.ignore(bextRemaining);\n                    break;\n                case '\\x00\\x00\\x00\\x00': // padding ??\n                    debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n                    this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);\n                    await this.tokenizer.ignore(header.chunkSize);\n                    break;\n                default:\n                    debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n                    this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);\n                    await this.tokenizer.ignore(header.chunkSize);\n            }\n            if (this.header.chunkSize % 2 === 1) {\n                debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\n                await this.tokenizer.ignore(1);\n            }\n        }\n    }\n    async parseListTag(listHeader) {\n        const listType = await this.tokenizer.readToken(new Token.StringType(4, 'binary'));\n        debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\n        switch (listType) {\n            case 'INFO':\n                return this.parseRiffInfoTags(listHeader.chunkSize - 4);\n            case 'adtl':\n            default:\n                this.metadata.addWarning('Ignore chunk: RIFF/WAVE/LIST/' + listType);\n                debug('Ignoring chunkID=RIFF/WAVE/LIST/' + listType);\n                return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\n        }\n    }\n    async parseRiffInfoTags(chunkSize) {\n        while (chunkSize >= 8) {\n            const header = await this.tokenizer.readToken(riff.Header);\n            const valueToken = new riff.ListInfoTagValue(header);\n            const value = await this.tokenizer.readToken(valueToken);\n            this.addTag(header.chunkID, util.stripNulls(value));\n            chunkSize -= (8 + valueToken.len);\n        }\n        if (chunkSize !== 0) {\n            throw Error('Illegal remaining size: ' + chunkSize);\n        }\n    }\n    addTag(id, value) {\n        this.metadata.addTag('exif', id, value);\n    }\n}\nexports.WaveParser = WaveParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}