{"ast":null,"code":"/**\n * AudioBuffer class\n */\nexport default class AudioBuffer {\n  /**\n   * Create AudioBuffer instance.\n   * @constructor\n   * @param {Object} options - buffer init options.\n   * @param {number} options.length - buffer length in samples.\n   * @param {number} options.sampleRate - buffer sample rate.\n   * @param {number} options.numberOfChannels - number of channels.\n   */\n  constructor(options) {\n    if (!options) throw TypeError('options argument is required');\n    if (!options.sampleRate) throw TypeError('options.sampleRate is required');\n    if (options.sampleRate < 3000 || options.sampleRate > 768000) throw TypeError('options.sampleRate must be within 3000..768000');\n    if (!options.length) throw TypeError('options.length must be more than 0');\n    this.sampleRate = options.sampleRate;\n    this.numberOfChannels = options.numberOfChannels || 1;\n    this.length = options.length | 0;\n    this.duration = this.length / this.sampleRate;\n\n    //data is stored as a planar sequence\n    this._data = new Float32Array(this.length * this.numberOfChannels);\n\n    //channels data is cached as subarrays\n    this._channelData = [];\n    for (let c = 0; c < this.numberOfChannels; c++) {\n      this._channelData.push(this._data.subarray(c * this.length, (c + 1) * this.length));\n    }\n  }\n\n  /**\n   * Return data associated with the channel.\n   * @param {number} channel - Channel index, starting from 0.\n   * @return {Float32Array} Array containing the data.\n   */\n  getChannelData(channel) {\n    if (channel >= this.numberOfChannels || channel < 0 || channel == null) throw Error('Cannot getChannelData: channel number (' + channel + ') exceeds number of channels (' + this.numberOfChannels + ')');\n    return this._channelData[channel];\n  }\n\n  /**\n   * Place data to the destination buffer, starting from the position.\n   * @param {Float32Array} destination - Destination array to write data to.\n   * @param {number} channelNumber - Channel to take data from.\n   * @param {number} startInChannel - Data offset in channel to read from.\n   */\n  copyFromChannel(destination, channelNumber, startInChannel) {\n    if (startInChannel == null) startInChannel = 0;\n    var data = this._channelData[channelNumber];\n    for (var i = startInChannel, j = 0; i < this.length && j < destination.length; i++, j++) {\n      destination[j] = data[i];\n    }\n  }\n\n  /**\n   * Place data from the source to the channel, starting (in self) from the position.\n   * @param {Float32Array | Array} source - source array to read data from.\n   * @param {number} channelNumber - channel index to copy data to.\n   * @param {number} startInChannel - offset in channel to copy data to.\n   */\n  copyToChannel(source, channelNumber, startInChannel) {\n    var data = this._channelData[channelNumber];\n    if (!startInChannel) startInChannel = 0;\n    for (var i = startInChannel, j = 0; i < this.length && j < source.length; i++, j++) {\n      data[i] = source[j];\n    }\n  }\n}","map":{"version":3,"names":["AudioBuffer","constructor","options","TypeError","sampleRate","length","numberOfChannels","duration","_data","Float32Array","_channelData","c","push","subarray","getChannelData","channel","Error","copyFromChannel","destination","channelNumber","startInChannel","data","i","j","copyToChannel","source"],"sources":["C:/Users/vanitas/node_modules/audio-buffer/index.js"],"sourcesContent":["/**\n * AudioBuffer class\n */\nexport default class AudioBuffer {\n\t/**\n\t * Create AudioBuffer instance.\n\t * @constructor\n\t * @param {Object} options - buffer init options.\n\t * @param {number} options.length - buffer length in samples.\n\t * @param {number} options.sampleRate - buffer sample rate.\n\t * @param {number} options.numberOfChannels - number of channels.\n\t */\n\tconstructor(options) {\n\t\tif (!options) throw TypeError('options argument is required')\n\t\tif (!options.sampleRate) throw TypeError('options.sampleRate is required')\n\t\tif (options.sampleRate < 3000 || options.sampleRate > 768000) throw TypeError('options.sampleRate must be within 3000..768000')\n\t\tif (!options.length) throw TypeError('options.length must be more than 0')\n\n\t\tthis.sampleRate = options.sampleRate\n\t\tthis.numberOfChannels = options.numberOfChannels || 1\n\t\tthis.length = options.length | 0\n\t\tthis.duration = this.length / this.sampleRate\n\n\t\t//data is stored as a planar sequence\n\t\tthis._data = new Float32Array(this.length * this.numberOfChannels)\n\n\t\t//channels data is cached as subarrays\n\t\tthis._channelData = []\n\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\tthis._channelData.push(this._data.subarray(c * this.length, (c+1) * this.length))\n\t\t}\n\t}\n\n\t/**\n\t * Return data associated with the channel.\n\t * @param {number} channel - Channel index, starting from 0.\n\t * @return {Float32Array} Array containing the data.\n\t */\n\tgetChannelData (channel) {\n\t\tif (channel >= this.numberOfChannels || channel < 0 || channel == null) throw Error('Cannot getChannelData: channel number (' + channel + ') exceeds number of channels (' + this.numberOfChannels + ')');\n\n\t\treturn this._channelData[channel]\n\t}\n\n\n\t/**\n\t * Place data to the destination buffer, starting from the position.\n\t * @param {Float32Array} destination - Destination array to write data to.\n\t * @param {number} channelNumber - Channel to take data from.\n\t * @param {number} startInChannel - Data offset in channel to read from.\n\t */\n\tcopyFromChannel (destination, channelNumber, startInChannel) {\n\t\tif (startInChannel == null) startInChannel = 0;\n\t\tvar data = this._channelData[channelNumber]\n\t\tfor (var i = startInChannel, j = 0; i < this.length && j < destination.length; i++, j++) {\n\t\t\tdestination[j] = data[i];\n\t\t}\n\t}\n\n\n\t/**\n\t * Place data from the source to the channel, starting (in self) from the position.\n\t * @param {Float32Array | Array} source - source array to read data from.\n\t * @param {number} channelNumber - channel index to copy data to.\n\t * @param {number} startInChannel - offset in channel to copy data to.\n\t */\n\tcopyToChannel (source, channelNumber, startInChannel) {\n\t\tvar data = this._channelData[channelNumber]\n\n\t\tif (!startInChannel) startInChannel = 0;\n\n\t\tfor (var i = startInChannel, j = 0; i < this.length && j < source.length; i++, j++) {\n\t\t\tdata[i] = source[j];\n\t\t}\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}