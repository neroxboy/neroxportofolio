{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getStatusCodeForMediaRetry = exports.decryptMediaRetryData = exports.decodeMediaRetryNode = exports.encryptMediaRetryRequest = exports.getWAUploadToServer = exports.extensionForMediaMessage = exports.downloadEncryptedContent = exports.downloadContentFromMessage = exports.getUrlFromDirectPath = exports.encryptedStream = exports.getHttpStream = exports.generateThumbnail = exports.getStream = exports.toBuffer = exports.toReadable = exports.getAudioWaveform = exports.getAudioDuration = exports.mediaMessageSHA256B64 = exports.generateProfilePicture = exports.encodeBase64EncodedStringForUpload = exports.extractImageThumb = exports.getMediaKeys = exports.hkdfInfoKey = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst axios_1 = __importDefault(require(\"axios\"));\nconst child_process_1 = require(\"child_process\");\nconst Crypto = __importStar(require(\"crypto\"));\nconst events_1 = require(\"events\");\nconst fs_1 = require(\"fs\");\nconst os_1 = require(\"os\");\nconst path_1 = require(\"path\");\nconst stream_1 = require(\"stream\");\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst WABinary_1 = require(\"../WABinary\");\nconst crypto_1 = require(\"./crypto\");\nconst generics_1 = require(\"./generics\");\nconst getTmpFilesDirectory = () => (0, os_1.tmpdir)();\nconst getImageProcessingLibrary = async () => {\n  const [_jimp, sharp] = await Promise.all([(async () => {\n    const jimp = await import('jimp').catch(() => {});\n    return jimp;\n  })(), (async () => {\n    const sharp = await import('sharp').catch(() => {});\n    return sharp;\n  })()]);\n  if (sharp) {\n    return {\n      sharp\n    };\n  }\n  const jimp = (_jimp === null || _jimp === void 0 ? void 0 : _jimp.default) || _jimp;\n  if (jimp) {\n    return {\n      jimp\n    };\n  }\n  throw new boom_1.Boom('No image processing library available');\n};\nconst hkdfInfoKey = type => {\n  const hkdfInfo = Defaults_1.MEDIA_HKDF_KEY_MAPPING[type];\n  return `WhatsApp ${hkdfInfo} Keys`;\n};\nexports.hkdfInfoKey = hkdfInfoKey;\n/** generates all the keys required to encrypt/decrypt & sign a media message */\nfunction getMediaKeys(buffer, mediaType) {\n  if (!buffer) {\n    throw new boom_1.Boom('Cannot derive from empty media key');\n  }\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer.replace('data:;base64,', ''), 'base64');\n  }\n  // expand using HKDF to 112 bytes, also pass in the relevant app info\n  const expandedMediaKey = (0, crypto_1.hkdf)(buffer, 112, {\n    info: (0, exports.hkdfInfoKey)(mediaType)\n  });\n  return {\n    iv: expandedMediaKey.slice(0, 16),\n    cipherKey: expandedMediaKey.slice(16, 48),\n    macKey: expandedMediaKey.slice(48, 80)\n  };\n}\nexports.getMediaKeys = getMediaKeys;\n/** Extracts video thumb using FFMPEG */\nconst extractVideoThumb = async (path, destPath, time, size) => new Promise((resolve, reject) => {\n  const cmd = `ffmpeg -ss ${time} -i ${path} -y -vf scale=${size.width}:-1 -vframes 1 -f image2 ${destPath}`;\n  (0, child_process_1.exec)(cmd, err => {\n    if (err) {\n      reject(err);\n    } else {\n      resolve();\n    }\n  });\n});\nconst extractImageThumb = async (bufferOrFilePath, width = 32) => {\n  var _a, _b;\n  if (bufferOrFilePath instanceof stream_1.Readable) {\n    bufferOrFilePath = await (0, exports.toBuffer)(bufferOrFilePath);\n  }\n  const lib = await getImageProcessingLibrary();\n  if ('sharp' in lib && typeof ((_a = lib.sharp) === null || _a === void 0 ? void 0 : _a.default) === 'function') {\n    const img = lib.sharp.default(bufferOrFilePath);\n    const dimensions = await img.metadata();\n    const buffer = await img.resize(width).jpeg({\n      quality: 50\n    }).toBuffer();\n    return {\n      buffer,\n      original: {\n        width: dimensions.width,\n        height: dimensions.height\n      }\n    };\n  } else if ('jimp' in lib && typeof ((_b = lib.jimp) === null || _b === void 0 ? void 0 : _b.read) === 'function') {\n    const {\n      read,\n      MIME_JPEG,\n      RESIZE_BILINEAR,\n      AUTO\n    } = lib.jimp;\n    const jimp = await read(bufferOrFilePath);\n    const dimensions = {\n      width: jimp.getWidth(),\n      height: jimp.getHeight()\n    };\n    const buffer = await jimp.quality(50).resize(width, AUTO, RESIZE_BILINEAR).getBufferAsync(MIME_JPEG);\n    return {\n      buffer,\n      original: dimensions\n    };\n  } else {\n    throw new boom_1.Boom('No image processing library available');\n  }\n};\nexports.extractImageThumb = extractImageThumb;\nconst encodeBase64EncodedStringForUpload = b64 => encodeURIComponent(b64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=+$/, ''));\nexports.encodeBase64EncodedStringForUpload = encodeBase64EncodedStringForUpload;\nconst generateProfilePicture = async mediaUpload => {\n  var _a, _b;\n  let bufferOrFilePath;\n  if (Buffer.isBuffer(mediaUpload)) {\n    bufferOrFilePath = mediaUpload;\n  } else if ('url' in mediaUpload) {\n    bufferOrFilePath = mediaUpload.url.toString();\n  } else {\n    bufferOrFilePath = await (0, exports.toBuffer)(mediaUpload.stream);\n  }\n  const lib = await getImageProcessingLibrary();\n  let img;\n  if ('sharp' in lib && typeof ((_a = lib.sharp) === null || _a === void 0 ? void 0 : _a.default) === 'function') {\n    img = lib.sharp.default(bufferOrFilePath).resize(640, 640).jpeg({\n      quality: 50\n    }).toBuffer();\n  } else if ('jimp' in lib && typeof ((_b = lib.jimp) === null || _b === void 0 ? void 0 : _b.read) === 'function') {\n    const {\n      read,\n      MIME_JPEG,\n      RESIZE_BILINEAR\n    } = lib.jimp;\n    const jimp = await read(bufferOrFilePath);\n    const min = Math.min(jimp.getWidth(), jimp.getHeight());\n    const cropped = jimp.crop(0, 0, min, min);\n    img = cropped.quality(50).resize(640, 640, RESIZE_BILINEAR).getBufferAsync(MIME_JPEG);\n  } else {\n    throw new boom_1.Boom('No image processing library available');\n  }\n  return {\n    img: await img\n  };\n};\nexports.generateProfilePicture = generateProfilePicture;\n/** gets the SHA256 of the given media message */\nconst mediaMessageSHA256B64 = message => {\n  const media = Object.values(message)[0];\n  return (media === null || media === void 0 ? void 0 : media.fileSha256) && Buffer.from(media.fileSha256).toString('base64');\n};\nexports.mediaMessageSHA256B64 = mediaMessageSHA256B64;\nasync function getAudioDuration(buffer) {\n  const musicMetadata = await import('music-metadata');\n  let metadata;\n  if (Buffer.isBuffer(buffer)) {\n    metadata = await musicMetadata.parseBuffer(buffer, undefined, {\n      duration: true\n    });\n  } else if (typeof buffer === 'string') {\n    const rStream = (0, fs_1.createReadStream)(buffer);\n    try {\n      metadata = await musicMetadata.parseStream(rStream, undefined, {\n        duration: true\n      });\n    } finally {\n      rStream.destroy();\n    }\n  } else {\n    metadata = await musicMetadata.parseStream(buffer, undefined, {\n      duration: true\n    });\n  }\n  return metadata.format.duration;\n}\nexports.getAudioDuration = getAudioDuration;\n/**\n  referenced from and modifying https://github.com/wppconnect-team/wa-js/blob/main/src/chat/functions/prepareAudioWaveform.ts\n */\nasync function getAudioWaveform(buffer, logger) {\n  try {\n    const audioDecode = buffer => import('audio-decode').then(({\n      default: audioDecode\n    }) => audioDecode(buffer));\n    let audioData;\n    if (Buffer.isBuffer(buffer)) {\n      audioData = buffer;\n    } else if (typeof buffer === 'string') {\n      const rStream = (0, fs_1.createReadStream)(buffer);\n      audioData = await (0, exports.toBuffer)(rStream);\n    } else {\n      audioData = await (0, exports.toBuffer)(buffer);\n    }\n    const audioBuffer = await audioDecode(audioData);\n    const rawData = audioBuffer.getChannelData(0); // We only need to work with one channel of data\n    const samples = 64; // Number of samples we want to have in our final data set\n    const blockSize = Math.floor(rawData.length / samples); // the number of samples in each subdivision\n    const filteredData = [];\n    for (let i = 0; i < samples; i++) {\n      const blockStart = blockSize * i; // the location of the first sample in the block\n      let sum = 0;\n      for (let j = 0; j < blockSize; j++) {\n        sum = sum + Math.abs(rawData[blockStart + j]); // find the sum of all the samples in the block\n      }\n      filteredData.push(sum / blockSize); // divide the sum by the block size to get the average\n    }\n    // This guarantees that the largest data point will be set to 1, and the rest of the data will scale proportionally.\n    const multiplier = Math.pow(Math.max(...filteredData), -1);\n    const normalizedData = filteredData.map(n => n * multiplier);\n    // Generate waveform like WhatsApp\n    const waveform = new Uint8Array(normalizedData.map(n => Math.floor(100 * n)));\n    return waveform;\n  } catch (e) {\n    logger === null || logger === void 0 ? void 0 : logger.debug('Failed to generate waveform: ' + e);\n  }\n}\nexports.getAudioWaveform = getAudioWaveform;\nconst toReadable = buffer => {\n  const readable = new stream_1.Readable({\n    read: () => {}\n  });\n  readable.push(buffer);\n  readable.push(null);\n  return readable;\n};\nexports.toReadable = toReadable;\nconst toBuffer = async stream => {\n  const chunks = [];\n  for await (const chunk of stream) {\n    chunks.push(chunk);\n  }\n  stream.destroy();\n  return Buffer.concat(chunks);\n};\nexports.toBuffer = toBuffer;\nconst getStream = async (item, opts) => {\n  if (Buffer.isBuffer(item)) {\n    return {\n      stream: (0, exports.toReadable)(item),\n      type: 'buffer'\n    };\n  }\n  if ('stream' in item) {\n    return {\n      stream: item.stream,\n      type: 'readable'\n    };\n  }\n  if (item.url.toString().startsWith('http://') || item.url.toString().startsWith('https://')) {\n    return {\n      stream: await (0, exports.getHttpStream)(item.url, opts),\n      type: 'remote'\n    };\n  }\n  return {\n    stream: (0, fs_1.createReadStream)(item.url),\n    type: 'file'\n  };\n};\nexports.getStream = getStream;\n/** generates a thumbnail for a given media, if required */\nasync function generateThumbnail(file, mediaType, options) {\n  var _a;\n  let thumbnail;\n  let originalImageDimensions;\n  if (mediaType === 'image') {\n    const {\n      buffer,\n      original\n    } = await (0, exports.extractImageThumb)(file);\n    thumbnail = buffer.toString('base64');\n    if (original.width && original.height) {\n      originalImageDimensions = {\n        width: original.width,\n        height: original.height\n      };\n    }\n  } else if (mediaType === 'video') {\n    const imgFilename = (0, path_1.join)(getTmpFilesDirectory(), (0, generics_1.generateMessageID)() + '.jpg');\n    try {\n      await extractVideoThumb(file, imgFilename, '00:00:00', {\n        width: 32,\n        height: 32\n      });\n      const buff = await fs_1.promises.readFile(imgFilename);\n      thumbnail = buff.toString('base64');\n      await fs_1.promises.unlink(imgFilename);\n    } catch (err) {\n      (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug('could not generate video thumb: ' + err);\n    }\n  }\n  return {\n    thumbnail,\n    originalImageDimensions\n  };\n}\nexports.generateThumbnail = generateThumbnail;\nconst getHttpStream = async (url, options = {}) => {\n  const fetched = await axios_1.default.get(url.toString(), {\n    ...options,\n    responseType: 'stream'\n  });\n  return fetched.data;\n};\nexports.getHttpStream = getHttpStream;\nconst encryptedStream = async (media, mediaType, {\n  logger,\n  saveOriginalFileIfRequired,\n  opts\n} = {}) => {\n  const {\n    stream,\n    type\n  } = await (0, exports.getStream)(media, opts);\n  logger === null || logger === void 0 ? void 0 : logger.debug('fetched media stream');\n  const mediaKey = Crypto.randomBytes(32);\n  const {\n    cipherKey,\n    iv,\n    macKey\n  } = getMediaKeys(mediaKey, mediaType);\n  const encWriteStream = new stream_1.Readable({\n    read: () => {}\n  });\n  let bodyPath;\n  let writeStream;\n  let didSaveToTmpPath = false;\n  if (type === 'file') {\n    bodyPath = media.url;\n  } else if (saveOriginalFileIfRequired) {\n    bodyPath = (0, path_1.join)(getTmpFilesDirectory(), mediaType + (0, generics_1.generateMessageID)());\n    writeStream = (0, fs_1.createWriteStream)(bodyPath);\n    didSaveToTmpPath = true;\n  }\n  let fileLength = 0;\n  const aes = Crypto.createCipheriv('aes-256-cbc', cipherKey, iv);\n  let hmac = Crypto.createHmac('sha256', macKey).update(iv);\n  let sha256Plain = Crypto.createHash('sha256');\n  let sha256Enc = Crypto.createHash('sha256');\n  try {\n    for await (const data of stream) {\n      fileLength += data.length;\n      if (type === 'remote' && (opts === null || opts === void 0 ? void 0 : opts.maxContentLength) && fileLength + data.length > opts.maxContentLength) {\n        throw new boom_1.Boom(`content length exceeded when encrypting \"${type}\"`, {\n          data: {\n            media,\n            type\n          }\n        });\n      }\n      sha256Plain = sha256Plain.update(data);\n      if (writeStream) {\n        if (!writeStream.write(data)) {\n          await (0, events_1.once)(writeStream, 'drain');\n        }\n      }\n      onChunk(aes.update(data));\n    }\n    onChunk(aes.final());\n    const mac = hmac.digest().slice(0, 10);\n    sha256Enc = sha256Enc.update(mac);\n    const fileSha256 = sha256Plain.digest();\n    const fileEncSha256 = sha256Enc.digest();\n    encWriteStream.push(mac);\n    encWriteStream.push(null);\n    writeStream === null || writeStream === void 0 ? void 0 : writeStream.end();\n    stream.destroy();\n    logger === null || logger === void 0 ? void 0 : logger.debug('encrypted data successfully');\n    return {\n      mediaKey,\n      encWriteStream,\n      bodyPath,\n      mac,\n      fileEncSha256,\n      fileSha256,\n      fileLength,\n      didSaveToTmpPath\n    };\n  } catch (error) {\n    // destroy all streams with error\n    encWriteStream.destroy();\n    writeStream === null || writeStream === void 0 ? void 0 : writeStream.destroy();\n    aes.destroy();\n    hmac.destroy();\n    sha256Plain.destroy();\n    sha256Enc.destroy();\n    stream.destroy();\n    if (didSaveToTmpPath) {\n      try {\n        await fs_1.promises.unlink(bodyPath);\n      } catch (err) {\n        logger === null || logger === void 0 ? void 0 : logger.error({\n          err\n        }, 'failed to save to tmp path');\n      }\n    }\n    throw error;\n  }\n  function onChunk(buff) {\n    sha256Enc = sha256Enc.update(buff);\n    hmac = hmac.update(buff);\n    encWriteStream.push(buff);\n  }\n};\nexports.encryptedStream = encryptedStream;\nconst DEF_HOST = 'mmg.whatsapp.net';\nconst AES_CHUNK_SIZE = 16;\nconst toSmallestChunkSize = num => {\n  return Math.floor(num / AES_CHUNK_SIZE) * AES_CHUNK_SIZE;\n};\nconst getUrlFromDirectPath = directPath => `https://${DEF_HOST}${directPath}`;\nexports.getUrlFromDirectPath = getUrlFromDirectPath;\nconst downloadContentFromMessage = ({\n  mediaKey,\n  directPath,\n  url\n}, type, opts = {}) => {\n  const downloadUrl = url || (0, exports.getUrlFromDirectPath)(directPath);\n  const keys = getMediaKeys(mediaKey, type);\n  return (0, exports.downloadEncryptedContent)(downloadUrl, keys, opts);\n};\nexports.downloadContentFromMessage = downloadContentFromMessage;\n/**\n * Decrypts and downloads an AES256-CBC encrypted file given the keys.\n * Assumes the SHA256 of the plaintext is appended to the end of the ciphertext\n * */\nconst downloadEncryptedContent = async (downloadUrl, {\n  cipherKey,\n  iv\n}, {\n  startByte,\n  endByte,\n  options\n} = {}) => {\n  let bytesFetched = 0;\n  let startChunk = 0;\n  let firstBlockIsIV = false;\n  // if a start byte is specified -- then we need to fetch the previous chunk as that will form the IV\n  if (startByte) {\n    const chunk = toSmallestChunkSize(startByte || 0);\n    if (chunk) {\n      startChunk = chunk - AES_CHUNK_SIZE;\n      bytesFetched = chunk;\n      firstBlockIsIV = true;\n    }\n  }\n  const endChunk = endByte ? toSmallestChunkSize(endByte || 0) + AES_CHUNK_SIZE : undefined;\n  const headers = {\n    ...((options === null || options === void 0 ? void 0 : options.headers) || {}),\n    Origin: Defaults_1.DEFAULT_ORIGIN\n  };\n  if (startChunk || endChunk) {\n    headers.Range = `bytes=${startChunk}-`;\n    if (endChunk) {\n      headers.Range += endChunk;\n    }\n  }\n  // download the message\n  const fetched = await (0, exports.getHttpStream)(downloadUrl, {\n    ...(options || {}),\n    headers,\n    maxBodyLength: Infinity,\n    maxContentLength: Infinity\n  });\n  let remainingBytes = Buffer.from([]);\n  let aes;\n  const pushBytes = (bytes, push) => {\n    if (startByte || endByte) {\n      const start = bytesFetched >= startByte ? undefined : Math.max(startByte - bytesFetched, 0);\n      const end = bytesFetched + bytes.length < endByte ? undefined : Math.max(endByte - bytesFetched, 0);\n      push(bytes.slice(start, end));\n      bytesFetched += bytes.length;\n    } else {\n      push(bytes);\n    }\n  };\n  const output = new stream_1.Transform({\n    transform(chunk, _, callback) {\n      let data = Buffer.concat([remainingBytes, chunk]);\n      const decryptLength = toSmallestChunkSize(data.length);\n      remainingBytes = data.slice(decryptLength);\n      data = data.slice(0, decryptLength);\n      if (!aes) {\n        let ivValue = iv;\n        if (firstBlockIsIV) {\n          ivValue = data.slice(0, AES_CHUNK_SIZE);\n          data = data.slice(AES_CHUNK_SIZE);\n        }\n        aes = Crypto.createDecipheriv('aes-256-cbc', cipherKey, ivValue);\n        // if an end byte that is not EOF is specified\n        // stop auto padding (PKCS7) -- otherwise throws an error for decryption\n        if (endByte) {\n          aes.setAutoPadding(false);\n        }\n      }\n      try {\n        pushBytes(aes.update(data), b => this.push(b));\n        callback();\n      } catch (error) {\n        callback(error);\n      }\n    },\n    final(callback) {\n      try {\n        pushBytes(aes.final(), b => this.push(b));\n        callback();\n      } catch (error) {\n        callback(error);\n      }\n    }\n  });\n  return fetched.pipe(output, {\n    end: true\n  });\n};\nexports.downloadEncryptedContent = downloadEncryptedContent;\nfunction extensionForMediaMessage(message) {\n  const getExtension = mimetype => mimetype.split(';')[0].split('/')[1];\n  const type = Object.keys(message)[0];\n  let extension;\n  if (type === 'locationMessage' || type === 'liveLocationMessage' || type === 'productMessage') {\n    extension = '.jpeg';\n  } else {\n    const messageContent = message[type];\n    extension = getExtension(messageContent.mimetype);\n  }\n  return extension;\n}\nexports.extensionForMediaMessage = extensionForMediaMessage;\nconst getWAUploadToServer = ({\n  customUploadHosts,\n  fetchAgent,\n  logger,\n  options\n}, refreshMediaConn) => {\n  return async (stream, {\n    mediaType,\n    fileEncSha256B64,\n    timeoutMs\n  }) => {\n    var _a, _b;\n    // send a query JSON to obtain the url & auth token to upload our media\n    let uploadInfo = await refreshMediaConn(false);\n    let urls;\n    const hosts = [...customUploadHosts, ...uploadInfo.hosts];\n    fileEncSha256B64 = (0, exports.encodeBase64EncodedStringForUpload)(fileEncSha256B64);\n    for (const {\n      hostname\n    } of hosts) {\n      logger.debug(`uploading to \"${hostname}\"`);\n      const auth = encodeURIComponent(uploadInfo.auth); // the auth token\n      const url = `https://${hostname}${Defaults_1.MEDIA_PATH_MAP[mediaType]}/${fileEncSha256B64}?auth=${auth}&token=${fileEncSha256B64}`;\n      let result;\n      try {\n        const body = await axios_1.default.post(url, stream, {\n          ...options,\n          headers: {\n            ...(options.headers || {}),\n            'Content-Type': 'application/octet-stream',\n            'Origin': Defaults_1.DEFAULT_ORIGIN\n          },\n          httpsAgent: fetchAgent,\n          timeout: timeoutMs,\n          responseType: 'json',\n          maxBodyLength: Infinity,\n          maxContentLength: Infinity\n        });\n        result = body.data;\n        if ((result === null || result === void 0 ? void 0 : result.url) || (result === null || result === void 0 ? void 0 : result.directPath)) {\n          urls = {\n            mediaUrl: result.url,\n            directPath: result.direct_path\n          };\n          break;\n        } else {\n          uploadInfo = await refreshMediaConn(true);\n          throw new Error(`upload failed, reason: ${JSON.stringify(result)}`);\n        }\n      } catch (error) {\n        if (axios_1.default.isAxiosError(error)) {\n          result = (_a = error.response) === null || _a === void 0 ? void 0 : _a.data;\n        }\n        const isLast = hostname === ((_b = hosts[uploadInfo.hosts.length - 1]) === null || _b === void 0 ? void 0 : _b.hostname);\n        logger.warn({\n          trace: error.stack,\n          uploadResult: result\n        }, `Error in uploading to ${hostname} ${isLast ? '' : ', retrying...'}`);\n      }\n    }\n    if (!urls) {\n      throw new boom_1.Boom('Media upload failed on all hosts', {\n        statusCode: 500\n      });\n    }\n    return urls;\n  };\n};\nexports.getWAUploadToServer = getWAUploadToServer;\nconst getMediaRetryKey = mediaKey => {\n  return (0, crypto_1.hkdf)(mediaKey, 32, {\n    info: 'WhatsApp Media Retry Notification'\n  });\n};\n/**\n * Generate a binary node that will request the phone to re-upload the media & return the newly uploaded URL\n */\nconst encryptMediaRetryRequest = (key, mediaKey, meId) => {\n  const recp = {\n    stanzaId: key.id\n  };\n  const recpBuffer = WAProto_1.proto.ServerErrorReceipt.encode(recp).finish();\n  const iv = Crypto.randomBytes(12);\n  const retryKey = getMediaRetryKey(mediaKey);\n  const ciphertext = (0, crypto_1.aesEncryptGCM)(recpBuffer, retryKey, iv, Buffer.from(key.id));\n  const req = {\n    tag: 'receipt',\n    attrs: {\n      id: key.id,\n      to: (0, WABinary_1.jidNormalizedUser)(meId),\n      type: 'server-error'\n    },\n    content: [\n    // this encrypt node is actually pretty useless\n    // the media is returned even without this node\n    // keeping it here to maintain parity with WA Web\n    {\n      tag: 'encrypt',\n      attrs: {},\n      content: [{\n        tag: 'enc_p',\n        attrs: {},\n        content: ciphertext\n      }, {\n        tag: 'enc_iv',\n        attrs: {},\n        content: iv\n      }]\n    }, {\n      tag: 'rmr',\n      attrs: {\n        jid: key.remoteJid,\n        'from_me': (!!key.fromMe).toString(),\n        // @ts-ignore\n        participant: key.participant || undefined\n      }\n    }]\n  };\n  return req;\n};\nexports.encryptMediaRetryRequest = encryptMediaRetryRequest;\nconst decodeMediaRetryNode = node => {\n  const rmrNode = (0, WABinary_1.getBinaryNodeChild)(node, 'rmr');\n  const event = {\n    key: {\n      id: node.attrs.id,\n      remoteJid: rmrNode.attrs.jid,\n      fromMe: rmrNode.attrs.from_me === 'true',\n      participant: rmrNode.attrs.participant\n    }\n  };\n  const errorNode = (0, WABinary_1.getBinaryNodeChild)(node, 'error');\n  if (errorNode) {\n    const errorCode = +errorNode.attrs.code;\n    event.error = new boom_1.Boom(`Failed to re-upload media (${errorCode})`, {\n      data: errorNode.attrs,\n      statusCode: (0, exports.getStatusCodeForMediaRetry)(errorCode)\n    });\n  } else {\n    const encryptedInfoNode = (0, WABinary_1.getBinaryNodeChild)(node, 'encrypt');\n    const ciphertext = (0, WABinary_1.getBinaryNodeChildBuffer)(encryptedInfoNode, 'enc_p');\n    const iv = (0, WABinary_1.getBinaryNodeChildBuffer)(encryptedInfoNode, 'enc_iv');\n    if (ciphertext && iv) {\n      event.media = {\n        ciphertext,\n        iv\n      };\n    } else {\n      event.error = new boom_1.Boom('Failed to re-upload media (missing ciphertext)', {\n        statusCode: 404\n      });\n    }\n  }\n  return event;\n};\nexports.decodeMediaRetryNode = decodeMediaRetryNode;\nconst decryptMediaRetryData = ({\n  ciphertext,\n  iv\n}, mediaKey, msgId) => {\n  const retryKey = getMediaRetryKey(mediaKey);\n  const plaintext = (0, crypto_1.aesDecryptGCM)(ciphertext, retryKey, iv, Buffer.from(msgId));\n  return WAProto_1.proto.MediaRetryNotification.decode(plaintext);\n};\nexports.decryptMediaRetryData = decryptMediaRetryData;\nconst getStatusCodeForMediaRetry = code => MEDIA_RETRY_STATUS_MAP[code];\nexports.getStatusCodeForMediaRetry = getStatusCodeForMediaRetry;\nconst MEDIA_RETRY_STATUS_MAP = {\n  [WAProto_1.proto.MediaRetryNotification.ResultType.SUCCESS]: 200,\n  [WAProto_1.proto.MediaRetryNotification.ResultType.DECRYPTION_ERROR]: 412,\n  [WAProto_1.proto.MediaRetryNotification.ResultType.NOT_FOUND]: 404,\n  [WAProto_1.proto.MediaRetryNotification.ResultType.GENERAL_ERROR]: 418\n};\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction __importStar(arg0) {\n  throw new Error('Function not implemented.');\n}","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__importDefault","exports","getStatusCodeForMediaRetry","decryptMediaRetryData","decodeMediaRetryNode","encryptMediaRetryRequest","getWAUploadToServer","extensionForMediaMessage","downloadEncryptedContent","downloadContentFromMessage","getUrlFromDirectPath","encryptedStream","getHttpStream","generateThumbnail","getStream","toBuffer","toReadable","getAudioWaveform","getAudioDuration","mediaMessageSHA256B64","generateProfilePicture","encodeBase64EncodedStringForUpload","extractImageThumb","getMediaKeys","hkdfInfoKey","boom_1","require","axios_1","child_process_1","Crypto","events_1","fs_1","os_1","path_1","stream_1","WAProto_1","Defaults_1","WABinary_1","crypto_1","generics_1","getTmpFilesDirectory","tmpdir","getImageProcessingLibrary","_jimp","sharp","Promise","all","jimp","catch","default","Boom","type","hkdfInfo","MEDIA_HKDF_KEY_MAPPING","buffer","mediaType","Buffer","from","replace","expandedMediaKey","hkdf","info","iv","slice","cipherKey","macKey","extractVideoThumb","path","destPath","time","size","resolve","reject","cmd","width","exec","err","bufferOrFilePath","_a","_b","Readable","lib","img","dimensions","metadata","resize","jpeg","quality","original","height","read","MIME_JPEG","RESIZE_BILINEAR","AUTO","getWidth","getHeight","getBufferAsync","b64","encodeURIComponent","mediaUpload","isBuffer","url","toString","stream","min","Math","cropped","crop","message","media","values","fileSha256","musicMetadata","parseBuffer","duration","rStream","createReadStream","parseStream","destroy","format","logger","audioDecode","then","audioData","audioBuffer","rawData","getChannelData","samples","blockSize","floor","length","filteredData","i","blockStart","sum","j","abs","push","multiplier","pow","max","normalizedData","map","n","waveform","Uint8Array","e","debug","readable","chunks","chunk","concat","item","opts","startsWith","file","options","thumbnail","originalImageDimensions","imgFilename","join","generateMessageID","buff","promises","readFile","unlink","fetched","responseType","data","saveOriginalFileIfRequired","mediaKey","randomBytes","encWriteStream","bodyPath","writeStream","didSaveToTmpPath","createWriteStream","fileLength","aes","createCipheriv","hmac","createHmac","update","sha256Plain","createHash","sha256Enc","maxContentLength","write","once","onChunk","final","mac","digest","fileEncSha256","end","error","DEF_HOST","AES_CHUNK_SIZE","toSmallestChunkSize","num","directPath","downloadUrl","keys","startByte","endByte","bytesFetched","startChunk","firstBlockIsIV","endChunk","headers","Origin","DEFAULT_ORIGIN","Range","maxBodyLength","Infinity","remainingBytes","pushBytes","bytes","start","output","Transform","transform","_","callback","decryptLength","ivValue","createDecipheriv","setAutoPadding","b","pipe","getExtension","mimetype","split","extension","messageContent","customUploadHosts","fetchAgent","refreshMediaConn","fileEncSha256B64","timeoutMs","uploadInfo","urls","hosts","hostname","auth","MEDIA_PATH_MAP","body","post","httpsAgent","timeout","mediaUrl","direct_path","Error","JSON","stringify","isAxiosError","response","isLast","warn","trace","stack","uploadResult","statusCode","getMediaRetryKey","key","meId","recp","stanzaId","id","recpBuffer","proto","ServerErrorReceipt","encode","finish","retryKey","ciphertext","aesEncryptGCM","req","tag","attrs","to","jidNormalizedUser","content","jid","remoteJid","fromMe","participant","node","rmrNode","getBinaryNodeChild","event","from_me","errorNode","errorCode","code","encryptedInfoNode","getBinaryNodeChildBuffer","msgId","plaintext","aesDecryptGCM","MediaRetryNotification","decode","MEDIA_RETRY_STATUS_MAP","ResultType","SUCCESS","DECRYPTION_ERROR","NOT_FOUND","GENERAL_ERROR","arg0"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Utils/messages-media.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getStatusCodeForMediaRetry = exports.decryptMediaRetryData = exports.decodeMediaRetryNode = exports.encryptMediaRetryRequest = exports.getWAUploadToServer = exports.extensionForMediaMessage = exports.downloadEncryptedContent = exports.downloadContentFromMessage = exports.getUrlFromDirectPath = exports.encryptedStream = exports.getHttpStream = exports.generateThumbnail = exports.getStream = exports.toBuffer = exports.toReadable = exports.getAudioWaveform = exports.getAudioDuration = exports.mediaMessageSHA256B64 = exports.generateProfilePicture = exports.encodeBase64EncodedStringForUpload = exports.extractImageThumb = exports.getMediaKeys = exports.hkdfInfoKey = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst axios_1 = __importDefault(require(\"axios\"));\nconst child_process_1 = require(\"child_process\");\nconst Crypto = __importStar(require(\"crypto\"));\nconst events_1 = require(\"events\");\nconst fs_1 = require(\"fs\");\nconst os_1 = require(\"os\");\nconst path_1 = require(\"path\");\nconst stream_1 = require(\"stream\");\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst WABinary_1 = require(\"../WABinary\");\nconst crypto_1 = require(\"./crypto\");\nconst generics_1 = require(\"./generics\");\nconst getTmpFilesDirectory = () => (0, os_1.tmpdir)();\nconst getImageProcessingLibrary = async () => {\n    const [_jimp, sharp] = await Promise.all([\n        (async () => {\n            const jimp = await (import('jimp')\n                .catch(() => { }));\n            return jimp;\n        })(),\n        (async () => {\n            const sharp = await (import('sharp')\n                .catch(() => { }));\n            return sharp;\n        })()\n    ]);\n    if (sharp) {\n        return { sharp };\n    }\n    const jimp = (_jimp === null || _jimp === void 0 ? void 0 : _jimp.default) || _jimp;\n    if (jimp) {\n        return { jimp };\n    }\n    throw new boom_1.Boom('No image processing library available');\n};\nconst hkdfInfoKey = (type) => {\n    const hkdfInfo = Defaults_1.MEDIA_HKDF_KEY_MAPPING[type];\n    return `WhatsApp ${hkdfInfo} Keys`;\n};\nexports.hkdfInfoKey = hkdfInfoKey;\n/** generates all the keys required to encrypt/decrypt & sign a media message */\nfunction getMediaKeys(buffer, mediaType) {\n    if (!buffer) {\n        throw new boom_1.Boom('Cannot derive from empty media key');\n    }\n    if (typeof buffer === 'string') {\n        buffer = Buffer.from(buffer.replace('data:;base64,', ''), 'base64');\n    }\n    // expand using HKDF to 112 bytes, also pass in the relevant app info\n    const expandedMediaKey = (0, crypto_1.hkdf)(buffer, 112, { info: (0, exports.hkdfInfoKey)(mediaType) });\n    return {\n        iv: expandedMediaKey.slice(0, 16),\n        cipherKey: expandedMediaKey.slice(16, 48),\n        macKey: expandedMediaKey.slice(48, 80),\n    };\n}\nexports.getMediaKeys = getMediaKeys;\n/** Extracts video thumb using FFMPEG */\nconst extractVideoThumb = async (path, destPath, time, size) => new Promise((resolve, reject) => {\n    const cmd = `ffmpeg -ss ${time} -i ${path} -y -vf scale=${size.width}:-1 -vframes 1 -f image2 ${destPath}`;\n    (0, child_process_1.exec)(cmd, (err) => {\n        if (err) {\n            reject(err);\n        }\n        else {\n            resolve();\n        }\n    });\n});\nconst extractImageThumb = async (bufferOrFilePath, width = 32) => {\n    var _a, _b;\n    if (bufferOrFilePath instanceof stream_1.Readable) {\n        bufferOrFilePath = await (0, exports.toBuffer)(bufferOrFilePath);\n    }\n    const lib = await getImageProcessingLibrary();\n    if ('sharp' in lib && typeof ((_a = lib.sharp) === null || _a === void 0 ? void 0 : _a.default) === 'function') {\n        const img = lib.sharp.default(bufferOrFilePath);\n        const dimensions = await img.metadata();\n        const buffer = await img\n            .resize(width)\n            .jpeg({ quality: 50 })\n            .toBuffer();\n        return {\n            buffer,\n            original: {\n                width: dimensions.width,\n                height: dimensions.height,\n            },\n        };\n    }\n    else if ('jimp' in lib && typeof ((_b = lib.jimp) === null || _b === void 0 ? void 0 : _b.read) === 'function') {\n        const { read, MIME_JPEG, RESIZE_BILINEAR, AUTO } = lib.jimp;\n        const jimp = await read(bufferOrFilePath);\n        const dimensions = {\n            width: jimp.getWidth(),\n            height: jimp.getHeight()\n        };\n        const buffer = await jimp\n            .quality(50)\n            .resize(width, AUTO, RESIZE_BILINEAR)\n            .getBufferAsync(MIME_JPEG);\n        return {\n            buffer,\n            original: dimensions\n        };\n    }\n    else {\n        throw new boom_1.Boom('No image processing library available');\n    }\n};\nexports.extractImageThumb = extractImageThumb;\nconst encodeBase64EncodedStringForUpload = (b64) => (encodeURIComponent(b64\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/\\=+$/, '')));\nexports.encodeBase64EncodedStringForUpload = encodeBase64EncodedStringForUpload;\nconst generateProfilePicture = async (mediaUpload) => {\n    var _a, _b;\n    let bufferOrFilePath;\n    if (Buffer.isBuffer(mediaUpload)) {\n        bufferOrFilePath = mediaUpload;\n    }\n    else if ('url' in mediaUpload) {\n        bufferOrFilePath = mediaUpload.url.toString();\n    }\n    else {\n        bufferOrFilePath = await (0, exports.toBuffer)(mediaUpload.stream);\n    }\n    const lib = await getImageProcessingLibrary();\n    let img;\n    if ('sharp' in lib && typeof ((_a = lib.sharp) === null || _a === void 0 ? void 0 : _a.default) === 'function') {\n        img = lib.sharp.default(bufferOrFilePath)\n            .resize(640, 640)\n            .jpeg({\n            quality: 50,\n        })\n            .toBuffer();\n    }\n    else if ('jimp' in lib && typeof ((_b = lib.jimp) === null || _b === void 0 ? void 0 : _b.read) === 'function') {\n        const { read, MIME_JPEG, RESIZE_BILINEAR } = lib.jimp;\n        const jimp = await read(bufferOrFilePath);\n        const min = Math.min(jimp.getWidth(), jimp.getHeight());\n        const cropped = jimp.crop(0, 0, min, min);\n        img = cropped\n            .quality(50)\n            .resize(640, 640, RESIZE_BILINEAR)\n            .getBufferAsync(MIME_JPEG);\n    }\n    else {\n        throw new boom_1.Boom('No image processing library available');\n    }\n    return {\n        img: await img,\n    };\n};\nexports.generateProfilePicture = generateProfilePicture;\n/** gets the SHA256 of the given media message */\nconst mediaMessageSHA256B64 = (message) => {\n    const media = Object.values(message)[0];\n    return (media === null || media === void 0 ? void 0 : media.fileSha256) && Buffer.from(media.fileSha256).toString('base64');\n};\nexports.mediaMessageSHA256B64 = mediaMessageSHA256B64;\nasync function getAudioDuration(buffer) {\n    const musicMetadata = await import('music-metadata');\n    let metadata;\n    if (Buffer.isBuffer(buffer)) {\n        metadata = await musicMetadata.parseBuffer(buffer, undefined, { duration: true });\n    }\n    else if (typeof buffer === 'string') {\n        const rStream = (0, fs_1.createReadStream)(buffer);\n        try {\n            metadata = await musicMetadata.parseStream(rStream, undefined, { duration: true });\n        }\n        finally {\n            rStream.destroy();\n        }\n    }\n    else {\n        metadata = await musicMetadata.parseStream(buffer, undefined, { duration: true });\n    }\n    return metadata.format.duration;\n}\nexports.getAudioDuration = getAudioDuration;\n/**\n  referenced from and modifying https://github.com/wppconnect-team/wa-js/blob/main/src/chat/functions/prepareAudioWaveform.ts\n */\nasync function getAudioWaveform(buffer, logger) {\n    try {\n        const audioDecode = (buffer) => import('audio-decode').then(({ default: audioDecode }) => audioDecode(buffer));\n        let audioData;\n        if (Buffer.isBuffer(buffer)) {\n            audioData = buffer;\n        }\n        else if (typeof buffer === 'string') {\n            const rStream = (0, fs_1.createReadStream)(buffer);\n            audioData = await (0, exports.toBuffer)(rStream);\n        }\n        else {\n            audioData = await (0, exports.toBuffer)(buffer);\n        }\n        const audioBuffer = await audioDecode(audioData);\n        const rawData = audioBuffer.getChannelData(0); // We only need to work with one channel of data\n        const samples = 64; // Number of samples we want to have in our final data set\n        const blockSize = Math.floor(rawData.length / samples); // the number of samples in each subdivision\n        const filteredData = [];\n        for (let i = 0; i < samples; i++) {\n            const blockStart = blockSize * i; // the location of the first sample in the block\n            let sum = 0;\n            for (let j = 0; j < blockSize; j++) {\n                sum = sum + Math.abs(rawData[blockStart + j]); // find the sum of all the samples in the block\n            }\n            filteredData.push(sum / blockSize); // divide the sum by the block size to get the average\n        }\n        // This guarantees that the largest data point will be set to 1, and the rest of the data will scale proportionally.\n        const multiplier = Math.pow(Math.max(...filteredData), -1);\n        const normalizedData = filteredData.map((n) => n * multiplier);\n        // Generate waveform like WhatsApp\n        const waveform = new Uint8Array(normalizedData.map((n) => Math.floor(100 * n)));\n        return waveform;\n    }\n    catch (e) {\n        logger === null || logger === void 0 ? void 0 : logger.debug('Failed to generate waveform: ' + e);\n    }\n}\nexports.getAudioWaveform = getAudioWaveform;\nconst toReadable = (buffer) => {\n    const readable = new stream_1.Readable({ read: () => { } });\n    readable.push(buffer);\n    readable.push(null);\n    return readable;\n};\nexports.toReadable = toReadable;\nconst toBuffer = async (stream) => {\n    const chunks = [];\n    for await (const chunk of stream) {\n        chunks.push(chunk);\n    }\n    stream.destroy();\n    return Buffer.concat(chunks);\n};\nexports.toBuffer = toBuffer;\nconst getStream = async (item, opts) => {\n    if (Buffer.isBuffer(item)) {\n        return { stream: (0, exports.toReadable)(item), type: 'buffer' };\n    }\n    if ('stream' in item) {\n        return { stream: item.stream, type: 'readable' };\n    }\n    if (item.url.toString().startsWith('http://') || item.url.toString().startsWith('https://')) {\n        return { stream: await (0, exports.getHttpStream)(item.url, opts), type: 'remote' };\n    }\n    return { stream: (0, fs_1.createReadStream)(item.url), type: 'file' };\n};\nexports.getStream = getStream;\n/** generates a thumbnail for a given media, if required */\nasync function generateThumbnail(file, mediaType, options) {\n    var _a;\n    let thumbnail;\n    let originalImageDimensions;\n    if (mediaType === 'image') {\n        const { buffer, original } = await (0, exports.extractImageThumb)(file);\n        thumbnail = buffer.toString('base64');\n        if (original.width && original.height) {\n            originalImageDimensions = {\n                width: original.width,\n                height: original.height,\n            };\n        }\n    }\n    else if (mediaType === 'video') {\n        const imgFilename = (0, path_1.join)(getTmpFilesDirectory(), (0, generics_1.generateMessageID)() + '.jpg');\n        try {\n            await extractVideoThumb(file, imgFilename, '00:00:00', { width: 32, height: 32 });\n            const buff = await fs_1.promises.readFile(imgFilename);\n            thumbnail = buff.toString('base64');\n            await fs_1.promises.unlink(imgFilename);\n        }\n        catch (err) {\n            (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug('could not generate video thumb: ' + err);\n        }\n    }\n    return {\n        thumbnail,\n        originalImageDimensions\n    };\n}\nexports.generateThumbnail = generateThumbnail;\nconst getHttpStream = async (url, options = {}) => {\n    const fetched = await axios_1.default.get(url.toString(), { ...options, responseType: 'stream' });\n    return fetched.data;\n};\nexports.getHttpStream = getHttpStream;\nconst encryptedStream = async (media, mediaType, { logger, saveOriginalFileIfRequired, opts } = {}) => {\n    const { stream, type } = await (0, exports.getStream)(media, opts);\n    logger === null || logger === void 0 ? void 0 : logger.debug('fetched media stream');\n    const mediaKey = Crypto.randomBytes(32);\n    const { cipherKey, iv, macKey } = getMediaKeys(mediaKey, mediaType);\n    const encWriteStream = new stream_1.Readable({ read: () => { } });\n    let bodyPath;\n    let writeStream;\n    let didSaveToTmpPath = false;\n    if (type === 'file') {\n        bodyPath = media.url;\n    }\n    else if (saveOriginalFileIfRequired) {\n        bodyPath = (0, path_1.join)(getTmpFilesDirectory(), mediaType + (0, generics_1.generateMessageID)());\n        writeStream = (0, fs_1.createWriteStream)(bodyPath);\n        didSaveToTmpPath = true;\n    }\n    let fileLength = 0;\n    const aes = Crypto.createCipheriv('aes-256-cbc', cipherKey, iv);\n    let hmac = Crypto.createHmac('sha256', macKey).update(iv);\n    let sha256Plain = Crypto.createHash('sha256');\n    let sha256Enc = Crypto.createHash('sha256');\n    try {\n        for await (const data of stream) {\n            fileLength += data.length;\n            if (type === 'remote'\n                && (opts === null || opts === void 0 ? void 0 : opts.maxContentLength)\n                && fileLength + data.length > opts.maxContentLength) {\n                throw new boom_1.Boom(`content length exceeded when encrypting \"${type}\"`, {\n                    data: { media, type }\n                });\n            }\n            sha256Plain = sha256Plain.update(data);\n            if (writeStream) {\n                if (!writeStream.write(data)) {\n                    await (0, events_1.once)(writeStream, 'drain');\n                }\n            }\n            onChunk(aes.update(data));\n        }\n        onChunk(aes.final());\n        const mac = hmac.digest().slice(0, 10);\n        sha256Enc = sha256Enc.update(mac);\n        const fileSha256 = sha256Plain.digest();\n        const fileEncSha256 = sha256Enc.digest();\n        encWriteStream.push(mac);\n        encWriteStream.push(null);\n        writeStream === null || writeStream === void 0 ? void 0 : writeStream.end();\n        stream.destroy();\n        logger === null || logger === void 0 ? void 0 : logger.debug('encrypted data successfully');\n        return {\n            mediaKey,\n            encWriteStream,\n            bodyPath,\n            mac,\n            fileEncSha256,\n            fileSha256,\n            fileLength,\n            didSaveToTmpPath\n        };\n    }\n    catch (error) {\n        // destroy all streams with error\n        encWriteStream.destroy();\n        writeStream === null || writeStream === void 0 ? void 0 : writeStream.destroy();\n        aes.destroy();\n        hmac.destroy();\n        sha256Plain.destroy();\n        sha256Enc.destroy();\n        stream.destroy();\n        if (didSaveToTmpPath) {\n            try {\n                await fs_1.promises.unlink(bodyPath);\n            }\n            catch (err) {\n                logger === null || logger === void 0 ? void 0 : logger.error({ err }, 'failed to save to tmp path');\n            }\n        }\n        throw error;\n    }\n    function onChunk(buff) {\n        sha256Enc = sha256Enc.update(buff);\n        hmac = hmac.update(buff);\n        encWriteStream.push(buff);\n    }\n};\nexports.encryptedStream = encryptedStream;\nconst DEF_HOST = 'mmg.whatsapp.net';\nconst AES_CHUNK_SIZE = 16;\nconst toSmallestChunkSize = (num) => {\n    return Math.floor(num / AES_CHUNK_SIZE) * AES_CHUNK_SIZE;\n};\nconst getUrlFromDirectPath = (directPath) => `https://${DEF_HOST}${directPath}`;\nexports.getUrlFromDirectPath = getUrlFromDirectPath;\nconst downloadContentFromMessage = ({ mediaKey, directPath, url }, type, opts = {}) => {\n    const downloadUrl = url || (0, exports.getUrlFromDirectPath)(directPath);\n    const keys = getMediaKeys(mediaKey, type);\n    return (0, exports.downloadEncryptedContent)(downloadUrl, keys, opts);\n};\nexports.downloadContentFromMessage = downloadContentFromMessage;\n/**\n * Decrypts and downloads an AES256-CBC encrypted file given the keys.\n * Assumes the SHA256 of the plaintext is appended to the end of the ciphertext\n * */\nconst downloadEncryptedContent = async (downloadUrl, { cipherKey, iv }, { startByte, endByte, options } = {}) => {\n    let bytesFetched = 0;\n    let startChunk = 0;\n    let firstBlockIsIV = false;\n    // if a start byte is specified -- then we need to fetch the previous chunk as that will form the IV\n    if (startByte) {\n        const chunk = toSmallestChunkSize(startByte || 0);\n        if (chunk) {\n            startChunk = chunk - AES_CHUNK_SIZE;\n            bytesFetched = chunk;\n            firstBlockIsIV = true;\n        }\n    }\n    const endChunk = endByte ? toSmallestChunkSize(endByte || 0) + AES_CHUNK_SIZE : undefined;\n    const headers = {\n        ...(options === null || options === void 0 ? void 0 : options.headers) || {},\n        Origin: Defaults_1.DEFAULT_ORIGIN,\n    };\n    if (startChunk || endChunk) {\n        headers.Range = `bytes=${startChunk}-`;\n        if (endChunk) {\n            headers.Range += endChunk;\n        }\n    }\n    // download the message\n    const fetched = await (0, exports.getHttpStream)(downloadUrl, {\n        ...options || {},\n        headers,\n        maxBodyLength: Infinity,\n        maxContentLength: Infinity,\n    });\n    let remainingBytes = Buffer.from([]);\n    let aes;\n    const pushBytes = (bytes, push) => {\n        if (startByte || endByte) {\n            const start = bytesFetched >= startByte ? undefined : Math.max(startByte - bytesFetched, 0);\n            const end = bytesFetched + bytes.length < endByte ? undefined : Math.max(endByte - bytesFetched, 0);\n            push(bytes.slice(start, end));\n            bytesFetched += bytes.length;\n        }\n        else {\n            push(bytes);\n        }\n    };\n    const output = new stream_1.Transform({\n        transform(chunk, _, callback) {\n            let data = Buffer.concat([remainingBytes, chunk]);\n            const decryptLength = toSmallestChunkSize(data.length);\n            remainingBytes = data.slice(decryptLength);\n            data = data.slice(0, decryptLength);\n            if (!aes) {\n                let ivValue = iv;\n                if (firstBlockIsIV) {\n                    ivValue = data.slice(0, AES_CHUNK_SIZE);\n                    data = data.slice(AES_CHUNK_SIZE);\n                }\n                aes = Crypto.createDecipheriv('aes-256-cbc', cipherKey, ivValue);\n                // if an end byte that is not EOF is specified\n                // stop auto padding (PKCS7) -- otherwise throws an error for decryption\n                if (endByte) {\n                    aes.setAutoPadding(false);\n                }\n            }\n            try {\n                pushBytes(aes.update(data), b => this.push(b));\n                callback();\n            }\n            catch (error) {\n                callback(error);\n            }\n        },\n        final(callback) {\n            try {\n                pushBytes(aes.final(), b => this.push(b));\n                callback();\n            }\n            catch (error) {\n                callback(error);\n            }\n        },\n    });\n    return fetched.pipe(output, { end: true });\n};\nexports.downloadEncryptedContent = downloadEncryptedContent;\nfunction extensionForMediaMessage(message) {\n    const getExtension = (mimetype) => mimetype.split(';')[0].split('/')[1];\n    const type = Object.keys(message)[0];\n    let extension;\n    if (type === 'locationMessage' ||\n        type === 'liveLocationMessage' ||\n        type === 'productMessage') {\n        extension = '.jpeg';\n    }\n    else {\n        const messageContent = message[type];\n        extension = getExtension(messageContent.mimetype);\n    }\n    return extension;\n}\nexports.extensionForMediaMessage = extensionForMediaMessage;\nconst getWAUploadToServer = ({ customUploadHosts, fetchAgent, logger, options }, refreshMediaConn) => {\n    return async (stream, { mediaType, fileEncSha256B64, timeoutMs }) => {\n        var _a, _b;\n        // send a query JSON to obtain the url & auth token to upload our media\n        let uploadInfo = await refreshMediaConn(false);\n        let urls;\n        const hosts = [...customUploadHosts, ...uploadInfo.hosts];\n        fileEncSha256B64 = (0, exports.encodeBase64EncodedStringForUpload)(fileEncSha256B64);\n        for (const { hostname } of hosts) {\n            logger.debug(`uploading to \"${hostname}\"`);\n            const auth = encodeURIComponent(uploadInfo.auth); // the auth token\n            const url = `https://${hostname}${Defaults_1.MEDIA_PATH_MAP[mediaType]}/${fileEncSha256B64}?auth=${auth}&token=${fileEncSha256B64}`;\n            let result;\n            try {\n                const body = await axios_1.default.post(url, stream, {\n                    ...options,\n                    headers: {\n                        ...options.headers || {},\n                        'Content-Type': 'application/octet-stream',\n                        'Origin': Defaults_1.DEFAULT_ORIGIN\n                    },\n                    httpsAgent: fetchAgent,\n                    timeout: timeoutMs,\n                    responseType: 'json',\n                    maxBodyLength: Infinity,\n                    maxContentLength: Infinity,\n                });\n                result = body.data;\n                if ((result === null || result === void 0 ? void 0 : result.url) || (result === null || result === void 0 ? void 0 : result.directPath)) {\n                    urls = {\n                        mediaUrl: result.url,\n                        directPath: result.direct_path\n                    };\n                    break;\n                }\n                else {\n                    uploadInfo = await refreshMediaConn(true);\n                    throw new Error(`upload failed, reason: ${JSON.stringify(result)}`);\n                }\n            }\n            catch (error) {\n                if (axios_1.default.isAxiosError(error)) {\n                    result = (_a = error.response) === null || _a === void 0 ? void 0 : _a.data;\n                }\n                const isLast = hostname === ((_b = hosts[uploadInfo.hosts.length - 1]) === null || _b === void 0 ? void 0 : _b.hostname);\n                logger.warn({ trace: error.stack, uploadResult: result }, `Error in uploading to ${hostname} ${isLast ? '' : ', retrying...'}`);\n            }\n        }\n        if (!urls) {\n            throw new boom_1.Boom('Media upload failed on all hosts', { statusCode: 500 });\n        }\n        return urls;\n    };\n};\nexports.getWAUploadToServer = getWAUploadToServer;\nconst getMediaRetryKey = (mediaKey) => {\n    return (0, crypto_1.hkdf)(mediaKey, 32, { info: 'WhatsApp Media Retry Notification' });\n};\n/**\n * Generate a binary node that will request the phone to re-upload the media & return the newly uploaded URL\n */\nconst encryptMediaRetryRequest = (key, mediaKey, meId) => {\n    const recp = { stanzaId: key.id };\n    const recpBuffer = WAProto_1.proto.ServerErrorReceipt.encode(recp).finish();\n    const iv = Crypto.randomBytes(12);\n    const retryKey = getMediaRetryKey(mediaKey);\n    const ciphertext = (0, crypto_1.aesEncryptGCM)(recpBuffer, retryKey, iv, Buffer.from(key.id));\n    const req = {\n        tag: 'receipt',\n        attrs: {\n            id: key.id,\n            to: (0, WABinary_1.jidNormalizedUser)(meId),\n            type: 'server-error'\n        },\n        content: [\n            // this encrypt node is actually pretty useless\n            // the media is returned even without this node\n            // keeping it here to maintain parity with WA Web\n            {\n                tag: 'encrypt',\n                attrs: {},\n                content: [\n                    { tag: 'enc_p', attrs: {}, content: ciphertext },\n                    { tag: 'enc_iv', attrs: {}, content: iv }\n                ]\n            },\n            {\n                tag: 'rmr',\n                attrs: {\n                    jid: key.remoteJid,\n                    'from_me': (!!key.fromMe).toString(),\n                    // @ts-ignore\n                    participant: key.participant || undefined\n                }\n            }\n        ]\n    };\n    return req;\n};\nexports.encryptMediaRetryRequest = encryptMediaRetryRequest;\nconst decodeMediaRetryNode = (node) => {\n    const rmrNode = (0, WABinary_1.getBinaryNodeChild)(node, 'rmr');\n    const event = {\n        key: {\n            id: node.attrs.id,\n            remoteJid: rmrNode.attrs.jid,\n            fromMe: rmrNode.attrs.from_me === 'true',\n            participant: rmrNode.attrs.participant\n        }\n    };\n    const errorNode = (0, WABinary_1.getBinaryNodeChild)(node, 'error');\n    if (errorNode) {\n        const errorCode = +errorNode.attrs.code;\n        event.error = new boom_1.Boom(`Failed to re-upload media (${errorCode})`, { data: errorNode.attrs, statusCode: (0, exports.getStatusCodeForMediaRetry)(errorCode) });\n    }\n    else {\n        const encryptedInfoNode = (0, WABinary_1.getBinaryNodeChild)(node, 'encrypt');\n        const ciphertext = (0, WABinary_1.getBinaryNodeChildBuffer)(encryptedInfoNode, 'enc_p');\n        const iv = (0, WABinary_1.getBinaryNodeChildBuffer)(encryptedInfoNode, 'enc_iv');\n        if (ciphertext && iv) {\n            event.media = { ciphertext, iv };\n        }\n        else {\n            event.error = new boom_1.Boom('Failed to re-upload media (missing ciphertext)', { statusCode: 404 });\n        }\n    }\n    return event;\n};\nexports.decodeMediaRetryNode = decodeMediaRetryNode;\nconst decryptMediaRetryData = ({ ciphertext, iv }, mediaKey, msgId) => {\n    const retryKey = getMediaRetryKey(mediaKey);\n    const plaintext = (0, crypto_1.aesDecryptGCM)(ciphertext, retryKey, iv, Buffer.from(msgId));\n    return WAProto_1.proto.MediaRetryNotification.decode(plaintext);\n};\nexports.decryptMediaRetryData = decryptMediaRetryData;\nconst getStatusCodeForMediaRetry = (code) => MEDIA_RETRY_STATUS_MAP[code];\nexports.getStatusCodeForMediaRetry = getStatusCodeForMediaRetry;\nconst MEDIA_RETRY_STATUS_MAP = {\n    [WAProto_1.proto.MediaRetryNotification.ResultType.SUCCESS]: 200,\n    [WAProto_1.proto.MediaRetryNotification.ResultType.DECRYPTION_ERROR]: 412,\n    [WAProto_1.proto.MediaRetryNotification.ResultType.NOT_FOUND]: 404,\n    [WAProto_1.proto.MediaRetryNotification.ResultType.GENERAL_ERROR]: 418,\n};\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction __importStar(arg0) {\n    throw new Error('Function not implemented.');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}