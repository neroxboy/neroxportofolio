{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.processSyncAction = exports.chatModificationToAppPatch = exports.decodePatches = exports.decodeSyncdSnapshot = exports.downloadExternalPatch = exports.downloadExternalBlob = exports.extractSyncdPatches = exports.decodeSyncdPatch = exports.decodeSyncdMutations = exports.encodeSyncdPatch = exports.newLTHashState = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst WAProto_1 = require(\"../../WAProto\");\nconst LabelAssociation_1 = require(\"../Types/LabelAssociation\");\nconst WABinary_1 = require(\"../WABinary\");\nconst crypto_1 = require(\"./crypto\");\nconst generics_1 = require(\"./generics\");\nconst lt_hash_1 = require(\"./lt-hash\");\nconst messages_media_1 = require(\"./messages-media\");\nconst mutationKeys = keydata => {\n  const expanded = (0, crypto_1.hkdf)(keydata, 160, {\n    info: 'WhatsApp Mutation Keys'\n  });\n  return {\n    indexKey: expanded.slice(0, 32),\n    valueEncryptionKey: expanded.slice(32, 64),\n    valueMacKey: expanded.slice(64, 96),\n    snapshotMacKey: expanded.slice(96, 128),\n    patchMacKey: expanded.slice(128, 160)\n  };\n};\nconst generateMac = (operation, data, keyId, key) => {\n  const getKeyData = () => {\n    let r;\n    switch (operation) {\n      case WAProto_1.proto.SyncdMutation.SyncdOperation.SET:\n        r = 0x01;\n        break;\n      case WAProto_1.proto.SyncdMutation.SyncdOperation.REMOVE:\n        r = 0x02;\n        break;\n    }\n    const buff = Buffer.from([r]);\n    return Buffer.concat([buff, Buffer.from(keyId, 'base64')]);\n  };\n  const keyData = getKeyData();\n  const last = Buffer.alloc(8); // 8 bytes\n  last.set([keyData.length], last.length - 1);\n  const total = Buffer.concat([keyData, data, last]);\n  const hmac = (0, crypto_1.hmacSign)(total, key, 'sha512');\n  return hmac.slice(0, 32);\n};\nconst to64BitNetworkOrder = e => {\n  const buff = Buffer.alloc(8);\n  buff.writeUint32BE(e, 4);\n  return buff;\n};\nconst makeLtHashGenerator = ({\n  indexValueMap,\n  hash\n}) => {\n  indexValueMap = {\n    ...indexValueMap\n  };\n  const addBuffs = [];\n  const subBuffs = [];\n  return {\n    mix: ({\n      indexMac,\n      valueMac,\n      operation\n    }) => {\n      const indexMacBase64 = Buffer.from(indexMac).toString('base64');\n      const prevOp = indexValueMap[indexMacBase64];\n      if (operation === WAProto_1.proto.SyncdMutation.SyncdOperation.REMOVE) {\n        if (!prevOp) {\n          throw new boom_1.Boom('tried remove, but no previous op', {\n            data: {\n              indexMac,\n              valueMac\n            }\n          });\n        }\n        // remove from index value mac, since this mutation is erased\n        delete indexValueMap[indexMacBase64];\n      } else {\n        addBuffs.push(new Uint8Array(valueMac).buffer);\n        // add this index into the history map\n        indexValueMap[indexMacBase64] = {\n          valueMac\n        };\n      }\n      if (prevOp) {\n        subBuffs.push(new Uint8Array(prevOp.valueMac).buffer);\n      }\n    },\n    finish: () => {\n      const hashArrayBuffer = new Uint8Array(hash).buffer;\n      const result = lt_hash_1.LT_HASH_ANTI_TAMPERING.subtractThenAdd(hashArrayBuffer, addBuffs, subBuffs);\n      const buffer = Buffer.from(result);\n      return {\n        hash: buffer,\n        indexValueMap\n      };\n    }\n  };\n};\nconst generateSnapshotMac = (lthash, version, name, key) => {\n  const total = Buffer.concat([lthash, to64BitNetworkOrder(version), Buffer.from(name, 'utf-8')]);\n  return (0, crypto_1.hmacSign)(total, key, 'sha256');\n};\nconst generatePatchMac = (snapshotMac, valueMacs, version, type, key) => {\n  const total = Buffer.concat([snapshotMac, ...valueMacs, to64BitNetworkOrder(version), Buffer.from(type, 'utf-8')]);\n  return (0, crypto_1.hmacSign)(total, key);\n};\nconst newLTHashState = () => ({\n  version: 0,\n  hash: Buffer.alloc(128),\n  indexValueMap: {}\n});\nexports.newLTHashState = newLTHashState;\nconst encodeSyncdPatch = async ({\n  type,\n  index,\n  syncAction,\n  apiVersion,\n  operation\n}, myAppStateKeyId, state, getAppStateSyncKey) => {\n  const key = !!myAppStateKeyId ? await getAppStateSyncKey(myAppStateKeyId) : undefined;\n  if (!key) {\n    throw new boom_1.Boom(`myAppStateKey (\"${myAppStateKeyId}\") not present`, {\n      statusCode: 404\n    });\n  }\n  const encKeyId = Buffer.from(myAppStateKeyId, 'base64');\n  state = {\n    ...state,\n    indexValueMap: {\n      ...state.indexValueMap\n    }\n  };\n  const indexBuffer = Buffer.from(JSON.stringify(index));\n  const dataProto = WAProto_1.proto.SyncActionData.fromObject({\n    index: indexBuffer,\n    value: syncAction,\n    padding: new Uint8Array(0),\n    version: apiVersion\n  });\n  const encoded = WAProto_1.proto.SyncActionData.encode(dataProto).finish();\n  const keyValue = mutationKeys(key.keyData);\n  const encValue = (0, crypto_1.aesEncrypt)(encoded, keyValue.valueEncryptionKey);\n  const valueMac = generateMac(operation, encValue, encKeyId, keyValue.valueMacKey);\n  const indexMac = (0, crypto_1.hmacSign)(indexBuffer, keyValue.indexKey);\n  // update LT hash\n  const generator = makeLtHashGenerator(state);\n  generator.mix({\n    indexMac,\n    valueMac,\n    operation\n  });\n  Object.assign(state, generator.finish());\n  state.version += 1;\n  const snapshotMac = generateSnapshotMac(state.hash, state.version, type, keyValue.snapshotMacKey);\n  const patch = {\n    patchMac: generatePatchMac(snapshotMac, [valueMac], state.version, type, keyValue.patchMacKey),\n    snapshotMac: snapshotMac,\n    keyId: {\n      id: encKeyId\n    },\n    mutations: [{\n      operation: operation,\n      record: {\n        index: {\n          blob: indexMac\n        },\n        value: {\n          blob: Buffer.concat([encValue, valueMac])\n        },\n        keyId: {\n          id: encKeyId\n        }\n      }\n    }]\n  };\n  const base64Index = indexMac.toString('base64');\n  state.indexValueMap[base64Index] = {\n    valueMac\n  };\n  return {\n    patch,\n    state\n  };\n};\nexports.encodeSyncdPatch = encodeSyncdPatch;\nconst decodeSyncdMutations = async (msgMutations, initialState, getAppStateSyncKey, onMutation, validateMacs) => {\n  const ltGenerator = makeLtHashGenerator(initialState);\n  // indexKey used to HMAC sign record.index.blob\n  // valueEncryptionKey used to AES-256-CBC encrypt record.value.blob[0:-32]\n  // the remaining record.value.blob[0:-32] is the mac, it the HMAC sign of key.keyId + decoded proto data + length of bytes in keyId\n  for (const msgMutation of msgMutations) {\n    // if it's a syncdmutation, get the operation property\n    // otherwise, if it's only a record -- it'll be a SET mutation\n    const operation = 'operation' in msgMutation ? msgMutation.operation : WAProto_1.proto.SyncdMutation.SyncdOperation.SET;\n    const record = 'record' in msgMutation && !!msgMutation.record ? msgMutation.record : msgMutation;\n    const key = await getKey(record.keyId.id);\n    const content = Buffer.from(record.value.blob);\n    const encContent = content.slice(0, -32);\n    const ogValueMac = content.slice(-32);\n    if (validateMacs) {\n      const contentHmac = generateMac(operation, encContent, record.keyId.id, key.valueMacKey);\n      if (Buffer.compare(contentHmac, ogValueMac) !== 0) {\n        throw new boom_1.Boom('HMAC content verification failed');\n      }\n    }\n    const result = (0, crypto_1.aesDecrypt)(encContent, key.valueEncryptionKey);\n    const syncAction = WAProto_1.proto.SyncActionData.decode(result);\n    if (validateMacs) {\n      const hmac = (0, crypto_1.hmacSign)(syncAction.index, key.indexKey);\n      if (Buffer.compare(hmac, record.index.blob) !== 0) {\n        throw new boom_1.Boom('HMAC index verification failed');\n      }\n    }\n    const indexStr = Buffer.from(syncAction.index).toString();\n    onMutation({\n      syncAction,\n      index: JSON.parse(indexStr)\n    });\n    ltGenerator.mix({\n      indexMac: record.index.blob,\n      valueMac: ogValueMac,\n      operation: operation\n    });\n  }\n  return ltGenerator.finish();\n  async function getKey(keyId) {\n    const base64Key = Buffer.from(keyId).toString('base64');\n    const keyEnc = await getAppStateSyncKey(base64Key);\n    if (!keyEnc) {\n      throw new boom_1.Boom(`failed to find key \"${base64Key}\" to decode mutation`, {\n        statusCode: 404,\n        data: {\n          msgMutations\n        }\n      });\n    }\n    return mutationKeys(keyEnc.keyData);\n  }\n};\nexports.decodeSyncdMutations = decodeSyncdMutations;\nconst decodeSyncdPatch = async (msg, name, initialState, getAppStateSyncKey, onMutation, validateMacs) => {\n  if (validateMacs) {\n    const base64Key = Buffer.from(msg.keyId.id).toString('base64');\n    const mainKeyObj = await getAppStateSyncKey(base64Key);\n    if (!mainKeyObj) {\n      throw new boom_1.Boom(`failed to find key \"${base64Key}\" to decode patch`, {\n        statusCode: 404,\n        data: {\n          msg\n        }\n      });\n    }\n    const mainKey = mutationKeys(mainKeyObj.keyData);\n    const mutationmacs = msg.mutations.map(mutation => mutation.record.value.blob.slice(-32));\n    const patchMac = generatePatchMac(msg.snapshotMac, mutationmacs, (0, generics_1.toNumber)(msg.version.version), name, mainKey.patchMacKey);\n    if (Buffer.compare(patchMac, msg.patchMac) !== 0) {\n      throw new boom_1.Boom('Invalid patch mac');\n    }\n  }\n  const result = await (0, exports.decodeSyncdMutations)(msg.mutations, initialState, getAppStateSyncKey, onMutation, validateMacs);\n  return result;\n};\nexports.decodeSyncdPatch = decodeSyncdPatch;\nconst extractSyncdPatches = async (result, options) => {\n  const syncNode = (0, WABinary_1.getBinaryNodeChild)(result, 'sync');\n  const collectionNodes = (0, WABinary_1.getBinaryNodeChildren)(syncNode, 'collection');\n  const final = {};\n  await Promise.all(collectionNodes.map(async collectionNode => {\n    const patchesNode = (0, WABinary_1.getBinaryNodeChild)(collectionNode, 'patches');\n    const patches = (0, WABinary_1.getBinaryNodeChildren)(patchesNode || collectionNode, 'patch');\n    const snapshotNode = (0, WABinary_1.getBinaryNodeChild)(collectionNode, 'snapshot');\n    const syncds = [];\n    const name = collectionNode.attrs.name;\n    const hasMorePatches = collectionNode.attrs.has_more_patches === 'true';\n    let snapshot = undefined;\n    if (snapshotNode && !!snapshotNode.content) {\n      if (!Buffer.isBuffer(snapshotNode)) {\n        snapshotNode.content = Buffer.from(Object.values(snapshotNode.content));\n      }\n      const blobRef = WAProto_1.proto.ExternalBlobReference.decode(snapshotNode.content);\n      const data = await (0, exports.downloadExternalBlob)(blobRef, options);\n      snapshot = WAProto_1.proto.SyncdSnapshot.decode(data);\n    }\n    for (let {\n      content\n    } of patches) {\n      if (content) {\n        if (!Buffer.isBuffer(content)) {\n          content = Buffer.from(Object.values(content));\n        }\n        const syncd = WAProto_1.proto.SyncdPatch.decode(content);\n        if (!syncd.version) {\n          syncd.version = {\n            version: +collectionNode.attrs.version + 1\n          };\n        }\n        syncds.push(syncd);\n      }\n    }\n    final[name] = {\n      patches: syncds,\n      hasMorePatches,\n      snapshot\n    };\n  }));\n  return final;\n};\nexports.extractSyncdPatches = extractSyncdPatches;\nconst downloadExternalBlob = async (blob, options) => {\n  const stream = await (0, messages_media_1.downloadContentFromMessage)(blob, 'md-app-state', {\n    options\n  });\n  const bufferArray = [];\n  for await (const chunk of stream) {\n    bufferArray.push(chunk);\n  }\n  return Buffer.concat(bufferArray);\n};\nexports.downloadExternalBlob = downloadExternalBlob;\nconst downloadExternalPatch = async (blob, options) => {\n  const buffer = await (0, exports.downloadExternalBlob)(blob, options);\n  const syncData = WAProto_1.proto.SyncdMutations.decode(buffer);\n  return syncData;\n};\nexports.downloadExternalPatch = downloadExternalPatch;\nconst decodeSyncdSnapshot = async (name, snapshot, getAppStateSyncKey, minimumVersionNumber, validateMacs = true) => {\n  const newState = (0, exports.newLTHashState)();\n  newState.version = (0, generics_1.toNumber)(snapshot.version.version);\n  const mutationMap = {};\n  const areMutationsRequired = typeof minimumVersionNumber === 'undefined' || newState.version > minimumVersionNumber;\n  const {\n    hash,\n    indexValueMap\n  } = await (0, exports.decodeSyncdMutations)(snapshot.records, newState, getAppStateSyncKey, areMutationsRequired ? mutation => {\n    var _a;\n    const index = (_a = mutation.syncAction.index) === null || _a === void 0 ? void 0 : _a.toString();\n    mutationMap[index] = mutation;\n  } : () => {}, validateMacs);\n  newState.hash = hash;\n  newState.indexValueMap = indexValueMap;\n  if (validateMacs) {\n    const base64Key = Buffer.from(snapshot.keyId.id).toString('base64');\n    const keyEnc = await getAppStateSyncKey(base64Key);\n    if (!keyEnc) {\n      throw new boom_1.Boom(`failed to find key \"${base64Key}\" to decode mutation`);\n    }\n    const result = mutationKeys(keyEnc.keyData);\n    const computedSnapshotMac = generateSnapshotMac(newState.hash, newState.version, name, result.snapshotMacKey);\n    if (Buffer.compare(snapshot.mac, computedSnapshotMac) !== 0) {\n      throw new boom_1.Boom(`failed to verify LTHash at ${newState.version} of ${name} from snapshot`);\n    }\n  }\n  return {\n    state: newState,\n    mutationMap\n  };\n};\nexports.decodeSyncdSnapshot = decodeSyncdSnapshot;\nconst decodePatches = async (name, syncds, initial, getAppStateSyncKey, options, minimumVersionNumber, logger, validateMacs = true) => {\n  var _a;\n  const newState = {\n    ...initial,\n    indexValueMap: {\n      ...initial.indexValueMap\n    }\n  };\n  const mutationMap = {};\n  for (let i = 0; i < syncds.length; i++) {\n    const syncd = syncds[i];\n    const {\n      version,\n      keyId,\n      snapshotMac\n    } = syncd;\n    if (syncd.externalMutations) {\n      logger === null || logger === void 0 ? void 0 : logger.trace({\n        name,\n        version\n      }, 'downloading external patch');\n      const ref = await (0, exports.downloadExternalPatch)(syncd.externalMutations, options);\n      logger === null || logger === void 0 ? void 0 : logger.debug({\n        name,\n        version,\n        mutations: ref.mutations.length\n      }, 'downloaded external patch');\n      (_a = syncd.mutations) === null || _a === void 0 ? void 0 : _a.push(...ref.mutations);\n    }\n    const patchVersion = (0, generics_1.toNumber)(version.version);\n    newState.version = patchVersion;\n    const shouldMutate = typeof minimumVersionNumber === 'undefined' || patchVersion > minimumVersionNumber;\n    const decodeResult = await (0, exports.decodeSyncdPatch)(syncd, name, newState, getAppStateSyncKey, shouldMutate ? mutation => {\n      var _a;\n      const index = (_a = mutation.syncAction.index) === null || _a === void 0 ? void 0 : _a.toString();\n      mutationMap[index] = mutation;\n    } : () => {}, true);\n    newState.hash = decodeResult.hash;\n    newState.indexValueMap = decodeResult.indexValueMap;\n    if (validateMacs) {\n      const base64Key = Buffer.from(keyId.id).toString('base64');\n      const keyEnc = await getAppStateSyncKey(base64Key);\n      if (!keyEnc) {\n        throw new boom_1.Boom(`failed to find key \"${base64Key}\" to decode mutation`);\n      }\n      const result = mutationKeys(keyEnc.keyData);\n      const computedSnapshotMac = generateSnapshotMac(newState.hash, newState.version, name, result.snapshotMacKey);\n      if (Buffer.compare(snapshotMac, computedSnapshotMac) !== 0) {\n        throw new boom_1.Boom(`failed to verify LTHash at ${newState.version} of ${name}`);\n      }\n    }\n    // clear memory used up by the mutations\n    syncd.mutations = [];\n  }\n  return {\n    state: newState,\n    mutationMap\n  };\n};\nexports.decodePatches = decodePatches;\nconst chatModificationToAppPatch = (mod, jid) => {\n  const OP = WAProto_1.proto.SyncdMutation.SyncdOperation;\n  const getMessageRange = lastMessages => {\n    let messageRange;\n    if (Array.isArray(lastMessages)) {\n      const lastMsg = lastMessages[lastMessages.length - 1];\n      messageRange = {\n        lastMessageTimestamp: lastMsg === null || lastMsg === void 0 ? void 0 : lastMsg.messageTimestamp,\n        messages: (lastMessages === null || lastMessages === void 0 ? void 0 : lastMessages.length) ? lastMessages.map(m => {\n          var _a, _b;\n          if (!((_a = m.key) === null || _a === void 0 ? void 0 : _a.id) || !((_b = m.key) === null || _b === void 0 ? void 0 : _b.remoteJid)) {\n            throw new boom_1.Boom('Incomplete key', {\n              statusCode: 400,\n              data: m\n            });\n          }\n          if ((0, WABinary_1.isJidGroup)(m.key.remoteJid) && !m.key.fromMe && !m.key.participant) {\n            throw new boom_1.Boom('Expected not from me message to have participant', {\n              statusCode: 400,\n              data: m\n            });\n          }\n          if (!m.messageTimestamp || !(0, generics_1.toNumber)(m.messageTimestamp)) {\n            throw new boom_1.Boom('Missing timestamp in last message list', {\n              statusCode: 400,\n              data: m\n            });\n          }\n          if (m.key.participant) {\n            m.key.participant = (0, WABinary_1.jidNormalizedUser)(m.key.participant);\n          }\n          return m;\n        }) : undefined\n      };\n    } else {\n      messageRange = lastMessages;\n    }\n    return messageRange;\n  };\n  let patch;\n  if ('mute' in mod) {\n    patch = {\n      syncAction: {\n        muteAction: {\n          muted: !!mod.mute,\n          muteEndTimestamp: mod.mute || undefined\n        }\n      },\n      index: ['mute', jid],\n      type: 'regular_high',\n      apiVersion: 2,\n      operation: OP.SET\n    };\n  } else if ('archive' in mod) {\n    patch = {\n      syncAction: {\n        archiveChatAction: {\n          archived: !!mod.archive,\n          messageRange: getMessageRange(mod.lastMessages)\n        }\n      },\n      index: ['archive', jid],\n      type: 'regular_low',\n      apiVersion: 3,\n      operation: OP.SET\n    };\n  } else if ('markRead' in mod) {\n    patch = {\n      syncAction: {\n        markChatAsReadAction: {\n          read: mod.markRead,\n          messageRange: getMessageRange(mod.lastMessages)\n        }\n      },\n      index: ['markChatAsRead', jid],\n      type: 'regular_low',\n      apiVersion: 3,\n      operation: OP.SET\n    };\n  } else if ('clear' in mod) {\n    if (mod.clear === 'all') {\n      throw new boom_1.Boom('not supported');\n    } else {\n      const key = mod.clear.messages[0];\n      patch = {\n        syncAction: {\n          deleteMessageForMeAction: {\n            deleteMedia: false,\n            messageTimestamp: key.timestamp\n          }\n        },\n        index: ['deleteMessageForMe', jid, key.id, key.fromMe ? '1' : '0', '0'],\n        type: 'regular_high',\n        apiVersion: 3,\n        operation: OP.SET\n      };\n    }\n  } else if ('pin' in mod) {\n    patch = {\n      syncAction: {\n        pinAction: {\n          pinned: !!mod.pin\n        }\n      },\n      index: ['pin_v1', jid],\n      type: 'regular_low',\n      apiVersion: 5,\n      operation: OP.SET\n    };\n  } else if ('star' in mod) {\n    const key = mod.star.messages[0];\n    patch = {\n      syncAction: {\n        starAction: {\n          starred: !!mod.star.star\n        }\n      },\n      index: ['star', jid, key.id, key.fromMe ? '1' : '0', '0'],\n      type: 'regular_low',\n      apiVersion: 2,\n      operation: OP.SET\n    };\n  } else if ('delete' in mod) {\n    patch = {\n      syncAction: {\n        deleteChatAction: {\n          messageRange: getMessageRange(mod.lastMessages)\n        }\n      },\n      index: ['deleteChat', jid, '1'],\n      type: 'regular_high',\n      apiVersion: 6,\n      operation: OP.SET\n    };\n  } else if ('pushNameSetting' in mod) {\n    patch = {\n      syncAction: {\n        pushNameSetting: {\n          name: mod.pushNameSetting\n        }\n      },\n      index: ['setting_pushName'],\n      type: 'critical_block',\n      apiVersion: 1,\n      operation: OP.SET\n    };\n  } else if ('addLabel' in mod) {\n    patch = {\n      syncAction: {\n        labelEditAction: {\n          name: mod.addLabel.name,\n          color: mod.addLabel.color,\n          predefinedId: mod.addLabel.predefinedId,\n          deleted: mod.addLabel.deleted\n        }\n      },\n      index: ['label_edit', mod.addLabel.id],\n      type: 'regular',\n      apiVersion: 3,\n      operation: OP.SET\n    };\n  } else if ('addChatLabel' in mod) {\n    patch = {\n      syncAction: {\n        labelAssociationAction: {\n          labeled: true\n        }\n      },\n      index: [LabelAssociation_1.LabelAssociationType.Chat, mod.addChatLabel.labelId, jid],\n      type: 'regular',\n      apiVersion: 3,\n      operation: OP.SET\n    };\n  } else if ('removeChatLabel' in mod) {\n    patch = {\n      syncAction: {\n        labelAssociationAction: {\n          labeled: false\n        }\n      },\n      index: [LabelAssociation_1.LabelAssociationType.Chat, mod.removeChatLabel.labelId, jid],\n      type: 'regular',\n      apiVersion: 3,\n      operation: OP.SET\n    };\n  } else if ('addMessageLabel' in mod) {\n    patch = {\n      syncAction: {\n        labelAssociationAction: {\n          labeled: true\n        }\n      },\n      index: [LabelAssociation_1.LabelAssociationType.Message, mod.addMessageLabel.labelId, jid, mod.addMessageLabel.messageId, '0', '0'],\n      type: 'regular',\n      apiVersion: 3,\n      operation: OP.SET\n    };\n  } else if ('removeMessageLabel' in mod) {\n    patch = {\n      syncAction: {\n        labelAssociationAction: {\n          labeled: false\n        }\n      },\n      index: [LabelAssociation_1.LabelAssociationType.Message, mod.removeMessageLabel.labelId, jid, mod.removeMessageLabel.messageId, '0', '0'],\n      type: 'regular',\n      apiVersion: 3,\n      operation: OP.SET\n    };\n  } else {\n    throw new boom_1.Boom('not supported');\n  }\n  patch.syncAction.timestamp = Date.now();\n  return patch;\n};\nexports.chatModificationToAppPatch = chatModificationToAppPatch;\nconst processSyncAction = (syncAction, ev, me, initialSyncOpts, logger) => {\n  var _a, _b, _c, _d;\n  const isInitialSync = !!initialSyncOpts;\n  const accountSettings = initialSyncOpts === null || initialSyncOpts === void 0 ? void 0 : initialSyncOpts.accountSettings;\n  logger === null || logger === void 0 ? void 0 : logger.trace({\n    syncAction,\n    initialSync: !!initialSyncOpts\n  }, 'processing sync action');\n  const {\n    syncAction: {\n      value: action\n    },\n    index: [type, id, msgId, fromMe]\n  } = syncAction;\n  if (action === null || action === void 0 ? void 0 : action.muteAction) {\n    ev.emit('chats.update', [{\n      id,\n      muteEndTime: ((_a = action.muteAction) === null || _a === void 0 ? void 0 : _a.muted) ? (0, generics_1.toNumber)(action.muteAction.muteEndTimestamp) : null,\n      conditional: getChatUpdateConditional(id, undefined)\n    }]);\n  } else if ((action === null || action === void 0 ? void 0 : action.archiveChatAction) || type === 'archive' || type === 'unarchive') {\n    // okay so we've to do some annoying computation here\n    // when we're initially syncing the app state\n    // there are a few cases we need to handle\n    // 1. if the account unarchiveChats setting is true\n    //   a. if the chat is archived, and no further messages have been received -- simple, keep archived\n    //   b. if the chat was archived, and the user received messages from the other person afterwards\n    //\t\tthen the chat should be marked unarchved --\n    //\t\twe compare the timestamp of latest message from the other person to determine this\n    // 2. if the account unarchiveChats setting is false -- then it doesn't matter,\n    //\tit'll always take an app state action to mark in unarchived -- which we'll get anyway\n    const archiveAction = action === null || action === void 0 ? void 0 : action.archiveChatAction;\n    const isArchived = archiveAction ? archiveAction.archived : type === 'archive';\n    // // basically we don't need to fire an \"archive\" update if the chat is being marked unarchvied\n    // // this only applies for the initial sync\n    // if(isInitialSync && !isArchived) {\n    // \tisArchived = false\n    // }\n    const msgRange = !(accountSettings === null || accountSettings === void 0 ? void 0 : accountSettings.unarchiveChats) ? undefined : archiveAction === null || archiveAction === void 0 ? void 0 : archiveAction.messageRange;\n    // logger?.debug({ chat: id, syncAction }, 'message range archive')\n    ev.emit('chats.update', [{\n      id,\n      archived: isArchived,\n      conditional: getChatUpdateConditional(id, msgRange)\n    }]);\n  } else if (action === null || action === void 0 ? void 0 : action.markChatAsReadAction) {\n    const markReadAction = action.markChatAsReadAction;\n    // basically we don't need to fire an \"read\" update if the chat is being marked as read\n    // because the chat is read by default\n    // this only applies for the initial sync\n    const isNullUpdate = isInitialSync && markReadAction.read;\n    ev.emit('chats.update', [{\n      id,\n      unreadCount: isNullUpdate ? null : !!(markReadAction === null || markReadAction === void 0 ? void 0 : markReadAction.read) ? 0 : -1,\n      conditional: getChatUpdateConditional(id, markReadAction === null || markReadAction === void 0 ? void 0 : markReadAction.messageRange)\n    }]);\n  } else if ((action === null || action === void 0 ? void 0 : action.deleteMessageForMeAction) || type === 'deleteMessageForMe') {\n    ev.emit('messages.delete', {\n      keys: [{\n        remoteJid: id,\n        id: msgId,\n        fromMe: fromMe === '1'\n      }]\n    });\n  } else if (action === null || action === void 0 ? void 0 : action.contactAction) {\n    ev.emit('contacts.upsert', [{\n      id,\n      name: action.contactAction.fullName\n    }]);\n  } else if (action === null || action === void 0 ? void 0 : action.pushNameSetting) {\n    const name = (_b = action === null || action === void 0 ? void 0 : action.pushNameSetting) === null || _b === void 0 ? void 0 : _b.name;\n    if (name && (me === null || me === void 0 ? void 0 : me.name) !== name) {\n      ev.emit('creds.update', {\n        me: {\n          ...me,\n          name\n        }\n      });\n    }\n  } else if (action === null || action === void 0 ? void 0 : action.pinAction) {\n    ev.emit('chats.update', [{\n      id,\n      pinned: ((_c = action.pinAction) === null || _c === void 0 ? void 0 : _c.pinned) ? (0, generics_1.toNumber)(action.timestamp) : null,\n      conditional: getChatUpdateConditional(id, undefined)\n    }]);\n  } else if (action === null || action === void 0 ? void 0 : action.unarchiveChatsSetting) {\n    const unarchiveChats = !!action.unarchiveChatsSetting.unarchiveChats;\n    ev.emit('creds.update', {\n      accountSettings: {\n        unarchiveChats\n      }\n    });\n    logger === null || logger === void 0 ? void 0 : logger.info(`archive setting updated => '${action.unarchiveChatsSetting.unarchiveChats}'`);\n    if (accountSettings) {\n      accountSettings.unarchiveChats = unarchiveChats;\n    }\n  } else if ((action === null || action === void 0 ? void 0 : action.starAction) || type === 'star') {\n    let starred = (_d = action === null || action === void 0 ? void 0 : action.starAction) === null || _d === void 0 ? void 0 : _d.starred;\n    if (typeof starred !== 'boolean') {\n      starred = syncAction.index[syncAction.index.length - 1] === '1';\n    }\n    ev.emit('messages.update', [{\n      key: {\n        remoteJid: id,\n        id: msgId,\n        fromMe: fromMe === '1'\n      },\n      update: {\n        starred\n      }\n    }]);\n  } else if ((action === null || action === void 0 ? void 0 : action.deleteChatAction) || type === 'deleteChat') {\n    if (!isInitialSync) {\n      ev.emit('chats.delete', [id]);\n    }\n  } else if (action === null || action === void 0 ? void 0 : action.labelEditAction) {\n    const {\n      name,\n      color,\n      deleted,\n      predefinedId\n    } = action.labelEditAction;\n    ev.emit('labels.edit', {\n      id,\n      name: name,\n      color: color,\n      deleted: deleted,\n      predefinedId: predefinedId ? String(predefinedId) : undefined\n    });\n  } else if (action === null || action === void 0 ? void 0 : action.labelAssociationAction) {\n    ev.emit('labels.association', {\n      type: action.labelAssociationAction.labeled ? 'add' : 'remove',\n      association: type === LabelAssociation_1.LabelAssociationType.Chat ? {\n        type: LabelAssociation_1.LabelAssociationType.Chat,\n        chatId: syncAction.index[2],\n        labelId: syncAction.index[1]\n      } : {\n        type: LabelAssociation_1.LabelAssociationType.Message,\n        chatId: syncAction.index[2],\n        messageId: syncAction.index[3],\n        labelId: syncAction.index[1]\n      }\n    });\n  } else {\n    logger === null || logger === void 0 ? void 0 : logger.debug({\n      syncAction,\n      id\n    }, 'unprocessable update');\n  }\n  function getChatUpdateConditional(id, msgRange) {\n    return isInitialSync ? data => {\n      const chat = data.historySets.chats[id] || data.chatUpserts[id];\n      if (chat) {\n        return msgRange ? isValidPatchBasedOnMessageRange(chat, msgRange) : true;\n      }\n    } : undefined;\n  }\n  function isValidPatchBasedOnMessageRange(chat, msgRange) {\n    const lastMsgTimestamp = Number((msgRange === null || msgRange === void 0 ? void 0 : msgRange.lastMessageTimestamp) || (msgRange === null || msgRange === void 0 ? void 0 : msgRange.lastSystemMessageTimestamp) || 0);\n    const chatLastMsgTimestamp = Number((chat === null || chat === void 0 ? void 0 : chat.lastMessageRecvTimestamp) || 0);\n    return lastMsgTimestamp >= chatLastMsgTimestamp;\n  }\n};\nexports.processSyncAction = processSyncAction;","map":{"version":3,"names":["Object","defineProperty","exports","value","processSyncAction","chatModificationToAppPatch","decodePatches","decodeSyncdSnapshot","downloadExternalPatch","downloadExternalBlob","extractSyncdPatches","decodeSyncdPatch","decodeSyncdMutations","encodeSyncdPatch","newLTHashState","boom_1","require","WAProto_1","LabelAssociation_1","WABinary_1","crypto_1","generics_1","lt_hash_1","messages_media_1","mutationKeys","keydata","expanded","hkdf","info","indexKey","slice","valueEncryptionKey","valueMacKey","snapshotMacKey","patchMacKey","generateMac","operation","data","keyId","key","getKeyData","r","proto","SyncdMutation","SyncdOperation","SET","REMOVE","buff","Buffer","from","concat","keyData","last","alloc","set","length","total","hmac","hmacSign","to64BitNetworkOrder","e","writeUint32BE","makeLtHashGenerator","indexValueMap","hash","addBuffs","subBuffs","mix","indexMac","valueMac","indexMacBase64","toString","prevOp","Boom","push","Uint8Array","buffer","finish","hashArrayBuffer","result","LT_HASH_ANTI_TAMPERING","subtractThenAdd","generateSnapshotMac","lthash","version","name","generatePatchMac","snapshotMac","valueMacs","type","index","syncAction","apiVersion","myAppStateKeyId","state","getAppStateSyncKey","undefined","statusCode","encKeyId","indexBuffer","JSON","stringify","dataProto","SyncActionData","fromObject","padding","encoded","encode","keyValue","encValue","aesEncrypt","generator","assign","patch","patchMac","id","mutations","record","blob","base64Index","msgMutations","initialState","onMutation","validateMacs","ltGenerator","msgMutation","getKey","content","encContent","ogValueMac","contentHmac","compare","aesDecrypt","decode","indexStr","parse","base64Key","keyEnc","msg","mainKeyObj","mainKey","mutationmacs","map","mutation","toNumber","options","syncNode","getBinaryNodeChild","collectionNodes","getBinaryNodeChildren","final","Promise","all","collectionNode","patchesNode","patches","snapshotNode","syncds","attrs","hasMorePatches","has_more_patches","snapshot","isBuffer","values","blobRef","ExternalBlobReference","SyncdSnapshot","syncd","SyncdPatch","stream","downloadContentFromMessage","bufferArray","chunk","syncData","SyncdMutations","minimumVersionNumber","newState","mutationMap","areMutationsRequired","records","_a","computedSnapshotMac","mac","initial","logger","i","externalMutations","trace","ref","debug","patchVersion","shouldMutate","decodeResult","mod","jid","OP","getMessageRange","lastMessages","messageRange","Array","isArray","lastMsg","lastMessageTimestamp","messageTimestamp","messages","m","_b","remoteJid","isJidGroup","fromMe","participant","jidNormalizedUser","muteAction","muted","mute","muteEndTimestamp","archiveChatAction","archived","archive","markChatAsReadAction","read","markRead","clear","deleteMessageForMeAction","deleteMedia","timestamp","pinAction","pinned","pin","star","starAction","starred","deleteChatAction","pushNameSetting","labelEditAction","addLabel","color","predefinedId","deleted","labelAssociationAction","labeled","LabelAssociationType","Chat","addChatLabel","labelId","removeChatLabel","Message","addMessageLabel","messageId","removeMessageLabel","Date","now","ev","me","initialSyncOpts","_c","_d","isInitialSync","accountSettings","initialSync","action","msgId","emit","muteEndTime","conditional","getChatUpdateConditional","archiveAction","isArchived","msgRange","unarchiveChats","markReadAction","isNullUpdate","unreadCount","keys","contactAction","fullName","unarchiveChatsSetting","update","String","association","chatId","chat","historySets","chats","chatUpserts","isValidPatchBasedOnMessageRange","lastMsgTimestamp","Number","lastSystemMessageTimestamp","chatLastMsgTimestamp","lastMessageRecvTimestamp"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Utils/chat-utils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.processSyncAction = exports.chatModificationToAppPatch = exports.decodePatches = exports.decodeSyncdSnapshot = exports.downloadExternalPatch = exports.downloadExternalBlob = exports.extractSyncdPatches = exports.decodeSyncdPatch = exports.decodeSyncdMutations = exports.encodeSyncdPatch = exports.newLTHashState = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst WAProto_1 = require(\"../../WAProto\");\nconst LabelAssociation_1 = require(\"../Types/LabelAssociation\");\nconst WABinary_1 = require(\"../WABinary\");\nconst crypto_1 = require(\"./crypto\");\nconst generics_1 = require(\"./generics\");\nconst lt_hash_1 = require(\"./lt-hash\");\nconst messages_media_1 = require(\"./messages-media\");\nconst mutationKeys = (keydata) => {\n    const expanded = (0, crypto_1.hkdf)(keydata, 160, { info: 'WhatsApp Mutation Keys' });\n    return {\n        indexKey: expanded.slice(0, 32),\n        valueEncryptionKey: expanded.slice(32, 64),\n        valueMacKey: expanded.slice(64, 96),\n        snapshotMacKey: expanded.slice(96, 128),\n        patchMacKey: expanded.slice(128, 160)\n    };\n};\nconst generateMac = (operation, data, keyId, key) => {\n    const getKeyData = () => {\n        let r;\n        switch (operation) {\n            case WAProto_1.proto.SyncdMutation.SyncdOperation.SET:\n                r = 0x01;\n                break;\n            case WAProto_1.proto.SyncdMutation.SyncdOperation.REMOVE:\n                r = 0x02;\n                break;\n        }\n        const buff = Buffer.from([r]);\n        return Buffer.concat([buff, Buffer.from(keyId, 'base64')]);\n    };\n    const keyData = getKeyData();\n    const last = Buffer.alloc(8); // 8 bytes\n    last.set([keyData.length], last.length - 1);\n    const total = Buffer.concat([keyData, data, last]);\n    const hmac = (0, crypto_1.hmacSign)(total, key, 'sha512');\n    return hmac.slice(0, 32);\n};\nconst to64BitNetworkOrder = (e) => {\n    const buff = Buffer.alloc(8);\n    buff.writeUint32BE(e, 4);\n    return buff;\n};\nconst makeLtHashGenerator = ({ indexValueMap, hash }) => {\n    indexValueMap = { ...indexValueMap };\n    const addBuffs = [];\n    const subBuffs = [];\n    return {\n        mix: ({ indexMac, valueMac, operation }) => {\n            const indexMacBase64 = Buffer.from(indexMac).toString('base64');\n            const prevOp = indexValueMap[indexMacBase64];\n            if (operation === WAProto_1.proto.SyncdMutation.SyncdOperation.REMOVE) {\n                if (!prevOp) {\n                    throw new boom_1.Boom('tried remove, but no previous op', { data: { indexMac, valueMac } });\n                }\n                // remove from index value mac, since this mutation is erased\n                delete indexValueMap[indexMacBase64];\n            }\n            else {\n                addBuffs.push(new Uint8Array(valueMac).buffer);\n                // add this index into the history map\n                indexValueMap[indexMacBase64] = { valueMac };\n            }\n            if (prevOp) {\n                subBuffs.push(new Uint8Array(prevOp.valueMac).buffer);\n            }\n        },\n        finish: () => {\n            const hashArrayBuffer = new Uint8Array(hash).buffer;\n            const result = lt_hash_1.LT_HASH_ANTI_TAMPERING.subtractThenAdd(hashArrayBuffer, addBuffs, subBuffs);\n            const buffer = Buffer.from(result);\n            return {\n                hash: buffer,\n                indexValueMap\n            };\n        }\n    };\n};\nconst generateSnapshotMac = (lthash, version, name, key) => {\n    const total = Buffer.concat([\n        lthash,\n        to64BitNetworkOrder(version),\n        Buffer.from(name, 'utf-8')\n    ]);\n    return (0, crypto_1.hmacSign)(total, key, 'sha256');\n};\nconst generatePatchMac = (snapshotMac, valueMacs, version, type, key) => {\n    const total = Buffer.concat([\n        snapshotMac,\n        ...valueMacs,\n        to64BitNetworkOrder(version),\n        Buffer.from(type, 'utf-8')\n    ]);\n    return (0, crypto_1.hmacSign)(total, key);\n};\nconst newLTHashState = () => ({ version: 0, hash: Buffer.alloc(128), indexValueMap: {} });\nexports.newLTHashState = newLTHashState;\nconst encodeSyncdPatch = async ({ type, index, syncAction, apiVersion, operation }, myAppStateKeyId, state, getAppStateSyncKey) => {\n    const key = !!myAppStateKeyId ? await getAppStateSyncKey(myAppStateKeyId) : undefined;\n    if (!key) {\n        throw new boom_1.Boom(`myAppStateKey (\"${myAppStateKeyId}\") not present`, { statusCode: 404 });\n    }\n    const encKeyId = Buffer.from(myAppStateKeyId, 'base64');\n    state = { ...state, indexValueMap: { ...state.indexValueMap } };\n    const indexBuffer = Buffer.from(JSON.stringify(index));\n    const dataProto = WAProto_1.proto.SyncActionData.fromObject({\n        index: indexBuffer,\n        value: syncAction,\n        padding: new Uint8Array(0),\n        version: apiVersion\n    });\n    const encoded = WAProto_1.proto.SyncActionData.encode(dataProto).finish();\n    const keyValue = mutationKeys(key.keyData);\n    const encValue = (0, crypto_1.aesEncrypt)(encoded, keyValue.valueEncryptionKey);\n    const valueMac = generateMac(operation, encValue, encKeyId, keyValue.valueMacKey);\n    const indexMac = (0, crypto_1.hmacSign)(indexBuffer, keyValue.indexKey);\n    // update LT hash\n    const generator = makeLtHashGenerator(state);\n    generator.mix({ indexMac, valueMac, operation });\n    Object.assign(state, generator.finish());\n    state.version += 1;\n    const snapshotMac = generateSnapshotMac(state.hash, state.version, type, keyValue.snapshotMacKey);\n    const patch = {\n        patchMac: generatePatchMac(snapshotMac, [valueMac], state.version, type, keyValue.patchMacKey),\n        snapshotMac: snapshotMac,\n        keyId: { id: encKeyId },\n        mutations: [\n            {\n                operation: operation,\n                record: {\n                    index: {\n                        blob: indexMac\n                    },\n                    value: {\n                        blob: Buffer.concat([encValue, valueMac])\n                    },\n                    keyId: { id: encKeyId }\n                }\n            }\n        ]\n    };\n    const base64Index = indexMac.toString('base64');\n    state.indexValueMap[base64Index] = { valueMac };\n    return { patch, state };\n};\nexports.encodeSyncdPatch = encodeSyncdPatch;\nconst decodeSyncdMutations = async (msgMutations, initialState, getAppStateSyncKey, onMutation, validateMacs) => {\n    const ltGenerator = makeLtHashGenerator(initialState);\n    // indexKey used to HMAC sign record.index.blob\n    // valueEncryptionKey used to AES-256-CBC encrypt record.value.blob[0:-32]\n    // the remaining record.value.blob[0:-32] is the mac, it the HMAC sign of key.keyId + decoded proto data + length of bytes in keyId\n    for (const msgMutation of msgMutations) {\n        // if it's a syncdmutation, get the operation property\n        // otherwise, if it's only a record -- it'll be a SET mutation\n        const operation = 'operation' in msgMutation ? msgMutation.operation : WAProto_1.proto.SyncdMutation.SyncdOperation.SET;\n        const record = ('record' in msgMutation && !!msgMutation.record) ? msgMutation.record : msgMutation;\n        const key = await getKey(record.keyId.id);\n        const content = Buffer.from(record.value.blob);\n        const encContent = content.slice(0, -32);\n        const ogValueMac = content.slice(-32);\n        if (validateMacs) {\n            const contentHmac = generateMac(operation, encContent, record.keyId.id, key.valueMacKey);\n            if (Buffer.compare(contentHmac, ogValueMac) !== 0) {\n                throw new boom_1.Boom('HMAC content verification failed');\n            }\n        }\n        const result = (0, crypto_1.aesDecrypt)(encContent, key.valueEncryptionKey);\n        const syncAction = WAProto_1.proto.SyncActionData.decode(result);\n        if (validateMacs) {\n            const hmac = (0, crypto_1.hmacSign)(syncAction.index, key.indexKey);\n            if (Buffer.compare(hmac, record.index.blob) !== 0) {\n                throw new boom_1.Boom('HMAC index verification failed');\n            }\n        }\n        const indexStr = Buffer.from(syncAction.index).toString();\n        onMutation({ syncAction, index: JSON.parse(indexStr) });\n        ltGenerator.mix({\n            indexMac: record.index.blob,\n            valueMac: ogValueMac,\n            operation: operation\n        });\n    }\n    return ltGenerator.finish();\n    async function getKey(keyId) {\n        const base64Key = Buffer.from(keyId).toString('base64');\n        const keyEnc = await getAppStateSyncKey(base64Key);\n        if (!keyEnc) {\n            throw new boom_1.Boom(`failed to find key \"${base64Key}\" to decode mutation`, { statusCode: 404, data: { msgMutations } });\n        }\n        return mutationKeys(keyEnc.keyData);\n    }\n};\nexports.decodeSyncdMutations = decodeSyncdMutations;\nconst decodeSyncdPatch = async (msg, name, initialState, getAppStateSyncKey, onMutation, validateMacs) => {\n    if (validateMacs) {\n        const base64Key = Buffer.from(msg.keyId.id).toString('base64');\n        const mainKeyObj = await getAppStateSyncKey(base64Key);\n        if (!mainKeyObj) {\n            throw new boom_1.Boom(`failed to find key \"${base64Key}\" to decode patch`, { statusCode: 404, data: { msg } });\n        }\n        const mainKey = mutationKeys(mainKeyObj.keyData);\n        const mutationmacs = msg.mutations.map(mutation => mutation.record.value.blob.slice(-32));\n        const patchMac = generatePatchMac(msg.snapshotMac, mutationmacs, (0, generics_1.toNumber)(msg.version.version), name, mainKey.patchMacKey);\n        if (Buffer.compare(patchMac, msg.patchMac) !== 0) {\n            throw new boom_1.Boom('Invalid patch mac');\n        }\n    }\n    const result = await (0, exports.decodeSyncdMutations)(msg.mutations, initialState, getAppStateSyncKey, onMutation, validateMacs);\n    return result;\n};\nexports.decodeSyncdPatch = decodeSyncdPatch;\nconst extractSyncdPatches = async (result, options) => {\n    const syncNode = (0, WABinary_1.getBinaryNodeChild)(result, 'sync');\n    const collectionNodes = (0, WABinary_1.getBinaryNodeChildren)(syncNode, 'collection');\n    const final = {};\n    await Promise.all(collectionNodes.map(async (collectionNode) => {\n        const patchesNode = (0, WABinary_1.getBinaryNodeChild)(collectionNode, 'patches');\n        const patches = (0, WABinary_1.getBinaryNodeChildren)(patchesNode || collectionNode, 'patch');\n        const snapshotNode = (0, WABinary_1.getBinaryNodeChild)(collectionNode, 'snapshot');\n        const syncds = [];\n        const name = collectionNode.attrs.name;\n        const hasMorePatches = collectionNode.attrs.has_more_patches === 'true';\n        let snapshot = undefined;\n        if (snapshotNode && !!snapshotNode.content) {\n            if (!Buffer.isBuffer(snapshotNode)) {\n                snapshotNode.content = Buffer.from(Object.values(snapshotNode.content));\n            }\n            const blobRef = WAProto_1.proto.ExternalBlobReference.decode(snapshotNode.content);\n            const data = await (0, exports.downloadExternalBlob)(blobRef, options);\n            snapshot = WAProto_1.proto.SyncdSnapshot.decode(data);\n        }\n        for (let { content } of patches) {\n            if (content) {\n                if (!Buffer.isBuffer(content)) {\n                    content = Buffer.from(Object.values(content));\n                }\n                const syncd = WAProto_1.proto.SyncdPatch.decode(content);\n                if (!syncd.version) {\n                    syncd.version = { version: +collectionNode.attrs.version + 1 };\n                }\n                syncds.push(syncd);\n            }\n        }\n        final[name] = { patches: syncds, hasMorePatches, snapshot };\n    }));\n    return final;\n};\nexports.extractSyncdPatches = extractSyncdPatches;\nconst downloadExternalBlob = async (blob, options) => {\n    const stream = await (0, messages_media_1.downloadContentFromMessage)(blob, 'md-app-state', { options });\n    const bufferArray = [];\n    for await (const chunk of stream) {\n        bufferArray.push(chunk);\n    }\n    return Buffer.concat(bufferArray);\n};\nexports.downloadExternalBlob = downloadExternalBlob;\nconst downloadExternalPatch = async (blob, options) => {\n    const buffer = await (0, exports.downloadExternalBlob)(blob, options);\n    const syncData = WAProto_1.proto.SyncdMutations.decode(buffer);\n    return syncData;\n};\nexports.downloadExternalPatch = downloadExternalPatch;\nconst decodeSyncdSnapshot = async (name, snapshot, getAppStateSyncKey, minimumVersionNumber, validateMacs = true) => {\n    const newState = (0, exports.newLTHashState)();\n    newState.version = (0, generics_1.toNumber)(snapshot.version.version);\n    const mutationMap = {};\n    const areMutationsRequired = typeof minimumVersionNumber === 'undefined'\n        || newState.version > minimumVersionNumber;\n    const { hash, indexValueMap } = await (0, exports.decodeSyncdMutations)(snapshot.records, newState, getAppStateSyncKey, areMutationsRequired\n        ? (mutation) => {\n            var _a;\n            const index = (_a = mutation.syncAction.index) === null || _a === void 0 ? void 0 : _a.toString();\n            mutationMap[index] = mutation;\n        }\n        : () => { }, validateMacs);\n    newState.hash = hash;\n    newState.indexValueMap = indexValueMap;\n    if (validateMacs) {\n        const base64Key = Buffer.from(snapshot.keyId.id).toString('base64');\n        const keyEnc = await getAppStateSyncKey(base64Key);\n        if (!keyEnc) {\n            throw new boom_1.Boom(`failed to find key \"${base64Key}\" to decode mutation`);\n        }\n        const result = mutationKeys(keyEnc.keyData);\n        const computedSnapshotMac = generateSnapshotMac(newState.hash, newState.version, name, result.snapshotMacKey);\n        if (Buffer.compare(snapshot.mac, computedSnapshotMac) !== 0) {\n            throw new boom_1.Boom(`failed to verify LTHash at ${newState.version} of ${name} from snapshot`);\n        }\n    }\n    return {\n        state: newState,\n        mutationMap\n    };\n};\nexports.decodeSyncdSnapshot = decodeSyncdSnapshot;\nconst decodePatches = async (name, syncds, initial, getAppStateSyncKey, options, minimumVersionNumber, logger, validateMacs = true) => {\n    var _a;\n    const newState = {\n        ...initial,\n        indexValueMap: { ...initial.indexValueMap }\n    };\n    const mutationMap = {};\n    for (let i = 0; i < syncds.length; i++) {\n        const syncd = syncds[i];\n        const { version, keyId, snapshotMac } = syncd;\n        if (syncd.externalMutations) {\n            logger === null || logger === void 0 ? void 0 : logger.trace({ name, version }, 'downloading external patch');\n            const ref = await (0, exports.downloadExternalPatch)(syncd.externalMutations, options);\n            logger === null || logger === void 0 ? void 0 : logger.debug({ name, version, mutations: ref.mutations.length }, 'downloaded external patch');\n            (_a = syncd.mutations) === null || _a === void 0 ? void 0 : _a.push(...ref.mutations);\n        }\n        const patchVersion = (0, generics_1.toNumber)(version.version);\n        newState.version = patchVersion;\n        const shouldMutate = typeof minimumVersionNumber === 'undefined' || patchVersion > minimumVersionNumber;\n        const decodeResult = await (0, exports.decodeSyncdPatch)(syncd, name, newState, getAppStateSyncKey, shouldMutate\n            ? mutation => {\n                var _a;\n                const index = (_a = mutation.syncAction.index) === null || _a === void 0 ? void 0 : _a.toString();\n                mutationMap[index] = mutation;\n            }\n            : (() => { }), true);\n        newState.hash = decodeResult.hash;\n        newState.indexValueMap = decodeResult.indexValueMap;\n        if (validateMacs) {\n            const base64Key = Buffer.from(keyId.id).toString('base64');\n            const keyEnc = await getAppStateSyncKey(base64Key);\n            if (!keyEnc) {\n                throw new boom_1.Boom(`failed to find key \"${base64Key}\" to decode mutation`);\n            }\n            const result = mutationKeys(keyEnc.keyData);\n            const computedSnapshotMac = generateSnapshotMac(newState.hash, newState.version, name, result.snapshotMacKey);\n            if (Buffer.compare(snapshotMac, computedSnapshotMac) !== 0) {\n                throw new boom_1.Boom(`failed to verify LTHash at ${newState.version} of ${name}`);\n            }\n        }\n        // clear memory used up by the mutations\n        syncd.mutations = [];\n    }\n    return { state: newState, mutationMap };\n};\nexports.decodePatches = decodePatches;\nconst chatModificationToAppPatch = (mod, jid) => {\n    const OP = WAProto_1.proto.SyncdMutation.SyncdOperation;\n    const getMessageRange = (lastMessages) => {\n        let messageRange;\n        if (Array.isArray(lastMessages)) {\n            const lastMsg = lastMessages[lastMessages.length - 1];\n            messageRange = {\n                lastMessageTimestamp: lastMsg === null || lastMsg === void 0 ? void 0 : lastMsg.messageTimestamp,\n                messages: (lastMessages === null || lastMessages === void 0 ? void 0 : lastMessages.length) ? lastMessages.map(m => {\n                    var _a, _b;\n                    if (!((_a = m.key) === null || _a === void 0 ? void 0 : _a.id) || !((_b = m.key) === null || _b === void 0 ? void 0 : _b.remoteJid)) {\n                        throw new boom_1.Boom('Incomplete key', { statusCode: 400, data: m });\n                    }\n                    if ((0, WABinary_1.isJidGroup)(m.key.remoteJid) && !m.key.fromMe && !m.key.participant) {\n                        throw new boom_1.Boom('Expected not from me message to have participant', { statusCode: 400, data: m });\n                    }\n                    if (!m.messageTimestamp || !(0, generics_1.toNumber)(m.messageTimestamp)) {\n                        throw new boom_1.Boom('Missing timestamp in last message list', { statusCode: 400, data: m });\n                    }\n                    if (m.key.participant) {\n                        m.key.participant = (0, WABinary_1.jidNormalizedUser)(m.key.participant);\n                    }\n                    return m;\n                }) : undefined\n            };\n        }\n        else {\n            messageRange = lastMessages;\n        }\n        return messageRange;\n    };\n    let patch;\n    if ('mute' in mod) {\n        patch = {\n            syncAction: {\n                muteAction: {\n                    muted: !!mod.mute,\n                    muteEndTimestamp: mod.mute || undefined\n                }\n            },\n            index: ['mute', jid],\n            type: 'regular_high',\n            apiVersion: 2,\n            operation: OP.SET\n        };\n    }\n    else if ('archive' in mod) {\n        patch = {\n            syncAction: {\n                archiveChatAction: {\n                    archived: !!mod.archive,\n                    messageRange: getMessageRange(mod.lastMessages)\n                }\n            },\n            index: ['archive', jid],\n            type: 'regular_low',\n            apiVersion: 3,\n            operation: OP.SET\n        };\n    }\n    else if ('markRead' in mod) {\n        patch = {\n            syncAction: {\n                markChatAsReadAction: {\n                    read: mod.markRead,\n                    messageRange: getMessageRange(mod.lastMessages)\n                }\n            },\n            index: ['markChatAsRead', jid],\n            type: 'regular_low',\n            apiVersion: 3,\n            operation: OP.SET\n        };\n    }\n    else if ('clear' in mod) {\n        if (mod.clear === 'all') {\n            throw new boom_1.Boom('not supported');\n        }\n        else {\n            const key = mod.clear.messages[0];\n            patch = {\n                syncAction: {\n                    deleteMessageForMeAction: {\n                        deleteMedia: false,\n                        messageTimestamp: key.timestamp\n                    }\n                },\n                index: ['deleteMessageForMe', jid, key.id, key.fromMe ? '1' : '0', '0'],\n                type: 'regular_high',\n                apiVersion: 3,\n                operation: OP.SET\n            };\n        }\n    }\n    else if ('pin' in mod) {\n        patch = {\n            syncAction: {\n                pinAction: {\n                    pinned: !!mod.pin\n                }\n            },\n            index: ['pin_v1', jid],\n            type: 'regular_low',\n            apiVersion: 5,\n            operation: OP.SET\n        };\n    }\n    else if ('star' in mod) {\n        const key = mod.star.messages[0];\n        patch = {\n            syncAction: {\n                starAction: {\n                    starred: !!mod.star.star\n                }\n            },\n            index: ['star', jid, key.id, key.fromMe ? '1' : '0', '0'],\n            type: 'regular_low',\n            apiVersion: 2,\n            operation: OP.SET\n        };\n    }\n    else if ('delete' in mod) {\n        patch = {\n            syncAction: {\n                deleteChatAction: {\n                    messageRange: getMessageRange(mod.lastMessages),\n                }\n            },\n            index: ['deleteChat', jid, '1'],\n            type: 'regular_high',\n            apiVersion: 6,\n            operation: OP.SET\n        };\n    }\n    else if ('pushNameSetting' in mod) {\n        patch = {\n            syncAction: {\n                pushNameSetting: {\n                    name: mod.pushNameSetting\n                }\n            },\n            index: ['setting_pushName'],\n            type: 'critical_block',\n            apiVersion: 1,\n            operation: OP.SET,\n        };\n    }\n    else if ('addLabel' in mod) {\n        patch = {\n            syncAction: {\n                labelEditAction: {\n                    name: mod.addLabel.name,\n                    color: mod.addLabel.color,\n                    predefinedId: mod.addLabel.predefinedId,\n                    deleted: mod.addLabel.deleted\n                }\n            },\n            index: ['label_edit', mod.addLabel.id],\n            type: 'regular',\n            apiVersion: 3,\n            operation: OP.SET,\n        };\n    }\n    else if ('addChatLabel' in mod) {\n        patch = {\n            syncAction: {\n                labelAssociationAction: {\n                    labeled: true,\n                }\n            },\n            index: [LabelAssociation_1.LabelAssociationType.Chat, mod.addChatLabel.labelId, jid],\n            type: 'regular',\n            apiVersion: 3,\n            operation: OP.SET,\n        };\n    }\n    else if ('removeChatLabel' in mod) {\n        patch = {\n            syncAction: {\n                labelAssociationAction: {\n                    labeled: false,\n                }\n            },\n            index: [LabelAssociation_1.LabelAssociationType.Chat, mod.removeChatLabel.labelId, jid],\n            type: 'regular',\n            apiVersion: 3,\n            operation: OP.SET,\n        };\n    }\n    else if ('addMessageLabel' in mod) {\n        patch = {\n            syncAction: {\n                labelAssociationAction: {\n                    labeled: true,\n                }\n            },\n            index: [\n                LabelAssociation_1.LabelAssociationType.Message,\n                mod.addMessageLabel.labelId,\n                jid,\n                mod.addMessageLabel.messageId,\n                '0',\n                '0'\n            ],\n            type: 'regular',\n            apiVersion: 3,\n            operation: OP.SET,\n        };\n    }\n    else if ('removeMessageLabel' in mod) {\n        patch = {\n            syncAction: {\n                labelAssociationAction: {\n                    labeled: false,\n                }\n            },\n            index: [\n                LabelAssociation_1.LabelAssociationType.Message,\n                mod.removeMessageLabel.labelId,\n                jid,\n                mod.removeMessageLabel.messageId,\n                '0',\n                '0'\n            ],\n            type: 'regular',\n            apiVersion: 3,\n            operation: OP.SET,\n        };\n    }\n    else {\n        throw new boom_1.Boom('not supported');\n    }\n    patch.syncAction.timestamp = Date.now();\n    return patch;\n};\nexports.chatModificationToAppPatch = chatModificationToAppPatch;\nconst processSyncAction = (syncAction, ev, me, initialSyncOpts, logger) => {\n    var _a, _b, _c, _d;\n    const isInitialSync = !!initialSyncOpts;\n    const accountSettings = initialSyncOpts === null || initialSyncOpts === void 0 ? void 0 : initialSyncOpts.accountSettings;\n    logger === null || logger === void 0 ? void 0 : logger.trace({ syncAction, initialSync: !!initialSyncOpts }, 'processing sync action');\n    const { syncAction: { value: action }, index: [type, id, msgId, fromMe] } = syncAction;\n    if (action === null || action === void 0 ? void 0 : action.muteAction) {\n        ev.emit('chats.update', [\n            {\n                id,\n                muteEndTime: ((_a = action.muteAction) === null || _a === void 0 ? void 0 : _a.muted)\n                    ? (0, generics_1.toNumber)(action.muteAction.muteEndTimestamp)\n                    : null,\n                conditional: getChatUpdateConditional(id, undefined)\n            }\n        ]);\n    }\n    else if ((action === null || action === void 0 ? void 0 : action.archiveChatAction) || type === 'archive' || type === 'unarchive') {\n        // okay so we've to do some annoying computation here\n        // when we're initially syncing the app state\n        // there are a few cases we need to handle\n        // 1. if the account unarchiveChats setting is true\n        //   a. if the chat is archived, and no further messages have been received -- simple, keep archived\n        //   b. if the chat was archived, and the user received messages from the other person afterwards\n        //\t\tthen the chat should be marked unarchved --\n        //\t\twe compare the timestamp of latest message from the other person to determine this\n        // 2. if the account unarchiveChats setting is false -- then it doesn't matter,\n        //\tit'll always take an app state action to mark in unarchived -- which we'll get anyway\n        const archiveAction = action === null || action === void 0 ? void 0 : action.archiveChatAction;\n        const isArchived = archiveAction\n            ? archiveAction.archived\n            : type === 'archive';\n        // // basically we don't need to fire an \"archive\" update if the chat is being marked unarchvied\n        // // this only applies for the initial sync\n        // if(isInitialSync && !isArchived) {\n        // \tisArchived = false\n        // }\n        const msgRange = !(accountSettings === null || accountSettings === void 0 ? void 0 : accountSettings.unarchiveChats) ? undefined : archiveAction === null || archiveAction === void 0 ? void 0 : archiveAction.messageRange;\n        // logger?.debug({ chat: id, syncAction }, 'message range archive')\n        ev.emit('chats.update', [{\n                id,\n                archived: isArchived,\n                conditional: getChatUpdateConditional(id, msgRange)\n            }]);\n    }\n    else if (action === null || action === void 0 ? void 0 : action.markChatAsReadAction) {\n        const markReadAction = action.markChatAsReadAction;\n        // basically we don't need to fire an \"read\" update if the chat is being marked as read\n        // because the chat is read by default\n        // this only applies for the initial sync\n        const isNullUpdate = isInitialSync && markReadAction.read;\n        ev.emit('chats.update', [{\n                id,\n                unreadCount: isNullUpdate ? null : !!(markReadAction === null || markReadAction === void 0 ? void 0 : markReadAction.read) ? 0 : -1,\n                conditional: getChatUpdateConditional(id, markReadAction === null || markReadAction === void 0 ? void 0 : markReadAction.messageRange)\n            }]);\n    }\n    else if ((action === null || action === void 0 ? void 0 : action.deleteMessageForMeAction) || type === 'deleteMessageForMe') {\n        ev.emit('messages.delete', {\n            keys: [\n                {\n                    remoteJid: id,\n                    id: msgId,\n                    fromMe: fromMe === '1'\n                }\n            ]\n        });\n    }\n    else if (action === null || action === void 0 ? void 0 : action.contactAction) {\n        ev.emit('contacts.upsert', [{ id, name: action.contactAction.fullName }]);\n    }\n    else if (action === null || action === void 0 ? void 0 : action.pushNameSetting) {\n        const name = (_b = action === null || action === void 0 ? void 0 : action.pushNameSetting) === null || _b === void 0 ? void 0 : _b.name;\n        if (name && (me === null || me === void 0 ? void 0 : me.name) !== name) {\n            ev.emit('creds.update', { me: { ...me, name } });\n        }\n    }\n    else if (action === null || action === void 0 ? void 0 : action.pinAction) {\n        ev.emit('chats.update', [{\n                id,\n                pinned: ((_c = action.pinAction) === null || _c === void 0 ? void 0 : _c.pinned) ? (0, generics_1.toNumber)(action.timestamp) : null,\n                conditional: getChatUpdateConditional(id, undefined)\n            }]);\n    }\n    else if (action === null || action === void 0 ? void 0 : action.unarchiveChatsSetting) {\n        const unarchiveChats = !!action.unarchiveChatsSetting.unarchiveChats;\n        ev.emit('creds.update', { accountSettings: { unarchiveChats } });\n        logger === null || logger === void 0 ? void 0 : logger.info(`archive setting updated => '${action.unarchiveChatsSetting.unarchiveChats}'`);\n        if (accountSettings) {\n            accountSettings.unarchiveChats = unarchiveChats;\n        }\n    }\n    else if ((action === null || action === void 0 ? void 0 : action.starAction) || type === 'star') {\n        let starred = (_d = action === null || action === void 0 ? void 0 : action.starAction) === null || _d === void 0 ? void 0 : _d.starred;\n        if (typeof starred !== 'boolean') {\n            starred = syncAction.index[syncAction.index.length - 1] === '1';\n        }\n        ev.emit('messages.update', [\n            {\n                key: { remoteJid: id, id: msgId, fromMe: fromMe === '1' },\n                update: { starred }\n            }\n        ]);\n    }\n    else if ((action === null || action === void 0 ? void 0 : action.deleteChatAction) || type === 'deleteChat') {\n        if (!isInitialSync) {\n            ev.emit('chats.delete', [id]);\n        }\n    }\n    else if (action === null || action === void 0 ? void 0 : action.labelEditAction) {\n        const { name, color, deleted, predefinedId } = action.labelEditAction;\n        ev.emit('labels.edit', {\n            id,\n            name: name,\n            color: color,\n            deleted: deleted,\n            predefinedId: predefinedId ? String(predefinedId) : undefined\n        });\n    }\n    else if (action === null || action === void 0 ? void 0 : action.labelAssociationAction) {\n        ev.emit('labels.association', {\n            type: action.labelAssociationAction.labeled\n                ? 'add'\n                : 'remove',\n            association: type === LabelAssociation_1.LabelAssociationType.Chat\n                ? {\n                    type: LabelAssociation_1.LabelAssociationType.Chat,\n                    chatId: syncAction.index[2],\n                    labelId: syncAction.index[1]\n                }\n                : {\n                    type: LabelAssociation_1.LabelAssociationType.Message,\n                    chatId: syncAction.index[2],\n                    messageId: syncAction.index[3],\n                    labelId: syncAction.index[1]\n                }\n        });\n    }\n    else {\n        logger === null || logger === void 0 ? void 0 : logger.debug({ syncAction, id }, 'unprocessable update');\n    }\n    function getChatUpdateConditional(id, msgRange) {\n        return isInitialSync\n            ? (data) => {\n                const chat = data.historySets.chats[id] || data.chatUpserts[id];\n                if (chat) {\n                    return msgRange ? isValidPatchBasedOnMessageRange(chat, msgRange) : true;\n                }\n            }\n            : undefined;\n    }\n    function isValidPatchBasedOnMessageRange(chat, msgRange) {\n        const lastMsgTimestamp = Number((msgRange === null || msgRange === void 0 ? void 0 : msgRange.lastMessageTimestamp) || (msgRange === null || msgRange === void 0 ? void 0 : msgRange.lastSystemMessageTimestamp) || 0);\n        const chatLastMsgTimestamp = Number((chat === null || chat === void 0 ? void 0 : chat.lastMessageRecvTimestamp) || 0);\n        return lastMsgTimestamp >= chatLastMsgTimestamp;\n    }\n};\nexports.processSyncAction = processSyncAction;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}