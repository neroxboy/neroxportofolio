{"ast":null,"code":"/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader,\n  $Writer = $protobuf.Writer,\n  $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n$root.groupproto = function () {\n  /**\n   * Namespace groupproto.\n   * @exports groupproto\n   * @namespace\n   */\n  var groupproto = {};\n  groupproto.SenderKeyMessage = function () {\n    /**\n     * Properties of a SenderKeyMessage.\n     * @memberof groupproto\n     * @interface ISenderKeyMessage\n     * @property {number|null} [id] SenderKeyMessage id\n     * @property {number|null} [iteration] SenderKeyMessage iteration\n     * @property {Uint8Array|null} [ciphertext] SenderKeyMessage ciphertext\n     */\n\n    /**\n     * Constructs a new SenderKeyMessage.\n     * @memberof groupproto\n     * @classdesc Represents a SenderKeyMessage.\n     * @implements ISenderKeyMessage\n     * @constructor\n     * @param {groupproto.ISenderKeyMessage=} [properties] Properties to set\n     */\n    function SenderKeyMessage(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * SenderKeyMessage id.\n     * @member {number} id\n     * @memberof groupproto.SenderKeyMessage\n     * @instance\n     */\n    SenderKeyMessage.prototype.id = 0;\n\n    /**\n     * SenderKeyMessage iteration.\n     * @member {number} iteration\n     * @memberof groupproto.SenderKeyMessage\n     * @instance\n     */\n    SenderKeyMessage.prototype.iteration = 0;\n\n    /**\n     * SenderKeyMessage ciphertext.\n     * @member {Uint8Array} ciphertext\n     * @memberof groupproto.SenderKeyMessage\n     * @instance\n     */\n    SenderKeyMessage.prototype.ciphertext = $util.newBuffer([]);\n\n    /**\n     * Creates a new SenderKeyMessage instance using the specified properties.\n     * @function create\n     * @memberof groupproto.SenderKeyMessage\n     * @static\n     * @param {groupproto.ISenderKeyMessage=} [properties] Properties to set\n     * @returns {groupproto.SenderKeyMessage} SenderKeyMessage instance\n     */\n    SenderKeyMessage.create = function create(properties) {\n      return new SenderKeyMessage(properties);\n    };\n\n    /**\n     * Encodes the specified SenderKeyMessage message. Does not implicitly {@link groupproto.SenderKeyMessage.verify|verify} messages.\n     * @function encode\n     * @memberof groupproto.SenderKeyMessage\n     * @static\n     * @param {groupproto.ISenderKeyMessage} message SenderKeyMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SenderKeyMessage.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.id != null && Object.hasOwnProperty.call(message, \"id\")) writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);\n      if (message.iteration != null && Object.hasOwnProperty.call(message, \"iteration\")) writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.iteration);\n      if (message.ciphertext != null && Object.hasOwnProperty.call(message, \"ciphertext\")) writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ciphertext);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified SenderKeyMessage message, length delimited. Does not implicitly {@link groupproto.SenderKeyMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof groupproto.SenderKeyMessage\n     * @static\n     * @param {groupproto.ISenderKeyMessage} message SenderKeyMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SenderKeyMessage.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a SenderKeyMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof groupproto.SenderKeyMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {groupproto.SenderKeyMessage} SenderKeyMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SenderKeyMessage.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.groupproto.SenderKeyMessage();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.id = reader.uint32();\n            break;\n          case 2:\n            message.iteration = reader.uint32();\n            break;\n          case 3:\n            message.ciphertext = reader.bytes();\n            break;\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a SenderKeyMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof groupproto.SenderKeyMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {groupproto.SenderKeyMessage} SenderKeyMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SenderKeyMessage.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a SenderKeyMessage message.\n     * @function verify\n     * @memberof groupproto.SenderKeyMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    SenderKeyMessage.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.id != null && message.hasOwnProperty(\"id\")) if (!$util.isInteger(message.id)) return \"id: integer expected\";\n      if (message.iteration != null && message.hasOwnProperty(\"iteration\")) if (!$util.isInteger(message.iteration)) return \"iteration: integer expected\";\n      if (message.ciphertext != null && message.hasOwnProperty(\"ciphertext\")) if (!(message.ciphertext && typeof message.ciphertext.length === \"number\" || $util.isString(message.ciphertext))) return \"ciphertext: buffer expected\";\n      return null;\n    };\n\n    /**\n     * Creates a SenderKeyMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof groupproto.SenderKeyMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {groupproto.SenderKeyMessage} SenderKeyMessage\n     */\n    SenderKeyMessage.fromObject = function fromObject(object) {\n      if (object instanceof $root.groupproto.SenderKeyMessage) return object;\n      var message = new $root.groupproto.SenderKeyMessage();\n      if (object.id != null) message.id = object.id >>> 0;\n      if (object.iteration != null) message.iteration = object.iteration >>> 0;\n      if (object.ciphertext != null) if (typeof object.ciphertext === \"string\") $util.base64.decode(object.ciphertext, message.ciphertext = $util.newBuffer($util.base64.length(object.ciphertext)), 0);else if (object.ciphertext.length) message.ciphertext = object.ciphertext;\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a SenderKeyMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof groupproto.SenderKeyMessage\n     * @static\n     * @param {groupproto.SenderKeyMessage} message SenderKeyMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    SenderKeyMessage.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) {\n        object.id = 0;\n        object.iteration = 0;\n        if (options.bytes === String) object.ciphertext = \"\";else {\n          object.ciphertext = [];\n          if (options.bytes !== Array) object.ciphertext = $util.newBuffer(object.ciphertext);\n        }\n      }\n      if (message.id != null && message.hasOwnProperty(\"id\")) object.id = message.id;\n      if (message.iteration != null && message.hasOwnProperty(\"iteration\")) object.iteration = message.iteration;\n      if (message.ciphertext != null && message.hasOwnProperty(\"ciphertext\")) object.ciphertext = options.bytes === String ? $util.base64.encode(message.ciphertext, 0, message.ciphertext.length) : options.bytes === Array ? Array.prototype.slice.call(message.ciphertext) : message.ciphertext;\n      return object;\n    };\n\n    /**\n     * Converts this SenderKeyMessage to JSON.\n     * @function toJSON\n     * @memberof groupproto.SenderKeyMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    SenderKeyMessage.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    return SenderKeyMessage;\n  }();\n  groupproto.SenderKeyDistributionMessage = function () {\n    /**\n     * Properties of a SenderKeyDistributionMessage.\n     * @memberof groupproto\n     * @interface ISenderKeyDistributionMessage\n     * @property {number|null} [id] SenderKeyDistributionMessage id\n     * @property {number|null} [iteration] SenderKeyDistributionMessage iteration\n     * @property {Uint8Array|null} [chainKey] SenderKeyDistributionMessage chainKey\n     * @property {Uint8Array|null} [signingKey] SenderKeyDistributionMessage signingKey\n     */\n\n    /**\n     * Constructs a new SenderKeyDistributionMessage.\n     * @memberof groupproto\n     * @classdesc Represents a SenderKeyDistributionMessage.\n     * @implements ISenderKeyDistributionMessage\n     * @constructor\n     * @param {groupproto.ISenderKeyDistributionMessage=} [properties] Properties to set\n     */\n    function SenderKeyDistributionMessage(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * SenderKeyDistributionMessage id.\n     * @member {number} id\n     * @memberof groupproto.SenderKeyDistributionMessage\n     * @instance\n     */\n    SenderKeyDistributionMessage.prototype.id = 0;\n\n    /**\n     * SenderKeyDistributionMessage iteration.\n     * @member {number} iteration\n     * @memberof groupproto.SenderKeyDistributionMessage\n     * @instance\n     */\n    SenderKeyDistributionMessage.prototype.iteration = 0;\n\n    /**\n     * SenderKeyDistributionMessage chainKey.\n     * @member {Uint8Array} chainKey\n     * @memberof groupproto.SenderKeyDistributionMessage\n     * @instance\n     */\n    SenderKeyDistributionMessage.prototype.chainKey = $util.newBuffer([]);\n\n    /**\n     * SenderKeyDistributionMessage signingKey.\n     * @member {Uint8Array} signingKey\n     * @memberof groupproto.SenderKeyDistributionMessage\n     * @instance\n     */\n    SenderKeyDistributionMessage.prototype.signingKey = $util.newBuffer([]);\n\n    /**\n     * Creates a new SenderKeyDistributionMessage instance using the specified properties.\n     * @function create\n     * @memberof groupproto.SenderKeyDistributionMessage\n     * @static\n     * @param {groupproto.ISenderKeyDistributionMessage=} [properties] Properties to set\n     * @returns {groupproto.SenderKeyDistributionMessage} SenderKeyDistributionMessage instance\n     */\n    SenderKeyDistributionMessage.create = function create(properties) {\n      return new SenderKeyDistributionMessage(properties);\n    };\n\n    /**\n     * Encodes the specified SenderKeyDistributionMessage message. Does not implicitly {@link groupproto.SenderKeyDistributionMessage.verify|verify} messages.\n     * @function encode\n     * @memberof groupproto.SenderKeyDistributionMessage\n     * @static\n     * @param {groupproto.ISenderKeyDistributionMessage} message SenderKeyDistributionMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SenderKeyDistributionMessage.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.id != null && Object.hasOwnProperty.call(message, \"id\")) writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);\n      if (message.iteration != null && Object.hasOwnProperty.call(message, \"iteration\")) writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.iteration);\n      if (message.chainKey != null && Object.hasOwnProperty.call(message, \"chainKey\")) writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.chainKey);\n      if (message.signingKey != null && Object.hasOwnProperty.call(message, \"signingKey\")) writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signingKey);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified SenderKeyDistributionMessage message, length delimited. Does not implicitly {@link groupproto.SenderKeyDistributionMessage.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof groupproto.SenderKeyDistributionMessage\n     * @static\n     * @param {groupproto.ISenderKeyDistributionMessage} message SenderKeyDistributionMessage message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SenderKeyDistributionMessage.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a SenderKeyDistributionMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof groupproto.SenderKeyDistributionMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {groupproto.SenderKeyDistributionMessage} SenderKeyDistributionMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SenderKeyDistributionMessage.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.groupproto.SenderKeyDistributionMessage();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.id = reader.uint32();\n            break;\n          case 2:\n            message.iteration = reader.uint32();\n            break;\n          case 3:\n            message.chainKey = reader.bytes();\n            break;\n          case 4:\n            message.signingKey = reader.bytes();\n            break;\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a SenderKeyDistributionMessage message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof groupproto.SenderKeyDistributionMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {groupproto.SenderKeyDistributionMessage} SenderKeyDistributionMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SenderKeyDistributionMessage.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a SenderKeyDistributionMessage message.\n     * @function verify\n     * @memberof groupproto.SenderKeyDistributionMessage\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    SenderKeyDistributionMessage.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.id != null && message.hasOwnProperty(\"id\")) if (!$util.isInteger(message.id)) return \"id: integer expected\";\n      if (message.iteration != null && message.hasOwnProperty(\"iteration\")) if (!$util.isInteger(message.iteration)) return \"iteration: integer expected\";\n      if (message.chainKey != null && message.hasOwnProperty(\"chainKey\")) if (!(message.chainKey && typeof message.chainKey.length === \"number\" || $util.isString(message.chainKey))) return \"chainKey: buffer expected\";\n      if (message.signingKey != null && message.hasOwnProperty(\"signingKey\")) if (!(message.signingKey && typeof message.signingKey.length === \"number\" || $util.isString(message.signingKey))) return \"signingKey: buffer expected\";\n      return null;\n    };\n\n    /**\n     * Creates a SenderKeyDistributionMessage message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof groupproto.SenderKeyDistributionMessage\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {groupproto.SenderKeyDistributionMessage} SenderKeyDistributionMessage\n     */\n    SenderKeyDistributionMessage.fromObject = function fromObject(object) {\n      if (object instanceof $root.groupproto.SenderKeyDistributionMessage) return object;\n      var message = new $root.groupproto.SenderKeyDistributionMessage();\n      if (object.id != null) message.id = object.id >>> 0;\n      if (object.iteration != null) message.iteration = object.iteration >>> 0;\n      if (object.chainKey != null) if (typeof object.chainKey === \"string\") $util.base64.decode(object.chainKey, message.chainKey = $util.newBuffer($util.base64.length(object.chainKey)), 0);else if (object.chainKey.length) message.chainKey = object.chainKey;\n      if (object.signingKey != null) if (typeof object.signingKey === \"string\") $util.base64.decode(object.signingKey, message.signingKey = $util.newBuffer($util.base64.length(object.signingKey)), 0);else if (object.signingKey.length) message.signingKey = object.signingKey;\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a SenderKeyDistributionMessage message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof groupproto.SenderKeyDistributionMessage\n     * @static\n     * @param {groupproto.SenderKeyDistributionMessage} message SenderKeyDistributionMessage\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    SenderKeyDistributionMessage.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) {\n        object.id = 0;\n        object.iteration = 0;\n        if (options.bytes === String) object.chainKey = \"\";else {\n          object.chainKey = [];\n          if (options.bytes !== Array) object.chainKey = $util.newBuffer(object.chainKey);\n        }\n        if (options.bytes === String) object.signingKey = \"\";else {\n          object.signingKey = [];\n          if (options.bytes !== Array) object.signingKey = $util.newBuffer(object.signingKey);\n        }\n      }\n      if (message.id != null && message.hasOwnProperty(\"id\")) object.id = message.id;\n      if (message.iteration != null && message.hasOwnProperty(\"iteration\")) object.iteration = message.iteration;\n      if (message.chainKey != null && message.hasOwnProperty(\"chainKey\")) object.chainKey = options.bytes === String ? $util.base64.encode(message.chainKey, 0, message.chainKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.chainKey) : message.chainKey;\n      if (message.signingKey != null && message.hasOwnProperty(\"signingKey\")) object.signingKey = options.bytes === String ? $util.base64.encode(message.signingKey, 0, message.signingKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.signingKey) : message.signingKey;\n      return object;\n    };\n\n    /**\n     * Converts this SenderKeyDistributionMessage to JSON.\n     * @function toJSON\n     * @memberof groupproto.SenderKeyDistributionMessage\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    SenderKeyDistributionMessage.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    return SenderKeyDistributionMessage;\n  }();\n  groupproto.SenderChainKey = function () {\n    /**\n     * Properties of a SenderChainKey.\n     * @memberof groupproto\n     * @interface ISenderChainKey\n     * @property {number|null} [iteration] SenderChainKey iteration\n     * @property {Uint8Array|null} [seed] SenderChainKey seed\n     */\n\n    /**\n     * Constructs a new SenderChainKey.\n     * @memberof groupproto\n     * @classdesc Represents a SenderChainKey.\n     * @implements ISenderChainKey\n     * @constructor\n     * @param {groupproto.ISenderChainKey=} [properties] Properties to set\n     */\n    function SenderChainKey(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * SenderChainKey iteration.\n     * @member {number} iteration\n     * @memberof groupproto.SenderChainKey\n     * @instance\n     */\n    SenderChainKey.prototype.iteration = 0;\n\n    /**\n     * SenderChainKey seed.\n     * @member {Uint8Array} seed\n     * @memberof groupproto.SenderChainKey\n     * @instance\n     */\n    SenderChainKey.prototype.seed = $util.newBuffer([]);\n\n    /**\n     * Creates a new SenderChainKey instance using the specified properties.\n     * @function create\n     * @memberof groupproto.SenderChainKey\n     * @static\n     * @param {groupproto.ISenderChainKey=} [properties] Properties to set\n     * @returns {groupproto.SenderChainKey} SenderChainKey instance\n     */\n    SenderChainKey.create = function create(properties) {\n      return new SenderChainKey(properties);\n    };\n\n    /**\n     * Encodes the specified SenderChainKey message. Does not implicitly {@link groupproto.SenderChainKey.verify|verify} messages.\n     * @function encode\n     * @memberof groupproto.SenderChainKey\n     * @static\n     * @param {groupproto.ISenderChainKey} message SenderChainKey message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SenderChainKey.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.iteration != null && Object.hasOwnProperty.call(message, \"iteration\")) writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.iteration);\n      if (message.seed != null && Object.hasOwnProperty.call(message, \"seed\")) writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.seed);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified SenderChainKey message, length delimited. Does not implicitly {@link groupproto.SenderChainKey.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof groupproto.SenderChainKey\n     * @static\n     * @param {groupproto.ISenderChainKey} message SenderChainKey message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SenderChainKey.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a SenderChainKey message from the specified reader or buffer.\n     * @function decode\n     * @memberof groupproto.SenderChainKey\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {groupproto.SenderChainKey} SenderChainKey\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SenderChainKey.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.groupproto.SenderChainKey();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.iteration = reader.uint32();\n            break;\n          case 2:\n            message.seed = reader.bytes();\n            break;\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a SenderChainKey message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof groupproto.SenderChainKey\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {groupproto.SenderChainKey} SenderChainKey\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SenderChainKey.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a SenderChainKey message.\n     * @function verify\n     * @memberof groupproto.SenderChainKey\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    SenderChainKey.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.iteration != null && message.hasOwnProperty(\"iteration\")) if (!$util.isInteger(message.iteration)) return \"iteration: integer expected\";\n      if (message.seed != null && message.hasOwnProperty(\"seed\")) if (!(message.seed && typeof message.seed.length === \"number\" || $util.isString(message.seed))) return \"seed: buffer expected\";\n      return null;\n    };\n\n    /**\n     * Creates a SenderChainKey message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof groupproto.SenderChainKey\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {groupproto.SenderChainKey} SenderChainKey\n     */\n    SenderChainKey.fromObject = function fromObject(object) {\n      if (object instanceof $root.groupproto.SenderChainKey) return object;\n      var message = new $root.groupproto.SenderChainKey();\n      if (object.iteration != null) message.iteration = object.iteration >>> 0;\n      if (object.seed != null) if (typeof object.seed === \"string\") $util.base64.decode(object.seed, message.seed = $util.newBuffer($util.base64.length(object.seed)), 0);else if (object.seed.length) message.seed = object.seed;\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a SenderChainKey message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof groupproto.SenderChainKey\n     * @static\n     * @param {groupproto.SenderChainKey} message SenderChainKey\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    SenderChainKey.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) {\n        object.iteration = 0;\n        if (options.bytes === String) object.seed = \"\";else {\n          object.seed = [];\n          if (options.bytes !== Array) object.seed = $util.newBuffer(object.seed);\n        }\n      }\n      if (message.iteration != null && message.hasOwnProperty(\"iteration\")) object.iteration = message.iteration;\n      if (message.seed != null && message.hasOwnProperty(\"seed\")) object.seed = options.bytes === String ? $util.base64.encode(message.seed, 0, message.seed.length) : options.bytes === Array ? Array.prototype.slice.call(message.seed) : message.seed;\n      return object;\n    };\n\n    /**\n     * Converts this SenderChainKey to JSON.\n     * @function toJSON\n     * @memberof groupproto.SenderChainKey\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    SenderChainKey.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    return SenderChainKey;\n  }();\n  groupproto.SenderMessageKey = function () {\n    /**\n     * Properties of a SenderMessageKey.\n     * @memberof groupproto\n     * @interface ISenderMessageKey\n     * @property {number|null} [iteration] SenderMessageKey iteration\n     * @property {Uint8Array|null} [seed] SenderMessageKey seed\n     */\n\n    /**\n     * Constructs a new SenderMessageKey.\n     * @memberof groupproto\n     * @classdesc Represents a SenderMessageKey.\n     * @implements ISenderMessageKey\n     * @constructor\n     * @param {groupproto.ISenderMessageKey=} [properties] Properties to set\n     */\n    function SenderMessageKey(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * SenderMessageKey iteration.\n     * @member {number} iteration\n     * @memberof groupproto.SenderMessageKey\n     * @instance\n     */\n    SenderMessageKey.prototype.iteration = 0;\n\n    /**\n     * SenderMessageKey seed.\n     * @member {Uint8Array} seed\n     * @memberof groupproto.SenderMessageKey\n     * @instance\n     */\n    SenderMessageKey.prototype.seed = $util.newBuffer([]);\n\n    /**\n     * Creates a new SenderMessageKey instance using the specified properties.\n     * @function create\n     * @memberof groupproto.SenderMessageKey\n     * @static\n     * @param {groupproto.ISenderMessageKey=} [properties] Properties to set\n     * @returns {groupproto.SenderMessageKey} SenderMessageKey instance\n     */\n    SenderMessageKey.create = function create(properties) {\n      return new SenderMessageKey(properties);\n    };\n\n    /**\n     * Encodes the specified SenderMessageKey message. Does not implicitly {@link groupproto.SenderMessageKey.verify|verify} messages.\n     * @function encode\n     * @memberof groupproto.SenderMessageKey\n     * @static\n     * @param {groupproto.ISenderMessageKey} message SenderMessageKey message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SenderMessageKey.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.iteration != null && Object.hasOwnProperty.call(message, \"iteration\")) writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.iteration);\n      if (message.seed != null && Object.hasOwnProperty.call(message, \"seed\")) writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.seed);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified SenderMessageKey message, length delimited. Does not implicitly {@link groupproto.SenderMessageKey.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof groupproto.SenderMessageKey\n     * @static\n     * @param {groupproto.ISenderMessageKey} message SenderMessageKey message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SenderMessageKey.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a SenderMessageKey message from the specified reader or buffer.\n     * @function decode\n     * @memberof groupproto.SenderMessageKey\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {groupproto.SenderMessageKey} SenderMessageKey\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SenderMessageKey.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.groupproto.SenderMessageKey();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.iteration = reader.uint32();\n            break;\n          case 2:\n            message.seed = reader.bytes();\n            break;\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a SenderMessageKey message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof groupproto.SenderMessageKey\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {groupproto.SenderMessageKey} SenderMessageKey\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SenderMessageKey.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a SenderMessageKey message.\n     * @function verify\n     * @memberof groupproto.SenderMessageKey\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    SenderMessageKey.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.iteration != null && message.hasOwnProperty(\"iteration\")) if (!$util.isInteger(message.iteration)) return \"iteration: integer expected\";\n      if (message.seed != null && message.hasOwnProperty(\"seed\")) if (!(message.seed && typeof message.seed.length === \"number\" || $util.isString(message.seed))) return \"seed: buffer expected\";\n      return null;\n    };\n\n    /**\n     * Creates a SenderMessageKey message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof groupproto.SenderMessageKey\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {groupproto.SenderMessageKey} SenderMessageKey\n     */\n    SenderMessageKey.fromObject = function fromObject(object) {\n      if (object instanceof $root.groupproto.SenderMessageKey) return object;\n      var message = new $root.groupproto.SenderMessageKey();\n      if (object.iteration != null) message.iteration = object.iteration >>> 0;\n      if (object.seed != null) if (typeof object.seed === \"string\") $util.base64.decode(object.seed, message.seed = $util.newBuffer($util.base64.length(object.seed)), 0);else if (object.seed.length) message.seed = object.seed;\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a SenderMessageKey message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof groupproto.SenderMessageKey\n     * @static\n     * @param {groupproto.SenderMessageKey} message SenderMessageKey\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    SenderMessageKey.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) {\n        object.iteration = 0;\n        if (options.bytes === String) object.seed = \"\";else {\n          object.seed = [];\n          if (options.bytes !== Array) object.seed = $util.newBuffer(object.seed);\n        }\n      }\n      if (message.iteration != null && message.hasOwnProperty(\"iteration\")) object.iteration = message.iteration;\n      if (message.seed != null && message.hasOwnProperty(\"seed\")) object.seed = options.bytes === String ? $util.base64.encode(message.seed, 0, message.seed.length) : options.bytes === Array ? Array.prototype.slice.call(message.seed) : message.seed;\n      return object;\n    };\n\n    /**\n     * Converts this SenderMessageKey to JSON.\n     * @function toJSON\n     * @memberof groupproto.SenderMessageKey\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    SenderMessageKey.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    return SenderMessageKey;\n  }();\n  groupproto.SenderSigningKey = function () {\n    /**\n     * Properties of a SenderSigningKey.\n     * @memberof groupproto\n     * @interface ISenderSigningKey\n     * @property {Uint8Array|null} [\"public\"] SenderSigningKey public\n     * @property {Uint8Array|null} [\"private\"] SenderSigningKey private\n     */\n\n    /**\n     * Constructs a new SenderSigningKey.\n     * @memberof groupproto\n     * @classdesc Represents a SenderSigningKey.\n     * @implements ISenderSigningKey\n     * @constructor\n     * @param {groupproto.ISenderSigningKey=} [properties] Properties to set\n     */\n    function SenderSigningKey(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * SenderSigningKey public.\n     * @member {Uint8Array} public\n     * @memberof groupproto.SenderSigningKey\n     * @instance\n     */\n    SenderSigningKey.prototype[\"public\"] = $util.newBuffer([]);\n\n    /**\n     * SenderSigningKey private.\n     * @member {Uint8Array} private\n     * @memberof groupproto.SenderSigningKey\n     * @instance\n     */\n    SenderSigningKey.prototype[\"private\"] = $util.newBuffer([]);\n\n    /**\n     * Creates a new SenderSigningKey instance using the specified properties.\n     * @function create\n     * @memberof groupproto.SenderSigningKey\n     * @static\n     * @param {groupproto.ISenderSigningKey=} [properties] Properties to set\n     * @returns {groupproto.SenderSigningKey} SenderSigningKey instance\n     */\n    SenderSigningKey.create = function create(properties) {\n      return new SenderSigningKey(properties);\n    };\n\n    /**\n     * Encodes the specified SenderSigningKey message. Does not implicitly {@link groupproto.SenderSigningKey.verify|verify} messages.\n     * @function encode\n     * @memberof groupproto.SenderSigningKey\n     * @static\n     * @param {groupproto.ISenderSigningKey} message SenderSigningKey message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SenderSigningKey.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message[\"public\"] != null && Object.hasOwnProperty.call(message, \"public\")) writer.uint32(/* id 1, wireType 2 =*/10).bytes(message[\"public\"]);\n      if (message[\"private\"] != null && Object.hasOwnProperty.call(message, \"private\")) writer.uint32(/* id 2, wireType 2 =*/18).bytes(message[\"private\"]);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified SenderSigningKey message, length delimited. Does not implicitly {@link groupproto.SenderSigningKey.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof groupproto.SenderSigningKey\n     * @static\n     * @param {groupproto.ISenderSigningKey} message SenderSigningKey message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SenderSigningKey.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a SenderSigningKey message from the specified reader or buffer.\n     * @function decode\n     * @memberof groupproto.SenderSigningKey\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {groupproto.SenderSigningKey} SenderSigningKey\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SenderSigningKey.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.groupproto.SenderSigningKey();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message[\"public\"] = reader.bytes();\n            break;\n          case 2:\n            message[\"private\"] = reader.bytes();\n            break;\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a SenderSigningKey message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof groupproto.SenderSigningKey\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {groupproto.SenderSigningKey} SenderSigningKey\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SenderSigningKey.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a SenderSigningKey message.\n     * @function verify\n     * @memberof groupproto.SenderSigningKey\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    SenderSigningKey.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message[\"public\"] != null && message.hasOwnProperty(\"public\")) if (!(message[\"public\"] && typeof message[\"public\"].length === \"number\" || $util.isString(message[\"public\"]))) return \"public: buffer expected\";\n      if (message[\"private\"] != null && message.hasOwnProperty(\"private\")) if (!(message[\"private\"] && typeof message[\"private\"].length === \"number\" || $util.isString(message[\"private\"]))) return \"private: buffer expected\";\n      return null;\n    };\n\n    /**\n     * Creates a SenderSigningKey message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof groupproto.SenderSigningKey\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {groupproto.SenderSigningKey} SenderSigningKey\n     */\n    SenderSigningKey.fromObject = function fromObject(object) {\n      if (object instanceof $root.groupproto.SenderSigningKey) return object;\n      var message = new $root.groupproto.SenderSigningKey();\n      if (object[\"public\"] != null) if (typeof object[\"public\"] === \"string\") $util.base64.decode(object[\"public\"], message[\"public\"] = $util.newBuffer($util.base64.length(object[\"public\"])), 0);else if (object[\"public\"].length) message[\"public\"] = object[\"public\"];\n      if (object[\"private\"] != null) if (typeof object[\"private\"] === \"string\") $util.base64.decode(object[\"private\"], message[\"private\"] = $util.newBuffer($util.base64.length(object[\"private\"])), 0);else if (object[\"private\"].length) message[\"private\"] = object[\"private\"];\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a SenderSigningKey message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof groupproto.SenderSigningKey\n     * @static\n     * @param {groupproto.SenderSigningKey} message SenderSigningKey\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    SenderSigningKey.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) {\n        if (options.bytes === String) object[\"public\"] = \"\";else {\n          object[\"public\"] = [];\n          if (options.bytes !== Array) object[\"public\"] = $util.newBuffer(object[\"public\"]);\n        }\n        if (options.bytes === String) object[\"private\"] = \"\";else {\n          object[\"private\"] = [];\n          if (options.bytes !== Array) object[\"private\"] = $util.newBuffer(object[\"private\"]);\n        }\n      }\n      if (message[\"public\"] != null && message.hasOwnProperty(\"public\")) object[\"public\"] = options.bytes === String ? $util.base64.encode(message[\"public\"], 0, message[\"public\"].length) : options.bytes === Array ? Array.prototype.slice.call(message[\"public\"]) : message[\"public\"];\n      if (message[\"private\"] != null && message.hasOwnProperty(\"private\")) object[\"private\"] = options.bytes === String ? $util.base64.encode(message[\"private\"], 0, message[\"private\"].length) : options.bytes === Array ? Array.prototype.slice.call(message[\"private\"]) : message[\"private\"];\n      return object;\n    };\n\n    /**\n     * Converts this SenderSigningKey to JSON.\n     * @function toJSON\n     * @memberof groupproto.SenderSigningKey\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    SenderSigningKey.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    return SenderSigningKey;\n  }();\n  groupproto.SenderKeyStateStructure = function () {\n    /**\n     * Properties of a SenderKeyStateStructure.\n     * @memberof groupproto\n     * @interface ISenderKeyStateStructure\n     * @property {number|null} [senderKeyId] SenderKeyStateStructure senderKeyId\n     * @property {groupproto.ISenderChainKey|null} [senderChainKey] SenderKeyStateStructure senderChainKey\n     * @property {groupproto.ISenderSigningKey|null} [senderSigningKey] SenderKeyStateStructure senderSigningKey\n     * @property {Array.<groupproto.ISenderMessageKey>|null} [senderMessageKeys] SenderKeyStateStructure senderMessageKeys\n     */\n\n    /**\n     * Constructs a new SenderKeyStateStructure.\n     * @memberof groupproto\n     * @classdesc Represents a SenderKeyStateStructure.\n     * @implements ISenderKeyStateStructure\n     * @constructor\n     * @param {groupproto.ISenderKeyStateStructure=} [properties] Properties to set\n     */\n    function SenderKeyStateStructure(properties) {\n      this.senderMessageKeys = [];\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * SenderKeyStateStructure senderKeyId.\n     * @member {number} senderKeyId\n     * @memberof groupproto.SenderKeyStateStructure\n     * @instance\n     */\n    SenderKeyStateStructure.prototype.senderKeyId = 0;\n\n    /**\n     * SenderKeyStateStructure senderChainKey.\n     * @member {groupproto.ISenderChainKey|null|undefined} senderChainKey\n     * @memberof groupproto.SenderKeyStateStructure\n     * @instance\n     */\n    SenderKeyStateStructure.prototype.senderChainKey = null;\n\n    /**\n     * SenderKeyStateStructure senderSigningKey.\n     * @member {groupproto.ISenderSigningKey|null|undefined} senderSigningKey\n     * @memberof groupproto.SenderKeyStateStructure\n     * @instance\n     */\n    SenderKeyStateStructure.prototype.senderSigningKey = null;\n\n    /**\n     * SenderKeyStateStructure senderMessageKeys.\n     * @member {Array.<groupproto.ISenderMessageKey>} senderMessageKeys\n     * @memberof groupproto.SenderKeyStateStructure\n     * @instance\n     */\n    SenderKeyStateStructure.prototype.senderMessageKeys = $util.emptyArray;\n\n    /**\n     * Creates a new SenderKeyStateStructure instance using the specified properties.\n     * @function create\n     * @memberof groupproto.SenderKeyStateStructure\n     * @static\n     * @param {groupproto.ISenderKeyStateStructure=} [properties] Properties to set\n     * @returns {groupproto.SenderKeyStateStructure} SenderKeyStateStructure instance\n     */\n    SenderKeyStateStructure.create = function create(properties) {\n      return new SenderKeyStateStructure(properties);\n    };\n\n    /**\n     * Encodes the specified SenderKeyStateStructure message. Does not implicitly {@link groupproto.SenderKeyStateStructure.verify|verify} messages.\n     * @function encode\n     * @memberof groupproto.SenderKeyStateStructure\n     * @static\n     * @param {groupproto.ISenderKeyStateStructure} message SenderKeyStateStructure message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SenderKeyStateStructure.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.senderKeyId != null && Object.hasOwnProperty.call(message, \"senderKeyId\")) writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.senderKeyId);\n      if (message.senderChainKey != null && Object.hasOwnProperty.call(message, \"senderChainKey\")) $root.groupproto.SenderChainKey.encode(message.senderChainKey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n      if (message.senderSigningKey != null && Object.hasOwnProperty.call(message, \"senderSigningKey\")) $root.groupproto.SenderSigningKey.encode(message.senderSigningKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n      if (message.senderMessageKeys != null && message.senderMessageKeys.length) for (var i = 0; i < message.senderMessageKeys.length; ++i) $root.groupproto.SenderMessageKey.encode(message.senderMessageKeys[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified SenderKeyStateStructure message, length delimited. Does not implicitly {@link groupproto.SenderKeyStateStructure.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof groupproto.SenderKeyStateStructure\n     * @static\n     * @param {groupproto.ISenderKeyStateStructure} message SenderKeyStateStructure message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SenderKeyStateStructure.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a SenderKeyStateStructure message from the specified reader or buffer.\n     * @function decode\n     * @memberof groupproto.SenderKeyStateStructure\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {groupproto.SenderKeyStateStructure} SenderKeyStateStructure\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SenderKeyStateStructure.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.groupproto.SenderKeyStateStructure();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.senderKeyId = reader.uint32();\n            break;\n          case 2:\n            message.senderChainKey = $root.groupproto.SenderChainKey.decode(reader, reader.uint32());\n            break;\n          case 3:\n            message.senderSigningKey = $root.groupproto.SenderSigningKey.decode(reader, reader.uint32());\n            break;\n          case 4:\n            if (!(message.senderMessageKeys && message.senderMessageKeys.length)) message.senderMessageKeys = [];\n            message.senderMessageKeys.push($root.groupproto.SenderMessageKey.decode(reader, reader.uint32()));\n            break;\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a SenderKeyStateStructure message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof groupproto.SenderKeyStateStructure\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {groupproto.SenderKeyStateStructure} SenderKeyStateStructure\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SenderKeyStateStructure.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a SenderKeyStateStructure message.\n     * @function verify\n     * @memberof groupproto.SenderKeyStateStructure\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    SenderKeyStateStructure.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.senderKeyId != null && message.hasOwnProperty(\"senderKeyId\")) if (!$util.isInteger(message.senderKeyId)) return \"senderKeyId: integer expected\";\n      if (message.senderChainKey != null && message.hasOwnProperty(\"senderChainKey\")) {\n        var error = $root.groupproto.SenderChainKey.verify(message.senderChainKey);\n        if (error) return \"senderChainKey.\" + error;\n      }\n      if (message.senderSigningKey != null && message.hasOwnProperty(\"senderSigningKey\")) {\n        var error = $root.groupproto.SenderSigningKey.verify(message.senderSigningKey);\n        if (error) return \"senderSigningKey.\" + error;\n      }\n      if (message.senderMessageKeys != null && message.hasOwnProperty(\"senderMessageKeys\")) {\n        if (!Array.isArray(message.senderMessageKeys)) return \"senderMessageKeys: array expected\";\n        for (var i = 0; i < message.senderMessageKeys.length; ++i) {\n          var error = $root.groupproto.SenderMessageKey.verify(message.senderMessageKeys[i]);\n          if (error) return \"senderMessageKeys.\" + error;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Creates a SenderKeyStateStructure message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof groupproto.SenderKeyStateStructure\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {groupproto.SenderKeyStateStructure} SenderKeyStateStructure\n     */\n    SenderKeyStateStructure.fromObject = function fromObject(object) {\n      if (object instanceof $root.groupproto.SenderKeyStateStructure) return object;\n      var message = new $root.groupproto.SenderKeyStateStructure();\n      if (object.senderKeyId != null) message.senderKeyId = object.senderKeyId >>> 0;\n      if (object.senderChainKey != null) {\n        if (typeof object.senderChainKey !== \"object\") throw TypeError(\".groupproto.SenderKeyStateStructure.senderChainKey: object expected\");\n        message.senderChainKey = $root.groupproto.SenderChainKey.fromObject(object.senderChainKey);\n      }\n      if (object.senderSigningKey != null) {\n        if (typeof object.senderSigningKey !== \"object\") throw TypeError(\".groupproto.SenderKeyStateStructure.senderSigningKey: object expected\");\n        message.senderSigningKey = $root.groupproto.SenderSigningKey.fromObject(object.senderSigningKey);\n      }\n      if (object.senderMessageKeys) {\n        if (!Array.isArray(object.senderMessageKeys)) throw TypeError(\".groupproto.SenderKeyStateStructure.senderMessageKeys: array expected\");\n        message.senderMessageKeys = [];\n        for (var i = 0; i < object.senderMessageKeys.length; ++i) {\n          if (typeof object.senderMessageKeys[i] !== \"object\") throw TypeError(\".groupproto.SenderKeyStateStructure.senderMessageKeys: object expected\");\n          message.senderMessageKeys[i] = $root.groupproto.SenderMessageKey.fromObject(object.senderMessageKeys[i]);\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a SenderKeyStateStructure message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof groupproto.SenderKeyStateStructure\n     * @static\n     * @param {groupproto.SenderKeyStateStructure} message SenderKeyStateStructure\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    SenderKeyStateStructure.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.senderMessageKeys = [];\n      if (options.defaults) {\n        object.senderKeyId = 0;\n        object.senderChainKey = null;\n        object.senderSigningKey = null;\n      }\n      if (message.senderKeyId != null && message.hasOwnProperty(\"senderKeyId\")) object.senderKeyId = message.senderKeyId;\n      if (message.senderChainKey != null && message.hasOwnProperty(\"senderChainKey\")) object.senderChainKey = $root.groupproto.SenderChainKey.toObject(message.senderChainKey, options);\n      if (message.senderSigningKey != null && message.hasOwnProperty(\"senderSigningKey\")) object.senderSigningKey = $root.groupproto.SenderSigningKey.toObject(message.senderSigningKey, options);\n      if (message.senderMessageKeys && message.senderMessageKeys.length) {\n        object.senderMessageKeys = [];\n        for (var j = 0; j < message.senderMessageKeys.length; ++j) object.senderMessageKeys[j] = $root.groupproto.SenderMessageKey.toObject(message.senderMessageKeys[j], options);\n      }\n      return object;\n    };\n\n    /**\n     * Converts this SenderKeyStateStructure to JSON.\n     * @function toJSON\n     * @memberof groupproto.SenderKeyStateStructure\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    SenderKeyStateStructure.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    return SenderKeyStateStructure;\n  }();\n  groupproto.SenderKeyRecordStructure = function () {\n    /**\n     * Properties of a SenderKeyRecordStructure.\n     * @memberof groupproto\n     * @interface ISenderKeyRecordStructure\n     * @property {Array.<groupproto.ISenderKeyStateStructure>|null} [senderKeyStates] SenderKeyRecordStructure senderKeyStates\n     */\n\n    /**\n     * Constructs a new SenderKeyRecordStructure.\n     * @memberof groupproto\n     * @classdesc Represents a SenderKeyRecordStructure.\n     * @implements ISenderKeyRecordStructure\n     * @constructor\n     * @param {groupproto.ISenderKeyRecordStructure=} [properties] Properties to set\n     */\n    function SenderKeyRecordStructure(properties) {\n      this.senderKeyStates = [];\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * SenderKeyRecordStructure senderKeyStates.\n     * @member {Array.<groupproto.ISenderKeyStateStructure>} senderKeyStates\n     * @memberof groupproto.SenderKeyRecordStructure\n     * @instance\n     */\n    SenderKeyRecordStructure.prototype.senderKeyStates = $util.emptyArray;\n\n    /**\n     * Creates a new SenderKeyRecordStructure instance using the specified properties.\n     * @function create\n     * @memberof groupproto.SenderKeyRecordStructure\n     * @static\n     * @param {groupproto.ISenderKeyRecordStructure=} [properties] Properties to set\n     * @returns {groupproto.SenderKeyRecordStructure} SenderKeyRecordStructure instance\n     */\n    SenderKeyRecordStructure.create = function create(properties) {\n      return new SenderKeyRecordStructure(properties);\n    };\n\n    /**\n     * Encodes the specified SenderKeyRecordStructure message. Does not implicitly {@link groupproto.SenderKeyRecordStructure.verify|verify} messages.\n     * @function encode\n     * @memberof groupproto.SenderKeyRecordStructure\n     * @static\n     * @param {groupproto.ISenderKeyRecordStructure} message SenderKeyRecordStructure message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SenderKeyRecordStructure.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.senderKeyStates != null && message.senderKeyStates.length) for (var i = 0; i < message.senderKeyStates.length; ++i) $root.groupproto.SenderKeyStateStructure.encode(message.senderKeyStates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified SenderKeyRecordStructure message, length delimited. Does not implicitly {@link groupproto.SenderKeyRecordStructure.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof groupproto.SenderKeyRecordStructure\n     * @static\n     * @param {groupproto.ISenderKeyRecordStructure} message SenderKeyRecordStructure message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    SenderKeyRecordStructure.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a SenderKeyRecordStructure message from the specified reader or buffer.\n     * @function decode\n     * @memberof groupproto.SenderKeyRecordStructure\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {groupproto.SenderKeyRecordStructure} SenderKeyRecordStructure\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SenderKeyRecordStructure.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.groupproto.SenderKeyRecordStructure();\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            if (!(message.senderKeyStates && message.senderKeyStates.length)) message.senderKeyStates = [];\n            message.senderKeyStates.push($root.groupproto.SenderKeyStateStructure.decode(reader, reader.uint32()));\n            break;\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a SenderKeyRecordStructure message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof groupproto.SenderKeyRecordStructure\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {groupproto.SenderKeyRecordStructure} SenderKeyRecordStructure\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    SenderKeyRecordStructure.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a SenderKeyRecordStructure message.\n     * @function verify\n     * @memberof groupproto.SenderKeyRecordStructure\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    SenderKeyRecordStructure.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.senderKeyStates != null && message.hasOwnProperty(\"senderKeyStates\")) {\n        if (!Array.isArray(message.senderKeyStates)) return \"senderKeyStates: array expected\";\n        for (var i = 0; i < message.senderKeyStates.length; ++i) {\n          var error = $root.groupproto.SenderKeyStateStructure.verify(message.senderKeyStates[i]);\n          if (error) return \"senderKeyStates.\" + error;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Creates a SenderKeyRecordStructure message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof groupproto.SenderKeyRecordStructure\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {groupproto.SenderKeyRecordStructure} SenderKeyRecordStructure\n     */\n    SenderKeyRecordStructure.fromObject = function fromObject(object) {\n      if (object instanceof $root.groupproto.SenderKeyRecordStructure) return object;\n      var message = new $root.groupproto.SenderKeyRecordStructure();\n      if (object.senderKeyStates) {\n        if (!Array.isArray(object.senderKeyStates)) throw TypeError(\".groupproto.SenderKeyRecordStructure.senderKeyStates: array expected\");\n        message.senderKeyStates = [];\n        for (var i = 0; i < object.senderKeyStates.length; ++i) {\n          if (typeof object.senderKeyStates[i] !== \"object\") throw TypeError(\".groupproto.SenderKeyRecordStructure.senderKeyStates: object expected\");\n          message.senderKeyStates[i] = $root.groupproto.SenderKeyStateStructure.fromObject(object.senderKeyStates[i]);\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a SenderKeyRecordStructure message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof groupproto.SenderKeyRecordStructure\n     * @static\n     * @param {groupproto.SenderKeyRecordStructure} message SenderKeyRecordStructure\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    SenderKeyRecordStructure.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.senderKeyStates = [];\n      if (message.senderKeyStates && message.senderKeyStates.length) {\n        object.senderKeyStates = [];\n        for (var j = 0; j < message.senderKeyStates.length; ++j) object.senderKeyStates[j] = $root.groupproto.SenderKeyStateStructure.toObject(message.senderKeyStates[j], options);\n      }\n      return object;\n    };\n\n    /**\n     * Converts this SenderKeyRecordStructure to JSON.\n     * @function toJSON\n     * @memberof groupproto.SenderKeyRecordStructure\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    SenderKeyRecordStructure.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    return SenderKeyRecordStructure;\n  }();\n  return groupproto;\n}();\nmodule.exports = $root;","map":{"version":3,"names":["$protobuf","require","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","groupproto","SenderKeyMessage","properties","keys","Object","i","length","prototype","id","iteration","ciphertext","newBuffer","create","encode","message","writer","hasOwnProperty","call","uint32","bytes","encodeDelimited","ldelim","decode","reader","end","undefined","len","pos","tag","skipType","decodeDelimited","verify","isInteger","isString","fromObject","object","base64","toObject","options","defaults","String","Array","slice","toJSON","constructor","toJSONOptions","SenderKeyDistributionMessage","chainKey","signingKey","SenderChainKey","seed","SenderMessageKey","SenderSigningKey","SenderKeyStateStructure","senderMessageKeys","senderKeyId","senderChainKey","senderSigningKey","emptyArray","fork","push","error","isArray","TypeError","arrays","j","SenderKeyRecordStructure","senderKeyStates","module","exports"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/WASignalGroup/GroupProtocol.js"],"sourcesContent":["/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.groupproto = (function() {\n\n    /**\n     * Namespace groupproto.\n     * @exports groupproto\n     * @namespace\n     */\n    var groupproto = {};\n\n    groupproto.SenderKeyMessage = (function() {\n\n        /**\n         * Properties of a SenderKeyMessage.\n         * @memberof groupproto\n         * @interface ISenderKeyMessage\n         * @property {number|null} [id] SenderKeyMessage id\n         * @property {number|null} [iteration] SenderKeyMessage iteration\n         * @property {Uint8Array|null} [ciphertext] SenderKeyMessage ciphertext\n         */\n\n        /**\n         * Constructs a new SenderKeyMessage.\n         * @memberof groupproto\n         * @classdesc Represents a SenderKeyMessage.\n         * @implements ISenderKeyMessage\n         * @constructor\n         * @param {groupproto.ISenderKeyMessage=} [properties] Properties to set\n         */\n        function SenderKeyMessage(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * SenderKeyMessage id.\n         * @member {number} id\n         * @memberof groupproto.SenderKeyMessage\n         * @instance\n         */\n        SenderKeyMessage.prototype.id = 0;\n\n        /**\n         * SenderKeyMessage iteration.\n         * @member {number} iteration\n         * @memberof groupproto.SenderKeyMessage\n         * @instance\n         */\n        SenderKeyMessage.prototype.iteration = 0;\n\n        /**\n         * SenderKeyMessage ciphertext.\n         * @member {Uint8Array} ciphertext\n         * @memberof groupproto.SenderKeyMessage\n         * @instance\n         */\n        SenderKeyMessage.prototype.ciphertext = $util.newBuffer([]);\n\n        /**\n         * Creates a new SenderKeyMessage instance using the specified properties.\n         * @function create\n         * @memberof groupproto.SenderKeyMessage\n         * @static\n         * @param {groupproto.ISenderKeyMessage=} [properties] Properties to set\n         * @returns {groupproto.SenderKeyMessage} SenderKeyMessage instance\n         */\n        SenderKeyMessage.create = function create(properties) {\n            return new SenderKeyMessage(properties);\n        };\n\n        /**\n         * Encodes the specified SenderKeyMessage message. Does not implicitly {@link groupproto.SenderKeyMessage.verify|verify} messages.\n         * @function encode\n         * @memberof groupproto.SenderKeyMessage\n         * @static\n         * @param {groupproto.ISenderKeyMessage} message SenderKeyMessage message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SenderKeyMessage.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);\n            if (message.iteration != null && Object.hasOwnProperty.call(message, \"iteration\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.iteration);\n            if (message.ciphertext != null && Object.hasOwnProperty.call(message, \"ciphertext\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ciphertext);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified SenderKeyMessage message, length delimited. Does not implicitly {@link groupproto.SenderKeyMessage.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof groupproto.SenderKeyMessage\n         * @static\n         * @param {groupproto.ISenderKeyMessage} message SenderKeyMessage message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SenderKeyMessage.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a SenderKeyMessage message from the specified reader or buffer.\n         * @function decode\n         * @memberof groupproto.SenderKeyMessage\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {groupproto.SenderKeyMessage} SenderKeyMessage\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SenderKeyMessage.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.groupproto.SenderKeyMessage();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.uint32();\n                    break;\n                case 2:\n                    message.iteration = reader.uint32();\n                    break;\n                case 3:\n                    message.ciphertext = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a SenderKeyMessage message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof groupproto.SenderKeyMessage\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {groupproto.SenderKeyMessage} SenderKeyMessage\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SenderKeyMessage.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a SenderKeyMessage message.\n         * @function verify\n         * @memberof groupproto.SenderKeyMessage\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        SenderKeyMessage.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                if (!$util.isInteger(message.id))\n                    return \"id: integer expected\";\n            if (message.iteration != null && message.hasOwnProperty(\"iteration\"))\n                if (!$util.isInteger(message.iteration))\n                    return \"iteration: integer expected\";\n            if (message.ciphertext != null && message.hasOwnProperty(\"ciphertext\"))\n                if (!(message.ciphertext && typeof message.ciphertext.length === \"number\" || $util.isString(message.ciphertext)))\n                    return \"ciphertext: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a SenderKeyMessage message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof groupproto.SenderKeyMessage\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {groupproto.SenderKeyMessage} SenderKeyMessage\n         */\n        SenderKeyMessage.fromObject = function fromObject(object) {\n            if (object instanceof $root.groupproto.SenderKeyMessage)\n                return object;\n            var message = new $root.groupproto.SenderKeyMessage();\n            if (object.id != null)\n                message.id = object.id >>> 0;\n            if (object.iteration != null)\n                message.iteration = object.iteration >>> 0;\n            if (object.ciphertext != null)\n                if (typeof object.ciphertext === \"string\")\n                    $util.base64.decode(object.ciphertext, message.ciphertext = $util.newBuffer($util.base64.length(object.ciphertext)), 0);\n                else if (object.ciphertext.length)\n                    message.ciphertext = object.ciphertext;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a SenderKeyMessage message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof groupproto.SenderKeyMessage\n         * @static\n         * @param {groupproto.SenderKeyMessage} message SenderKeyMessage\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        SenderKeyMessage.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.id = 0;\n                object.iteration = 0;\n                if (options.bytes === String)\n                    object.ciphertext = \"\";\n                else {\n                    object.ciphertext = [];\n                    if (options.bytes !== Array)\n                        object.ciphertext = $util.newBuffer(object.ciphertext);\n                }\n            }\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                object.id = message.id;\n            if (message.iteration != null && message.hasOwnProperty(\"iteration\"))\n                object.iteration = message.iteration;\n            if (message.ciphertext != null && message.hasOwnProperty(\"ciphertext\"))\n                object.ciphertext = options.bytes === String ? $util.base64.encode(message.ciphertext, 0, message.ciphertext.length) : options.bytes === Array ? Array.prototype.slice.call(message.ciphertext) : message.ciphertext;\n            return object;\n        };\n\n        /**\n         * Converts this SenderKeyMessage to JSON.\n         * @function toJSON\n         * @memberof groupproto.SenderKeyMessage\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        SenderKeyMessage.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return SenderKeyMessage;\n    })();\n\n    groupproto.SenderKeyDistributionMessage = (function() {\n\n        /**\n         * Properties of a SenderKeyDistributionMessage.\n         * @memberof groupproto\n         * @interface ISenderKeyDistributionMessage\n         * @property {number|null} [id] SenderKeyDistributionMessage id\n         * @property {number|null} [iteration] SenderKeyDistributionMessage iteration\n         * @property {Uint8Array|null} [chainKey] SenderKeyDistributionMessage chainKey\n         * @property {Uint8Array|null} [signingKey] SenderKeyDistributionMessage signingKey\n         */\n\n        /**\n         * Constructs a new SenderKeyDistributionMessage.\n         * @memberof groupproto\n         * @classdesc Represents a SenderKeyDistributionMessage.\n         * @implements ISenderKeyDistributionMessage\n         * @constructor\n         * @param {groupproto.ISenderKeyDistributionMessage=} [properties] Properties to set\n         */\n        function SenderKeyDistributionMessage(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * SenderKeyDistributionMessage id.\n         * @member {number} id\n         * @memberof groupproto.SenderKeyDistributionMessage\n         * @instance\n         */\n        SenderKeyDistributionMessage.prototype.id = 0;\n\n        /**\n         * SenderKeyDistributionMessage iteration.\n         * @member {number} iteration\n         * @memberof groupproto.SenderKeyDistributionMessage\n         * @instance\n         */\n        SenderKeyDistributionMessage.prototype.iteration = 0;\n\n        /**\n         * SenderKeyDistributionMessage chainKey.\n         * @member {Uint8Array} chainKey\n         * @memberof groupproto.SenderKeyDistributionMessage\n         * @instance\n         */\n        SenderKeyDistributionMessage.prototype.chainKey = $util.newBuffer([]);\n\n        /**\n         * SenderKeyDistributionMessage signingKey.\n         * @member {Uint8Array} signingKey\n         * @memberof groupproto.SenderKeyDistributionMessage\n         * @instance\n         */\n        SenderKeyDistributionMessage.prototype.signingKey = $util.newBuffer([]);\n\n        /**\n         * Creates a new SenderKeyDistributionMessage instance using the specified properties.\n         * @function create\n         * @memberof groupproto.SenderKeyDistributionMessage\n         * @static\n         * @param {groupproto.ISenderKeyDistributionMessage=} [properties] Properties to set\n         * @returns {groupproto.SenderKeyDistributionMessage} SenderKeyDistributionMessage instance\n         */\n        SenderKeyDistributionMessage.create = function create(properties) {\n            return new SenderKeyDistributionMessage(properties);\n        };\n\n        /**\n         * Encodes the specified SenderKeyDistributionMessage message. Does not implicitly {@link groupproto.SenderKeyDistributionMessage.verify|verify} messages.\n         * @function encode\n         * @memberof groupproto.SenderKeyDistributionMessage\n         * @static\n         * @param {groupproto.ISenderKeyDistributionMessage} message SenderKeyDistributionMessage message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SenderKeyDistributionMessage.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);\n            if (message.iteration != null && Object.hasOwnProperty.call(message, \"iteration\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.iteration);\n            if (message.chainKey != null && Object.hasOwnProperty.call(message, \"chainKey\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.chainKey);\n            if (message.signingKey != null && Object.hasOwnProperty.call(message, \"signingKey\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signingKey);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified SenderKeyDistributionMessage message, length delimited. Does not implicitly {@link groupproto.SenderKeyDistributionMessage.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof groupproto.SenderKeyDistributionMessage\n         * @static\n         * @param {groupproto.ISenderKeyDistributionMessage} message SenderKeyDistributionMessage message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SenderKeyDistributionMessage.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a SenderKeyDistributionMessage message from the specified reader or buffer.\n         * @function decode\n         * @memberof groupproto.SenderKeyDistributionMessage\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {groupproto.SenderKeyDistributionMessage} SenderKeyDistributionMessage\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SenderKeyDistributionMessage.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.groupproto.SenderKeyDistributionMessage();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.uint32();\n                    break;\n                case 2:\n                    message.iteration = reader.uint32();\n                    break;\n                case 3:\n                    message.chainKey = reader.bytes();\n                    break;\n                case 4:\n                    message.signingKey = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a SenderKeyDistributionMessage message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof groupproto.SenderKeyDistributionMessage\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {groupproto.SenderKeyDistributionMessage} SenderKeyDistributionMessage\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SenderKeyDistributionMessage.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a SenderKeyDistributionMessage message.\n         * @function verify\n         * @memberof groupproto.SenderKeyDistributionMessage\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        SenderKeyDistributionMessage.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                if (!$util.isInteger(message.id))\n                    return \"id: integer expected\";\n            if (message.iteration != null && message.hasOwnProperty(\"iteration\"))\n                if (!$util.isInteger(message.iteration))\n                    return \"iteration: integer expected\";\n            if (message.chainKey != null && message.hasOwnProperty(\"chainKey\"))\n                if (!(message.chainKey && typeof message.chainKey.length === \"number\" || $util.isString(message.chainKey)))\n                    return \"chainKey: buffer expected\";\n            if (message.signingKey != null && message.hasOwnProperty(\"signingKey\"))\n                if (!(message.signingKey && typeof message.signingKey.length === \"number\" || $util.isString(message.signingKey)))\n                    return \"signingKey: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a SenderKeyDistributionMessage message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof groupproto.SenderKeyDistributionMessage\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {groupproto.SenderKeyDistributionMessage} SenderKeyDistributionMessage\n         */\n        SenderKeyDistributionMessage.fromObject = function fromObject(object) {\n            if (object instanceof $root.groupproto.SenderKeyDistributionMessage)\n                return object;\n            var message = new $root.groupproto.SenderKeyDistributionMessage();\n            if (object.id != null)\n                message.id = object.id >>> 0;\n            if (object.iteration != null)\n                message.iteration = object.iteration >>> 0;\n            if (object.chainKey != null)\n                if (typeof object.chainKey === \"string\")\n                    $util.base64.decode(object.chainKey, message.chainKey = $util.newBuffer($util.base64.length(object.chainKey)), 0);\n                else if (object.chainKey.length)\n                    message.chainKey = object.chainKey;\n            if (object.signingKey != null)\n                if (typeof object.signingKey === \"string\")\n                    $util.base64.decode(object.signingKey, message.signingKey = $util.newBuffer($util.base64.length(object.signingKey)), 0);\n                else if (object.signingKey.length)\n                    message.signingKey = object.signingKey;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a SenderKeyDistributionMessage message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof groupproto.SenderKeyDistributionMessage\n         * @static\n         * @param {groupproto.SenderKeyDistributionMessage} message SenderKeyDistributionMessage\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        SenderKeyDistributionMessage.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.id = 0;\n                object.iteration = 0;\n                if (options.bytes === String)\n                    object.chainKey = \"\";\n                else {\n                    object.chainKey = [];\n                    if (options.bytes !== Array)\n                        object.chainKey = $util.newBuffer(object.chainKey);\n                }\n                if (options.bytes === String)\n                    object.signingKey = \"\";\n                else {\n                    object.signingKey = [];\n                    if (options.bytes !== Array)\n                        object.signingKey = $util.newBuffer(object.signingKey);\n                }\n            }\n            if (message.id != null && message.hasOwnProperty(\"id\"))\n                object.id = message.id;\n            if (message.iteration != null && message.hasOwnProperty(\"iteration\"))\n                object.iteration = message.iteration;\n            if (message.chainKey != null && message.hasOwnProperty(\"chainKey\"))\n                object.chainKey = options.bytes === String ? $util.base64.encode(message.chainKey, 0, message.chainKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.chainKey) : message.chainKey;\n            if (message.signingKey != null && message.hasOwnProperty(\"signingKey\"))\n                object.signingKey = options.bytes === String ? $util.base64.encode(message.signingKey, 0, message.signingKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.signingKey) : message.signingKey;\n            return object;\n        };\n\n        /**\n         * Converts this SenderKeyDistributionMessage to JSON.\n         * @function toJSON\n         * @memberof groupproto.SenderKeyDistributionMessage\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        SenderKeyDistributionMessage.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return SenderKeyDistributionMessage;\n    })();\n\n    groupproto.SenderChainKey = (function() {\n\n        /**\n         * Properties of a SenderChainKey.\n         * @memberof groupproto\n         * @interface ISenderChainKey\n         * @property {number|null} [iteration] SenderChainKey iteration\n         * @property {Uint8Array|null} [seed] SenderChainKey seed\n         */\n\n        /**\n         * Constructs a new SenderChainKey.\n         * @memberof groupproto\n         * @classdesc Represents a SenderChainKey.\n         * @implements ISenderChainKey\n         * @constructor\n         * @param {groupproto.ISenderChainKey=} [properties] Properties to set\n         */\n        function SenderChainKey(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * SenderChainKey iteration.\n         * @member {number} iteration\n         * @memberof groupproto.SenderChainKey\n         * @instance\n         */\n        SenderChainKey.prototype.iteration = 0;\n\n        /**\n         * SenderChainKey seed.\n         * @member {Uint8Array} seed\n         * @memberof groupproto.SenderChainKey\n         * @instance\n         */\n        SenderChainKey.prototype.seed = $util.newBuffer([]);\n\n        /**\n         * Creates a new SenderChainKey instance using the specified properties.\n         * @function create\n         * @memberof groupproto.SenderChainKey\n         * @static\n         * @param {groupproto.ISenderChainKey=} [properties] Properties to set\n         * @returns {groupproto.SenderChainKey} SenderChainKey instance\n         */\n        SenderChainKey.create = function create(properties) {\n            return new SenderChainKey(properties);\n        };\n\n        /**\n         * Encodes the specified SenderChainKey message. Does not implicitly {@link groupproto.SenderChainKey.verify|verify} messages.\n         * @function encode\n         * @memberof groupproto.SenderChainKey\n         * @static\n         * @param {groupproto.ISenderChainKey} message SenderChainKey message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SenderChainKey.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.iteration != null && Object.hasOwnProperty.call(message, \"iteration\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.iteration);\n            if (message.seed != null && Object.hasOwnProperty.call(message, \"seed\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.seed);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified SenderChainKey message, length delimited. Does not implicitly {@link groupproto.SenderChainKey.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof groupproto.SenderChainKey\n         * @static\n         * @param {groupproto.ISenderChainKey} message SenderChainKey message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SenderChainKey.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a SenderChainKey message from the specified reader or buffer.\n         * @function decode\n         * @memberof groupproto.SenderChainKey\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {groupproto.SenderChainKey} SenderChainKey\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SenderChainKey.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.groupproto.SenderChainKey();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.iteration = reader.uint32();\n                    break;\n                case 2:\n                    message.seed = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a SenderChainKey message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof groupproto.SenderChainKey\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {groupproto.SenderChainKey} SenderChainKey\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SenderChainKey.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a SenderChainKey message.\n         * @function verify\n         * @memberof groupproto.SenderChainKey\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        SenderChainKey.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.iteration != null && message.hasOwnProperty(\"iteration\"))\n                if (!$util.isInteger(message.iteration))\n                    return \"iteration: integer expected\";\n            if (message.seed != null && message.hasOwnProperty(\"seed\"))\n                if (!(message.seed && typeof message.seed.length === \"number\" || $util.isString(message.seed)))\n                    return \"seed: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a SenderChainKey message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof groupproto.SenderChainKey\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {groupproto.SenderChainKey} SenderChainKey\n         */\n        SenderChainKey.fromObject = function fromObject(object) {\n            if (object instanceof $root.groupproto.SenderChainKey)\n                return object;\n            var message = new $root.groupproto.SenderChainKey();\n            if (object.iteration != null)\n                message.iteration = object.iteration >>> 0;\n            if (object.seed != null)\n                if (typeof object.seed === \"string\")\n                    $util.base64.decode(object.seed, message.seed = $util.newBuffer($util.base64.length(object.seed)), 0);\n                else if (object.seed.length)\n                    message.seed = object.seed;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a SenderChainKey message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof groupproto.SenderChainKey\n         * @static\n         * @param {groupproto.SenderChainKey} message SenderChainKey\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        SenderChainKey.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.iteration = 0;\n                if (options.bytes === String)\n                    object.seed = \"\";\n                else {\n                    object.seed = [];\n                    if (options.bytes !== Array)\n                        object.seed = $util.newBuffer(object.seed);\n                }\n            }\n            if (message.iteration != null && message.hasOwnProperty(\"iteration\"))\n                object.iteration = message.iteration;\n            if (message.seed != null && message.hasOwnProperty(\"seed\"))\n                object.seed = options.bytes === String ? $util.base64.encode(message.seed, 0, message.seed.length) : options.bytes === Array ? Array.prototype.slice.call(message.seed) : message.seed;\n            return object;\n        };\n\n        /**\n         * Converts this SenderChainKey to JSON.\n         * @function toJSON\n         * @memberof groupproto.SenderChainKey\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        SenderChainKey.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return SenderChainKey;\n    })();\n\n    groupproto.SenderMessageKey = (function() {\n\n        /**\n         * Properties of a SenderMessageKey.\n         * @memberof groupproto\n         * @interface ISenderMessageKey\n         * @property {number|null} [iteration] SenderMessageKey iteration\n         * @property {Uint8Array|null} [seed] SenderMessageKey seed\n         */\n\n        /**\n         * Constructs a new SenderMessageKey.\n         * @memberof groupproto\n         * @classdesc Represents a SenderMessageKey.\n         * @implements ISenderMessageKey\n         * @constructor\n         * @param {groupproto.ISenderMessageKey=} [properties] Properties to set\n         */\n        function SenderMessageKey(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * SenderMessageKey iteration.\n         * @member {number} iteration\n         * @memberof groupproto.SenderMessageKey\n         * @instance\n         */\n        SenderMessageKey.prototype.iteration = 0;\n\n        /**\n         * SenderMessageKey seed.\n         * @member {Uint8Array} seed\n         * @memberof groupproto.SenderMessageKey\n         * @instance\n         */\n        SenderMessageKey.prototype.seed = $util.newBuffer([]);\n\n        /**\n         * Creates a new SenderMessageKey instance using the specified properties.\n         * @function create\n         * @memberof groupproto.SenderMessageKey\n         * @static\n         * @param {groupproto.ISenderMessageKey=} [properties] Properties to set\n         * @returns {groupproto.SenderMessageKey} SenderMessageKey instance\n         */\n        SenderMessageKey.create = function create(properties) {\n            return new SenderMessageKey(properties);\n        };\n\n        /**\n         * Encodes the specified SenderMessageKey message. Does not implicitly {@link groupproto.SenderMessageKey.verify|verify} messages.\n         * @function encode\n         * @memberof groupproto.SenderMessageKey\n         * @static\n         * @param {groupproto.ISenderMessageKey} message SenderMessageKey message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SenderMessageKey.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.iteration != null && Object.hasOwnProperty.call(message, \"iteration\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.iteration);\n            if (message.seed != null && Object.hasOwnProperty.call(message, \"seed\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.seed);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified SenderMessageKey message, length delimited. Does not implicitly {@link groupproto.SenderMessageKey.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof groupproto.SenderMessageKey\n         * @static\n         * @param {groupproto.ISenderMessageKey} message SenderMessageKey message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SenderMessageKey.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a SenderMessageKey message from the specified reader or buffer.\n         * @function decode\n         * @memberof groupproto.SenderMessageKey\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {groupproto.SenderMessageKey} SenderMessageKey\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SenderMessageKey.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.groupproto.SenderMessageKey();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.iteration = reader.uint32();\n                    break;\n                case 2:\n                    message.seed = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a SenderMessageKey message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof groupproto.SenderMessageKey\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {groupproto.SenderMessageKey} SenderMessageKey\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SenderMessageKey.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a SenderMessageKey message.\n         * @function verify\n         * @memberof groupproto.SenderMessageKey\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        SenderMessageKey.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.iteration != null && message.hasOwnProperty(\"iteration\"))\n                if (!$util.isInteger(message.iteration))\n                    return \"iteration: integer expected\";\n            if (message.seed != null && message.hasOwnProperty(\"seed\"))\n                if (!(message.seed && typeof message.seed.length === \"number\" || $util.isString(message.seed)))\n                    return \"seed: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a SenderMessageKey message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof groupproto.SenderMessageKey\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {groupproto.SenderMessageKey} SenderMessageKey\n         */\n        SenderMessageKey.fromObject = function fromObject(object) {\n            if (object instanceof $root.groupproto.SenderMessageKey)\n                return object;\n            var message = new $root.groupproto.SenderMessageKey();\n            if (object.iteration != null)\n                message.iteration = object.iteration >>> 0;\n            if (object.seed != null)\n                if (typeof object.seed === \"string\")\n                    $util.base64.decode(object.seed, message.seed = $util.newBuffer($util.base64.length(object.seed)), 0);\n                else if (object.seed.length)\n                    message.seed = object.seed;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a SenderMessageKey message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof groupproto.SenderMessageKey\n         * @static\n         * @param {groupproto.SenderMessageKey} message SenderMessageKey\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        SenderMessageKey.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.iteration = 0;\n                if (options.bytes === String)\n                    object.seed = \"\";\n                else {\n                    object.seed = [];\n                    if (options.bytes !== Array)\n                        object.seed = $util.newBuffer(object.seed);\n                }\n            }\n            if (message.iteration != null && message.hasOwnProperty(\"iteration\"))\n                object.iteration = message.iteration;\n            if (message.seed != null && message.hasOwnProperty(\"seed\"))\n                object.seed = options.bytes === String ? $util.base64.encode(message.seed, 0, message.seed.length) : options.bytes === Array ? Array.prototype.slice.call(message.seed) : message.seed;\n            return object;\n        };\n\n        /**\n         * Converts this SenderMessageKey to JSON.\n         * @function toJSON\n         * @memberof groupproto.SenderMessageKey\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        SenderMessageKey.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return SenderMessageKey;\n    })();\n\n    groupproto.SenderSigningKey = (function() {\n\n        /**\n         * Properties of a SenderSigningKey.\n         * @memberof groupproto\n         * @interface ISenderSigningKey\n         * @property {Uint8Array|null} [\"public\"] SenderSigningKey public\n         * @property {Uint8Array|null} [\"private\"] SenderSigningKey private\n         */\n\n        /**\n         * Constructs a new SenderSigningKey.\n         * @memberof groupproto\n         * @classdesc Represents a SenderSigningKey.\n         * @implements ISenderSigningKey\n         * @constructor\n         * @param {groupproto.ISenderSigningKey=} [properties] Properties to set\n         */\n        function SenderSigningKey(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * SenderSigningKey public.\n         * @member {Uint8Array} public\n         * @memberof groupproto.SenderSigningKey\n         * @instance\n         */\n        SenderSigningKey.prototype[\"public\"] = $util.newBuffer([]);\n\n        /**\n         * SenderSigningKey private.\n         * @member {Uint8Array} private\n         * @memberof groupproto.SenderSigningKey\n         * @instance\n         */\n        SenderSigningKey.prototype[\"private\"] = $util.newBuffer([]);\n\n        /**\n         * Creates a new SenderSigningKey instance using the specified properties.\n         * @function create\n         * @memberof groupproto.SenderSigningKey\n         * @static\n         * @param {groupproto.ISenderSigningKey=} [properties] Properties to set\n         * @returns {groupproto.SenderSigningKey} SenderSigningKey instance\n         */\n        SenderSigningKey.create = function create(properties) {\n            return new SenderSigningKey(properties);\n        };\n\n        /**\n         * Encodes the specified SenderSigningKey message. Does not implicitly {@link groupproto.SenderSigningKey.verify|verify} messages.\n         * @function encode\n         * @memberof groupproto.SenderSigningKey\n         * @static\n         * @param {groupproto.ISenderSigningKey} message SenderSigningKey message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SenderSigningKey.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message[\"public\"] != null && Object.hasOwnProperty.call(message, \"public\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message[\"public\"]);\n            if (message[\"private\"] != null && Object.hasOwnProperty.call(message, \"private\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message[\"private\"]);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified SenderSigningKey message, length delimited. Does not implicitly {@link groupproto.SenderSigningKey.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof groupproto.SenderSigningKey\n         * @static\n         * @param {groupproto.ISenderSigningKey} message SenderSigningKey message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SenderSigningKey.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a SenderSigningKey message from the specified reader or buffer.\n         * @function decode\n         * @memberof groupproto.SenderSigningKey\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {groupproto.SenderSigningKey} SenderSigningKey\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SenderSigningKey.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.groupproto.SenderSigningKey();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message[\"public\"] = reader.bytes();\n                    break;\n                case 2:\n                    message[\"private\"] = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a SenderSigningKey message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof groupproto.SenderSigningKey\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {groupproto.SenderSigningKey} SenderSigningKey\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SenderSigningKey.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a SenderSigningKey message.\n         * @function verify\n         * @memberof groupproto.SenderSigningKey\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        SenderSigningKey.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message[\"public\"] != null && message.hasOwnProperty(\"public\"))\n                if (!(message[\"public\"] && typeof message[\"public\"].length === \"number\" || $util.isString(message[\"public\"])))\n                    return \"public: buffer expected\";\n            if (message[\"private\"] != null && message.hasOwnProperty(\"private\"))\n                if (!(message[\"private\"] && typeof message[\"private\"].length === \"number\" || $util.isString(message[\"private\"])))\n                    return \"private: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a SenderSigningKey message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof groupproto.SenderSigningKey\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {groupproto.SenderSigningKey} SenderSigningKey\n         */\n        SenderSigningKey.fromObject = function fromObject(object) {\n            if (object instanceof $root.groupproto.SenderSigningKey)\n                return object;\n            var message = new $root.groupproto.SenderSigningKey();\n            if (object[\"public\"] != null)\n                if (typeof object[\"public\"] === \"string\")\n                    $util.base64.decode(object[\"public\"], message[\"public\"] = $util.newBuffer($util.base64.length(object[\"public\"])), 0);\n                else if (object[\"public\"].length)\n                    message[\"public\"] = object[\"public\"];\n            if (object[\"private\"] != null)\n                if (typeof object[\"private\"] === \"string\")\n                    $util.base64.decode(object[\"private\"], message[\"private\"] = $util.newBuffer($util.base64.length(object[\"private\"])), 0);\n                else if (object[\"private\"].length)\n                    message[\"private\"] = object[\"private\"];\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a SenderSigningKey message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof groupproto.SenderSigningKey\n         * @static\n         * @param {groupproto.SenderSigningKey} message SenderSigningKey\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        SenderSigningKey.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object[\"public\"] = \"\";\n                else {\n                    object[\"public\"] = [];\n                    if (options.bytes !== Array)\n                        object[\"public\"] = $util.newBuffer(object[\"public\"]);\n                }\n                if (options.bytes === String)\n                    object[\"private\"] = \"\";\n                else {\n                    object[\"private\"] = [];\n                    if (options.bytes !== Array)\n                        object[\"private\"] = $util.newBuffer(object[\"private\"]);\n                }\n            }\n            if (message[\"public\"] != null && message.hasOwnProperty(\"public\"))\n                object[\"public\"] = options.bytes === String ? $util.base64.encode(message[\"public\"], 0, message[\"public\"].length) : options.bytes === Array ? Array.prototype.slice.call(message[\"public\"]) : message[\"public\"];\n            if (message[\"private\"] != null && message.hasOwnProperty(\"private\"))\n                object[\"private\"] = options.bytes === String ? $util.base64.encode(message[\"private\"], 0, message[\"private\"].length) : options.bytes === Array ? Array.prototype.slice.call(message[\"private\"]) : message[\"private\"];\n            return object;\n        };\n\n        /**\n         * Converts this SenderSigningKey to JSON.\n         * @function toJSON\n         * @memberof groupproto.SenderSigningKey\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        SenderSigningKey.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return SenderSigningKey;\n    })();\n\n    groupproto.SenderKeyStateStructure = (function() {\n\n        /**\n         * Properties of a SenderKeyStateStructure.\n         * @memberof groupproto\n         * @interface ISenderKeyStateStructure\n         * @property {number|null} [senderKeyId] SenderKeyStateStructure senderKeyId\n         * @property {groupproto.ISenderChainKey|null} [senderChainKey] SenderKeyStateStructure senderChainKey\n         * @property {groupproto.ISenderSigningKey|null} [senderSigningKey] SenderKeyStateStructure senderSigningKey\n         * @property {Array.<groupproto.ISenderMessageKey>|null} [senderMessageKeys] SenderKeyStateStructure senderMessageKeys\n         */\n\n        /**\n         * Constructs a new SenderKeyStateStructure.\n         * @memberof groupproto\n         * @classdesc Represents a SenderKeyStateStructure.\n         * @implements ISenderKeyStateStructure\n         * @constructor\n         * @param {groupproto.ISenderKeyStateStructure=} [properties] Properties to set\n         */\n        function SenderKeyStateStructure(properties) {\n            this.senderMessageKeys = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * SenderKeyStateStructure senderKeyId.\n         * @member {number} senderKeyId\n         * @memberof groupproto.SenderKeyStateStructure\n         * @instance\n         */\n        SenderKeyStateStructure.prototype.senderKeyId = 0;\n\n        /**\n         * SenderKeyStateStructure senderChainKey.\n         * @member {groupproto.ISenderChainKey|null|undefined} senderChainKey\n         * @memberof groupproto.SenderKeyStateStructure\n         * @instance\n         */\n        SenderKeyStateStructure.prototype.senderChainKey = null;\n\n        /**\n         * SenderKeyStateStructure senderSigningKey.\n         * @member {groupproto.ISenderSigningKey|null|undefined} senderSigningKey\n         * @memberof groupproto.SenderKeyStateStructure\n         * @instance\n         */\n        SenderKeyStateStructure.prototype.senderSigningKey = null;\n\n        /**\n         * SenderKeyStateStructure senderMessageKeys.\n         * @member {Array.<groupproto.ISenderMessageKey>} senderMessageKeys\n         * @memberof groupproto.SenderKeyStateStructure\n         * @instance\n         */\n        SenderKeyStateStructure.prototype.senderMessageKeys = $util.emptyArray;\n\n        /**\n         * Creates a new SenderKeyStateStructure instance using the specified properties.\n         * @function create\n         * @memberof groupproto.SenderKeyStateStructure\n         * @static\n         * @param {groupproto.ISenderKeyStateStructure=} [properties] Properties to set\n         * @returns {groupproto.SenderKeyStateStructure} SenderKeyStateStructure instance\n         */\n        SenderKeyStateStructure.create = function create(properties) {\n            return new SenderKeyStateStructure(properties);\n        };\n\n        /**\n         * Encodes the specified SenderKeyStateStructure message. Does not implicitly {@link groupproto.SenderKeyStateStructure.verify|verify} messages.\n         * @function encode\n         * @memberof groupproto.SenderKeyStateStructure\n         * @static\n         * @param {groupproto.ISenderKeyStateStructure} message SenderKeyStateStructure message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SenderKeyStateStructure.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.senderKeyId != null && Object.hasOwnProperty.call(message, \"senderKeyId\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.senderKeyId);\n            if (message.senderChainKey != null && Object.hasOwnProperty.call(message, \"senderChainKey\"))\n                $root.groupproto.SenderChainKey.encode(message.senderChainKey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.senderSigningKey != null && Object.hasOwnProperty.call(message, \"senderSigningKey\"))\n                $root.groupproto.SenderSigningKey.encode(message.senderSigningKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.senderMessageKeys != null && message.senderMessageKeys.length)\n                for (var i = 0; i < message.senderMessageKeys.length; ++i)\n                    $root.groupproto.SenderMessageKey.encode(message.senderMessageKeys[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified SenderKeyStateStructure message, length delimited. Does not implicitly {@link groupproto.SenderKeyStateStructure.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof groupproto.SenderKeyStateStructure\n         * @static\n         * @param {groupproto.ISenderKeyStateStructure} message SenderKeyStateStructure message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SenderKeyStateStructure.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a SenderKeyStateStructure message from the specified reader or buffer.\n         * @function decode\n         * @memberof groupproto.SenderKeyStateStructure\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {groupproto.SenderKeyStateStructure} SenderKeyStateStructure\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SenderKeyStateStructure.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.groupproto.SenderKeyStateStructure();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.senderKeyId = reader.uint32();\n                    break;\n                case 2:\n                    message.senderChainKey = $root.groupproto.SenderChainKey.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.senderSigningKey = $root.groupproto.SenderSigningKey.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.senderMessageKeys && message.senderMessageKeys.length))\n                        message.senderMessageKeys = [];\n                    message.senderMessageKeys.push($root.groupproto.SenderMessageKey.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a SenderKeyStateStructure message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof groupproto.SenderKeyStateStructure\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {groupproto.SenderKeyStateStructure} SenderKeyStateStructure\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SenderKeyStateStructure.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a SenderKeyStateStructure message.\n         * @function verify\n         * @memberof groupproto.SenderKeyStateStructure\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        SenderKeyStateStructure.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.senderKeyId != null && message.hasOwnProperty(\"senderKeyId\"))\n                if (!$util.isInteger(message.senderKeyId))\n                    return \"senderKeyId: integer expected\";\n            if (message.senderChainKey != null && message.hasOwnProperty(\"senderChainKey\")) {\n                var error = $root.groupproto.SenderChainKey.verify(message.senderChainKey);\n                if (error)\n                    return \"senderChainKey.\" + error;\n            }\n            if (message.senderSigningKey != null && message.hasOwnProperty(\"senderSigningKey\")) {\n                var error = $root.groupproto.SenderSigningKey.verify(message.senderSigningKey);\n                if (error)\n                    return \"senderSigningKey.\" + error;\n            }\n            if (message.senderMessageKeys != null && message.hasOwnProperty(\"senderMessageKeys\")) {\n                if (!Array.isArray(message.senderMessageKeys))\n                    return \"senderMessageKeys: array expected\";\n                for (var i = 0; i < message.senderMessageKeys.length; ++i) {\n                    var error = $root.groupproto.SenderMessageKey.verify(message.senderMessageKeys[i]);\n                    if (error)\n                        return \"senderMessageKeys.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a SenderKeyStateStructure message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof groupproto.SenderKeyStateStructure\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {groupproto.SenderKeyStateStructure} SenderKeyStateStructure\n         */\n        SenderKeyStateStructure.fromObject = function fromObject(object) {\n            if (object instanceof $root.groupproto.SenderKeyStateStructure)\n                return object;\n            var message = new $root.groupproto.SenderKeyStateStructure();\n            if (object.senderKeyId != null)\n                message.senderKeyId = object.senderKeyId >>> 0;\n            if (object.senderChainKey != null) {\n                if (typeof object.senderChainKey !== \"object\")\n                    throw TypeError(\".groupproto.SenderKeyStateStructure.senderChainKey: object expected\");\n                message.senderChainKey = $root.groupproto.SenderChainKey.fromObject(object.senderChainKey);\n            }\n            if (object.senderSigningKey != null) {\n                if (typeof object.senderSigningKey !== \"object\")\n                    throw TypeError(\".groupproto.SenderKeyStateStructure.senderSigningKey: object expected\");\n                message.senderSigningKey = $root.groupproto.SenderSigningKey.fromObject(object.senderSigningKey);\n            }\n            if (object.senderMessageKeys) {\n                if (!Array.isArray(object.senderMessageKeys))\n                    throw TypeError(\".groupproto.SenderKeyStateStructure.senderMessageKeys: array expected\");\n                message.senderMessageKeys = [];\n                for (var i = 0; i < object.senderMessageKeys.length; ++i) {\n                    if (typeof object.senderMessageKeys[i] !== \"object\")\n                        throw TypeError(\".groupproto.SenderKeyStateStructure.senderMessageKeys: object expected\");\n                    message.senderMessageKeys[i] = $root.groupproto.SenderMessageKey.fromObject(object.senderMessageKeys[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a SenderKeyStateStructure message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof groupproto.SenderKeyStateStructure\n         * @static\n         * @param {groupproto.SenderKeyStateStructure} message SenderKeyStateStructure\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        SenderKeyStateStructure.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.senderMessageKeys = [];\n            if (options.defaults) {\n                object.senderKeyId = 0;\n                object.senderChainKey = null;\n                object.senderSigningKey = null;\n            }\n            if (message.senderKeyId != null && message.hasOwnProperty(\"senderKeyId\"))\n                object.senderKeyId = message.senderKeyId;\n            if (message.senderChainKey != null && message.hasOwnProperty(\"senderChainKey\"))\n                object.senderChainKey = $root.groupproto.SenderChainKey.toObject(message.senderChainKey, options);\n            if (message.senderSigningKey != null && message.hasOwnProperty(\"senderSigningKey\"))\n                object.senderSigningKey = $root.groupproto.SenderSigningKey.toObject(message.senderSigningKey, options);\n            if (message.senderMessageKeys && message.senderMessageKeys.length) {\n                object.senderMessageKeys = [];\n                for (var j = 0; j < message.senderMessageKeys.length; ++j)\n                    object.senderMessageKeys[j] = $root.groupproto.SenderMessageKey.toObject(message.senderMessageKeys[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this SenderKeyStateStructure to JSON.\n         * @function toJSON\n         * @memberof groupproto.SenderKeyStateStructure\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        SenderKeyStateStructure.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return SenderKeyStateStructure;\n    })();\n\n    groupproto.SenderKeyRecordStructure = (function() {\n\n        /**\n         * Properties of a SenderKeyRecordStructure.\n         * @memberof groupproto\n         * @interface ISenderKeyRecordStructure\n         * @property {Array.<groupproto.ISenderKeyStateStructure>|null} [senderKeyStates] SenderKeyRecordStructure senderKeyStates\n         */\n\n        /**\n         * Constructs a new SenderKeyRecordStructure.\n         * @memberof groupproto\n         * @classdesc Represents a SenderKeyRecordStructure.\n         * @implements ISenderKeyRecordStructure\n         * @constructor\n         * @param {groupproto.ISenderKeyRecordStructure=} [properties] Properties to set\n         */\n        function SenderKeyRecordStructure(properties) {\n            this.senderKeyStates = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * SenderKeyRecordStructure senderKeyStates.\n         * @member {Array.<groupproto.ISenderKeyStateStructure>} senderKeyStates\n         * @memberof groupproto.SenderKeyRecordStructure\n         * @instance\n         */\n        SenderKeyRecordStructure.prototype.senderKeyStates = $util.emptyArray;\n\n        /**\n         * Creates a new SenderKeyRecordStructure instance using the specified properties.\n         * @function create\n         * @memberof groupproto.SenderKeyRecordStructure\n         * @static\n         * @param {groupproto.ISenderKeyRecordStructure=} [properties] Properties to set\n         * @returns {groupproto.SenderKeyRecordStructure} SenderKeyRecordStructure instance\n         */\n        SenderKeyRecordStructure.create = function create(properties) {\n            return new SenderKeyRecordStructure(properties);\n        };\n\n        /**\n         * Encodes the specified SenderKeyRecordStructure message. Does not implicitly {@link groupproto.SenderKeyRecordStructure.verify|verify} messages.\n         * @function encode\n         * @memberof groupproto.SenderKeyRecordStructure\n         * @static\n         * @param {groupproto.ISenderKeyRecordStructure} message SenderKeyRecordStructure message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SenderKeyRecordStructure.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.senderKeyStates != null && message.senderKeyStates.length)\n                for (var i = 0; i < message.senderKeyStates.length; ++i)\n                    $root.groupproto.SenderKeyStateStructure.encode(message.senderKeyStates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified SenderKeyRecordStructure message, length delimited. Does not implicitly {@link groupproto.SenderKeyRecordStructure.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof groupproto.SenderKeyRecordStructure\n         * @static\n         * @param {groupproto.ISenderKeyRecordStructure} message SenderKeyRecordStructure message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SenderKeyRecordStructure.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a SenderKeyRecordStructure message from the specified reader or buffer.\n         * @function decode\n         * @memberof groupproto.SenderKeyRecordStructure\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {groupproto.SenderKeyRecordStructure} SenderKeyRecordStructure\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SenderKeyRecordStructure.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.groupproto.SenderKeyRecordStructure();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.senderKeyStates && message.senderKeyStates.length))\n                        message.senderKeyStates = [];\n                    message.senderKeyStates.push($root.groupproto.SenderKeyStateStructure.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a SenderKeyRecordStructure message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof groupproto.SenderKeyRecordStructure\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {groupproto.SenderKeyRecordStructure} SenderKeyRecordStructure\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SenderKeyRecordStructure.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a SenderKeyRecordStructure message.\n         * @function verify\n         * @memberof groupproto.SenderKeyRecordStructure\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        SenderKeyRecordStructure.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.senderKeyStates != null && message.hasOwnProperty(\"senderKeyStates\")) {\n                if (!Array.isArray(message.senderKeyStates))\n                    return \"senderKeyStates: array expected\";\n                for (var i = 0; i < message.senderKeyStates.length; ++i) {\n                    var error = $root.groupproto.SenderKeyStateStructure.verify(message.senderKeyStates[i]);\n                    if (error)\n                        return \"senderKeyStates.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a SenderKeyRecordStructure message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof groupproto.SenderKeyRecordStructure\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {groupproto.SenderKeyRecordStructure} SenderKeyRecordStructure\n         */\n        SenderKeyRecordStructure.fromObject = function fromObject(object) {\n            if (object instanceof $root.groupproto.SenderKeyRecordStructure)\n                return object;\n            var message = new $root.groupproto.SenderKeyRecordStructure();\n            if (object.senderKeyStates) {\n                if (!Array.isArray(object.senderKeyStates))\n                    throw TypeError(\".groupproto.SenderKeyRecordStructure.senderKeyStates: array expected\");\n                message.senderKeyStates = [];\n                for (var i = 0; i < object.senderKeyStates.length; ++i) {\n                    if (typeof object.senderKeyStates[i] !== \"object\")\n                        throw TypeError(\".groupproto.SenderKeyRecordStructure.senderKeyStates: object expected\");\n                    message.senderKeyStates[i] = $root.groupproto.SenderKeyStateStructure.fromObject(object.senderKeyStates[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a SenderKeyRecordStructure message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof groupproto.SenderKeyRecordStructure\n         * @static\n         * @param {groupproto.SenderKeyRecordStructure} message SenderKeyRecordStructure\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        SenderKeyRecordStructure.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.senderKeyStates = [];\n            if (message.senderKeyStates && message.senderKeyStates.length) {\n                object.senderKeyStates = [];\n                for (var j = 0; j < message.senderKeyStates.length; ++j)\n                    object.senderKeyStates[j] = $root.groupproto.SenderKeyStateStructure.toObject(message.senderKeyStates[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this SenderKeyRecordStructure to JSON.\n         * @function toJSON\n         * @memberof groupproto.SenderKeyRecordStructure\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        SenderKeyRecordStructure.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return SenderKeyRecordStructure;\n    })();\n\n    return groupproto;\n})();\n\nmodule.exports = $root;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}