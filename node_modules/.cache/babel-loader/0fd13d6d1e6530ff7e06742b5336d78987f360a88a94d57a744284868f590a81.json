{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.joinArtists = exports.MetadataCollector = void 0;\nconst type_1 = require(\"../type\");\nconst debug_1 = require(\"debug\");\nconst GenericTagTypes_1 = require(\"./GenericTagTypes\");\nconst CombinedTagMapper_1 = require(\"./CombinedTagMapper\");\nconst GenericTagMapper_1 = require(\"./GenericTagMapper\");\nconst Util_1 = require(\"./Util\");\nconst FileType = require(\"file-type/core\");\nconst debug = (0, debug_1.default)('music-metadata:collector');\nconst TagPriority = ['matroska', 'APEv2', 'vorbis', 'ID3v2.4', 'ID3v2.3', 'ID3v2.2', 'exif', 'asf', 'iTunes', 'AIFF', 'ID3v1'];\n/**\n * Provided to the parser to uodate the metadata result.\n * Responsible for triggering async updates\n */\nclass MetadataCollector {\n  constructor(opts) {\n    this.opts = opts;\n    this.format = {\n      tagTypes: [],\n      trackInfo: []\n    };\n    this.native = {};\n    this.common = {\n      track: {\n        no: null,\n        of: null\n      },\n      disk: {\n        no: null,\n        of: null\n      },\n      movementIndex: {}\n    };\n    this.quality = {\n      warnings: []\n    };\n    /**\n     * Keeps track of origin priority for each mapped id\n     */\n    this.commonOrigin = {};\n    /**\n     * Maps a tag type to a priority\n     */\n    this.originPriority = {};\n    this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();\n    let priority = 1;\n    for (const tagType of TagPriority) {\n      this.originPriority[tagType] = priority++;\n    }\n    this.originPriority.artificial = 500; // Filled using alternative tags\n    this.originPriority.id3v1 = 600; // Consider as the worst because of the field length limit\n  }\n  /**\n   * @returns {boolean} true if one or more tags have been found\n   */\n  hasAny() {\n    return Object.keys(this.native).length > 0;\n  }\n  addStreamInfo(streamInfo) {\n    debug(`streamInfo: type=${type_1.TrackType[streamInfo.type]}, codec=${streamInfo.codecName}`);\n    this.format.trackInfo.push(streamInfo);\n  }\n  setFormat(key, value) {\n    debug(`format: ${key} = ${value}`);\n    this.format[key] = value; // as any to override readonly\n    if (this.opts.observer) {\n      this.opts.observer({\n        metadata: this,\n        tag: {\n          type: 'format',\n          id: key,\n          value\n        }\n      });\n    }\n  }\n  addTag(tagType, tagId, value) {\n    debug(`tag ${tagType}.${tagId} = ${value}`);\n    if (!this.native[tagType]) {\n      this.format.tagTypes.push(tagType);\n      this.native[tagType] = [];\n    }\n    this.native[tagType].push({\n      id: tagId,\n      value\n    });\n    this.toCommon(tagType, tagId, value);\n  }\n  addWarning(warning) {\n    this.quality.warnings.push({\n      message: warning\n    });\n  }\n  postMap(tagType, tag) {\n    // Common tag (alias) found\n    // check if we need to do something special with common tag\n    // if the event has been aliased then we need to clean it before\n    // it is emitted to the user. e.g. genre (20) -> Electronic\n    switch (tag.id) {\n      case 'artist':\n        if (this.commonOrigin.artist === this.originPriority[tagType]) {\n          // Assume the artist field is used as artists\n          return this.postMap('artificial', {\n            id: 'artists',\n            value: tag.value\n          });\n        }\n        if (!this.common.artists) {\n          // Fill artists using artist source\n          this.setGenericTag('artificial', {\n            id: 'artists',\n            value: tag.value\n          });\n        }\n        break;\n      case 'artists':\n        if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {\n          if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {\n            // Fill artist using artists source\n            const artists = (this.common.artists || []).concat([tag.value]);\n            const value = joinArtists(artists);\n            const artistTag = {\n              id: 'artist',\n              value\n            };\n            this.setGenericTag('artificial', artistTag);\n          }\n        }\n        break;\n      case 'picture':\n        this.postFixPicture(tag.value).then(picture => {\n          if (picture !== null) {\n            tag.value = picture;\n            this.setGenericTag(tagType, tag);\n          }\n        });\n        return;\n      case 'totaltracks':\n        this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n        return;\n      case 'totaldiscs':\n        this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n        return;\n      case 'movementTotal':\n        this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n        return;\n      case 'track':\n      case 'disk':\n      case 'movementIndex':\n        const of = this.common[tag.id].of; // store of value, maybe maybe overwritten\n        this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value);\n        this.common[tag.id].of = of != null ? of : this.common[tag.id].of;\n        return;\n      case 'bpm':\n      case 'year':\n      case 'originalyear':\n        tag.value = parseInt(tag.value, 10);\n        break;\n      case 'date':\n        // ToDo: be more strict on 'YYYY...'\n        const year = parseInt(tag.value.substr(0, 4), 10);\n        if (!isNaN(year)) {\n          this.common.year = year;\n        }\n        break;\n      case 'discogs_label_id':\n      case 'discogs_release_id':\n      case 'discogs_master_release_id':\n      case 'discogs_artist_id':\n      case 'discogs_votes':\n        tag.value = typeof tag.value === 'string' ? parseInt(tag.value, 10) : tag.value;\n        break;\n      case 'replaygain_track_gain':\n      case 'replaygain_track_peak':\n      case 'replaygain_album_gain':\n      case 'replaygain_album_peak':\n        tag.value = (0, Util_1.toRatio)(tag.value);\n        break;\n      case 'replaygain_track_minmax':\n        tag.value = tag.value.split(',').map(v => parseInt(v, 10));\n        break;\n      case 'replaygain_undo':\n        const minMix = tag.value.split(',').map(v => parseInt(v, 10));\n        tag.value = {\n          leftChannel: minMix[0],\n          rightChannel: minMix[1]\n        };\n        break;\n      case 'gapless': // iTunes gap-less flag\n      case 'compilation':\n      case 'podcast':\n      case 'showMovement':\n        tag.value = tag.value === '1' || tag.value === 1; // boolean\n        break;\n      case 'isrc':\n        // Only keep unique values\n        if (this.common[tag.id] && this.common[tag.id].indexOf(tag.value) !== -1) return;\n        break;\n      default:\n      // nothing to do\n    }\n    if (tag.value !== null) {\n      this.setGenericTag(tagType, tag);\n    }\n  }\n  /**\n   * Convert native tags to common tags\n   * @returns {IAudioMetadata} Native + common tags\n   */\n  toCommonMetadata() {\n    return {\n      format: this.format,\n      native: this.native,\n      quality: this.quality,\n      common: this.common\n    };\n  }\n  /**\n   * Fix some common issues with picture object\n   * @param picture Picture\n   */\n  async postFixPicture(picture) {\n    if (picture.data && picture.data.length > 0) {\n      if (!picture.format) {\n        const fileType = await FileType.fromBuffer(picture.data);\n        if (fileType) {\n          picture.format = fileType.mime;\n        } else {\n          return null;\n        }\n      }\n      picture.format = picture.format.toLocaleLowerCase();\n      switch (picture.format) {\n        case 'image/jpg':\n          picture.format = 'image/jpeg';\n        // ToDo: register warning\n      }\n      return picture;\n    }\n    this.addWarning(`Empty picture tag found`);\n    return null;\n  }\n  /**\n   * Convert native tag to common tags\n   */\n  toCommon(tagType, tagId, value) {\n    const tag = {\n      id: tagId,\n      value\n    };\n    const genericTag = this.tagMapper.mapTag(tagType, tag, this);\n    if (genericTag) {\n      this.postMap(tagType, genericTag);\n    }\n  }\n  /**\n   * Set generic tag\n   */\n  setGenericTag(tagType, tag) {\n    debug(`common.${tag.id} = ${tag.value}`);\n    const prio0 = this.commonOrigin[tag.id] || 1000;\n    const prio1 = this.originPriority[tagType];\n    if ((0, GenericTagTypes_1.isSingleton)(tag.id)) {\n      if (prio1 <= prio0) {\n        this.common[tag.id] = tag.value;\n        this.commonOrigin[tag.id] = prio1;\n      } else {\n        return debug(`Ignore native tag (singleton): ${tagType}.${tag.id} = ${tag.value}`);\n      }\n    } else {\n      if (prio1 === prio0) {\n        if (!(0, GenericTagTypes_1.isUnique)(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {\n          this.common[tag.id].push(tag.value);\n        } else {\n          debug(`Ignore duplicate value: ${tagType}.${tag.id} = ${tag.value}`);\n        }\n        // no effect? this.commonOrigin[tag.id] = prio1;\n      } else if (prio1 < prio0) {\n        this.common[tag.id] = [tag.value];\n        this.commonOrigin[tag.id] = prio1;\n      } else {\n        return debug(`Ignore native tag (list): ${tagType}.${tag.id} = ${tag.value}`);\n      }\n    }\n    if (this.opts.observer) {\n      this.opts.observer({\n        metadata: this,\n        tag: {\n          type: 'common',\n          id: tag.id,\n          value: tag.value\n        }\n      });\n    }\n    // ToDo: trigger metadata event\n  }\n}\nexports.MetadataCollector = MetadataCollector;\nfunction joinArtists(artists) {\n  if (artists.length > 2) {\n    return artists.slice(0, artists.length - 1).join(', ') + ' & ' + artists[artists.length - 1];\n  }\n  return artists.join(' & ');\n}\nexports.joinArtists = joinArtists;","map":{"version":3,"names":["Object","defineProperty","exports","value","joinArtists","MetadataCollector","type_1","require","debug_1","GenericTagTypes_1","CombinedTagMapper_1","GenericTagMapper_1","Util_1","FileType","debug","default","TagPriority","constructor","opts","format","tagTypes","trackInfo","native","common","track","no","of","disk","movementIndex","quality","warnings","commonOrigin","originPriority","tagMapper","CombinedTagMapper","priority","tagType","artificial","id3v1","hasAny","keys","length","addStreamInfo","streamInfo","TrackType","type","codecName","push","setFormat","key","observer","metadata","tag","id","addTag","tagId","toCommon","addWarning","warning","message","postMap","artist","artists","setGenericTag","indexOf","concat","artistTag","postFixPicture","then","picture","CommonTagMapper","toIntOrNull","normalizeTrack","parseInt","year","substr","isNaN","toRatio","split","map","v","minMix","leftChannel","rightChannel","toCommonMetadata","data","fileType","fromBuffer","mime","toLocaleLowerCase","genericTag","mapTag","prio0","prio1","isSingleton","isUnique","slice","join"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/common/MetadataCollector.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.joinArtists = exports.MetadataCollector = void 0;\nconst type_1 = require(\"../type\");\nconst debug_1 = require(\"debug\");\nconst GenericTagTypes_1 = require(\"./GenericTagTypes\");\nconst CombinedTagMapper_1 = require(\"./CombinedTagMapper\");\nconst GenericTagMapper_1 = require(\"./GenericTagMapper\");\nconst Util_1 = require(\"./Util\");\nconst FileType = require(\"file-type/core\");\nconst debug = (0, debug_1.default)('music-metadata:collector');\nconst TagPriority = ['matroska', 'APEv2', 'vorbis', 'ID3v2.4', 'ID3v2.3', 'ID3v2.2', 'exif', 'asf', 'iTunes', 'AIFF', 'ID3v1'];\n/**\n * Provided to the parser to uodate the metadata result.\n * Responsible for triggering async updates\n */\nclass MetadataCollector {\n    constructor(opts) {\n        this.opts = opts;\n        this.format = {\n            tagTypes: [],\n            trackInfo: []\n        };\n        this.native = {};\n        this.common = {\n            track: { no: null, of: null },\n            disk: { no: null, of: null },\n            movementIndex: {}\n        };\n        this.quality = {\n            warnings: []\n        };\n        /**\n         * Keeps track of origin priority for each mapped id\n         */\n        this.commonOrigin = {};\n        /**\n         * Maps a tag type to a priority\n         */\n        this.originPriority = {};\n        this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();\n        let priority = 1;\n        for (const tagType of TagPriority) {\n            this.originPriority[tagType] = priority++;\n        }\n        this.originPriority.artificial = 500; // Filled using alternative tags\n        this.originPriority.id3v1 = 600; // Consider as the worst because of the field length limit\n    }\n    /**\n     * @returns {boolean} true if one or more tags have been found\n     */\n    hasAny() {\n        return Object.keys(this.native).length > 0;\n    }\n    addStreamInfo(streamInfo) {\n        debug(`streamInfo: type=${type_1.TrackType[streamInfo.type]}, codec=${streamInfo.codecName}`);\n        this.format.trackInfo.push(streamInfo);\n    }\n    setFormat(key, value) {\n        debug(`format: ${key} = ${value}`);\n        this.format[key] = value; // as any to override readonly\n        if (this.opts.observer) {\n            this.opts.observer({ metadata: this, tag: { type: 'format', id: key, value } });\n        }\n    }\n    addTag(tagType, tagId, value) {\n        debug(`tag ${tagType}.${tagId} = ${value}`);\n        if (!this.native[tagType]) {\n            this.format.tagTypes.push(tagType);\n            this.native[tagType] = [];\n        }\n        this.native[tagType].push({ id: tagId, value });\n        this.toCommon(tagType, tagId, value);\n    }\n    addWarning(warning) {\n        this.quality.warnings.push({ message: warning });\n    }\n    postMap(tagType, tag) {\n        // Common tag (alias) found\n        // check if we need to do something special with common tag\n        // if the event has been aliased then we need to clean it before\n        // it is emitted to the user. e.g. genre (20) -> Electronic\n        switch (tag.id) {\n            case 'artist':\n                if (this.commonOrigin.artist === this.originPriority[tagType]) {\n                    // Assume the artist field is used as artists\n                    return this.postMap('artificial', { id: 'artists', value: tag.value });\n                }\n                if (!this.common.artists) {\n                    // Fill artists using artist source\n                    this.setGenericTag('artificial', { id: 'artists', value: tag.value });\n                }\n                break;\n            case 'artists':\n                if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {\n                    if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {\n                        // Fill artist using artists source\n                        const artists = (this.common.artists || []).concat([tag.value]);\n                        const value = joinArtists(artists);\n                        const artistTag = { id: 'artist', value };\n                        this.setGenericTag('artificial', artistTag);\n                    }\n                }\n                break;\n            case 'picture':\n                this.postFixPicture(tag.value).then(picture => {\n                    if (picture !== null) {\n                        tag.value = picture;\n                        this.setGenericTag(tagType, tag);\n                    }\n                });\n                return;\n            case 'totaltracks':\n                this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n                return;\n            case 'totaldiscs':\n                this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n                return;\n            case 'movementTotal':\n                this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n                return;\n            case 'track':\n            case 'disk':\n            case 'movementIndex':\n                const of = this.common[tag.id].of; // store of value, maybe maybe overwritten\n                this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value);\n                this.common[tag.id].of = of != null ? of : this.common[tag.id].of;\n                return;\n            case 'bpm':\n            case 'year':\n            case 'originalyear':\n                tag.value = parseInt(tag.value, 10);\n                break;\n            case 'date':\n                // ToDo: be more strict on 'YYYY...'\n                const year = parseInt(tag.value.substr(0, 4), 10);\n                if (!isNaN(year)) {\n                    this.common.year = year;\n                }\n                break;\n            case 'discogs_label_id':\n            case 'discogs_release_id':\n            case 'discogs_master_release_id':\n            case 'discogs_artist_id':\n            case 'discogs_votes':\n                tag.value = typeof tag.value === 'string' ? parseInt(tag.value, 10) : tag.value;\n                break;\n            case 'replaygain_track_gain':\n            case 'replaygain_track_peak':\n            case 'replaygain_album_gain':\n            case 'replaygain_album_peak':\n                tag.value = (0, Util_1.toRatio)(tag.value);\n                break;\n            case 'replaygain_track_minmax':\n                tag.value = tag.value.split(',').map(v => parseInt(v, 10));\n                break;\n            case 'replaygain_undo':\n                const minMix = tag.value.split(',').map(v => parseInt(v, 10));\n                tag.value = {\n                    leftChannel: minMix[0],\n                    rightChannel: minMix[1]\n                };\n                break;\n            case 'gapless': // iTunes gap-less flag\n            case 'compilation':\n            case 'podcast':\n            case 'showMovement':\n                tag.value = tag.value === '1' || tag.value === 1; // boolean\n                break;\n            case 'isrc': // Only keep unique values\n                if (this.common[tag.id] && this.common[tag.id].indexOf(tag.value) !== -1)\n                    return;\n                break;\n            default:\n            // nothing to do\n        }\n        if (tag.value !== null) {\n            this.setGenericTag(tagType, tag);\n        }\n    }\n    /**\n     * Convert native tags to common tags\n     * @returns {IAudioMetadata} Native + common tags\n     */\n    toCommonMetadata() {\n        return {\n            format: this.format,\n            native: this.native,\n            quality: this.quality,\n            common: this.common\n        };\n    }\n    /**\n     * Fix some common issues with picture object\n     * @param picture Picture\n     */\n    async postFixPicture(picture) {\n        if (picture.data && picture.data.length > 0) {\n            if (!picture.format) {\n                const fileType = await FileType.fromBuffer(picture.data);\n                if (fileType) {\n                    picture.format = fileType.mime;\n                }\n                else {\n                    return null;\n                }\n            }\n            picture.format = picture.format.toLocaleLowerCase();\n            switch (picture.format) {\n                case 'image/jpg':\n                    picture.format = 'image/jpeg'; // ToDo: register warning\n            }\n            return picture;\n        }\n        this.addWarning(`Empty picture tag found`);\n        return null;\n    }\n    /**\n     * Convert native tag to common tags\n     */\n    toCommon(tagType, tagId, value) {\n        const tag = { id: tagId, value };\n        const genericTag = this.tagMapper.mapTag(tagType, tag, this);\n        if (genericTag) {\n            this.postMap(tagType, genericTag);\n        }\n    }\n    /**\n     * Set generic tag\n     */\n    setGenericTag(tagType, tag) {\n        debug(`common.${tag.id} = ${tag.value}`);\n        const prio0 = this.commonOrigin[tag.id] || 1000;\n        const prio1 = this.originPriority[tagType];\n        if ((0, GenericTagTypes_1.isSingleton)(tag.id)) {\n            if (prio1 <= prio0) {\n                this.common[tag.id] = tag.value;\n                this.commonOrigin[tag.id] = prio1;\n            }\n            else {\n                return debug(`Ignore native tag (singleton): ${tagType}.${tag.id} = ${tag.value}`);\n            }\n        }\n        else {\n            if (prio1 === prio0) {\n                if (!(0, GenericTagTypes_1.isUnique)(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {\n                    this.common[tag.id].push(tag.value);\n                }\n                else {\n                    debug(`Ignore duplicate value: ${tagType}.${tag.id} = ${tag.value}`);\n                }\n                // no effect? this.commonOrigin[tag.id] = prio1;\n            }\n            else if (prio1 < prio0) {\n                this.common[tag.id] = [tag.value];\n                this.commonOrigin[tag.id] = prio1;\n            }\n            else {\n                return debug(`Ignore native tag (list): ${tagType}.${tag.id} = ${tag.value}`);\n            }\n        }\n        if (this.opts.observer) {\n            this.opts.observer({ metadata: this, tag: { type: 'common', id: tag.id, value: tag.value } });\n        }\n        // ToDo: trigger metadata event\n    }\n}\nexports.MetadataCollector = MetadataCollector;\nfunction joinArtists(artists) {\n    if (artists.length > 2) {\n        return artists.slice(0, artists.length - 1).join(', ') + ' & ' + artists[artists.length - 1];\n    }\n    return artists.join(' & ');\n}\nexports.joinArtists = joinArtists;\n//# sourceMappingURL=MetadataCollector.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}