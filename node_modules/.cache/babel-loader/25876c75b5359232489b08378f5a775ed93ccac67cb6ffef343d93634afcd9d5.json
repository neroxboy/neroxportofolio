{"ast":null,"code":"// vim: ts=4:sw=4\n\nconst BaseKeyType = require('./base_key_type');\nconst CLOSED_SESSIONS_MAX = 40;\nconst SESSION_RECORD_VERSION = 'v1';\nfunction assertBuffer(value) {\n  if (!Buffer.isBuffer(value)) {\n    throw new TypeError(\"Buffer required\");\n  }\n}\nclass SessionEntry {\n  constructor() {\n    this._chains = {};\n  }\n  toString() {\n    const baseKey = this.indexInfo && this.indexInfo.baseKey && this.indexInfo.baseKey.toString('base64');\n    return `<SessionEntry [baseKey=${baseKey}]>`;\n  }\n  inspect() {\n    return this.toString();\n  }\n  addChain(key, value) {\n    assertBuffer(key);\n    const id = key.toString('base64');\n    if (this._chains.hasOwnProperty(id)) {\n      throw new Error(\"Overwrite attempt\");\n    }\n    this._chains[id] = value;\n  }\n  getChain(key) {\n    assertBuffer(key);\n    return this._chains[key.toString('base64')];\n  }\n  deleteChain(key) {\n    assertBuffer(key);\n    const id = key.toString('base64');\n    if (!this._chains.hasOwnProperty(id)) {\n      throw new ReferenceError(\"Not Found\");\n    }\n    delete this._chains[id];\n  }\n  *chains() {\n    for (const [k, v] of Object.entries(this._chains)) {\n      yield [Buffer.from(k, 'base64'), v];\n    }\n  }\n  serialize() {\n    const data = {\n      registrationId: this.registrationId,\n      currentRatchet: {\n        ephemeralKeyPair: {\n          pubKey: this.currentRatchet.ephemeralKeyPair.pubKey.toString('base64'),\n          privKey: this.currentRatchet.ephemeralKeyPair.privKey.toString('base64')\n        },\n        lastRemoteEphemeralKey: this.currentRatchet.lastRemoteEphemeralKey.toString('base64'),\n        previousCounter: this.currentRatchet.previousCounter,\n        rootKey: this.currentRatchet.rootKey.toString('base64')\n      },\n      indexInfo: {\n        baseKey: this.indexInfo.baseKey.toString('base64'),\n        baseKeyType: this.indexInfo.baseKeyType,\n        closed: this.indexInfo.closed,\n        used: this.indexInfo.used,\n        created: this.indexInfo.created,\n        remoteIdentityKey: this.indexInfo.remoteIdentityKey.toString('base64')\n      },\n      _chains: this._serialize_chains(this._chains)\n    };\n    if (this.pendingPreKey) {\n      data.pendingPreKey = Object.assign({}, this.pendingPreKey);\n      data.pendingPreKey.baseKey = this.pendingPreKey.baseKey.toString('base64');\n    }\n    return data;\n  }\n  static deserialize(data) {\n    const obj = new this();\n    obj.registrationId = data.registrationId;\n    obj.currentRatchet = {\n      ephemeralKeyPair: {\n        pubKey: Buffer.from(data.currentRatchet.ephemeralKeyPair.pubKey, 'base64'),\n        privKey: Buffer.from(data.currentRatchet.ephemeralKeyPair.privKey, 'base64')\n      },\n      lastRemoteEphemeralKey: Buffer.from(data.currentRatchet.lastRemoteEphemeralKey, 'base64'),\n      previousCounter: data.currentRatchet.previousCounter,\n      rootKey: Buffer.from(data.currentRatchet.rootKey, 'base64')\n    };\n    obj.indexInfo = {\n      baseKey: Buffer.from(data.indexInfo.baseKey, 'base64'),\n      baseKeyType: data.indexInfo.baseKeyType,\n      closed: data.indexInfo.closed,\n      used: data.indexInfo.used,\n      created: data.indexInfo.created,\n      remoteIdentityKey: Buffer.from(data.indexInfo.remoteIdentityKey, 'base64')\n    };\n    obj._chains = this._deserialize_chains(data._chains);\n    if (data.pendingPreKey) {\n      obj.pendingPreKey = Object.assign({}, data.pendingPreKey);\n      obj.pendingPreKey.baseKey = Buffer.from(data.pendingPreKey.baseKey, 'base64');\n    }\n    return obj;\n  }\n  _serialize_chains(chains) {\n    const r = {};\n    for (const key of Object.keys(chains)) {\n      const c = chains[key];\n      const messageKeys = {};\n      for (const [idx, key] of Object.entries(c.messageKeys)) {\n        messageKeys[idx] = key.toString('base64');\n      }\n      r[key] = {\n        chainKey: {\n          counter: c.chainKey.counter,\n          key: c.chainKey.key && c.chainKey.key.toString('base64')\n        },\n        chainType: c.chainType,\n        messageKeys: messageKeys\n      };\n    }\n    return r;\n  }\n  static _deserialize_chains(chains_data) {\n    const r = {};\n    for (const key of Object.keys(chains_data)) {\n      const c = chains_data[key];\n      const messageKeys = {};\n      for (const [idx, key] of Object.entries(c.messageKeys)) {\n        messageKeys[idx] = Buffer.from(key, 'base64');\n      }\n      r[key] = {\n        chainKey: {\n          counter: c.chainKey.counter,\n          key: c.chainKey.key && Buffer.from(c.chainKey.key, 'base64')\n        },\n        chainType: c.chainType,\n        messageKeys: messageKeys\n      };\n    }\n    return r;\n  }\n}\nconst migrations = [{\n  version: 'v1',\n  migrate: function migrateV1(data) {\n    const sessions = data._sessions;\n    if (data.registrationId) {\n      for (const key in sessions) {\n        if (!sessions[key].registrationId) {\n          sessions[key].registrationId = data.registrationId;\n        }\n      }\n    } else {\n      for (const key in sessions) {\n        if (sessions[key].indexInfo.closed === -1) {\n          console.error('V1 session storage migration error: registrationId', data.registrationId, 'for open session version', data.version);\n        }\n      }\n    }\n  }\n}];\nclass SessionRecord {\n  static createEntry() {\n    return new SessionEntry();\n  }\n  static migrate(data) {\n    let run = data.version === undefined;\n    for (let i = 0; i < migrations.length; ++i) {\n      if (run) {\n        console.info(\"Migrating session to:\", migrations[i].version);\n        migrations[i].migrate(data);\n      } else if (migrations[i].version === data.version) {\n        run = true;\n      }\n    }\n    if (!run) {\n      throw new Error(\"Error migrating SessionRecord\");\n    }\n  }\n  static deserialize(data) {\n    if (data.version !== SESSION_RECORD_VERSION) {\n      this.migrate(data);\n    }\n    const obj = new this();\n    if (data._sessions) {\n      for (const [key, entry] of Object.entries(data._sessions)) {\n        obj.sessions[key] = SessionEntry.deserialize(entry);\n      }\n    }\n    return obj;\n  }\n  constructor() {\n    this.sessions = {};\n    this.version = SESSION_RECORD_VERSION;\n  }\n  serialize() {\n    const _sessions = {};\n    for (const [key, entry] of Object.entries(this.sessions)) {\n      _sessions[key] = entry.serialize();\n    }\n    return {\n      _sessions,\n      version: this.version\n    };\n  }\n  haveOpenSession() {\n    const openSession = this.getOpenSession();\n    return !!openSession && typeof openSession.registrationId === 'number';\n  }\n  getSession(key) {\n    assertBuffer(key);\n    const session = this.sessions[key.toString('base64')];\n    if (session && session.indexInfo.baseKeyType === BaseKeyType.OURS) {\n      throw new Error(\"Tried to lookup a session using our basekey\");\n    }\n    return session;\n  }\n  getOpenSession() {\n    for (const session of Object.values(this.sessions)) {\n      if (!this.isClosed(session)) {\n        return session;\n      }\n    }\n  }\n  setSession(session) {\n    this.sessions[session.indexInfo.baseKey.toString('base64')] = session;\n  }\n  getSessions() {\n    // Return sessions ordered with most recently used first.\n    return Array.from(Object.values(this.sessions)).sort((a, b) => {\n      const aUsed = a.indexInfo.used || 0;\n      const bUsed = b.indexInfo.used || 0;\n      return aUsed === bUsed ? 0 : aUsed < bUsed ? 1 : -1;\n    });\n  }\n  closeSession(session) {\n    if (this.isClosed(session)) {\n      console.warn(\"Session already closed\", session);\n      return;\n    }\n    console.info(\"Closing session:\", session);\n    session.indexInfo.closed = Date.now();\n  }\n  openSession(session) {\n    if (!this.isClosed(session)) {\n      console.warn(\"Session already open\");\n    }\n    console.info(\"Opening session:\", session);\n    session.indexInfo.closed = -1;\n  }\n  isClosed(session) {\n    return session.indexInfo.closed !== -1;\n  }\n  removeOldSessions() {\n    while (Object.keys(this.sessions).length > CLOSED_SESSIONS_MAX) {\n      let oldestKey;\n      let oldestSession;\n      for (const [key, session] of Object.entries(this.sessions)) {\n        if (session.indexInfo.closed !== -1 && (!oldestSession || session.indexInfo.closed < oldestSession.indexInfo.closed)) {\n          oldestKey = key;\n          oldestSession = session;\n        }\n      }\n      if (oldestKey) {\n        console.info(\"Removing old closed session:\", oldestSession);\n        delete this.sessions[oldestKey];\n      } else {\n        throw new Error('Corrupt sessions object');\n      }\n    }\n  }\n  deleteAllSessions() {\n    for (const key of Object.keys(this.sessions)) {\n      delete this.sessions[key];\n    }\n  }\n}\nmodule.exports = SessionRecord;","map":{"version":3,"names":["BaseKeyType","require","CLOSED_SESSIONS_MAX","SESSION_RECORD_VERSION","assertBuffer","value","Buffer","isBuffer","TypeError","SessionEntry","constructor","_chains","toString","baseKey","indexInfo","inspect","addChain","key","id","hasOwnProperty","Error","getChain","deleteChain","ReferenceError","chains","k","v","Object","entries","from","serialize","data","registrationId","currentRatchet","ephemeralKeyPair","pubKey","privKey","lastRemoteEphemeralKey","previousCounter","rootKey","baseKeyType","closed","used","created","remoteIdentityKey","_serialize_chains","pendingPreKey","assign","deserialize","obj","_deserialize_chains","r","keys","c","messageKeys","idx","chainKey","counter","chainType","chains_data","migrations","version","migrate","migrateV1","sessions","_sessions","console","error","SessionRecord","createEntry","run","undefined","i","length","info","entry","haveOpenSession","openSession","getOpenSession","getSession","session","OURS","values","isClosed","setSession","getSessions","Array","sort","a","b","aUsed","bUsed","closeSession","warn","Date","now","removeOldSessions","oldestKey","oldestSession","deleteAllSessions","module","exports"],"sources":["C:/Users/vanitas/node_modules/libsignal/src/session_record.js"],"sourcesContent":["// vim: ts=4:sw=4\n\nconst BaseKeyType = require('./base_key_type');\n\nconst CLOSED_SESSIONS_MAX = 40;\nconst SESSION_RECORD_VERSION = 'v1';\n\nfunction assertBuffer(value) {\n    if (!Buffer.isBuffer(value)) {\n        throw new TypeError(\"Buffer required\");\n    }\n}\n\n\nclass SessionEntry {\n\n    constructor() {\n        this._chains = {};\n    }\n\n    toString() {\n        const baseKey = this.indexInfo && this.indexInfo.baseKey &&\n            this.indexInfo.baseKey.toString('base64');\n        return `<SessionEntry [baseKey=${baseKey}]>`;\n    }\n\n    inspect() {\n        return this.toString();\n    }\n\n    addChain(key, value) {\n        assertBuffer(key);\n        const id = key.toString('base64');\n        if (this._chains.hasOwnProperty(id)) {\n            throw new Error(\"Overwrite attempt\");\n        }\n        this._chains[id] = value;\n    }\n\n    getChain(key) {\n        assertBuffer(key);\n        return this._chains[key.toString('base64')];\n    }\n\n    deleteChain(key) {\n        assertBuffer(key);\n        const id = key.toString('base64');\n        if (!this._chains.hasOwnProperty(id)) {\n            throw new ReferenceError(\"Not Found\");\n        }\n        delete this._chains[id];\n    }\n\n    *chains() {\n        for (const [k, v] of Object.entries(this._chains)) {\n            yield [Buffer.from(k, 'base64'), v];\n        }\n    }\n\n    serialize() {\n        const data = {\n            registrationId: this.registrationId,\n            currentRatchet: {\n                ephemeralKeyPair: {\n                    pubKey: this.currentRatchet.ephemeralKeyPair.pubKey.toString('base64'),\n                    privKey: this.currentRatchet.ephemeralKeyPair.privKey.toString('base64')\n                },\n                lastRemoteEphemeralKey: this.currentRatchet.lastRemoteEphemeralKey.toString('base64'),\n                previousCounter: this.currentRatchet.previousCounter,\n                rootKey: this.currentRatchet.rootKey.toString('base64')\n            },\n            indexInfo: {\n                baseKey: this.indexInfo.baseKey.toString('base64'),\n                baseKeyType: this.indexInfo.baseKeyType,\n                closed: this.indexInfo.closed,\n                used: this.indexInfo.used,\n                created: this.indexInfo.created,\n                remoteIdentityKey: this.indexInfo.remoteIdentityKey.toString('base64')\n            },\n            _chains: this._serialize_chains(this._chains)\n        };\n        if (this.pendingPreKey) {\n            data.pendingPreKey = Object.assign({}, this.pendingPreKey);\n            data.pendingPreKey.baseKey = this.pendingPreKey.baseKey.toString('base64');\n        }\n        return data;\n    }\n\n    static deserialize(data) {\n        const obj = new this();\n        obj.registrationId = data.registrationId;\n        obj.currentRatchet = {\n            ephemeralKeyPair: {\n                pubKey: Buffer.from(data.currentRatchet.ephemeralKeyPair.pubKey, 'base64'),\n                privKey: Buffer.from(data.currentRatchet.ephemeralKeyPair.privKey, 'base64')\n            },\n            lastRemoteEphemeralKey: Buffer.from(data.currentRatchet.lastRemoteEphemeralKey, 'base64'),\n            previousCounter: data.currentRatchet.previousCounter,\n            rootKey: Buffer.from(data.currentRatchet.rootKey, 'base64')\n        };\n        obj.indexInfo = {\n            baseKey: Buffer.from(data.indexInfo.baseKey, 'base64'),\n            baseKeyType: data.indexInfo.baseKeyType,\n            closed: data.indexInfo.closed,\n            used: data.indexInfo.used,\n            created: data.indexInfo.created,\n            remoteIdentityKey: Buffer.from(data.indexInfo.remoteIdentityKey, 'base64')\n        };\n        obj._chains = this._deserialize_chains(data._chains);\n        if (data.pendingPreKey) {\n            obj.pendingPreKey = Object.assign({}, data.pendingPreKey);\n            obj.pendingPreKey.baseKey = Buffer.from(data.pendingPreKey.baseKey, 'base64');\n        }\n        return obj;\n    }\n\n    _serialize_chains(chains) {\n        const r = {};\n        for (const key of Object.keys(chains)) {\n            const c = chains[key];\n            const messageKeys = {};\n            for (const [idx, key] of Object.entries(c.messageKeys)) {\n                messageKeys[idx] = key.toString('base64');\n            }\n            r[key] = {\n                chainKey: {\n                    counter: c.chainKey.counter,\n                    key: c.chainKey.key && c.chainKey.key.toString('base64')\n                },\n                chainType: c.chainType,\n                messageKeys: messageKeys\n            };\n        }\n        return r;\n    }\n\n    static _deserialize_chains(chains_data) {\n        const r = {};\n        for (const key of Object.keys(chains_data)) {\n            const c = chains_data[key];\n            const messageKeys = {};\n            for (const [idx, key] of Object.entries(c.messageKeys)) {\n                messageKeys[idx] = Buffer.from(key, 'base64');\n            }\n            r[key] = {\n                chainKey: {\n                    counter: c.chainKey.counter,\n                    key: c.chainKey.key && Buffer.from(c.chainKey.key, 'base64')\n                },\n                chainType: c.chainType,\n                messageKeys: messageKeys\n            };\n        }\n        return r;\n    }\n\n}\n\n\nconst migrations = [{\n    version: 'v1',\n    migrate: function migrateV1(data) {\n        const sessions = data._sessions;\n        if (data.registrationId) {\n            for (const key in sessions) {\n                if (!sessions[key].registrationId) {\n                    sessions[key].registrationId = data.registrationId;\n                }\n            }\n        } else {\n            for (const key in sessions) {\n                if (sessions[key].indexInfo.closed === -1) {\n                    console.error('V1 session storage migration error: registrationId',\n                                  data.registrationId, 'for open session version',\n                                  data.version);\n                }\n            }\n        }\n    }\n}];\n\n\nclass SessionRecord {\n\n    static createEntry() {\n        return new SessionEntry();\n    }\n\n    static migrate(data) {\n        let run = (data.version === undefined);\n        for (let i = 0; i < migrations.length; ++i) {\n            if (run) {\n                console.info(\"Migrating session to:\", migrations[i].version);\n                migrations[i].migrate(data);\n            } else if (migrations[i].version === data.version) {\n                run = true;\n            }\n        }\n        if (!run) {\n            throw new Error(\"Error migrating SessionRecord\");\n        }\n    }\n\n    static deserialize(data) {\n        if (data.version !== SESSION_RECORD_VERSION) {\n            this.migrate(data);\n        }\n        const obj = new this();\n        if (data._sessions) {\n            for (const [key, entry] of Object.entries(data._sessions)) {\n                obj.sessions[key] = SessionEntry.deserialize(entry);\n            }\n        }\n        return obj;\n    }\n\n    constructor() {\n        this.sessions = {};\n        this.version = SESSION_RECORD_VERSION;\n    }\n\n    serialize() {\n        const _sessions = {};\n        for (const [key, entry] of Object.entries(this.sessions)) {\n            _sessions[key] = entry.serialize();\n        }\n        return {\n            _sessions,\n            version: this.version\n        };\n    }\n\n    haveOpenSession() {\n        const openSession = this.getOpenSession();\n        return (!!openSession && typeof openSession.registrationId === 'number');\n    }\n\n    getSession(key) {\n        assertBuffer(key);\n        const session = this.sessions[key.toString('base64')];\n        if (session && session.indexInfo.baseKeyType === BaseKeyType.OURS) {\n            throw new Error(\"Tried to lookup a session using our basekey\");\n        }\n        return session;\n    }\n\n    getOpenSession() {\n        for (const session of Object.values(this.sessions)) {\n            if (!this.isClosed(session)) {\n                return session;\n            }\n        }\n    }\n\n    setSession(session) {\n        this.sessions[session.indexInfo.baseKey.toString('base64')] = session;\n    }\n\n    getSessions() {\n        // Return sessions ordered with most recently used first.\n        return Array.from(Object.values(this.sessions)).sort((a, b) => {\n            const aUsed = a.indexInfo.used || 0;\n            const bUsed = b.indexInfo.used || 0;\n            return aUsed === bUsed ? 0 : aUsed < bUsed ? 1 : -1;\n        });\n    }\n\n    closeSession(session) {\n        if (this.isClosed(session)) {\n            console.warn(\"Session already closed\", session);\n            return;\n        }\n        console.info(\"Closing session:\", session);\n        session.indexInfo.closed = Date.now();\n    }\n\n    openSession(session) {\n        if (!this.isClosed(session)) {\n            console.warn(\"Session already open\");\n        }\n        console.info(\"Opening session:\", session);\n        session.indexInfo.closed = -1;\n    }\n\n    isClosed(session) {\n        return session.indexInfo.closed !== -1;\n    }\n\n    removeOldSessions() {\n        while (Object.keys(this.sessions).length > CLOSED_SESSIONS_MAX) {\n            let oldestKey;\n            let oldestSession;\n            for (const [key, session] of Object.entries(this.sessions)) {\n                if (session.indexInfo.closed !== -1 &&\n                    (!oldestSession || session.indexInfo.closed < oldestSession.indexInfo.closed)) {\n                    oldestKey = key;\n                    oldestSession = session;\n                }\n            }\n            if (oldestKey) {\n                console.info(\"Removing old closed session:\", oldestSession);\n                delete this.sessions[oldestKey];\n            } else {\n                throw new Error('Corrupt sessions object');\n            }\n        }\n    }\n\n    deleteAllSessions() {\n        for (const key of Object.keys(this.sessions)) {\n            delete this.sessions[key];\n        }\n    }\n}\n\nmodule.exports = SessionRecord;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}