{"ast":null,"code":"// vim: ts=4:sw=4:expandtab\n\n/*\n * jobQueue manages multiple queues indexed by device to serialize\n * session io ops on the database.\n */\n'use strict';\n\nconst _queueAsyncBuckets = new Map();\nconst _gcLimit = 10000;\nasync function _asyncQueueExecutor(queue, cleanup) {\n  let offt = 0;\n  while (true) {\n    let limit = Math.min(queue.length, _gcLimit); // Break up thundering hurds for GC duty.\n    for (let i = offt; i < limit; i++) {\n      const job = queue[i];\n      try {\n        job.resolve(await job.awaitable());\n      } catch (e) {\n        job.reject(e);\n      }\n    }\n    if (limit < queue.length) {\n      /* Perform lazy GC of queue for faster iteration. */\n      if (limit >= _gcLimit) {\n        queue.splice(0, limit);\n        offt = 0;\n      } else {\n        offt = limit;\n      }\n    } else {\n      break;\n    }\n  }\n  cleanup();\n}\nmodule.exports = function (bucket, awaitable) {\n  /* Run the async awaitable only when all other async calls registered\n   * here have completed (or thrown).  The bucket argument is a hashable\n   * key representing the task queue to use. */\n  if (!awaitable.name) {\n    // Make debuging easier by adding a name to this function.\n    Object.defineProperty(awaitable, 'name', {\n      writable: true\n    });\n    if (typeof bucket === 'string') {\n      awaitable.name = bucket;\n    } else {\n      console.warn(\"Unhandled bucket type (for naming):\", typeof bucket, bucket);\n    }\n  }\n  let inactive;\n  if (!_queueAsyncBuckets.has(bucket)) {\n    _queueAsyncBuckets.set(bucket, []);\n    inactive = true;\n  }\n  const queue = _queueAsyncBuckets.get(bucket);\n  const job = new Promise((resolve, reject) => queue.push({\n    awaitable,\n    resolve,\n    reject\n  }));\n  if (inactive) {\n    /* An executor is not currently active; Start one now. */\n    _asyncQueueExecutor(queue, () => _queueAsyncBuckets.delete(bucket));\n  }\n  return job;\n};","map":{"version":3,"names":["_queueAsyncBuckets","Map","_gcLimit","_asyncQueueExecutor","queue","cleanup","offt","limit","Math","min","length","i","job","resolve","awaitable","e","reject","splice","module","exports","bucket","name","Object","defineProperty","writable","console","warn","inactive","has","set","get","Promise","push","delete"],"sources":["C:/Users/vanitas/node_modules/libsignal/src/queue_job.js"],"sourcesContent":["// vim: ts=4:sw=4:expandtab\n \n /*\n  * jobQueue manages multiple queues indexed by device to serialize\n  * session io ops on the database.\n  */\n'use strict';\n\n\nconst _queueAsyncBuckets = new Map();\nconst _gcLimit = 10000;\n\nasync function _asyncQueueExecutor(queue, cleanup) {\n    let offt = 0;\n    while (true) {\n        let limit = Math.min(queue.length, _gcLimit); // Break up thundering hurds for GC duty.\n        for (let i = offt; i < limit; i++) {\n            const job = queue[i];\n            try {\n                job.resolve(await job.awaitable());\n            } catch(e) {\n                job.reject(e);\n            }\n        }\n        if (limit < queue.length) {\n            /* Perform lazy GC of queue for faster iteration. */\n            if (limit >= _gcLimit) {\n                queue.splice(0, limit);\n                offt = 0;\n            } else {\n                offt = limit;\n            }\n        } else {\n            break;\n        }\n    }\n    cleanup();\n}\n\nmodule.exports = function(bucket, awaitable) {\n    /* Run the async awaitable only when all other async calls registered\n     * here have completed (or thrown).  The bucket argument is a hashable\n     * key representing the task queue to use. */\n    if (!awaitable.name) {\n        // Make debuging easier by adding a name to this function.\n        Object.defineProperty(awaitable, 'name', {writable: true});\n        if (typeof bucket === 'string') {\n            awaitable.name = bucket;\n        } else {\n            console.warn(\"Unhandled bucket type (for naming):\", typeof bucket, bucket);\n        }\n    }\n    let inactive;\n    if (!_queueAsyncBuckets.has(bucket)) {\n        _queueAsyncBuckets.set(bucket, []);\n        inactive = true;\n    }\n    const queue = _queueAsyncBuckets.get(bucket);\n    const job = new Promise((resolve, reject) => queue.push({\n        awaitable,\n        resolve,\n        reject\n    }));\n    if (inactive) {\n        /* An executor is not currently active; Start one now. */\n        _asyncQueueExecutor(queue, () => _queueAsyncBuckets.delete(bucket));\n    }\n    return job;\n};\n"],"mappings":"AAAA;;AAEC;AACD;AACA;AACA;AACA,YAAY;;AAGZ,MAAMA,kBAAkB,GAAG,IAAIC,GAAG,CAAC,CAAC;AACpC,MAAMC,QAAQ,GAAG,KAAK;AAEtB,eAAeC,mBAAmBA,CAACC,KAAK,EAAEC,OAAO,EAAE;EAC/C,IAAIC,IAAI,GAAG,CAAC;EACZ,OAAO,IAAI,EAAE;IACT,IAAIC,KAAK,GAAGC,IAAI,CAACC,GAAG,CAACL,KAAK,CAACM,MAAM,EAAER,QAAQ,CAAC,CAAC,CAAC;IAC9C,KAAK,IAAIS,CAAC,GAAGL,IAAI,EAAEK,CAAC,GAAGJ,KAAK,EAAEI,CAAC,EAAE,EAAE;MAC/B,MAAMC,GAAG,GAAGR,KAAK,CAACO,CAAC,CAAC;MACpB,IAAI;QACAC,GAAG,CAACC,OAAO,CAAC,MAAMD,GAAG,CAACE,SAAS,CAAC,CAAC,CAAC;MACtC,CAAC,CAAC,OAAMC,CAAC,EAAE;QACPH,GAAG,CAACI,MAAM,CAACD,CAAC,CAAC;MACjB;IACJ;IACA,IAAIR,KAAK,GAAGH,KAAK,CAACM,MAAM,EAAE;MACtB;MACA,IAAIH,KAAK,IAAIL,QAAQ,EAAE;QACnBE,KAAK,CAACa,MAAM,CAAC,CAAC,EAAEV,KAAK,CAAC;QACtBD,IAAI,GAAG,CAAC;MACZ,CAAC,MAAM;QACHA,IAAI,GAAGC,KAAK;MAChB;IACJ,CAAC,MAAM;MACH;IACJ;EACJ;EACAF,OAAO,CAAC,CAAC;AACb;AAEAa,MAAM,CAACC,OAAO,GAAG,UAASC,MAAM,EAAEN,SAAS,EAAE;EACzC;AACJ;AACA;EACI,IAAI,CAACA,SAAS,CAACO,IAAI,EAAE;IACjB;IACAC,MAAM,CAACC,cAAc,CAACT,SAAS,EAAE,MAAM,EAAE;MAACU,QAAQ,EAAE;IAAI,CAAC,CAAC;IAC1D,IAAI,OAAOJ,MAAM,KAAK,QAAQ,EAAE;MAC5BN,SAAS,CAACO,IAAI,GAAGD,MAAM;IAC3B,CAAC,MAAM;MACHK,OAAO,CAACC,IAAI,CAAC,qCAAqC,EAAE,OAAON,MAAM,EAAEA,MAAM,CAAC;IAC9E;EACJ;EACA,IAAIO,QAAQ;EACZ,IAAI,CAAC3B,kBAAkB,CAAC4B,GAAG,CAACR,MAAM,CAAC,EAAE;IACjCpB,kBAAkB,CAAC6B,GAAG,CAACT,MAAM,EAAE,EAAE,CAAC;IAClCO,QAAQ,GAAG,IAAI;EACnB;EACA,MAAMvB,KAAK,GAAGJ,kBAAkB,CAAC8B,GAAG,CAACV,MAAM,CAAC;EAC5C,MAAMR,GAAG,GAAG,IAAImB,OAAO,CAAC,CAAClB,OAAO,EAAEG,MAAM,KAAKZ,KAAK,CAAC4B,IAAI,CAAC;IACpDlB,SAAS;IACTD,OAAO;IACPG;EACJ,CAAC,CAAC,CAAC;EACH,IAAIW,QAAQ,EAAE;IACV;IACAxB,mBAAmB,CAACC,KAAK,EAAE,MAAMJ,kBAAkB,CAACiC,MAAM,CAACb,MAAM,CAAC,CAAC;EACvE;EACA,OAAOR,GAAG;AACd,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}