{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decryptMessageNode = exports.decodeMessageNode = exports.NO_MESSAGE_FOUND_ERROR_TEXT = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst WAProto_1 = require(\"../../WAProto\");\nconst WABinary_1 = require(\"../WABinary\");\nconst generics_1 = require(\"./generics\");\nexports.NO_MESSAGE_FOUND_ERROR_TEXT = 'Message absent from node';\n/**\n * Decode the received node as a message.\n * @note this will only parse the message, not decrypt it\n */\nfunction decodeMessageNode(stanza, meId, meLid) {\n  var _a;\n  let msgType;\n  let chatId;\n  let author;\n  const msgId = stanza.attrs.id;\n  const from = stanza.attrs.from;\n  const participant = stanza.attrs.participant;\n  const recipient = stanza.attrs.recipient;\n  const isMe = jid => (0, WABinary_1.areJidsSameUser)(jid, meId);\n  const isMeLid = jid => (0, WABinary_1.areJidsSameUser)(jid, meLid);\n  if ((0, WABinary_1.isJidUser)(from)) {\n    if (recipient) {\n      if (!isMe(from)) {\n        throw new boom_1.Boom('receipient present, but msg not from me', {\n          data: stanza\n        });\n      }\n      chatId = recipient;\n    } else {\n      chatId = from;\n    }\n    msgType = 'chat';\n    author = from;\n  } else if ((0, WABinary_1.isLidUser)(from)) {\n    if (recipient) {\n      if (!isMeLid(from)) {\n        throw new boom_1.Boom('receipient present, but msg not from me', {\n          data: stanza\n        });\n      }\n      chatId = recipient;\n    } else {\n      chatId = from;\n    }\n    msgType = 'chat';\n    author = from;\n  } else if ((0, WABinary_1.isJidGroup)(from)) {\n    if (!participant) {\n      throw new boom_1.Boom('No participant in group message');\n    }\n    msgType = 'group';\n    author = participant;\n    chatId = from;\n  } else if ((0, WABinary_1.isJidBroadcast)(from)) {\n    if (!participant) {\n      throw new boom_1.Boom('No participant in group message');\n    }\n    const isParticipantMe = isMe(participant);\n    if ((0, WABinary_1.isJidStatusBroadcast)(from)) {\n      msgType = isParticipantMe ? 'direct_peer_status' : 'other_status';\n    } else {\n      msgType = isParticipantMe ? 'peer_broadcast' : 'other_broadcast';\n    }\n    chatId = from;\n    author = participant;\n  } else if ((0, WABinary_1.isJidNewsletter)(from)) {\n    msgType = 'newsletter';\n    chatId = from;\n    author = from;\n  } else {\n    throw new boom_1.Boom('Unknown message type', {\n      data: stanza\n    });\n  }\n  const fromMe = ((0, WABinary_1.isLidUser)(from) ? isMeLid : isMe)(stanza.attrs.participant || stanza.attrs.from);\n  const pushname = (_a = stanza === null || stanza === void 0 ? void 0 : stanza.attrs) === null || _a === void 0 ? void 0 : _a.notify;\n  const key = {\n    remoteJid: chatId,\n    fromMe,\n    id: msgId,\n    participant\n  };\n  const fullMessage = {\n    key,\n    messageTimestamp: +stanza.attrs.t,\n    pushName: pushname,\n    broadcast: (0, WABinary_1.isJidBroadcast)(from)\n  };\n  if (key.fromMe) {\n    fullMessage.status = WAProto_1.proto.WebMessageInfo.Status.SERVER_ACK;\n  }\n  return {\n    fullMessage,\n    author,\n    sender: msgType === 'chat' ? author : chatId\n  };\n}\nexports.decodeMessageNode = decodeMessageNode;\nconst decryptMessageNode = (stanza, meId, meLid, repository, logger) => {\n  const {\n    fullMessage,\n    author,\n    sender\n  } = decodeMessageNode(stanza, meId, meLid);\n  return {\n    fullMessage,\n    category: stanza.attrs.category,\n    author,\n    async decrypt() {\n      var _a;\n      let decryptables = 0;\n      if (Array.isArray(stanza.content)) {\n        for (const {\n          tag,\n          attrs,\n          content\n        } of stanza.content) {\n          if (tag === 'verified_name' && content instanceof Uint8Array) {\n            const cert = WAProto_1.proto.VerifiedNameCertificate.decode(content);\n            const details = WAProto_1.proto.VerifiedNameCertificate.Details.decode(cert.details);\n            fullMessage.verifiedBizName = details.verifiedName;\n          }\n          if (tag !== 'enc' && tag !== 'plaintext') {\n            continue;\n          }\n          if (!(content instanceof Uint8Array)) {\n            continue;\n          }\n          decryptables += 1;\n          let msgBuffer;\n          try {\n            const e2eType = tag === 'plaintext' ? 'plaintext' : attrs.type;\n            switch (e2eType) {\n              case 'skmsg':\n                msgBuffer = await repository.decryptGroupMessage({\n                  group: sender,\n                  authorJid: author,\n                  msg: content\n                });\n                break;\n              case 'pkmsg':\n              case 'msg':\n                const user = (0, WABinary_1.isJidUser)(sender) ? sender : author;\n                msgBuffer = await repository.decryptMessage({\n                  jid: user,\n                  type: e2eType,\n                  ciphertext: content\n                });\n                break;\n              case 'plaintext':\n                msgBuffer = content;\n                break;\n              default:\n                throw new Error(`Unknown e2e type: ${e2eType}`);\n            }\n            let msg = WAProto_1.proto.Message.decode(e2eType !== 'plaintext' ? (0, generics_1.unpadRandomMax16)(msgBuffer) : msgBuffer);\n            msg = ((_a = msg.deviceSentMessage) === null || _a === void 0 ? void 0 : _a.message) || msg;\n            if (msg.senderKeyDistributionMessage) {\n              try {\n                await repository.processSenderKeyDistributionMessage({\n                  authorJid: author,\n                  item: msg.senderKeyDistributionMessage\n                });\n              } catch (err) {\n                logger.error({\n                  key: fullMessage.key,\n                  err\n                }, 'failed to decrypt message');\n              }\n            }\n            if (fullMessage.message) {\n              Object.assign(fullMessage.message, msg);\n            } else {\n              fullMessage.message = msg;\n            }\n          } catch (err) {\n            logger.error({\n              key: fullMessage.key,\n              err\n            }, 'failed to decrypt message');\n            fullMessage.messageStubType = WAProto_1.proto.WebMessageInfo.StubType.CIPHERTEXT;\n            fullMessage.messageStubParameters = [err.message];\n          }\n        }\n      }\n      // if nothing was found to decrypt\n      if (!decryptables) {\n        fullMessage.messageStubType = WAProto_1.proto.WebMessageInfo.StubType.CIPHERTEXT;\n        fullMessage.messageStubParameters = [exports.NO_MESSAGE_FOUND_ERROR_TEXT];\n      }\n    }\n  };\n};\nexports.decryptMessageNode = decryptMessageNode;","map":{"version":3,"names":["Object","defineProperty","exports","value","decryptMessageNode","decodeMessageNode","NO_MESSAGE_FOUND_ERROR_TEXT","boom_1","require","WAProto_1","WABinary_1","generics_1","stanza","meId","meLid","_a","msgType","chatId","author","msgId","attrs","id","from","participant","recipient","isMe","jid","areJidsSameUser","isMeLid","isJidUser","Boom","data","isLidUser","isJidGroup","isJidBroadcast","isParticipantMe","isJidStatusBroadcast","isJidNewsletter","fromMe","pushname","notify","key","remoteJid","fullMessage","messageTimestamp","t","pushName","broadcast","status","proto","WebMessageInfo","Status","SERVER_ACK","sender","repository","logger","category","decrypt","decryptables","Array","isArray","content","tag","Uint8Array","cert","VerifiedNameCertificate","decode","details","Details","verifiedBizName","verifiedName","msgBuffer","e2eType","type","decryptGroupMessage","group","authorJid","msg","user","decryptMessage","ciphertext","Error","Message","unpadRandomMax16","deviceSentMessage","message","senderKeyDistributionMessage","processSenderKeyDistributionMessage","item","err","error","assign","messageStubType","StubType","CIPHERTEXT","messageStubParameters"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Utils/decode-wa-message.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decryptMessageNode = exports.decodeMessageNode = exports.NO_MESSAGE_FOUND_ERROR_TEXT = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst WAProto_1 = require(\"../../WAProto\");\nconst WABinary_1 = require(\"../WABinary\");\nconst generics_1 = require(\"./generics\");\nexports.NO_MESSAGE_FOUND_ERROR_TEXT = 'Message absent from node';\n/**\n * Decode the received node as a message.\n * @note this will only parse the message, not decrypt it\n */\nfunction decodeMessageNode(stanza, meId, meLid) {\n    var _a;\n    let msgType;\n    let chatId;\n    let author;\n    const msgId = stanza.attrs.id;\n    const from = stanza.attrs.from;\n    const participant = stanza.attrs.participant;\n    const recipient = stanza.attrs.recipient;\n    const isMe = (jid) => (0, WABinary_1.areJidsSameUser)(jid, meId);\n    const isMeLid = (jid) => (0, WABinary_1.areJidsSameUser)(jid, meLid);\n    if ((0, WABinary_1.isJidUser)(from)) {\n        if (recipient) {\n            if (!isMe(from)) {\n                throw new boom_1.Boom('receipient present, but msg not from me', { data: stanza });\n            }\n            chatId = recipient;\n        }\n        else {\n            chatId = from;\n        }\n        msgType = 'chat';\n        author = from;\n    }\n    else if ((0, WABinary_1.isLidUser)(from)) {\n        if (recipient) {\n            if (!isMeLid(from)) {\n                throw new boom_1.Boom('receipient present, but msg not from me', { data: stanza });\n            }\n            chatId = recipient;\n        }\n        else {\n            chatId = from;\n        }\n        msgType = 'chat';\n        author = from;\n    }\n    else if ((0, WABinary_1.isJidGroup)(from)) {\n        if (!participant) {\n            throw new boom_1.Boom('No participant in group message');\n        }\n        msgType = 'group';\n        author = participant;\n        chatId = from;\n    }\n    else if ((0, WABinary_1.isJidBroadcast)(from)) {\n        if (!participant) {\n            throw new boom_1.Boom('No participant in group message');\n        }\n        const isParticipantMe = isMe(participant);\n        if ((0, WABinary_1.isJidStatusBroadcast)(from)) {\n            msgType = isParticipantMe ? 'direct_peer_status' : 'other_status';\n        }\n        else {\n            msgType = isParticipantMe ? 'peer_broadcast' : 'other_broadcast';\n        }\n        chatId = from;\n        author = participant;\n    }\n    else if ((0, WABinary_1.isJidNewsletter)(from)) {\n        msgType = 'newsletter';\n        chatId = from;\n        author = from;\n    }\n    else {\n        throw new boom_1.Boom('Unknown message type', { data: stanza });\n    }\n    const fromMe = ((0, WABinary_1.isLidUser)(from) ? isMeLid : isMe)(stanza.attrs.participant || stanza.attrs.from);\n    const pushname = (_a = stanza === null || stanza === void 0 ? void 0 : stanza.attrs) === null || _a === void 0 ? void 0 : _a.notify;\n    const key = {\n        remoteJid: chatId,\n        fromMe,\n        id: msgId,\n        participant\n    };\n    const fullMessage = {\n        key,\n        messageTimestamp: +stanza.attrs.t,\n        pushName: pushname,\n        broadcast: (0, WABinary_1.isJidBroadcast)(from)\n    };\n    if (key.fromMe) {\n        fullMessage.status = WAProto_1.proto.WebMessageInfo.Status.SERVER_ACK;\n    }\n    return {\n        fullMessage,\n        author,\n        sender: msgType === 'chat' ? author : chatId\n    };\n}\nexports.decodeMessageNode = decodeMessageNode;\nconst decryptMessageNode = (stanza, meId, meLid, repository, logger) => {\n    const { fullMessage, author, sender } = decodeMessageNode(stanza, meId, meLid);\n    return {\n        fullMessage,\n        category: stanza.attrs.category,\n        author,\n        async decrypt() {\n            var _a;\n            let decryptables = 0;\n            if (Array.isArray(stanza.content)) {\n                for (const { tag, attrs, content } of stanza.content) {\n                    if (tag === 'verified_name' && content instanceof Uint8Array) {\n                        const cert = WAProto_1.proto.VerifiedNameCertificate.decode(content);\n                        const details = WAProto_1.proto.VerifiedNameCertificate.Details.decode(cert.details);\n                        fullMessage.verifiedBizName = details.verifiedName;\n                    }\n                    if (tag !== 'enc' && tag !== 'plaintext') {\n                        continue;\n                    }\n                    if (!(content instanceof Uint8Array)) {\n                        continue;\n                    }\n                    decryptables += 1;\n                    let msgBuffer;\n                    try {\n                        const e2eType = tag === 'plaintext' ? 'plaintext' : attrs.type;\n                        switch (e2eType) {\n                            case 'skmsg':\n                                msgBuffer = await repository.decryptGroupMessage({\n                                    group: sender,\n                                    authorJid: author,\n                                    msg: content\n                                });\n                                break;\n                            case 'pkmsg':\n                            case 'msg':\n                                const user = (0, WABinary_1.isJidUser)(sender) ? sender : author;\n                                msgBuffer = await repository.decryptMessage({\n                                    jid: user,\n                                    type: e2eType,\n                                    ciphertext: content\n                                });\n                                break;\n                            case 'plaintext':\n                                msgBuffer = content;\n                                break;\n                            default:\n                                throw new Error(`Unknown e2e type: ${e2eType}`);\n                        }\n                        let msg = WAProto_1.proto.Message.decode(e2eType !== 'plaintext' ? (0, generics_1.unpadRandomMax16)(msgBuffer) : msgBuffer);\n                        msg = ((_a = msg.deviceSentMessage) === null || _a === void 0 ? void 0 : _a.message) || msg;\n                        if (msg.senderKeyDistributionMessage) {\n                            try {\n                                await repository.processSenderKeyDistributionMessage({\n                                    authorJid: author,\n                                    item: msg.senderKeyDistributionMessage\n                                });\n                            }\n                            catch (err) {\n                                logger.error({ key: fullMessage.key, err }, 'failed to decrypt message');\n                            }\n                        }\n                        if (fullMessage.message) {\n                            Object.assign(fullMessage.message, msg);\n                        }\n                        else {\n                            fullMessage.message = msg;\n                        }\n                    }\n                    catch (err) {\n                        logger.error({ key: fullMessage.key, err }, 'failed to decrypt message');\n                        fullMessage.messageStubType = WAProto_1.proto.WebMessageInfo.StubType.CIPHERTEXT;\n                        fullMessage.messageStubParameters = [err.message];\n                    }\n                }\n            }\n            // if nothing was found to decrypt\n            if (!decryptables) {\n                fullMessage.messageStubType = WAProto_1.proto.WebMessageInfo.StubType.CIPHERTEXT;\n                fullMessage.messageStubParameters = [exports.NO_MESSAGE_FOUND_ERROR_TEXT];\n            }\n        }\n    };\n};\nexports.decryptMessageNode = decryptMessageNode;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}