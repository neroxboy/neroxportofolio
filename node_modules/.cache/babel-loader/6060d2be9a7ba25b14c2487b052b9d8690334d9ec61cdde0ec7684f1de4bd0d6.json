{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.coalesceAsync = void 0;\nconst callbacks = new Map();\n/**\n * Enqueue a promise for the group identified by `key`.\n *\n * All requests received for the same key while a request for that key\n * is already being executed will wait. Once the running request settles\n * then all the waiting requests in the group will settle, too.\n * This minimizes how many times the function itself runs at the same time.\n * This function resolves or rejects according to the given function argument.\n */\nasync function coalesceAsync(\n/**\n * Any identifier to group requests together.\n */\nkey,\n/**\n * The function to run.\n */\nfn) {\n  if (!hasKey(key)) {\n    addKey(key);\n    try {\n      const result = await Promise.resolve(fn());\n      coalesce({\n        key,\n        result\n      });\n      return result;\n    } catch (error) {\n      coalesce({\n        key,\n        error\n      });\n      throw error;\n    }\n  }\n  return enqueue(key);\n}\nexports.coalesceAsync = coalesceAsync;\nfunction hasKey(key) {\n  return callbacks.has(key);\n}\nfunction addKey(key) {\n  callbacks.set(key, []);\n}\nfunction removeKey(key) {\n  callbacks.delete(key);\n}\nfunction addCallbackToKey(key, callback) {\n  const stash = getCallbacksByKey(key);\n  stash.push(callback);\n  callbacks.set(key, stash);\n}\nfunction getCallbacksByKey(key) {\n  return callbacks.get(key) ?? [];\n}\nfunction enqueue(key) {\n  return new Promise((resolve, reject) => {\n    const callback = {\n      resolve,\n      reject\n    };\n    addCallbackToKey(key, callback);\n  });\n}\nfunction dequeue(key) {\n  const stash = getCallbacksByKey(key);\n  removeKey(key);\n  return stash;\n}\nfunction coalesce(options) {\n  const {\n    key,\n    error,\n    result\n  } = options;\n  dequeue(key).forEach(callback => {\n    if (error) {\n      callback.reject(error);\n    } else {\n      callback.resolve(result);\n    }\n  });\n}","map":{"version":3,"names":["callbacks","Map","coalesceAsync","key","fn","hasKey","addKey","result","Promise","resolve","coalesce","error","enqueue","exports","has","set","removeKey","delete","addCallbackToKey","callback","stash","getCallbacksByKey","push","get","reject","dequeue","options","forEach"],"sources":["../src/coalesce.ts"],"sourcesContent":[null],"mappings":";;;;;;AAEA,MAAMA,SAAS,GAAG,IAAIC,GAAG,EAAuC;AAEhE;;;;;;;;;AASO,eAAeC,aAAaA;AACjC;;;AAGAC,GAAW;AACX;;;AAGAC,EAA4B;EAE5B,IAAI,CAACC,MAAM,CAACF,GAAG,CAAC,EAAE;IAChBG,MAAM,CAACH,GAAG,CAAC;IACX,IAAI;MACF,MAAMI,MAAM,GAAG,MAAMC,OAAO,CAACC,OAAO,CAACL,EAAE,EAAE,CAAC;MAC1CM,QAAQ,CAAC;QAAEP,GAAG;QAAEI;MAAM,CAAE,CAAC;MACzB,OAAOA,MAAM;KACd,CAAC,OAAOI,KAAK,EAAE;MACdD,QAAQ,CAAC;QAAEP,GAAG;QAAEQ;MAAK,CAAE,CAAC;MACxB,MAAMA,KAAK;;;EAGf,OAAOC,OAAO,CAACT,GAAG,CAAC;AACrB;AAtBAU,OAAA,CAAAX,aAAA,GAAAA,aAAA;AAwBA,SAASG,MAAMA,CAACF,GAAW;EACzB,OAAOH,SAAS,CAACc,GAAG,CAACX,GAAG,CAAC;AAC3B;AAEA,SAASG,MAAMA,CAACH,GAAW;EACzBH,SAAS,CAACe,GAAG,CAACZ,GAAG,EAAE,EAAE,CAAC;AACxB;AAEA,SAASa,SAASA,CAACb,GAAW;EAC5BH,SAAS,CAACiB,MAAM,CAACd,GAAG,CAAC;AACvB;AAEA,SAASe,gBAAgBA,CAAIf,GAAW,EAAEgB,QAA4B;EACpE,MAAMC,KAAK,GAAGC,iBAAiB,CAAIlB,GAAG,CAAC;EACvCiB,KAAK,CAACE,IAAI,CAACH,QAAQ,CAAC;EACpBnB,SAAS,CAACe,GAAG,CAACZ,GAAG,EAAEiB,KAAK,CAAC;AAC3B;AAEA,SAASC,iBAAiBA,CAAIlB,GAAW;EACvC,OAAOH,SAAS,CAACuB,GAAG,CAACpB,GAAG,CAAC,IAAI,EAAE;AACjC;AAEA,SAASS,OAAOA,CAAIT,GAAW;EAC7B,OAAO,IAAIK,OAAO,CAAI,CAACC,OAAO,EAAEe,MAAM,KAAI;IACxC,MAAML,QAAQ,GAAuB;MAAEV,OAAO;MAAEe;IAAM,CAAE;IACxDN,gBAAgB,CAACf,GAAG,EAAEgB,QAAQ,CAAC;EACjC,CAAC,CAAC;AACJ;AAEA,SAASM,OAAOA,CAAItB,GAAW;EAC7B,MAAMiB,KAAK,GAAGC,iBAAiB,CAAIlB,GAAG,CAAC;EACvCa,SAAS,CAACb,GAAG,CAAC;EACd,OAAOiB,KAAK;AACd;AAEA,SAASV,QAAQA,CAAIgB,OAIpB;EACC,MAAM;IAAEvB,GAAG;IAAEQ,KAAK;IAAEJ;EAAM,CAAE,GAAGmB,OAAO;EACtCD,OAAO,CAACtB,GAAG,CAAC,CAACwB,OAAO,CAAER,QAAQ,IAAI;IAChC,IAAIR,KAAK,EAAE;MACTQ,QAAQ,CAACK,MAAM,CAACb,KAAK,CAAC;KACvB,MAAM;MACLQ,QAAQ,CAACV,OAAO,CAACF,MAAM,CAAC;;EAE5B,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}