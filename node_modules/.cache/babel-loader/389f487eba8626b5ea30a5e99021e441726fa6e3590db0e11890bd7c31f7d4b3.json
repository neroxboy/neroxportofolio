{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ratingToStars = exports.orderTags = exports.parseFile = exports.parseStream = exports.selectCover = exports.parseBuffer = exports.parseFromTokenizer = void 0;\nconst strtok3 = require(\"strtok3\");\nconst Core = require(\"./core\");\nconst ParserFactory_1 = require(\"./ParserFactory\");\nconst debug_1 = require(\"debug\");\nconst RandomFileReader_1 = require(\"./common/RandomFileReader\");\nconst debug = (0, debug_1.default)(\"music-metadata:parser\");\nvar core_1 = require(\"./core\");\nObject.defineProperty(exports, \"parseFromTokenizer\", {\n  enumerable: true,\n  get: function () {\n    return core_1.parseFromTokenizer;\n  }\n});\nObject.defineProperty(exports, \"parseBuffer\", {\n  enumerable: true,\n  get: function () {\n    return core_1.parseBuffer;\n  }\n});\nObject.defineProperty(exports, \"selectCover\", {\n  enumerable: true,\n  get: function () {\n    return core_1.selectCover;\n  }\n});\n/**\n * Parse audio from Node Stream.Readable\n * @param stream - Stream to read the audio track from\n * @param fileInfo - File information object or MIME-type, e.g.: 'audio/mpeg'\n * @param options - Parsing options\n * @returns Metadata\n */\nasync function parseStream(stream, fileInfo, options = {}) {\n  const tokenizer = await strtok3.fromStream(stream, typeof fileInfo === 'string' ? {\n    mimeType: fileInfo\n  } : fileInfo);\n  return Core.parseFromTokenizer(tokenizer, options);\n}\nexports.parseStream = parseStream;\n/**\n * Parse audio from Node file\n * @param filePath - Media file to read meta-data from\n * @param options - Parsing options\n * @returns Metadata\n */\nasync function parseFile(filePath, options = {}) {\n  debug(`parseFile: ${filePath}`);\n  const fileTokenizer = await strtok3.fromFile(filePath);\n  const fileReader = await RandomFileReader_1.RandomFileReader.init(filePath, fileTokenizer.fileInfo.size);\n  try {\n    await Core.scanAppendingHeaders(fileReader, options);\n  } finally {\n    await fileReader.close();\n  }\n  try {\n    const parserName = ParserFactory_1.ParserFactory.getParserIdForExtension(filePath);\n    if (!parserName) debug(' Parser could not be determined by file extension');\n    return await ParserFactory_1.ParserFactory.parse(fileTokenizer, parserName, options);\n  } finally {\n    await fileTokenizer.close();\n  }\n}\nexports.parseFile = parseFile;\n/**\n * Create a dictionary ordered by their tag id (key)\n * @param nativeTags - List of tags\n * @returns Tags indexed by id\n */\nexports.orderTags = Core.orderTags;\n/**\n * Convert rating to 1-5 star rating\n * @param rating - Normalized rating [0..1] (common.rating[n].rating)\n * @returns Number of stars: 1, 2, 3, 4 or 5 stars\n */\nexports.ratingToStars = Core.ratingToStars;\n/**\n * Define default module exports\n */\nexports.default = {\n  parseStream,\n  parseFile,\n  parseFromTokenizer: Core.parseFromTokenizer,\n  parseBuffer: Core.parseBuffer,\n  selectCover: Core.selectCover\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","ratingToStars","orderTags","parseFile","parseStream","selectCover","parseBuffer","parseFromTokenizer","strtok3","require","Core","ParserFactory_1","debug_1","RandomFileReader_1","debug","default","core_1","enumerable","get","stream","fileInfo","options","tokenizer","fromStream","mimeType","filePath","fileTokenizer","fromFile","fileReader","RandomFileReader","init","size","scanAppendingHeaders","close","parserName","ParserFactory","getParserIdForExtension","parse"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ratingToStars = exports.orderTags = exports.parseFile = exports.parseStream = exports.selectCover = exports.parseBuffer = exports.parseFromTokenizer = void 0;\nconst strtok3 = require(\"strtok3\");\nconst Core = require(\"./core\");\nconst ParserFactory_1 = require(\"./ParserFactory\");\nconst debug_1 = require(\"debug\");\nconst RandomFileReader_1 = require(\"./common/RandomFileReader\");\nconst debug = (0, debug_1.default)(\"music-metadata:parser\");\nvar core_1 = require(\"./core\");\nObject.defineProperty(exports, \"parseFromTokenizer\", { enumerable: true, get: function () { return core_1.parseFromTokenizer; } });\nObject.defineProperty(exports, \"parseBuffer\", { enumerable: true, get: function () { return core_1.parseBuffer; } });\nObject.defineProperty(exports, \"selectCover\", { enumerable: true, get: function () { return core_1.selectCover; } });\n/**\n * Parse audio from Node Stream.Readable\n * @param stream - Stream to read the audio track from\n * @param fileInfo - File information object or MIME-type, e.g.: 'audio/mpeg'\n * @param options - Parsing options\n * @returns Metadata\n */\nasync function parseStream(stream, fileInfo, options = {}) {\n    const tokenizer = await strtok3.fromStream(stream, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo);\n    return Core.parseFromTokenizer(tokenizer, options);\n}\nexports.parseStream = parseStream;\n/**\n * Parse audio from Node file\n * @param filePath - Media file to read meta-data from\n * @param options - Parsing options\n * @returns Metadata\n */\nasync function parseFile(filePath, options = {}) {\n    debug(`parseFile: ${filePath}`);\n    const fileTokenizer = await strtok3.fromFile(filePath);\n    const fileReader = await RandomFileReader_1.RandomFileReader.init(filePath, fileTokenizer.fileInfo.size);\n    try {\n        await Core.scanAppendingHeaders(fileReader, options);\n    }\n    finally {\n        await fileReader.close();\n    }\n    try {\n        const parserName = ParserFactory_1.ParserFactory.getParserIdForExtension(filePath);\n        if (!parserName)\n            debug(' Parser could not be determined by file extension');\n        return await ParserFactory_1.ParserFactory.parse(fileTokenizer, parserName, options);\n    }\n    finally {\n        await fileTokenizer.close();\n    }\n}\nexports.parseFile = parseFile;\n/**\n * Create a dictionary ordered by their tag id (key)\n * @param nativeTags - List of tags\n * @returns Tags indexed by id\n */\nexports.orderTags = Core.orderTags;\n/**\n * Convert rating to 1-5 star rating\n * @param rating - Normalized rating [0..1] (common.rating[n].rating)\n * @returns Number of stars: 1, 2, 3, 4 or 5 stars\n */\nexports.ratingToStars = Core.ratingToStars;\n/**\n * Define default module exports\n */\nexports.default = {\n    parseStream,\n    parseFile,\n    parseFromTokenizer: Core.parseFromTokenizer,\n    parseBuffer: Core.parseBuffer,\n    selectCover: Core.selectCover\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}