{"ast":null,"code":"/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n\n'use strict';\n\nconst data_decoders = {\n  pcm8: (buffer, offset, output, channels, samples) => {\n    let input = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let data = input[pos++] - 128;\n        output[ch][i] = data < 0 ? data / 128 : data / 127;\n      }\n    }\n  },\n  pcm16: (buffer, offset, output, channels, samples) => {\n    let input = new Int16Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let data = input[pos++];\n        output[ch][i] = data < 0 ? data / 32768 : data / 32767;\n      }\n    }\n  },\n  pcm24: (buffer, offset, output, channels, samples) => {\n    let input = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let x0 = input[pos++];\n        let x1 = input[pos++];\n        let x2 = input[pos++];\n        let xx = x0 + (x1 << 8) + (x2 << 16);\n        let data = xx > 0x800000 ? xx - 0x1000000 : xx;\n        output[ch][i] = data < 0 ? data / 8388608 : data / 8388607;\n      }\n    }\n  },\n  pcm32: (buffer, offset, output, channels, samples) => {\n    let input = new Int32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let data = input[pos++];\n        output[ch][i] = data < 0 ? data / 2147483648 : data / 2147483647;\n      }\n    }\n  },\n  pcm32f: (buffer, offset, output, channels, samples) => {\n    let input = new Float32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) output[ch][i] = input[pos++];\n    }\n  },\n  pcm64f: (buffer, offset, output, channels, samples) => {\n    let input = new Float64Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) output[ch][i] = input[pos++];\n    }\n  }\n};\nconst data_encoders = {\n  pcm8: (buffer, offset, input, channels, samples) => {\n    let output = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = (v * 0.5 + 0.5) * 255 | 0;\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm16: (buffer, offset, input, channels, samples) => {\n    let output = new Int16Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = (v < 0 ? v * 32768 : v * 32767) | 0;\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm24: (buffer, offset, input, channels, samples) => {\n    let output = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = (v < 0 ? 0x1000000 + v * 8388608 : v * 8388607) | 0;\n        output[pos++] = v >> 0 & 0xff;\n        output[pos++] = v >> 8 & 0xff;\n        output[pos++] = v >> 16 & 0xff;\n      }\n    }\n  },\n  pcm32: (buffer, offset, input, channels, samples) => {\n    let output = new Int32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = (v < 0 ? v * 2147483648 : v * 2147483647) | 0;\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm32f: (buffer, offset, input, channels, samples) => {\n    let output = new Float32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm64f: (buffer, offset, input, channels, samples) => {\n    let output = new Float64Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        output[pos++] = v;\n      }\n    }\n  }\n};\nfunction lookup(table, bitDepth, floatingPoint) {\n  let name = 'pcm' + bitDepth + (floatingPoint ? 'f' : '');\n  let fn = table[name];\n  if (!fn) throw new TypeError('Unsupported data format: ' + name);\n  return fn;\n}\nfunction decode(buffer) {\n  let pos = 0,\n    end = 0;\n  if (buffer.buffer) {\n    // If we are handed a typed array or a buffer, then we have to consider the\n    // offset and length into the underlying array buffer.\n    pos = buffer.byteOffset;\n    end = buffer.length;\n    buffer = buffer.buffer;\n  } else {\n    // If we are handed a straight up array buffer, start at offset 0 and use\n    // the full length of the buffer.\n    pos = 0;\n    end = buffer.byteLength;\n  }\n  let v = new DataView(buffer);\n  function u8() {\n    let x = v.getUint8(pos);\n    pos++;\n    return x;\n  }\n  function u16() {\n    let x = v.getUint16(pos, true);\n    pos += 2;\n    return x;\n  }\n  function u32() {\n    let x = v.getUint32(pos, true);\n    pos += 4;\n    return x;\n  }\n  function string(len) {\n    let str = '';\n    for (let i = 0; i < len; ++i) str += String.fromCharCode(u8());\n    return str;\n  }\n  if (string(4) !== 'RIFF') throw new TypeError('Invalid WAV file');\n  u32();\n  if (string(4) !== 'WAVE') throw new TypeError('Invalid WAV file');\n  let fmt;\n  while (pos < end) {\n    let type = string(4);\n    let size = u32();\n    let next = pos + size;\n    switch (type) {\n      case 'fmt ':\n        let formatId = u16();\n        if (formatId !== 0x0001 && formatId !== 0x0003) throw new TypeError('Unsupported format in WAV file: ' + formatId.toString(16));\n        fmt = {\n          format: 'lpcm',\n          floatingPoint: formatId === 0x0003,\n          channels: u16(),\n          sampleRate: u32(),\n          byteRate: u32(),\n          blockSize: u16(),\n          bitDepth: u16()\n        };\n        break;\n      case 'data':\n        if (!fmt) throw new TypeError('Missing \"fmt \" chunk.');\n        let samples = Math.floor(size / fmt.blockSize);\n        let channels = fmt.channels;\n        let sampleRate = fmt.sampleRate;\n        let channelData = [];\n        for (let ch = 0; ch < channels; ++ch) channelData[ch] = new Float32Array(samples);\n        lookup(data_decoders, fmt.bitDepth, fmt.floatingPoint)(buffer, pos, channelData, channels, samples);\n        return {\n          sampleRate: sampleRate,\n          channelData: channelData\n        };\n        break;\n    }\n    pos = next;\n  }\n}\nfunction encode(channelData, opts) {\n  let sampleRate = opts.sampleRate || 16000;\n  let floatingPoint = !!(opts.float || opts.floatingPoint);\n  let bitDepth = floatingPoint ? 32 : opts.bitDepth | 0 || 16;\n  let channels = channelData.length;\n  let samples = channelData[0].length;\n  let buffer = new ArrayBuffer(44 + samples * channels * (bitDepth >> 3));\n  let v = new DataView(buffer);\n  let pos = 0;\n  function u8(x) {\n    v.setUint8(pos++, x);\n  }\n  function u16(x) {\n    v.setUint16(pos, x, true);\n    pos += 2;\n  }\n  function u32(x) {\n    v.setUint32(pos, x, true);\n    pos += 4;\n  }\n  function string(s) {\n    for (var i = 0; i < s.length; ++i) u8(s.charCodeAt(i));\n  }\n\n  // write header\n  string('RIFF');\n  u32(buffer.byteLength - 8);\n  string('WAVE');\n\n  // write 'fmt ' chunk\n  string('fmt ');\n  u32(16);\n  u16(floatingPoint ? 0x0003 : 0x0001);\n  u16(channels);\n  u32(sampleRate);\n  u32(sampleRate * channels * (bitDepth >> 3));\n  u16(channels * (bitDepth >> 3));\n  u16(bitDepth);\n\n  // write 'data' chunk\n  string('data');\n  u32(buffer.byteLength - 44);\n  lookup(data_encoders, bitDepth, floatingPoint)(buffer, pos, channelData, channels, samples);\n  return Buffer(buffer);\n}\nmodule.exports = {\n  decode: decode,\n  encode: encode\n};","map":{"version":3,"names":["data_decoders","pcm8","buffer","offset","output","channels","samples","input","Uint8Array","pos","i","ch","data","pcm16","Int16Array","pcm24","x0","x1","x2","xx","pcm32","Int32Array","pcm32f","Float32Array","pcm64f","Float64Array","data_encoders","v","Math","max","min","lookup","table","bitDepth","floatingPoint","name","fn","TypeError","decode","end","byteOffset","length","byteLength","DataView","u8","x","getUint8","u16","getUint16","u32","getUint32","string","len","str","String","fromCharCode","fmt","type","size","next","formatId","toString","format","sampleRate","byteRate","blockSize","floor","channelData","encode","opts","float","ArrayBuffer","setUint8","setUint16","setUint32","s","charCodeAt","Buffer","module","exports"],"sources":["C:/Users/vanitas/node_modules/node-wav/index.js"],"sourcesContent":["/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n\n'use strict';\n\nconst data_decoders = {\n  pcm8: (buffer, offset, output, channels, samples) => {\n    let input = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let data = input[pos++] - 128;\n        output[ch][i] = data < 0 ? data / 128 : data / 127;\n      }\n    }\n  },\n  pcm16: (buffer, offset, output, channels, samples) => {\n    let input = new Int16Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let data = input[pos++];\n        output[ch][i] = data < 0 ? data / 32768 : data / 32767;\n      }\n    }\n  },\n  pcm24: (buffer, offset, output, channels, samples) => {\n    let input = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let x0 = input[pos++];\n        let x1 = input[pos++];\n        let x2 = input[pos++];\n        let xx = (x0 + (x1 << 8) + (x2 << 16));\n        let data = xx > 0x800000 ? xx - 0x1000000 : xx;\n        output[ch][i] = data < 0 ? data / 8388608 : data / 8388607;\n      }\n    }\n  },\n  pcm32: (buffer, offset, output, channels, samples) => {\n    let input = new Int32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let data = input[pos++];\n        output[ch][i] = data < 0 ? data / 2147483648 : data / 2147483647;\n      }\n    }\n  },\n  pcm32f: (buffer, offset, output, channels, samples) => {\n    let input = new Float32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch)\n        output[ch][i] = input[pos++];\n    }\n  },\n  pcm64f: (buffer, offset, output, channels, samples) => {\n    let input = new Float64Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch)\n        output[ch][i] = input[pos++];\n    }\n  },\n};\n\nconst data_encoders = {\n  pcm8: (buffer, offset, input, channels, samples) => {\n    let output = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = ((v * 0.5 + 0.5) * 255) | 0;\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm16: (buffer, offset, input, channels, samples) => {\n    let output = new Int16Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = ((v < 0) ? v * 32768 : v * 32767) | 0;\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm24: (buffer, offset, input, channels, samples) => {\n    let output = new Uint8Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = ((v < 0) ? 0x1000000 + v * 8388608 : v * 8388607) | 0;\n        output[pos++] = (v >> 0) & 0xff;\n        output[pos++] = (v >> 8) & 0xff;\n        output[pos++] = (v >> 16) & 0xff;\n      }\n    }\n  },\n  pcm32: (buffer, offset, input, channels, samples) => {\n    let output = new Int32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));\n        v = ((v < 0) ? v * 2147483648 : v * 2147483647) | 0;\n        output[pos++] = v;\n      }\n    }\n  },\n  pcm32f: (buffer, offset, input, channels, samples) => {\n    let output = new Float32Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));        \n        output[pos++] = v;\n      }\n    }\n  },\n  pcm64f: (buffer, offset, input, channels, samples) => {\n    let output = new Float64Array(buffer, offset);\n    let pos = 0;\n    for (let i = 0; i < samples; ++i) {\n      for (let ch = 0; ch < channels; ++ch) {\n        let v = Math.max(-1, Math.min(input[ch][i], 1));        \n        output[pos++] = v;\n      }\n    }\n  },\n};\n\nfunction lookup(table, bitDepth, floatingPoint) {\n  let name = 'pcm' + bitDepth + (floatingPoint ? 'f' : '');\n  let fn = table[name];\n  if (!fn)\n    throw new TypeError('Unsupported data format: ' + name);\n  return fn;\n}\n\nfunction decode(buffer) {\n  let pos = 0, end = 0;\n  if (buffer.buffer) {\n    // If we are handed a typed array or a buffer, then we have to consider the\n    // offset and length into the underlying array buffer.\n    pos = buffer.byteOffset;\n    end = buffer.length;\n    buffer = buffer.buffer;\n  } else {\n    // If we are handed a straight up array buffer, start at offset 0 and use\n    // the full length of the buffer.\n    pos = 0;\n    end = buffer.byteLength;\n  }\n\n  let v = new DataView(buffer);\n\n  function u8() {\n    let x = v.getUint8(pos);\n    pos++;\n    return x;\n  }\n\n  function u16() {\n    let x = v.getUint16(pos, true);\n    pos += 2;\n    return x;\n  }\n\n  function u32() {\n    let x = v.getUint32(pos, true);\n    pos += 4;\n    return x;\n  }\n\n  function string(len) {\n    let str = '';\n    for (let i = 0; i < len; ++i)\n      str += String.fromCharCode(u8());\n    return str;\n  }\n\n  if (string(4) !== 'RIFF')\n    throw new TypeError('Invalid WAV file');\n  u32();\n  if (string(4) !== 'WAVE')\n    throw new TypeError('Invalid WAV file');\n\n  let fmt;\n  \n  while (pos < end) {\n    let type = string(4);\n    let size = u32();\n    let next = pos + size;\n    switch (type) {\n    case 'fmt ':\n      let formatId = u16();\n      if (formatId !== 0x0001 && formatId !== 0x0003)\n        throw new TypeError('Unsupported format in WAV file: ' + formatId.toString(16));\n      fmt = {\n        format: 'lpcm',\n        floatingPoint: formatId === 0x0003,\n        channels: u16(),\n        sampleRate: u32(),\n        byteRate: u32(),\n        blockSize: u16(),\n        bitDepth: u16(),\n      };\n      break;\n    case 'data':\n      if (!fmt)\n        throw new TypeError('Missing \"fmt \" chunk.');\n      let samples = Math.floor(size / fmt.blockSize);\n      let channels = fmt.channels;\n      let sampleRate = fmt.sampleRate;\n      let channelData = [];\n      for (let ch = 0; ch < channels; ++ch)\n        channelData[ch] = new Float32Array(samples);\n      lookup(data_decoders, fmt.bitDepth, fmt.floatingPoint)(buffer, pos, channelData, channels, samples);\n      return {\n        sampleRate: sampleRate,\n        channelData: channelData\n      };\n      break;\n    }\n    pos = next;\n  }\n}\n\nfunction encode(channelData, opts) {\n  let sampleRate = opts.sampleRate || 16000;\n  let floatingPoint = !!(opts.float || opts.floatingPoint);\n  let bitDepth = floatingPoint ? 32 : ((opts.bitDepth | 0) || 16);\n  let channels = channelData.length;\n  let samples = channelData[0].length;\n  let buffer = new ArrayBuffer(44 + (samples * channels * (bitDepth >> 3)));\n\n  let v = new DataView(buffer);\n  let pos = 0;\n\n  function u8(x) {\n    v.setUint8(pos++, x);\n  }\n\n  function u16(x) {\n    v.setUint16(pos, x, true);\n    pos += 2;\n  }\n\n  function u32(x) {\n    v.setUint32(pos, x, true);\n    pos += 4;\n  }\n  \n  function string(s) {\n    for (var i = 0; i < s.length; ++i)\n      u8(s.charCodeAt(i));\n  }\n\n  // write header\n  string('RIFF');\n  u32(buffer.byteLength - 8);\n  string('WAVE');\n\n  // write 'fmt ' chunk\n  string('fmt ');\n  u32(16);\n  u16(floatingPoint ? 0x0003 : 0x0001);\n  u16(channels);\n  u32(sampleRate);\n  u32(sampleRate * channels * (bitDepth >> 3));\n  u16(channels * (bitDepth >> 3));\n  u16(bitDepth);\n\n  // write 'data' chunk\n  string('data');\n  u32(buffer.byteLength - 44);\n  lookup(data_encoders, bitDepth, floatingPoint)(buffer, pos, channelData, channels, samples);\n\n  return Buffer(buffer);\n}\n\nmodule.exports = {\n  decode: decode,\n  encode: encode,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}