{"ast":null,"code":"// vim: ts=4:sw=4:expandtab\n\nclass ProtocolAddress {\n  static from(encodedAddress) {\n    if (typeof encodedAddress !== 'string' || !encodedAddress.match(/.*\\.\\d+/)) {\n      throw new Error('Invalid address encoding');\n    }\n    const parts = encodedAddress.split('.');\n    return new this(parts[0], parseInt(parts[1]));\n  }\n  constructor(id, deviceId) {\n    if (typeof id !== 'string') {\n      throw new TypeError('id required for addr');\n    }\n    if (id.indexOf('.') !== -1) {\n      throw new TypeError('encoded addr detected');\n    }\n    this.id = id;\n    if (typeof deviceId !== 'number') {\n      throw new TypeError('number required for deviceId');\n    }\n    this.deviceId = deviceId;\n  }\n  toString() {\n    return `${this.id}.${this.deviceId}`;\n  }\n  is(other) {\n    if (!(other instanceof ProtocolAddress)) {\n      return false;\n    }\n    return other.id === this.id && other.deviceId === this.deviceId;\n  }\n}\nmodule.exports = ProtocolAddress;","map":{"version":3,"names":["ProtocolAddress","from","encodedAddress","match","Error","parts","split","parseInt","constructor","id","deviceId","TypeError","indexOf","toString","is","other","module","exports"],"sources":["C:/Users/vanitas/node_modules/libsignal/src/protocol_address.js"],"sourcesContent":["// vim: ts=4:sw=4:expandtab\n\n\nclass ProtocolAddress {\n\n    static from(encodedAddress) {\n        if (typeof encodedAddress !== 'string' || !encodedAddress.match(/.*\\.\\d+/)) {\n            throw new Error('Invalid address encoding');\n        }\n        const parts = encodedAddress.split('.');\n        return new this(parts[0], parseInt(parts[1]));\n    }\n\n    constructor(id, deviceId) {\n        if (typeof id !== 'string') {\n            throw new TypeError('id required for addr');\n        }\n        if (id.indexOf('.') !== -1) {\n            throw new TypeError('encoded addr detected');\n        }\n        this.id = id;\n        if (typeof deviceId !== 'number') {\n            throw new TypeError('number required for deviceId');\n        }\n        this.deviceId = deviceId;\n    }\n\n    toString() {\n        return `${this.id}.${this.deviceId}`;\n    }\n\n    is(other) {\n        if (!(other instanceof ProtocolAddress)) {\n            return false;\n        }\n        return other.id === this.id && other.deviceId === this.deviceId;\n    }\n}\n\nmodule.exports = ProtocolAddress;\n"],"mappings":"AAAA;;AAGA,MAAMA,eAAe,CAAC;EAElB,OAAOC,IAAIA,CAACC,cAAc,EAAE;IACxB,IAAI,OAAOA,cAAc,KAAK,QAAQ,IAAI,CAACA,cAAc,CAACC,KAAK,CAAC,SAAS,CAAC,EAAE;MACxE,MAAM,IAAIC,KAAK,CAAC,0BAA0B,CAAC;IAC/C;IACA,MAAMC,KAAK,GAAGH,cAAc,CAACI,KAAK,CAAC,GAAG,CAAC;IACvC,OAAO,IAAI,IAAI,CAACD,KAAK,CAAC,CAAC,CAAC,EAAEE,QAAQ,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;EACjD;EAEAG,WAAWA,CAACC,EAAE,EAAEC,QAAQ,EAAE;IACtB,IAAI,OAAOD,EAAE,KAAK,QAAQ,EAAE;MACxB,MAAM,IAAIE,SAAS,CAAC,sBAAsB,CAAC;IAC/C;IACA,IAAIF,EAAE,CAACG,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;MACxB,MAAM,IAAID,SAAS,CAAC,uBAAuB,CAAC;IAChD;IACA,IAAI,CAACF,EAAE,GAAGA,EAAE;IACZ,IAAI,OAAOC,QAAQ,KAAK,QAAQ,EAAE;MAC9B,MAAM,IAAIC,SAAS,CAAC,8BAA8B,CAAC;IACvD;IACA,IAAI,CAACD,QAAQ,GAAGA,QAAQ;EAC5B;EAEAG,QAAQA,CAAA,EAAG;IACP,OAAO,GAAG,IAAI,CAACJ,EAAE,IAAI,IAAI,CAACC,QAAQ,EAAE;EACxC;EAEAI,EAAEA,CAACC,KAAK,EAAE;IACN,IAAI,EAAEA,KAAK,YAAYf,eAAe,CAAC,EAAE;MACrC,OAAO,KAAK;IAChB;IACA,OAAOe,KAAK,CAACN,EAAE,KAAK,IAAI,CAACA,EAAE,IAAIM,KAAK,CAACL,QAAQ,KAAK,IAAI,CAACA,QAAQ;EACnE;AACJ;AAEAM,MAAM,CAACC,OAAO,GAAGjB,eAAe","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}