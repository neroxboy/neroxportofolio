{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParserFactory = exports.parseHttpContentType = void 0;\nconst FileType = require(\"file-type/core\");\nconst ContentType = require(\"content-type\");\nconst MimeType = require(\"media-typer\");\nconst debug_1 = require(\"debug\");\nconst MetadataCollector_1 = require(\"./common/MetadataCollector\");\nconst AiffParser_1 = require(\"./aiff/AiffParser\");\nconst APEv2Parser_1 = require(\"./apev2/APEv2Parser\");\nconst AsfParser_1 = require(\"./asf/AsfParser\");\nconst FlacParser_1 = require(\"./flac/FlacParser\");\nconst MP4Parser_1 = require(\"./mp4/MP4Parser\");\nconst MpegParser_1 = require(\"./mpeg/MpegParser\");\nconst musepack_1 = require(\"./musepack\");\nconst OggParser_1 = require(\"./ogg/OggParser\");\nconst WaveParser_1 = require(\"./wav/WaveParser\");\nconst WavPackParser_1 = require(\"./wavpack/WavPackParser\");\nconst DsfParser_1 = require(\"./dsf/DsfParser\");\nconst DsdiffParser_1 = require(\"./dsdiff/DsdiffParser\");\nconst MatroskaParser_1 = require(\"./matroska/MatroskaParser\");\nconst debug = (0, debug_1.default)('music-metadata:parser:factory');\nfunction parseHttpContentType(contentType) {\n  const type = ContentType.parse(contentType);\n  const mime = MimeType.parse(type.type);\n  return {\n    type: mime.type,\n    subtype: mime.subtype,\n    suffix: mime.suffix,\n    parameters: type.parameters\n  };\n}\nexports.parseHttpContentType = parseHttpContentType;\nasync function parse(tokenizer, parserId, opts = {}) {\n  // Parser found, execute parser\n  const parser = await ParserFactory.loadParser(parserId);\n  const metadata = new MetadataCollector_1.MetadataCollector(opts);\n  await parser.init(metadata, tokenizer, opts).parse();\n  return metadata.toCommonMetadata();\n}\nclass ParserFactory {\n  /**\n   * Parse metadata from tokenizer\n   * @param tokenizer - Tokenizer\n   * @param opts - Options\n   * @returns Native metadata\n   */\n  static async parseOnContentType(tokenizer, opts) {\n    const {\n      mimeType,\n      path,\n      url\n    } = await tokenizer.fileInfo;\n    // Resolve parser based on MIME-type or file extension\n    const parserId = ParserFactory.getParserIdForMimeType(mimeType) || ParserFactory.getParserIdForExtension(path) || ParserFactory.getParserIdForExtension(url);\n    if (!parserId) {\n      debug('No parser found for MIME-type / extension: ' + mimeType);\n    }\n    return this.parse(tokenizer, parserId, opts);\n  }\n  static async parse(tokenizer, parserId, opts) {\n    if (!parserId) {\n      // Parser could not be determined on MIME-type or extension\n      debug('Guess parser on content...');\n      const buf = Buffer.alloc(4100);\n      await tokenizer.peekBuffer(buf, {\n        mayBeLess: true\n      });\n      if (tokenizer.fileInfo.path) {\n        parserId = this.getParserIdForExtension(tokenizer.fileInfo.path);\n      }\n      if (!parserId) {\n        const guessedType = await FileType.fromBuffer(buf);\n        if (!guessedType) {\n          throw new Error('Failed to determine audio format');\n        }\n        debug(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`);\n        parserId = ParserFactory.getParserIdForMimeType(guessedType.mime);\n        if (!parserId) {\n          throw new Error('Guessed MIME-type not supported: ' + guessedType.mime);\n        }\n      }\n    }\n    // Parser found, execute parser\n    return parse(tokenizer, parserId, opts);\n  }\n  /**\n   * @param filePath - Path, filename or extension to audio file\n   * @return Parser sub-module name\n   */\n  static getParserIdForExtension(filePath) {\n    if (!filePath) return;\n    const extension = this.getExtension(filePath).toLocaleLowerCase() || filePath;\n    switch (extension) {\n      case '.mp2':\n      case '.mp3':\n      case '.m2a':\n      case '.aac':\n        // Assume it is ADTS-container\n        return 'mpeg';\n      case '.ape':\n        return 'apev2';\n      case '.mp4':\n      case '.m4a':\n      case '.m4b':\n      case '.m4pa':\n      case '.m4v':\n      case '.m4r':\n      case '.3gp':\n        return 'mp4';\n      case '.wma':\n      case '.wmv':\n      case '.asf':\n        return 'asf';\n      case '.flac':\n        return 'flac';\n      case '.ogg':\n      case '.ogv':\n      case '.oga':\n      case '.ogm':\n      case '.ogx':\n      case '.opus': // recommended filename extension for Ogg Opus\n      case '.spx':\n        // recommended filename extension for Ogg Speex\n        return 'ogg';\n      case '.aif':\n      case '.aiff':\n      case '.aifc':\n        return 'aiff';\n      case '.wav':\n      case '.bwf':\n        // Broadcast Wave Format\n        return 'riff';\n      case '.wv':\n      case '.wvp':\n        return 'wavpack';\n      case '.mpc':\n        return 'musepack';\n      case '.dsf':\n        return 'dsf';\n      case '.dff':\n        return 'dsdiff';\n      case '.mka':\n      case '.mkv':\n      case '.mk3d':\n      case '.mks':\n      case '.webm':\n        return 'matroska';\n    }\n  }\n  static async loadParser(moduleName) {\n    switch (moduleName) {\n      case 'aiff':\n        return new AiffParser_1.AIFFParser();\n      case 'adts':\n      case 'mpeg':\n        return new MpegParser_1.MpegParser();\n      case 'apev2':\n        return new APEv2Parser_1.APEv2Parser();\n      case 'asf':\n        return new AsfParser_1.AsfParser();\n      case 'dsf':\n        return new DsfParser_1.DsfParser();\n      case 'dsdiff':\n        return new DsdiffParser_1.DsdiffParser();\n      case 'flac':\n        return new FlacParser_1.FlacParser();\n      case 'mp4':\n        return new MP4Parser_1.MP4Parser();\n      case 'musepack':\n        return new musepack_1.default();\n      case 'ogg':\n        return new OggParser_1.OggParser();\n      case 'riff':\n        return new WaveParser_1.WaveParser();\n      case 'wavpack':\n        return new WavPackParser_1.WavPackParser();\n      case 'matroska':\n        return new MatroskaParser_1.MatroskaParser();\n      default:\n        throw new Error(`Unknown parser type: ${moduleName}`);\n    }\n  }\n  static getExtension(fname) {\n    const i = fname.lastIndexOf('.');\n    return i === -1 ? '' : fname.slice(i);\n  }\n  /**\n   * @param httpContentType - HTTP Content-Type, extension, path or filename\n   * @returns Parser sub-module name\n   */\n  static getParserIdForMimeType(httpContentType) {\n    let mime;\n    try {\n      mime = parseHttpContentType(httpContentType);\n    } catch (err) {\n      debug(`Invalid HTTP Content-Type header value: ${httpContentType}`);\n      return;\n    }\n    const subType = mime.subtype.indexOf('x-') === 0 ? mime.subtype.substring(2) : mime.subtype;\n    switch (mime.type) {\n      case 'audio':\n        switch (subType) {\n          case 'mp3': // Incorrect MIME-type, Chrome, in Web API File object\n          case 'mpeg':\n            return 'mpeg';\n          case 'aac':\n          case 'aacp':\n            return 'adts';\n          case 'flac':\n            return 'flac';\n          case 'ape':\n          case 'monkeys-audio':\n            return 'apev2';\n          case 'mp4':\n          case 'm4a':\n            return 'mp4';\n          case 'ogg': // RFC 7845\n          case 'opus': // RFC 6716\n          case 'speex':\n            // RFC 5574\n            return 'ogg';\n          case 'ms-wma':\n          case 'ms-wmv':\n          case 'ms-asf':\n            return 'asf';\n          case 'aiff':\n          case 'aif':\n          case 'aifc':\n            return 'aiff';\n          case 'vnd.wave':\n          case 'wav':\n          case 'wave':\n            return 'riff';\n          case 'wavpack':\n            return 'wavpack';\n          case 'musepack':\n            return 'musepack';\n          case 'matroska':\n          case 'webm':\n            return 'matroska';\n          case 'dsf':\n            return 'dsf';\n        }\n        break;\n      case 'video':\n        switch (subType) {\n          case 'ms-asf':\n          case 'ms-wmv':\n            return 'asf';\n          case 'm4v':\n          case 'mp4':\n            return 'mp4';\n          case 'ogg':\n            return 'ogg';\n          case 'matroska':\n          case 'webm':\n            return 'matroska';\n        }\n        break;\n      case 'application':\n        switch (subType) {\n          case 'vnd.ms-asf':\n            return 'asf';\n          case 'ogg':\n            return 'ogg';\n        }\n        break;\n    }\n  }\n}\nexports.ParserFactory = ParserFactory;","map":{"version":3,"names":["Object","defineProperty","exports","value","ParserFactory","parseHttpContentType","FileType","require","ContentType","MimeType","debug_1","MetadataCollector_1","AiffParser_1","APEv2Parser_1","AsfParser_1","FlacParser_1","MP4Parser_1","MpegParser_1","musepack_1","OggParser_1","WaveParser_1","WavPackParser_1","DsfParser_1","DsdiffParser_1","MatroskaParser_1","debug","default","contentType","type","parse","mime","subtype","suffix","parameters","tokenizer","parserId","opts","parser","loadParser","metadata","MetadataCollector","init","toCommonMetadata","parseOnContentType","mimeType","path","url","fileInfo","getParserIdForMimeType","getParserIdForExtension","buf","Buffer","alloc","peekBuffer","mayBeLess","guessedType","fromBuffer","Error","ext","filePath","extension","getExtension","toLocaleLowerCase","moduleName","AIFFParser","MpegParser","APEv2Parser","AsfParser","DsfParser","DsdiffParser","FlacParser","MP4Parser","OggParser","WaveParser","WavPackParser","MatroskaParser","fname","i","lastIndexOf","slice","httpContentType","err","subType","indexOf","substring"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/ParserFactory.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParserFactory = exports.parseHttpContentType = void 0;\nconst FileType = require(\"file-type/core\");\nconst ContentType = require(\"content-type\");\nconst MimeType = require(\"media-typer\");\nconst debug_1 = require(\"debug\");\nconst MetadataCollector_1 = require(\"./common/MetadataCollector\");\nconst AiffParser_1 = require(\"./aiff/AiffParser\");\nconst APEv2Parser_1 = require(\"./apev2/APEv2Parser\");\nconst AsfParser_1 = require(\"./asf/AsfParser\");\nconst FlacParser_1 = require(\"./flac/FlacParser\");\nconst MP4Parser_1 = require(\"./mp4/MP4Parser\");\nconst MpegParser_1 = require(\"./mpeg/MpegParser\");\nconst musepack_1 = require(\"./musepack\");\nconst OggParser_1 = require(\"./ogg/OggParser\");\nconst WaveParser_1 = require(\"./wav/WaveParser\");\nconst WavPackParser_1 = require(\"./wavpack/WavPackParser\");\nconst DsfParser_1 = require(\"./dsf/DsfParser\");\nconst DsdiffParser_1 = require(\"./dsdiff/DsdiffParser\");\nconst MatroskaParser_1 = require(\"./matroska/MatroskaParser\");\nconst debug = (0, debug_1.default)('music-metadata:parser:factory');\nfunction parseHttpContentType(contentType) {\n    const type = ContentType.parse(contentType);\n    const mime = MimeType.parse(type.type);\n    return {\n        type: mime.type,\n        subtype: mime.subtype,\n        suffix: mime.suffix,\n        parameters: type.parameters\n    };\n}\nexports.parseHttpContentType = parseHttpContentType;\nasync function parse(tokenizer, parserId, opts = {}) {\n    // Parser found, execute parser\n    const parser = await ParserFactory.loadParser(parserId);\n    const metadata = new MetadataCollector_1.MetadataCollector(opts);\n    await parser.init(metadata, tokenizer, opts).parse();\n    return metadata.toCommonMetadata();\n}\nclass ParserFactory {\n    /**\n     * Parse metadata from tokenizer\n     * @param tokenizer - Tokenizer\n     * @param opts - Options\n     * @returns Native metadata\n     */\n    static async parseOnContentType(tokenizer, opts) {\n        const { mimeType, path, url } = await tokenizer.fileInfo;\n        // Resolve parser based on MIME-type or file extension\n        const parserId = ParserFactory.getParserIdForMimeType(mimeType) || ParserFactory.getParserIdForExtension(path) || ParserFactory.getParserIdForExtension(url);\n        if (!parserId) {\n            debug('No parser found for MIME-type / extension: ' + mimeType);\n        }\n        return this.parse(tokenizer, parserId, opts);\n    }\n    static async parse(tokenizer, parserId, opts) {\n        if (!parserId) {\n            // Parser could not be determined on MIME-type or extension\n            debug('Guess parser on content...');\n            const buf = Buffer.alloc(4100);\n            await tokenizer.peekBuffer(buf, { mayBeLess: true });\n            if (tokenizer.fileInfo.path) {\n                parserId = this.getParserIdForExtension(tokenizer.fileInfo.path);\n            }\n            if (!parserId) {\n                const guessedType = await FileType.fromBuffer(buf);\n                if (!guessedType) {\n                    throw new Error('Failed to determine audio format');\n                }\n                debug(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`);\n                parserId = ParserFactory.getParserIdForMimeType(guessedType.mime);\n                if (!parserId) {\n                    throw new Error('Guessed MIME-type not supported: ' + guessedType.mime);\n                }\n            }\n        }\n        // Parser found, execute parser\n        return parse(tokenizer, parserId, opts);\n    }\n    /**\n     * @param filePath - Path, filename or extension to audio file\n     * @return Parser sub-module name\n     */\n    static getParserIdForExtension(filePath) {\n        if (!filePath)\n            return;\n        const extension = this.getExtension(filePath).toLocaleLowerCase() || filePath;\n        switch (extension) {\n            case '.mp2':\n            case '.mp3':\n            case '.m2a':\n            case '.aac': // Assume it is ADTS-container\n                return 'mpeg';\n            case '.ape':\n                return 'apev2';\n            case '.mp4':\n            case '.m4a':\n            case '.m4b':\n            case '.m4pa':\n            case '.m4v':\n            case '.m4r':\n            case '.3gp':\n                return 'mp4';\n            case '.wma':\n            case '.wmv':\n            case '.asf':\n                return 'asf';\n            case '.flac':\n                return 'flac';\n            case '.ogg':\n            case '.ogv':\n            case '.oga':\n            case '.ogm':\n            case '.ogx':\n            case '.opus': // recommended filename extension for Ogg Opus\n            case '.spx': // recommended filename extension for Ogg Speex\n                return 'ogg';\n            case '.aif':\n            case '.aiff':\n            case '.aifc':\n                return 'aiff';\n            case '.wav':\n            case '.bwf': // Broadcast Wave Format\n                return 'riff';\n            case '.wv':\n            case '.wvp':\n                return 'wavpack';\n            case '.mpc':\n                return 'musepack';\n            case '.dsf':\n                return 'dsf';\n            case '.dff':\n                return 'dsdiff';\n            case '.mka':\n            case '.mkv':\n            case '.mk3d':\n            case '.mks':\n            case '.webm':\n                return 'matroska';\n        }\n    }\n    static async loadParser(moduleName) {\n        switch (moduleName) {\n            case 'aiff': return new AiffParser_1.AIFFParser();\n            case 'adts':\n            case 'mpeg':\n                return new MpegParser_1.MpegParser();\n            case 'apev2': return new APEv2Parser_1.APEv2Parser();\n            case 'asf': return new AsfParser_1.AsfParser();\n            case 'dsf': return new DsfParser_1.DsfParser();\n            case 'dsdiff': return new DsdiffParser_1.DsdiffParser();\n            case 'flac': return new FlacParser_1.FlacParser();\n            case 'mp4': return new MP4Parser_1.MP4Parser();\n            case 'musepack': return new musepack_1.default();\n            case 'ogg': return new OggParser_1.OggParser();\n            case 'riff': return new WaveParser_1.WaveParser();\n            case 'wavpack': return new WavPackParser_1.WavPackParser();\n            case 'matroska': return new MatroskaParser_1.MatroskaParser();\n            default:\n                throw new Error(`Unknown parser type: ${moduleName}`);\n        }\n    }\n    static getExtension(fname) {\n        const i = fname.lastIndexOf('.');\n        return i === -1 ? '' : fname.slice(i);\n    }\n    /**\n     * @param httpContentType - HTTP Content-Type, extension, path or filename\n     * @returns Parser sub-module name\n     */\n    static getParserIdForMimeType(httpContentType) {\n        let mime;\n        try {\n            mime = parseHttpContentType(httpContentType);\n        }\n        catch (err) {\n            debug(`Invalid HTTP Content-Type header value: ${httpContentType}`);\n            return;\n        }\n        const subType = mime.subtype.indexOf('x-') === 0 ? mime.subtype.substring(2) : mime.subtype;\n        switch (mime.type) {\n            case 'audio':\n                switch (subType) {\n                    case 'mp3': // Incorrect MIME-type, Chrome, in Web API File object\n                    case 'mpeg':\n                        return 'mpeg';\n                    case 'aac':\n                    case 'aacp':\n                        return 'adts';\n                    case 'flac':\n                        return 'flac';\n                    case 'ape':\n                    case 'monkeys-audio':\n                        return 'apev2';\n                    case 'mp4':\n                    case 'm4a':\n                        return 'mp4';\n                    case 'ogg': // RFC 7845\n                    case 'opus': // RFC 6716\n                    case 'speex': // RFC 5574\n                        return 'ogg';\n                    case 'ms-wma':\n                    case 'ms-wmv':\n                    case 'ms-asf':\n                        return 'asf';\n                    case 'aiff':\n                    case 'aif':\n                    case 'aifc':\n                        return 'aiff';\n                    case 'vnd.wave':\n                    case 'wav':\n                    case 'wave':\n                        return 'riff';\n                    case 'wavpack':\n                        return 'wavpack';\n                    case 'musepack':\n                        return 'musepack';\n                    case 'matroska':\n                    case 'webm':\n                        return 'matroska';\n                    case 'dsf':\n                        return 'dsf';\n                }\n                break;\n            case 'video':\n                switch (subType) {\n                    case 'ms-asf':\n                    case 'ms-wmv':\n                        return 'asf';\n                    case 'm4v':\n                    case 'mp4':\n                        return 'mp4';\n                    case 'ogg':\n                        return 'ogg';\n                    case 'matroska':\n                    case 'webm':\n                        return 'matroska';\n                }\n                break;\n            case 'application':\n                switch (subType) {\n                    case 'vnd.ms-asf':\n                        return 'asf';\n                    case 'ogg':\n                        return 'ogg';\n                }\n                break;\n        }\n    }\n}\nexports.ParserFactory = ParserFactory;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}