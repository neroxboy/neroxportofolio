{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AIFFParser = void 0;\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst AiffToken = require(\"./AiffToken\");\nconst iff = require(\"../iff\");\nconst debug = (0, debug_1.default)('music-metadata:parser:aiff');\nconst compressionTypes = {\n  NONE: 'not compressed\tPCM\tApple Computer',\n  sowt: 'PCM (byte swapped)',\n  fl32: '32-bit floating point IEEE 32-bit float',\n  fl64: '64-bit floating point IEEE 64-bit float\tApple Computer',\n  alaw: 'ALaw 2:1\t8-bit ITU-T G.711 A-law',\n  ulaw: 'µLaw 2:1\t8-bit ITU-T G.711 µ-law\tApple Computer',\n  ULAW: 'CCITT G.711 u-law 8-bit ITU-T G.711 µ-law',\n  ALAW: 'CCITT G.711 A-law 8-bit ITU-T G.711 A-law',\n  FL32: 'Float 32\tIEEE 32-bit float '\n};\n/**\n * AIFF - Audio Interchange File Format\n *\n * Ref:\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf\n */\nclass AIFFParser extends BasicParser_1.BasicParser {\n  async parse() {\n    const header = await this.tokenizer.readToken(iff.Header);\n    if (header.chunkID !== 'FORM') throw new Error('Invalid Chunk-ID, expected \\'FORM\\''); // Not AIFF format\n    const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n    switch (type) {\n      case 'AIFF':\n        this.metadata.setFormat('container', type);\n        this.isCompressed = false;\n        break;\n      case 'AIFC':\n        this.metadata.setFormat('container', 'AIFF-C');\n        this.isCompressed = true;\n        break;\n      default:\n        throw Error('Unsupported AIFF type: ' + type);\n    }\n    this.metadata.setFormat('lossless', !this.isCompressed);\n    try {\n      while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len) {\n        debug('Reading AIFF chunk at offset=' + this.tokenizer.position);\n        const chunkHeader = await this.tokenizer.readToken(iff.Header);\n        const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);\n        const bytesRead = await this.readData(chunkHeader);\n        await this.tokenizer.ignore(nextChunk - bytesRead);\n      }\n    } catch (err) {\n      if (err instanceof strtok3.EndOfStreamError) {\n        debug(`End-of-stream`);\n      } else {\n        throw err;\n      }\n    }\n  }\n  async readData(header) {\n    var _a;\n    switch (header.chunkID) {\n      case 'COMM':\n        // The Common Chunk\n        const common = await this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));\n        this.metadata.setFormat('bitsPerSample', common.sampleSize);\n        this.metadata.setFormat('sampleRate', common.sampleRate);\n        this.metadata.setFormat('numberOfChannels', common.numChannels);\n        this.metadata.setFormat('numberOfSamples', common.numSampleFrames);\n        this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);\n        this.metadata.setFormat('codec', (_a = common.compressionName) !== null && _a !== void 0 ? _a : compressionTypes[common.compressionType]);\n        return header.chunkSize;\n      case 'ID3 ':\n        // ID3-meta-data\n        const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\n        const rst = strtok3.fromBuffer(id3_data);\n        await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n        return header.chunkSize;\n      case 'SSND':\n        // Sound Data Chunk\n        if (this.metadata.format.duration) {\n          this.metadata.setFormat('bitrate', 8 * header.chunkSize / this.metadata.format.duration);\n        }\n        return 0;\n      case 'NAME': // Sample name chunk\n      case 'AUTH': // Author chunk\n      case '(c) ': // Copyright chunk\n      case 'ANNO':\n        // Annotation chunk\n        return this.readTextChunk(header);\n      default:\n        debug(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`);\n        return 0;\n    }\n  }\n  async readTextChunk(header) {\n    const value = await this.tokenizer.readToken(new Token.StringType(header.chunkSize, 'ascii'));\n    value.split('\\0').map(v => v.trim()).filter(v => v && v.length > 0).forEach(v => {\n      this.metadata.addTag('AIFF', header.chunkID, v.trim());\n    });\n    return header.chunkSize;\n  }\n}\nexports.AIFFParser = AIFFParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","AIFFParser","Token","require","debug_1","strtok3","ID3v2Parser_1","FourCC_1","BasicParser_1","AiffToken","iff","debug","default","compressionTypes","NONE","sowt","fl32","fl64","alaw","ulaw","ULAW","ALAW","FL32","BasicParser","parse","header","tokenizer","readToken","Header","chunkID","Error","type","FourCcToken","metadata","setFormat","isCompressed","fileInfo","size","position","len","chunkHeader","nextChunk","Math","round","chunkSize","bytesRead","readData","ignore","err","EndOfStreamError","_a","common","Common","sampleSize","sampleRate","numChannels","numSampleFrames","compressionName","compressionType","id3_data","Uint8ArrayType","rst","fromBuffer","ID3v2Parser","options","format","duration","readTextChunk","StringType","split","map","v","trim","filter","length","forEach","addTag"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/aiff/AiffParser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AIFFParser = void 0;\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst AiffToken = require(\"./AiffToken\");\nconst iff = require(\"../iff\");\nconst debug = (0, debug_1.default)('music-metadata:parser:aiff');\nconst compressionTypes = {\n    NONE: 'not compressed\tPCM\tApple Computer',\n    sowt: 'PCM (byte swapped)',\n    fl32: '32-bit floating point IEEE 32-bit float',\n    fl64: '64-bit floating point IEEE 64-bit float\tApple Computer',\n    alaw: 'ALaw 2:1\t8-bit ITU-T G.711 A-law',\n    ulaw: 'µLaw 2:1\t8-bit ITU-T G.711 µ-law\tApple Computer',\n    ULAW: 'CCITT G.711 u-law 8-bit ITU-T G.711 µ-law',\n    ALAW: 'CCITT G.711 A-law 8-bit ITU-T G.711 A-law',\n    FL32: 'Float 32\tIEEE 32-bit float '\n};\n/**\n * AIFF - Audio Interchange File Format\n *\n * Ref:\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf\n */\nclass AIFFParser extends BasicParser_1.BasicParser {\n    async parse() {\n        const header = await this.tokenizer.readToken(iff.Header);\n        if (header.chunkID !== 'FORM')\n            throw new Error('Invalid Chunk-ID, expected \\'FORM\\''); // Not AIFF format\n        const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        switch (type) {\n            case 'AIFF':\n                this.metadata.setFormat('container', type);\n                this.isCompressed = false;\n                break;\n            case 'AIFC':\n                this.metadata.setFormat('container', 'AIFF-C');\n                this.isCompressed = true;\n                break;\n            default:\n                throw Error('Unsupported AIFF type: ' + type);\n        }\n        this.metadata.setFormat('lossless', !this.isCompressed);\n        try {\n            while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len) {\n                debug('Reading AIFF chunk at offset=' + this.tokenizer.position);\n                const chunkHeader = await this.tokenizer.readToken(iff.Header);\n                const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);\n                const bytesRead = await this.readData(chunkHeader);\n                await this.tokenizer.ignore(nextChunk - bytesRead);\n            }\n        }\n        catch (err) {\n            if (err instanceof strtok3.EndOfStreamError) {\n                debug(`End-of-stream`);\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    async readData(header) {\n        var _a;\n        switch (header.chunkID) {\n            case 'COMM': // The Common Chunk\n                const common = await this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));\n                this.metadata.setFormat('bitsPerSample', common.sampleSize);\n                this.metadata.setFormat('sampleRate', common.sampleRate);\n                this.metadata.setFormat('numberOfChannels', common.numChannels);\n                this.metadata.setFormat('numberOfSamples', common.numSampleFrames);\n                this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);\n                this.metadata.setFormat('codec', (_a = common.compressionName) !== null && _a !== void 0 ? _a : compressionTypes[common.compressionType]);\n                return header.chunkSize;\n            case 'ID3 ': // ID3-meta-data\n                const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\n                const rst = strtok3.fromBuffer(id3_data);\n                await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n                return header.chunkSize;\n            case 'SSND': // Sound Data Chunk\n                if (this.metadata.format.duration) {\n                    this.metadata.setFormat('bitrate', 8 * header.chunkSize / this.metadata.format.duration);\n                }\n                return 0;\n            case 'NAME': // Sample name chunk\n            case 'AUTH': // Author chunk\n            case '(c) ': // Copyright chunk\n            case 'ANNO': // Annotation chunk\n                return this.readTextChunk(header);\n            default:\n                debug(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`);\n                return 0;\n        }\n    }\n    async readTextChunk(header) {\n        const value = await this.tokenizer.readToken(new Token.StringType(header.chunkSize, 'ascii'));\n        value.split('\\0').map(v => v.trim()).filter(v => v && v.length > 0).forEach(v => {\n            this.metadata.addTag('AIFF', header.chunkID, v.trim());\n        });\n        return header.chunkSize;\n    }\n}\nexports.AIFFParser = AIFFParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}