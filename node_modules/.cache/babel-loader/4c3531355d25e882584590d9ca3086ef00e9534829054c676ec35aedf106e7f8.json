{"ast":null,"code":"/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { frameStore, headerStore } from \"../../globals.js\";\nimport { length, pageSequenceNumber, data, codec, codecFrames, segments, subarray, readRawData, incrementRawData, mapFrameStats, logWarning, parseFrame, parseOggPage, getHeader, enable, checkFrameFooterCrc16, getHeaderFromUint8Array } from \"../../constants.js\";\nimport Parser from \"../Parser.js\";\nimport FLACFrame from \"./FLACFrame.js\";\nimport FLACHeader from \"./FLACHeader.js\";\nconst MIN_FLAC_FRAME_SIZE = 2;\nconst MAX_FLAC_FRAME_SIZE = 512 * 1024;\nexport default class FLACParser extends Parser {\n  constructor(codecParser, headerCache, onCodec) {\n    super(codecParser, headerCache);\n    this.Frame = FLACFrame;\n    this.Header = FLACHeader;\n    onCodec(this[codec]);\n  }\n  get [codec]() {\n    return \"flac\";\n  }\n  *_getNextFrameSyncOffset(offset) {\n    const data = yield* this._codecParser[readRawData](2, 0);\n    const dataLength = data[length] - 2;\n    while (offset < dataLength) {\n      // * `11111111|111110..`: Frame sync\n      // * `........|......0.`: Reserved 0 - mandatory, 1 - reserved\n      const firstByte = data[offset];\n      if (firstByte === 0xff) {\n        const secondByte = data[offset + 1];\n        if (secondByte === 0xf8 || secondByte === 0xf9) break;\n        if (secondByte !== 0xff) offset++; // might as well check for the next sync byte\n      }\n      offset++;\n    }\n    return offset;\n  }\n  *[parseFrame]() {\n    // find the first valid frame header\n    do {\n      const header = yield* FLACHeader[getHeader](this._codecParser, this._headerCache, 0);\n      if (header) {\n        // found a valid frame header\n        // find the next valid frame header\n        let nextHeaderOffset = headerStore.get(header)[length] + MIN_FLAC_FRAME_SIZE;\n        while (nextHeaderOffset <= MAX_FLAC_FRAME_SIZE) {\n          if (this._codecParser._flushing || (yield* FLACHeader[getHeader](this._codecParser, this._headerCache, nextHeaderOffset))) {\n            // found a valid next frame header\n            let frameData = yield* this._codecParser[readRawData](nextHeaderOffset);\n            if (!this._codecParser._flushing) frameData = frameData[subarray](0, nextHeaderOffset);\n\n            // check that this is actually the next header by validating the frame footer crc16\n            if (FLACFrame[checkFrameFooterCrc16](frameData)) {\n              // both frame headers, and frame footer crc16 are valid, we are synced (odds are pretty low of a false positive)\n              const frame = new FLACFrame(frameData, header);\n              this._headerCache[enable](); // start caching when synced\n              this._codecParser[incrementRawData](nextHeaderOffset); // increment to the next frame\n              this._codecParser[mapFrameStats](frame);\n              return frame;\n            }\n          }\n          nextHeaderOffset = yield* this._getNextFrameSyncOffset(nextHeaderOffset + 1);\n        }\n        this._codecParser[logWarning](`Unable to sync FLAC frame after searching ${nextHeaderOffset} bytes.`);\n        this._codecParser[incrementRawData](nextHeaderOffset);\n      } else {\n        // not synced, increment data to continue syncing\n        this._codecParser[incrementRawData](yield* this._getNextFrameSyncOffset(1));\n      }\n    } while (true);\n  }\n  [parseOggPage](oggPage) {\n    if (oggPage[pageSequenceNumber] === 0) {\n      // Identification header\n\n      this._headerCache[enable]();\n      this._streamInfo = oggPage[data][subarray](13);\n    } else if (oggPage[pageSequenceNumber] === 1) {\n      // Vorbis comments\n    } else {\n      oggPage[codecFrames] = frameStore.get(oggPage)[segments].map(segment => {\n        const header = FLACHeader[getHeaderFromUint8Array](segment, this._headerCache);\n        if (header) {\n          return new FLACFrame(segment, header, this._streamInfo);\n        } else {\n          this._codecParser[logWarning](\"Failed to parse Ogg FLAC frame\", \"Skipping invalid FLAC frame\");\n        }\n      }).filter(frame => !!frame);\n    }\n    return oggPage;\n  }\n}","map":{"version":3,"names":["frameStore","headerStore","length","pageSequenceNumber","data","codec","codecFrames","segments","subarray","readRawData","incrementRawData","mapFrameStats","logWarning","parseFrame","parseOggPage","getHeader","enable","checkFrameFooterCrc16","getHeaderFromUint8Array","Parser","FLACFrame","FLACHeader","MIN_FLAC_FRAME_SIZE","MAX_FLAC_FRAME_SIZE","FLACParser","constructor","codecParser","headerCache","onCodec","Frame","Header","_getNextFrameSyncOffset","offset","_codecParser","dataLength","firstByte","secondByte","header","_headerCache","nextHeaderOffset","get","_flushing","frameData","frame","oggPage","_streamInfo","map","segment","filter"],"sources":["C:/Users/vanitas/node_modules/codec-parser/src/codecs/flac/FLACParser.js"],"sourcesContent":["/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { frameStore, headerStore } from \"../../globals.js\";\nimport {\n  length,\n  pageSequenceNumber,\n  data,\n  codec,\n  codecFrames,\n  segments,\n  subarray,\n  readRawData,\n  incrementRawData,\n  mapFrameStats,\n  logWarning,\n  parseFrame,\n  parseOggPage,\n  getHeader,\n  enable,\n  checkFrameFooterCrc16,\n  getHeaderFromUint8Array,\n} from \"../../constants.js\";\nimport Parser from \"../Parser.js\";\nimport FLACFrame from \"./FLACFrame.js\";\nimport FLACHeader from \"./FLACHeader.js\";\n\nconst MIN_FLAC_FRAME_SIZE = 2;\nconst MAX_FLAC_FRAME_SIZE = 512 * 1024;\n\nexport default class FLACParser extends Parser {\n  constructor(codecParser, headerCache, onCodec) {\n    super(codecParser, headerCache);\n    this.Frame = FLACFrame;\n    this.Header = FLACHeader;\n\n    onCodec(this[codec]);\n  }\n\n  get [codec]() {\n    return \"flac\";\n  }\n\n  *_getNextFrameSyncOffset(offset) {\n    const data = yield* this._codecParser[readRawData](2, 0);\n    const dataLength = data[length] - 2;\n\n    while (offset < dataLength) {\n      // * `11111111|111110..`: Frame sync\n      // * `........|......0.`: Reserved 0 - mandatory, 1 - reserved\n      const firstByte = data[offset];\n      if (firstByte === 0xff) {\n        const secondByte = data[offset + 1];\n        if (secondByte === 0xf8 || secondByte === 0xf9) break;\n        if (secondByte !== 0xff) offset++; // might as well check for the next sync byte\n      }\n      offset++;\n    }\n\n    return offset;\n  }\n\n  *[parseFrame]() {\n    // find the first valid frame header\n    do {\n      const header = yield* FLACHeader[getHeader](\n        this._codecParser,\n        this._headerCache,\n        0,\n      );\n\n      if (header) {\n        // found a valid frame header\n        // find the next valid frame header\n        let nextHeaderOffset =\n          headerStore.get(header)[length] + MIN_FLAC_FRAME_SIZE;\n\n        while (nextHeaderOffset <= MAX_FLAC_FRAME_SIZE) {\n          if (\n            this._codecParser._flushing ||\n            (yield* FLACHeader[getHeader](\n              this._codecParser,\n              this._headerCache,\n              nextHeaderOffset,\n            ))\n          ) {\n            // found a valid next frame header\n            let frameData = yield* this._codecParser[readRawData](\n              nextHeaderOffset,\n            );\n\n            if (!this._codecParser._flushing)\n              frameData = frameData[subarray](0, nextHeaderOffset);\n\n            // check that this is actually the next header by validating the frame footer crc16\n            if (FLACFrame[checkFrameFooterCrc16](frameData)) {\n              // both frame headers, and frame footer crc16 are valid, we are synced (odds are pretty low of a false positive)\n              const frame = new FLACFrame(frameData, header);\n\n              this._headerCache[enable](); // start caching when synced\n              this._codecParser[incrementRawData](nextHeaderOffset); // increment to the next frame\n              this._codecParser[mapFrameStats](frame);\n\n              return frame;\n            }\n          }\n\n          nextHeaderOffset = yield* this._getNextFrameSyncOffset(\n            nextHeaderOffset + 1,\n          );\n        }\n\n        this._codecParser[logWarning](\n          `Unable to sync FLAC frame after searching ${nextHeaderOffset} bytes.`,\n        );\n        this._codecParser[incrementRawData](nextHeaderOffset);\n      } else {\n        // not synced, increment data to continue syncing\n        this._codecParser[incrementRawData](\n          yield* this._getNextFrameSyncOffset(1),\n        );\n      }\n    } while (true);\n  }\n\n  [parseOggPage](oggPage) {\n    if (oggPage[pageSequenceNumber] === 0) {\n      // Identification header\n\n      this._headerCache[enable]();\n      this._streamInfo = oggPage[data][subarray](13);\n    } else if (oggPage[pageSequenceNumber] === 1) {\n      // Vorbis comments\n    } else {\n      oggPage[codecFrames] = frameStore\n        .get(oggPage)\n        [segments].map((segment) => {\n          const header = FLACHeader[getHeaderFromUint8Array](\n            segment,\n            this._headerCache,\n          );\n\n          if (header) {\n            return new FLACFrame(segment, header, this._streamInfo);\n          } else {\n            this._codecParser[logWarning](\n              \"Failed to parse Ogg FLAC frame\",\n              \"Skipping invalid FLAC frame\",\n            );\n          }\n        })\n        .filter((frame) => !!frame);\n    }\n\n    return oggPage;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}