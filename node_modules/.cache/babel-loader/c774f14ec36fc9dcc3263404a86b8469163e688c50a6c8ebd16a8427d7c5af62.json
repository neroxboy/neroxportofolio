{"ast":null,"code":"// vim: ts=4:sw=4\n\n'use strict';\n\nconst nodeCrypto = require('crypto');\nconst assert = require('assert');\nfunction assertBuffer(value) {\n  if (!(value instanceof Buffer)) {\n    throw TypeError(`Expected Buffer instead of: ${value.constructor.name}`);\n  }\n  return value;\n}\nfunction encrypt(key, data, iv) {\n  assertBuffer(key);\n  assertBuffer(data);\n  assertBuffer(iv);\n  const cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);\n  return Buffer.concat([cipher.update(data), cipher.final()]);\n}\nfunction decrypt(key, data, iv) {\n  assertBuffer(key);\n  assertBuffer(data);\n  assertBuffer(iv);\n  const decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);\n  return Buffer.concat([decipher.update(data), decipher.final()]);\n}\nfunction calculateMAC(key, data) {\n  assertBuffer(key);\n  assertBuffer(data);\n  const hmac = nodeCrypto.createHmac('sha256', key);\n  hmac.update(data);\n  return Buffer.from(hmac.digest());\n}\nfunction hash(data) {\n  assertBuffer(data);\n  const sha512 = nodeCrypto.createHash('sha512');\n  sha512.update(data);\n  return sha512.digest();\n}\n\n// Salts always end up being 32 bytes\nfunction deriveSecrets(input, salt, info, chunks) {\n  // Specific implementation of RFC 5869 that only returns the first 3 32-byte chunks\n  assertBuffer(input);\n  assertBuffer(salt);\n  assertBuffer(info);\n  if (salt.byteLength != 32) {\n    throw new Error(\"Got salt of incorrect length\");\n  }\n  chunks = chunks || 3;\n  assert(chunks >= 1 && chunks <= 3);\n  const PRK = calculateMAC(salt, input);\n  const infoArray = new Uint8Array(info.byteLength + 1 + 32);\n  infoArray.set(info, 32);\n  infoArray[infoArray.length - 1] = 1;\n  const signed = [calculateMAC(PRK, Buffer.from(infoArray.slice(32)))];\n  if (chunks > 1) {\n    infoArray.set(signed[signed.length - 1]);\n    infoArray[infoArray.length - 1] = 2;\n    signed.push(calculateMAC(PRK, Buffer.from(infoArray)));\n  }\n  if (chunks > 2) {\n    infoArray.set(signed[signed.length - 1]);\n    infoArray[infoArray.length - 1] = 3;\n    signed.push(calculateMAC(PRK, Buffer.from(infoArray)));\n  }\n  return signed;\n}\nfunction verifyMAC(data, key, mac, length) {\n  const calculatedMac = calculateMAC(key, data).slice(0, length);\n  if (mac.length !== length || calculatedMac.length !== length) {\n    throw new Error(\"Bad MAC length\");\n  }\n  if (!mac.equals(calculatedMac)) {\n    throw new Error(\"Bad MAC\");\n  }\n}\nmodule.exports = {\n  deriveSecrets,\n  decrypt,\n  encrypt,\n  hash,\n  calculateMAC,\n  verifyMAC\n};","map":{"version":3,"names":["nodeCrypto","require","assert","assertBuffer","value","Buffer","TypeError","constructor","name","encrypt","key","data","iv","cipher","createCipheriv","concat","update","final","decrypt","decipher","createDecipheriv","calculateMAC","hmac","createHmac","from","digest","hash","sha512","createHash","deriveSecrets","input","salt","info","chunks","byteLength","Error","PRK","infoArray","Uint8Array","set","length","signed","slice","push","verifyMAC","mac","calculatedMac","equals","module","exports"],"sources":["C:/Users/vanitas/node_modules/libsignal/src/crypto.js"],"sourcesContent":["// vim: ts=4:sw=4\n\n'use strict';\n\nconst nodeCrypto = require('crypto');\nconst assert = require('assert');\n\n\nfunction assertBuffer(value) {\n    if (!(value instanceof Buffer)) {\n        throw TypeError(`Expected Buffer instead of: ${value.constructor.name}`);\n    }\n    return value;\n}\n\n\nfunction encrypt(key, data, iv) {\n    assertBuffer(key);\n    assertBuffer(data);\n    assertBuffer(iv);\n    const cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);\n    return Buffer.concat([cipher.update(data), cipher.final()]);\n}\n\n\nfunction decrypt(key, data, iv) {\n    assertBuffer(key);\n    assertBuffer(data);\n    assertBuffer(iv);\n    const decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);\n    return Buffer.concat([decipher.update(data), decipher.final()]);\n}\n\n\nfunction calculateMAC(key, data) {\n    assertBuffer(key);\n    assertBuffer(data);\n    const hmac = nodeCrypto.createHmac('sha256', key);\n    hmac.update(data);\n    return Buffer.from(hmac.digest());\n}\n\n\nfunction hash(data) {\n    assertBuffer(data);\n    const sha512 = nodeCrypto.createHash('sha512');\n    sha512.update(data);\n    return sha512.digest();\n}\n\n\n// Salts always end up being 32 bytes\nfunction deriveSecrets(input, salt, info, chunks) {\n    // Specific implementation of RFC 5869 that only returns the first 3 32-byte chunks\n    assertBuffer(input);\n    assertBuffer(salt);\n    assertBuffer(info);\n    if (salt.byteLength != 32) {\n        throw new Error(\"Got salt of incorrect length\");\n    }\n    chunks = chunks || 3;\n    assert(chunks >= 1 && chunks <= 3);\n    const PRK = calculateMAC(salt, input);\n    const infoArray = new Uint8Array(info.byteLength + 1 + 32);\n    infoArray.set(info, 32);\n    infoArray[infoArray.length - 1] = 1;\n    const signed = [calculateMAC(PRK, Buffer.from(infoArray.slice(32)))];\n    if (chunks > 1) {\n        infoArray.set(signed[signed.length - 1]);\n        infoArray[infoArray.length - 1] = 2;\n        signed.push(calculateMAC(PRK, Buffer.from(infoArray)));\n    }\n    if (chunks > 2) {\n        infoArray.set(signed[signed.length - 1]);\n        infoArray[infoArray.length - 1] = 3;\n        signed.push(calculateMAC(PRK, Buffer.from(infoArray)));\n    }\n    return signed;\n}\n\nfunction verifyMAC(data, key, mac, length) {\n    const calculatedMac = calculateMAC(key, data).slice(0, length);\n    if (mac.length !== length || calculatedMac.length !== length) {\n        throw new Error(\"Bad MAC length\");\n    }\n    if (!mac.equals(calculatedMac)) {\n        throw new Error(\"Bad MAC\");\n    }\n}\n\nmodule.exports = {\n    deriveSecrets,\n    decrypt,\n    encrypt,\n    hash,\n    calculateMAC,\n    verifyMAC\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}