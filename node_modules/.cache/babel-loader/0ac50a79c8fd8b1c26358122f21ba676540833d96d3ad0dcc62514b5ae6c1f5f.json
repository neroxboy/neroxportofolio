{"ast":null,"code":"/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { reserved, bad, free, none, sixteenBitCRC, rate44100, rate48000, rate32000, rate22050, rate24000, rate16000, rate11025, rate12000, rate8000, monophonic, stereo, bitDepth, channelMode, sampleRate, bitrate, channels, isOriginal, isPrivate, layer, length, mpegVersion, frameLength, protection, emphasis, framePadding, isCopyrighted, modeExtension, description, samples, subarray, readRawData, incrementRawData, getHeader, setHeader } from \"../../constants.js\";\nimport { bytesToString } from \"../../utilities.js\";\nimport ID3v2 from \"../../metadata/ID3v2.js\";\nimport CodecHeader from \"../CodecHeader.js\";\n\n// http://www.mp3-tech.org/programmer/frame_header.html\n\nconst bitrateMatrix = {\n  // bits | V1,L1 | V1,L2 | V1,L3 | V2,L1 | V2,L2 & L3\n  0b00000000: [free, free, free, free, free],\n  0b00010000: [32, 32, 32, 32, 8],\n  // 0b00100000: [64,   48,  40,  48,  16,],\n  // 0b00110000: [96,   56,  48,  56,  24,],\n  // 0b01000000: [128,  64,  56,  64,  32,],\n  // 0b01010000: [160,  80,  64,  80,  40,],\n  // 0b01100000: [192,  96,  80,  96,  48,],\n  // 0b01110000: [224, 112,  96, 112,  56,],\n  // 0b10000000: [256, 128, 112, 128,  64,],\n  // 0b10010000: [288, 160, 128, 144,  80,],\n  // 0b10100000: [320, 192, 160, 160,  96,],\n  // 0b10110000: [352, 224, 192, 176, 112,],\n  // 0b11000000: [384, 256, 224, 192, 128,],\n  // 0b11010000: [416, 320, 256, 224, 144,],\n  // 0b11100000: [448, 384, 320, 256, 160,],\n  0b11110000: [bad, bad, bad, bad, bad]\n};\nconst calcBitrate = (idx, interval, intervalOffset) => 8 * ((idx + intervalOffset) % interval + interval) * (1 << (idx + intervalOffset) / interval) - 8 * interval * (interval / 8 | 0);\n\n// generate bitrate matrix\nfor (let i = 2; i < 15; i++) bitrateMatrix[i << 4] = [i * 32,\n//                V1,L1\ncalcBitrate(i, 4, 0),\n//  V1,L2\ncalcBitrate(i, 4, -1),\n// V1,L3\ncalcBitrate(i, 8, 4),\n//  V2,L1\ncalcBitrate(i, 8, 0) //  V2,L2 & L3\n];\nconst v1Layer1 = 0;\nconst v1Layer2 = 1;\nconst v1Layer3 = 2;\nconst v2Layer1 = 3;\nconst v2Layer23 = 4;\nconst bands = \"bands \";\nconst to31 = \" to 31\";\nconst layer12ModeExtensions = {\n  0b00000000: bands + 4 + to31,\n  0b00010000: bands + 8 + to31,\n  0b00100000: bands + 12 + to31,\n  0b00110000: bands + 16 + to31\n};\nconst bitrateIndex = \"bitrateIndex\";\nconst v2 = \"v2\";\nconst v1 = \"v1\";\nconst intensityStereo = \"Intensity stereo \";\nconst msStereo = \", MS stereo \";\nconst on = \"on\";\nconst off = \"off\";\nconst layer3ModeExtensions = {\n  0b00000000: intensityStereo + off + msStereo + off,\n  0b00010000: intensityStereo + on + msStereo + off,\n  0b00100000: intensityStereo + off + msStereo + on,\n  0b00110000: intensityStereo + on + msStereo + on\n};\nconst layersValues = {\n  0b00000000: {\n    [description]: reserved\n  },\n  0b00000010: {\n    [description]: \"Layer III\",\n    [framePadding]: 1,\n    [modeExtension]: layer3ModeExtensions,\n    [v1]: {\n      [bitrateIndex]: v1Layer3,\n      [samples]: 1152\n    },\n    [v2]: {\n      [bitrateIndex]: v2Layer23,\n      [samples]: 576\n    }\n  },\n  0b00000100: {\n    [description]: \"Layer II\",\n    [framePadding]: 1,\n    [modeExtension]: layer12ModeExtensions,\n    [samples]: 1152,\n    [v1]: {\n      [bitrateIndex]: v1Layer2\n    },\n    [v2]: {\n      [bitrateIndex]: v2Layer23\n    }\n  },\n  0b00000110: {\n    [description]: \"Layer I\",\n    [framePadding]: 4,\n    [modeExtension]: layer12ModeExtensions,\n    [samples]: 384,\n    [v1]: {\n      [bitrateIndex]: v1Layer1\n    },\n    [v2]: {\n      [bitrateIndex]: v2Layer1\n    }\n  }\n};\nconst mpegVersionDescription = \"MPEG Version \";\nconst isoIec = \"ISO/IEC \";\nconst mpegVersions = {\n  0b00000000: {\n    [description]: `${mpegVersionDescription}2.5 (later extension of MPEG 2)`,\n    [layer]: v2,\n    [sampleRate]: {\n      0b00000000: rate11025,\n      0b00000100: rate12000,\n      0b00001000: rate8000,\n      0b00001100: reserved\n    }\n  },\n  0b00001000: {\n    [description]: reserved\n  },\n  0b00010000: {\n    [description]: `${mpegVersionDescription}2 (${isoIec}13818-3)`,\n    [layer]: v2,\n    [sampleRate]: {\n      0b00000000: rate22050,\n      0b00000100: rate24000,\n      0b00001000: rate16000,\n      0b00001100: reserved\n    }\n  },\n  0b00011000: {\n    [description]: `${mpegVersionDescription}1 (${isoIec}11172-3)`,\n    [layer]: v1,\n    [sampleRate]: {\n      0b00000000: rate44100,\n      0b00000100: rate48000,\n      0b00001000: rate32000,\n      0b00001100: reserved\n    }\n  },\n  length\n};\nconst protectionValues = {\n  0b00000000: sixteenBitCRC,\n  0b00000001: none\n};\nconst emphasisValues = {\n  0b00000000: none,\n  0b00000001: \"50/15 ms\",\n  0b00000010: reserved,\n  0b00000011: \"CCIT J.17\"\n};\nconst channelModes = {\n  0b00000000: {\n    [channels]: 2,\n    [description]: stereo\n  },\n  0b01000000: {\n    [channels]: 2,\n    [description]: \"joint \" + stereo\n  },\n  0b10000000: {\n    [channels]: 2,\n    [description]: \"dual channel\"\n  },\n  0b11000000: {\n    [channels]: 1,\n    [description]: monophonic\n  }\n};\nexport default class MPEGHeader extends CodecHeader {\n  static *[getHeader](codecParser, headerCache, readOffset) {\n    const header = {};\n\n    // check for id3 header\n    const id3v2Header = yield* ID3v2.getID3v2Header(codecParser, headerCache, readOffset);\n    if (id3v2Header) {\n      // throw away the data. id3 parsing is not implemented yet.\n      yield* codecParser[readRawData](id3v2Header[length], readOffset);\n      codecParser[incrementRawData](id3v2Header[length]);\n    }\n\n    // Must be at least four bytes.\n    const data = yield* codecParser[readRawData](4, readOffset);\n\n    // Check header cache\n    const key = bytesToString(data[subarray](0, 4));\n    const cachedHeader = headerCache[getHeader](key);\n    if (cachedHeader) return new MPEGHeader(cachedHeader);\n\n    // Frame sync (all bits must be set): `11111111|111`:\n    if (data[0] !== 0xff || data[1] < 0xe0) return null;\n\n    // Byte (2 of 4)\n    // * `111BBCCD`\n    // * `...BB...`: MPEG Audio version ID\n    // * `.....CC.`: Layer description\n    // * `.......D`: Protection bit (0 - Protected by CRC (16bit CRC follows header), 1 = Not protected)\n\n    // Mpeg version (1, 2, 2.5)\n    const mpegVersionValues = mpegVersions[data[1] & 0b00011000];\n    if (mpegVersionValues[description] === reserved) return null;\n\n    // Layer (I, II, III)\n    const layerBits = data[1] & 0b00000110;\n    if (layersValues[layerBits][description] === reserved) return null;\n    const layerValues = {\n      ...layersValues[layerBits],\n      ...layersValues[layerBits][mpegVersionValues[layer]]\n    };\n    header[mpegVersion] = mpegVersionValues[description];\n    header[layer] = layerValues[description];\n    header[samples] = layerValues[samples];\n    header[protection] = protectionValues[data[1] & 0b00000001];\n    header[length] = 4;\n\n    // Byte (3 of 4)\n    // * `EEEEFFGH`\n    // * `EEEE....`: Bitrate index. 1111 is invalid, everything else is accepted\n    // * `....FF..`: Sample rate\n    // * `......G.`: Padding bit, 0=frame not padded, 1=frame padded\n    // * `.......H`: Private bit.\n    header[bitrate] = bitrateMatrix[data[2] & 0b11110000][layerValues[bitrateIndex]];\n    if (header[bitrate] === bad) return null;\n    header[sampleRate] = mpegVersionValues[sampleRate][data[2] & 0b00001100];\n    if (header[sampleRate] === reserved) return null;\n    header[framePadding] = data[2] & 0b00000010 && layerValues[framePadding];\n    header[isPrivate] = !!(data[2] & 0b00000001);\n    header[frameLength] = Math.floor(125 * header[bitrate] * header[samples] / header[sampleRate] + header[framePadding]);\n    if (!header[frameLength]) return null;\n\n    // Byte (4 of 4)\n    // * `IIJJKLMM`\n    // * `II......`: Channel mode\n    // * `..JJ....`: Mode extension (only if joint stereo)\n    // * `....K...`: Copyright\n    // * `.....L..`: Original\n    // * `......MM`: Emphasis\n    const channelModeBits = data[3] & 0b11000000;\n    header[channelMode] = channelModes[channelModeBits][description];\n    header[channels] = channelModes[channelModeBits][channels];\n    header[modeExtension] = layerValues[modeExtension][data[3] & 0b00110000];\n    header[isCopyrighted] = !!(data[3] & 0b00001000);\n    header[isOriginal] = !!(data[3] & 0b00000100);\n    header[emphasis] = emphasisValues[data[3] & 0b00000011];\n    if (header[emphasis] === reserved) return null;\n    header[bitDepth] = 16;\n\n    // set header cache\n    {\n      const {\n        length,\n        frameLength,\n        samples,\n        ...codecUpdateFields\n      } = header;\n      headerCache[setHeader](key, header, codecUpdateFields);\n    }\n    return new MPEGHeader(header);\n  }\n\n  /**\n   * @private\n   * Call MPEGHeader.getHeader(Array<Uint8>) to get instance\n   */\n  constructor(header) {\n    super(header);\n    this[bitrate] = header[bitrate];\n    this[emphasis] = header[emphasis];\n    this[framePadding] = header[framePadding];\n    this[isCopyrighted] = header[isCopyrighted];\n    this[isOriginal] = header[isOriginal];\n    this[isPrivate] = header[isPrivate];\n    this[layer] = header[layer];\n    this[modeExtension] = header[modeExtension];\n    this[mpegVersion] = header[mpegVersion];\n    this[protection] = header[protection];\n  }\n}","map":{"version":3,"names":["reserved","bad","free","none","sixteenBitCRC","rate44100","rate48000","rate32000","rate22050","rate24000","rate16000","rate11025","rate12000","rate8000","monophonic","stereo","bitDepth","channelMode","sampleRate","bitrate","channels","isOriginal","isPrivate","layer","length","mpegVersion","frameLength","protection","emphasis","framePadding","isCopyrighted","modeExtension","description","samples","subarray","readRawData","incrementRawData","getHeader","setHeader","bytesToString","ID3v2","CodecHeader","bitrateMatrix","calcBitrate","idx","interval","intervalOffset","i","v1Layer1","v1Layer2","v1Layer3","v2Layer1","v2Layer23","bands","to31","layer12ModeExtensions","bitrateIndex","v2","v1","intensityStereo","msStereo","on","off","layer3ModeExtensions","layersValues","mpegVersionDescription","isoIec","mpegVersions","protectionValues","emphasisValues","channelModes","MPEGHeader","codecParser","headerCache","readOffset","header","id3v2Header","getID3v2Header","data","key","cachedHeader","mpegVersionValues","layerBits","layerValues","Math","floor","channelModeBits","codecUpdateFields","constructor"],"sources":["C:/Users/vanitas/node_modules/codec-parser/src/codecs/mpeg/MPEGHeader.js"],"sourcesContent":["/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport {\n  reserved,\n  bad,\n  free,\n  none,\n  sixteenBitCRC,\n  rate44100,\n  rate48000,\n  rate32000,\n  rate22050,\n  rate24000,\n  rate16000,\n  rate11025,\n  rate12000,\n  rate8000,\n  monophonic,\n  stereo,\n  bitDepth,\n  channelMode,\n  sampleRate,\n  bitrate,\n  channels,\n  isOriginal,\n  isPrivate,\n  layer,\n  length,\n  mpegVersion,\n  frameLength,\n  protection,\n  emphasis,\n  framePadding,\n  isCopyrighted,\n  modeExtension,\n  description,\n  samples,\n  subarray,\n  readRawData,\n  incrementRawData,\n  getHeader,\n  setHeader,\n} from \"../../constants.js\";\nimport { bytesToString } from \"../../utilities.js\";\n\nimport ID3v2 from \"../../metadata/ID3v2.js\";\nimport CodecHeader from \"../CodecHeader.js\";\n\n// http://www.mp3-tech.org/programmer/frame_header.html\n\nconst bitrateMatrix = {\n  // bits | V1,L1 | V1,L2 | V1,L3 | V2,L1 | V2,L2 & L3\n  0b00000000: [free, free, free, free, free],\n  0b00010000: [32, 32, 32, 32, 8],\n  // 0b00100000: [64,   48,  40,  48,  16,],\n  // 0b00110000: [96,   56,  48,  56,  24,],\n  // 0b01000000: [128,  64,  56,  64,  32,],\n  // 0b01010000: [160,  80,  64,  80,  40,],\n  // 0b01100000: [192,  96,  80,  96,  48,],\n  // 0b01110000: [224, 112,  96, 112,  56,],\n  // 0b10000000: [256, 128, 112, 128,  64,],\n  // 0b10010000: [288, 160, 128, 144,  80,],\n  // 0b10100000: [320, 192, 160, 160,  96,],\n  // 0b10110000: [352, 224, 192, 176, 112,],\n  // 0b11000000: [384, 256, 224, 192, 128,],\n  // 0b11010000: [416, 320, 256, 224, 144,],\n  // 0b11100000: [448, 384, 320, 256, 160,],\n  0b11110000: [bad, bad, bad, bad, bad],\n};\n\nconst calcBitrate = (idx, interval, intervalOffset) =>\n  8 *\n    (((idx + intervalOffset) % interval) + interval) *\n    (1 << ((idx + intervalOffset) / interval)) -\n  8 * interval * ((interval / 8) | 0);\n\n// generate bitrate matrix\nfor (let i = 2; i < 15; i++)\n  bitrateMatrix[i << 4] = [\n    i * 32, //                V1,L1\n    calcBitrate(i, 4, 0), //  V1,L2\n    calcBitrate(i, 4, -1), // V1,L3\n    calcBitrate(i, 8, 4), //  V2,L1\n    calcBitrate(i, 8, 0), //  V2,L2 & L3\n  ];\n\nconst v1Layer1 = 0;\nconst v1Layer2 = 1;\nconst v1Layer3 = 2;\nconst v2Layer1 = 3;\nconst v2Layer23 = 4;\n\nconst bands = \"bands \";\nconst to31 = \" to 31\";\nconst layer12ModeExtensions = {\n  0b00000000: bands + 4 + to31,\n  0b00010000: bands + 8 + to31,\n  0b00100000: bands + 12 + to31,\n  0b00110000: bands + 16 + to31,\n};\n\nconst bitrateIndex = \"bitrateIndex\";\nconst v2 = \"v2\";\nconst v1 = \"v1\";\n\nconst intensityStereo = \"Intensity stereo \";\nconst msStereo = \", MS stereo \";\nconst on = \"on\";\nconst off = \"off\";\nconst layer3ModeExtensions = {\n  0b00000000: intensityStereo + off + msStereo + off,\n  0b00010000: intensityStereo + on + msStereo + off,\n  0b00100000: intensityStereo + off + msStereo + on,\n  0b00110000: intensityStereo + on + msStereo + on,\n};\n\nconst layersValues = {\n  0b00000000: { [description]: reserved },\n  0b00000010: {\n    [description]: \"Layer III\",\n    [framePadding]: 1,\n    [modeExtension]: layer3ModeExtensions,\n    [v1]: {\n      [bitrateIndex]: v1Layer3,\n      [samples]: 1152,\n    },\n    [v2]: {\n      [bitrateIndex]: v2Layer23,\n      [samples]: 576,\n    },\n  },\n  0b00000100: {\n    [description]: \"Layer II\",\n    [framePadding]: 1,\n    [modeExtension]: layer12ModeExtensions,\n    [samples]: 1152,\n    [v1]: {\n      [bitrateIndex]: v1Layer2,\n    },\n    [v2]: {\n      [bitrateIndex]: v2Layer23,\n    },\n  },\n  0b00000110: {\n    [description]: \"Layer I\",\n    [framePadding]: 4,\n    [modeExtension]: layer12ModeExtensions,\n    [samples]: 384,\n    [v1]: {\n      [bitrateIndex]: v1Layer1,\n    },\n    [v2]: {\n      [bitrateIndex]: v2Layer1,\n    },\n  },\n};\n\nconst mpegVersionDescription = \"MPEG Version \";\nconst isoIec = \"ISO/IEC \";\nconst mpegVersions = {\n  0b00000000: {\n    [description]: `${mpegVersionDescription}2.5 (later extension of MPEG 2)`,\n    [layer]: v2,\n    [sampleRate]: {\n      0b00000000: rate11025,\n      0b00000100: rate12000,\n      0b00001000: rate8000,\n      0b00001100: reserved,\n    },\n  },\n  0b00001000: { [description]: reserved },\n  0b00010000: {\n    [description]: `${mpegVersionDescription}2 (${isoIec}13818-3)`,\n    [layer]: v2,\n    [sampleRate]: {\n      0b00000000: rate22050,\n      0b00000100: rate24000,\n      0b00001000: rate16000,\n      0b00001100: reserved,\n    },\n  },\n  0b00011000: {\n    [description]: `${mpegVersionDescription}1 (${isoIec}11172-3)`,\n    [layer]: v1,\n    [sampleRate]: {\n      0b00000000: rate44100,\n      0b00000100: rate48000,\n      0b00001000: rate32000,\n      0b00001100: reserved,\n    },\n  },\n  length,\n};\n\nconst protectionValues = {\n  0b00000000: sixteenBitCRC,\n  0b00000001: none,\n};\n\nconst emphasisValues = {\n  0b00000000: none,\n  0b00000001: \"50/15 ms\",\n  0b00000010: reserved,\n  0b00000011: \"CCIT J.17\",\n};\n\nconst channelModes = {\n  0b00000000: { [channels]: 2, [description]: stereo },\n  0b01000000: { [channels]: 2, [description]: \"joint \" + stereo },\n  0b10000000: { [channels]: 2, [description]: \"dual channel\" },\n  0b11000000: { [channels]: 1, [description]: monophonic },\n};\n\nexport default class MPEGHeader extends CodecHeader {\n  static *[getHeader](codecParser, headerCache, readOffset) {\n    const header = {};\n\n    // check for id3 header\n    const id3v2Header = yield* ID3v2.getID3v2Header(\n      codecParser,\n      headerCache,\n      readOffset,\n    );\n\n    if (id3v2Header) {\n      // throw away the data. id3 parsing is not implemented yet.\n      yield* codecParser[readRawData](id3v2Header[length], readOffset);\n      codecParser[incrementRawData](id3v2Header[length]);\n    }\n\n    // Must be at least four bytes.\n    const data = yield* codecParser[readRawData](4, readOffset);\n\n    // Check header cache\n    const key = bytesToString(data[subarray](0, 4));\n    const cachedHeader = headerCache[getHeader](key);\n    if (cachedHeader) return new MPEGHeader(cachedHeader);\n\n    // Frame sync (all bits must be set): `11111111|111`:\n    if (data[0] !== 0xff || data[1] < 0xe0) return null;\n\n    // Byte (2 of 4)\n    // * `111BBCCD`\n    // * `...BB...`: MPEG Audio version ID\n    // * `.....CC.`: Layer description\n    // * `.......D`: Protection bit (0 - Protected by CRC (16bit CRC follows header), 1 = Not protected)\n\n    // Mpeg version (1, 2, 2.5)\n    const mpegVersionValues = mpegVersions[data[1] & 0b00011000];\n    if (mpegVersionValues[description] === reserved) return null;\n\n    // Layer (I, II, III)\n    const layerBits = data[1] & 0b00000110;\n    if (layersValues[layerBits][description] === reserved) return null;\n    const layerValues = {\n      ...layersValues[layerBits],\n      ...layersValues[layerBits][mpegVersionValues[layer]],\n    };\n\n    header[mpegVersion] = mpegVersionValues[description];\n    header[layer] = layerValues[description];\n    header[samples] = layerValues[samples];\n    header[protection] = protectionValues[data[1] & 0b00000001];\n\n    header[length] = 4;\n\n    // Byte (3 of 4)\n    // * `EEEEFFGH`\n    // * `EEEE....`: Bitrate index. 1111 is invalid, everything else is accepted\n    // * `....FF..`: Sample rate\n    // * `......G.`: Padding bit, 0=frame not padded, 1=frame padded\n    // * `.......H`: Private bit.\n    header[bitrate] =\n      bitrateMatrix[data[2] & 0b11110000][layerValues[bitrateIndex]];\n    if (header[bitrate] === bad) return null;\n\n    header[sampleRate] = mpegVersionValues[sampleRate][data[2] & 0b00001100];\n    if (header[sampleRate] === reserved) return null;\n\n    header[framePadding] = data[2] & 0b00000010 && layerValues[framePadding];\n    header[isPrivate] = !!(data[2] & 0b00000001);\n\n    header[frameLength] = Math.floor(\n      (125 * header[bitrate] * header[samples]) / header[sampleRate] +\n        header[framePadding],\n    );\n    if (!header[frameLength]) return null;\n\n    // Byte (4 of 4)\n    // * `IIJJKLMM`\n    // * `II......`: Channel mode\n    // * `..JJ....`: Mode extension (only if joint stereo)\n    // * `....K...`: Copyright\n    // * `.....L..`: Original\n    // * `......MM`: Emphasis\n    const channelModeBits = data[3] & 0b11000000;\n    header[channelMode] = channelModes[channelModeBits][description];\n    header[channels] = channelModes[channelModeBits][channels];\n\n    header[modeExtension] = layerValues[modeExtension][data[3] & 0b00110000];\n    header[isCopyrighted] = !!(data[3] & 0b00001000);\n    header[isOriginal] = !!(data[3] & 0b00000100);\n\n    header[emphasis] = emphasisValues[data[3] & 0b00000011];\n    if (header[emphasis] === reserved) return null;\n\n    header[bitDepth] = 16;\n\n    // set header cache\n    {\n      const { length, frameLength, samples, ...codecUpdateFields } = header;\n\n      headerCache[setHeader](key, header, codecUpdateFields);\n    }\n    return new MPEGHeader(header);\n  }\n\n  /**\n   * @private\n   * Call MPEGHeader.getHeader(Array<Uint8>) to get instance\n   */\n  constructor(header) {\n    super(header);\n\n    this[bitrate] = header[bitrate];\n    this[emphasis] = header[emphasis];\n    this[framePadding] = header[framePadding];\n    this[isCopyrighted] = header[isCopyrighted];\n    this[isOriginal] = header[isOriginal];\n    this[isPrivate] = header[isPrivate];\n    this[layer] = header[layer];\n    this[modeExtension] = header[modeExtension];\n    this[mpegVersion] = header[mpegVersion];\n    this[protection] = header[protection];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}