{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNextPreKeysNode = exports.getNextPreKeys = exports.extractDeviceJids = exports.parseAndInjectE2ESessions = exports.xmppPreKey = exports.xmppSignedPreKey = exports.generateOrGetPreKeys = exports.getPreKeys = exports.createSignalIdentity = void 0;\nconst lodash_1 = require(\"lodash\");\nconst Defaults_1 = require(\"../Defaults\");\nconst WABinary_1 = require(\"../WABinary\");\nconst crypto_1 = require(\"./crypto\");\nconst generics_1 = require(\"./generics\");\nconst createSignalIdentity = (wid, accountSignatureKey) => {\n  return {\n    identifier: {\n      name: wid,\n      deviceId: 0\n    },\n    identifierKey: (0, crypto_1.generateSignalPubKey)(accountSignatureKey)\n  };\n};\nexports.createSignalIdentity = createSignalIdentity;\nconst getPreKeys = async ({\n  get\n}, min, limit) => {\n  const idList = [];\n  for (let id = min; id < limit; id++) {\n    idList.push(id.toString());\n  }\n  return get('pre-key', idList);\n};\nexports.getPreKeys = getPreKeys;\nconst generateOrGetPreKeys = (creds, range) => {\n  const avaliable = creds.nextPreKeyId - creds.firstUnuploadedPreKeyId;\n  const remaining = range - avaliable;\n  const lastPreKeyId = creds.nextPreKeyId + remaining - 1;\n  const newPreKeys = {};\n  if (remaining > 0) {\n    for (let i = creds.nextPreKeyId; i <= lastPreKeyId; i++) {\n      newPreKeys[i] = crypto_1.Curve.generateKeyPair();\n    }\n  }\n  return {\n    newPreKeys,\n    lastPreKeyId,\n    preKeysRange: [creds.firstUnuploadedPreKeyId, range]\n  };\n};\nexports.generateOrGetPreKeys = generateOrGetPreKeys;\nconst xmppSignedPreKey = key => ({\n  tag: 'skey',\n  attrs: {},\n  content: [{\n    tag: 'id',\n    attrs: {},\n    content: (0, generics_1.encodeBigEndian)(key.keyId, 3)\n  }, {\n    tag: 'value',\n    attrs: {},\n    content: key.keyPair.public\n  }, {\n    tag: 'signature',\n    attrs: {},\n    content: key.signature\n  }]\n});\nexports.xmppSignedPreKey = xmppSignedPreKey;\nconst xmppPreKey = (pair, id) => ({\n  tag: 'key',\n  attrs: {},\n  content: [{\n    tag: 'id',\n    attrs: {},\n    content: (0, generics_1.encodeBigEndian)(id, 3)\n  }, {\n    tag: 'value',\n    attrs: {},\n    content: pair.public\n  }]\n});\nexports.xmppPreKey = xmppPreKey;\nconst parseAndInjectE2ESessions = async (node, repository) => {\n  const extractKey = key => key ? {\n    keyId: (0, WABinary_1.getBinaryNodeChildUInt)(key, 'id', 3),\n    publicKey: (0, crypto_1.generateSignalPubKey)((0, WABinary_1.getBinaryNodeChildBuffer)(key, 'value')),\n    signature: (0, WABinary_1.getBinaryNodeChildBuffer)(key, 'signature')\n  } : undefined;\n  const nodes = (0, WABinary_1.getBinaryNodeChildren)((0, WABinary_1.getBinaryNodeChild)(node, 'list'), 'user');\n  for (const node of nodes) {\n    (0, WABinary_1.assertNodeErrorFree)(node);\n  }\n  // Most of the work in repository.injectE2ESession is CPU intensive, not IO\n  // So Promise.all doesn't really help here,\n  // but blocks even loop if we're using it inside keys.transaction, and it makes it \"sync\" actually\n  // This way we chunk it in smaller parts and between those parts we can yield to the event loop\n  // It's rare case when you need to E2E sessions for so many users, but it's possible\n  const chunkSize = 100;\n  const chunks = (0, lodash_1.chunk)(nodes, chunkSize);\n  for (const nodesChunk of chunks) {\n    await Promise.all(nodesChunk.map(async node => {\n      const signedKey = (0, WABinary_1.getBinaryNodeChild)(node, 'skey');\n      const key = (0, WABinary_1.getBinaryNodeChild)(node, 'key');\n      const identity = (0, WABinary_1.getBinaryNodeChildBuffer)(node, 'identity');\n      const jid = node.attrs.jid;\n      const registrationId = (0, WABinary_1.getBinaryNodeChildUInt)(node, 'registration', 4);\n      await repository.injectE2ESession({\n        jid,\n        session: {\n          registrationId: registrationId,\n          identityKey: (0, crypto_1.generateSignalPubKey)(identity),\n          signedPreKey: extractKey(signedKey),\n          preKey: extractKey(key)\n        }\n      });\n    }));\n  }\n};\nexports.parseAndInjectE2ESessions = parseAndInjectE2ESessions;\nconst extractDeviceJids = (result, myJid, excludeZeroDevices) => {\n  var _a;\n  const {\n    user: myUser,\n    device: myDevice\n  } = (0, WABinary_1.jidDecode)(myJid);\n  const extracted = [];\n  for (const node of result.content) {\n    const list = (_a = (0, WABinary_1.getBinaryNodeChild)(node, 'list')) === null || _a === void 0 ? void 0 : _a.content;\n    if (list && Array.isArray(list)) {\n      for (const item of list) {\n        const {\n          user\n        } = (0, WABinary_1.jidDecode)(item.attrs.jid);\n        const devicesNode = (0, WABinary_1.getBinaryNodeChild)(item, 'devices');\n        const deviceListNode = (0, WABinary_1.getBinaryNodeChild)(devicesNode, 'device-list');\n        if (Array.isArray(deviceListNode === null || deviceListNode === void 0 ? void 0 : deviceListNode.content)) {\n          for (const {\n            tag,\n            attrs\n          } of deviceListNode.content) {\n            const device = +attrs.id;\n            if (tag === 'device' && (\n            // ensure the \"device\" tag\n            !excludeZeroDevices || device !== 0) && (\n            // if zero devices are not-excluded, or device is non zero\n            myUser !== user || myDevice !== device) && (\n            // either different user or if me user, not this device\n            device === 0 || !!attrs['key-index']) // ensure that \"key-index\" is specified for \"non-zero\" devices, produces a bad req otherwise\n            ) {\n              extracted.push({\n                user,\n                device\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  return extracted;\n};\nexports.extractDeviceJids = extractDeviceJids;\n/**\n * get the next N keys for upload or processing\n * @param count number of pre-keys to get or generate\n */\nconst getNextPreKeys = async ({\n  creds,\n  keys\n}, count) => {\n  const {\n    newPreKeys,\n    lastPreKeyId,\n    preKeysRange\n  } = (0, exports.generateOrGetPreKeys)(creds, count);\n  const update = {\n    nextPreKeyId: Math.max(lastPreKeyId + 1, creds.nextPreKeyId),\n    firstUnuploadedPreKeyId: Math.max(creds.firstUnuploadedPreKeyId, lastPreKeyId + 1)\n  };\n  await keys.set({\n    'pre-key': newPreKeys\n  });\n  const preKeys = await (0, exports.getPreKeys)(keys, preKeysRange[0], preKeysRange[0] + preKeysRange[1]);\n  return {\n    update,\n    preKeys\n  };\n};\nexports.getNextPreKeys = getNextPreKeys;\nconst getNextPreKeysNode = async (state, count) => {\n  const {\n    creds\n  } = state;\n  const {\n    update,\n    preKeys\n  } = await (0, exports.getNextPreKeys)(state, count);\n  const node = {\n    tag: 'iq',\n    attrs: {\n      xmlns: 'encrypt',\n      type: 'set',\n      to: WABinary_1.S_WHATSAPP_NET\n    },\n    content: [{\n      tag: 'registration',\n      attrs: {},\n      content: (0, generics_1.encodeBigEndian)(creds.registrationId)\n    }, {\n      tag: 'type',\n      attrs: {},\n      content: Defaults_1.KEY_BUNDLE_TYPE\n    }, {\n      tag: 'identity',\n      attrs: {},\n      content: creds.signedIdentityKey.public\n    }, {\n      tag: 'list',\n      attrs: {},\n      content: Object.keys(preKeys).map(k => (0, exports.xmppPreKey)(preKeys[+k], +k))\n    }, (0, exports.xmppSignedPreKey)(creds.signedPreKey)]\n  };\n  return {\n    update,\n    node\n  };\n};\nexports.getNextPreKeysNode = getNextPreKeysNode;","map":{"version":3,"names":["Object","defineProperty","exports","value","getNextPreKeysNode","getNextPreKeys","extractDeviceJids","parseAndInjectE2ESessions","xmppPreKey","xmppSignedPreKey","generateOrGetPreKeys","getPreKeys","createSignalIdentity","lodash_1","require","Defaults_1","WABinary_1","crypto_1","generics_1","wid","accountSignatureKey","identifier","name","deviceId","identifierKey","generateSignalPubKey","get","min","limit","idList","id","push","toString","creds","range","avaliable","nextPreKeyId","firstUnuploadedPreKeyId","remaining","lastPreKeyId","newPreKeys","i","Curve","generateKeyPair","preKeysRange","key","tag","attrs","content","encodeBigEndian","keyId","keyPair","public","signature","pair","node","repository","extractKey","getBinaryNodeChildUInt","publicKey","getBinaryNodeChildBuffer","undefined","nodes","getBinaryNodeChildren","getBinaryNodeChild","assertNodeErrorFree","chunkSize","chunks","chunk","nodesChunk","Promise","all","map","signedKey","identity","jid","registrationId","injectE2ESession","session","identityKey","signedPreKey","preKey","result","myJid","excludeZeroDevices","_a","user","myUser","device","myDevice","jidDecode","extracted","list","Array","isArray","item","devicesNode","deviceListNode","keys","count","update","Math","max","set","preKeys","state","xmlns","type","to","S_WHATSAPP_NET","KEY_BUNDLE_TYPE","signedIdentityKey","k"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Utils/signal.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getNextPreKeysNode = exports.getNextPreKeys = exports.extractDeviceJids = exports.parseAndInjectE2ESessions = exports.xmppPreKey = exports.xmppSignedPreKey = exports.generateOrGetPreKeys = exports.getPreKeys = exports.createSignalIdentity = void 0;\nconst lodash_1 = require(\"lodash\");\nconst Defaults_1 = require(\"../Defaults\");\nconst WABinary_1 = require(\"../WABinary\");\nconst crypto_1 = require(\"./crypto\");\nconst generics_1 = require(\"./generics\");\nconst createSignalIdentity = (wid, accountSignatureKey) => {\n    return {\n        identifier: { name: wid, deviceId: 0 },\n        identifierKey: (0, crypto_1.generateSignalPubKey)(accountSignatureKey)\n    };\n};\nexports.createSignalIdentity = createSignalIdentity;\nconst getPreKeys = async ({ get }, min, limit) => {\n    const idList = [];\n    for (let id = min; id < limit; id++) {\n        idList.push(id.toString());\n    }\n    return get('pre-key', idList);\n};\nexports.getPreKeys = getPreKeys;\nconst generateOrGetPreKeys = (creds, range) => {\n    const avaliable = creds.nextPreKeyId - creds.firstUnuploadedPreKeyId;\n    const remaining = range - avaliable;\n    const lastPreKeyId = creds.nextPreKeyId + remaining - 1;\n    const newPreKeys = {};\n    if (remaining > 0) {\n        for (let i = creds.nextPreKeyId; i <= lastPreKeyId; i++) {\n            newPreKeys[i] = crypto_1.Curve.generateKeyPair();\n        }\n    }\n    return {\n        newPreKeys,\n        lastPreKeyId,\n        preKeysRange: [creds.firstUnuploadedPreKeyId, range],\n    };\n};\nexports.generateOrGetPreKeys = generateOrGetPreKeys;\nconst xmppSignedPreKey = (key) => ({\n    tag: 'skey',\n    attrs: {},\n    content: [\n        { tag: 'id', attrs: {}, content: (0, generics_1.encodeBigEndian)(key.keyId, 3) },\n        { tag: 'value', attrs: {}, content: key.keyPair.public },\n        { tag: 'signature', attrs: {}, content: key.signature }\n    ]\n});\nexports.xmppSignedPreKey = xmppSignedPreKey;\nconst xmppPreKey = (pair, id) => ({\n    tag: 'key',\n    attrs: {},\n    content: [\n        { tag: 'id', attrs: {}, content: (0, generics_1.encodeBigEndian)(id, 3) },\n        { tag: 'value', attrs: {}, content: pair.public }\n    ]\n});\nexports.xmppPreKey = xmppPreKey;\nconst parseAndInjectE2ESessions = async (node, repository) => {\n    const extractKey = (key) => (key ? ({\n        keyId: (0, WABinary_1.getBinaryNodeChildUInt)(key, 'id', 3),\n        publicKey: (0, crypto_1.generateSignalPubKey)((0, WABinary_1.getBinaryNodeChildBuffer)(key, 'value')),\n        signature: (0, WABinary_1.getBinaryNodeChildBuffer)(key, 'signature'),\n    }) : undefined);\n    const nodes = (0, WABinary_1.getBinaryNodeChildren)((0, WABinary_1.getBinaryNodeChild)(node, 'list'), 'user');\n    for (const node of nodes) {\n        (0, WABinary_1.assertNodeErrorFree)(node);\n    }\n    // Most of the work in repository.injectE2ESession is CPU intensive, not IO\n    // So Promise.all doesn't really help here,\n    // but blocks even loop if we're using it inside keys.transaction, and it makes it \"sync\" actually\n    // This way we chunk it in smaller parts and between those parts we can yield to the event loop\n    // It's rare case when you need to E2E sessions for so many users, but it's possible\n    const chunkSize = 100;\n    const chunks = (0, lodash_1.chunk)(nodes, chunkSize);\n    for (const nodesChunk of chunks) {\n        await Promise.all(nodesChunk.map(async (node) => {\n            const signedKey = (0, WABinary_1.getBinaryNodeChild)(node, 'skey');\n            const key = (0, WABinary_1.getBinaryNodeChild)(node, 'key');\n            const identity = (0, WABinary_1.getBinaryNodeChildBuffer)(node, 'identity');\n            const jid = node.attrs.jid;\n            const registrationId = (0, WABinary_1.getBinaryNodeChildUInt)(node, 'registration', 4);\n            await repository.injectE2ESession({\n                jid,\n                session: {\n                    registrationId: registrationId,\n                    identityKey: (0, crypto_1.generateSignalPubKey)(identity),\n                    signedPreKey: extractKey(signedKey),\n                    preKey: extractKey(key)\n                }\n            });\n        }));\n    }\n};\nexports.parseAndInjectE2ESessions = parseAndInjectE2ESessions;\nconst extractDeviceJids = (result, myJid, excludeZeroDevices) => {\n    var _a;\n    const { user: myUser, device: myDevice } = (0, WABinary_1.jidDecode)(myJid);\n    const extracted = [];\n    for (const node of result.content) {\n        const list = (_a = (0, WABinary_1.getBinaryNodeChild)(node, 'list')) === null || _a === void 0 ? void 0 : _a.content;\n        if (list && Array.isArray(list)) {\n            for (const item of list) {\n                const { user } = (0, WABinary_1.jidDecode)(item.attrs.jid);\n                const devicesNode = (0, WABinary_1.getBinaryNodeChild)(item, 'devices');\n                const deviceListNode = (0, WABinary_1.getBinaryNodeChild)(devicesNode, 'device-list');\n                if (Array.isArray(deviceListNode === null || deviceListNode === void 0 ? void 0 : deviceListNode.content)) {\n                    for (const { tag, attrs } of deviceListNode.content) {\n                        const device = +attrs.id;\n                        if (tag === 'device' && // ensure the \"device\" tag\n                            (!excludeZeroDevices || device !== 0) && // if zero devices are not-excluded, or device is non zero\n                            (myUser !== user || myDevice !== device) && // either different user or if me user, not this device\n                            (device === 0 || !!attrs['key-index']) // ensure that \"key-index\" is specified for \"non-zero\" devices, produces a bad req otherwise\n                        ) {\n                            extracted.push({ user, device });\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return extracted;\n};\nexports.extractDeviceJids = extractDeviceJids;\n/**\n * get the next N keys for upload or processing\n * @param count number of pre-keys to get or generate\n */\nconst getNextPreKeys = async ({ creds, keys }, count) => {\n    const { newPreKeys, lastPreKeyId, preKeysRange } = (0, exports.generateOrGetPreKeys)(creds, count);\n    const update = {\n        nextPreKeyId: Math.max(lastPreKeyId + 1, creds.nextPreKeyId),\n        firstUnuploadedPreKeyId: Math.max(creds.firstUnuploadedPreKeyId, lastPreKeyId + 1)\n    };\n    await keys.set({ 'pre-key': newPreKeys });\n    const preKeys = await (0, exports.getPreKeys)(keys, preKeysRange[0], preKeysRange[0] + preKeysRange[1]);\n    return { update, preKeys };\n};\nexports.getNextPreKeys = getNextPreKeys;\nconst getNextPreKeysNode = async (state, count) => {\n    const { creds } = state;\n    const { update, preKeys } = await (0, exports.getNextPreKeys)(state, count);\n    const node = {\n        tag: 'iq',\n        attrs: {\n            xmlns: 'encrypt',\n            type: 'set',\n            to: WABinary_1.S_WHATSAPP_NET,\n        },\n        content: [\n            { tag: 'registration', attrs: {}, content: (0, generics_1.encodeBigEndian)(creds.registrationId) },\n            { tag: 'type', attrs: {}, content: Defaults_1.KEY_BUNDLE_TYPE },\n            { tag: 'identity', attrs: {}, content: creds.signedIdentityKey.public },\n            { tag: 'list', attrs: {}, content: Object.keys(preKeys).map(k => (0, exports.xmppPreKey)(preKeys[+k], +k)) },\n            (0, exports.xmppSignedPreKey)(creds.signedPreKey)\n        ]\n    };\n    return { update, node };\n};\nexports.getNextPreKeysNode = getNextPreKeysNode;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}