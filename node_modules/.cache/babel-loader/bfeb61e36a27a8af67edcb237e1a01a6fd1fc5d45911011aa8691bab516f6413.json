{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeNoiseHandler = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst WABinary_1 = require(\"../WABinary\");\nconst crypto_1 = require(\"./crypto\");\nconst generateIV = counter => {\n  const iv = new ArrayBuffer(12);\n  new DataView(iv).setUint32(8, counter);\n  return new Uint8Array(iv);\n};\nconst makeNoiseHandler = ({\n  keyPair: {\n    private: privateKey,\n    public: publicKey\n  },\n  NOISE_HEADER,\n  mobile,\n  logger,\n  routingInfo\n}) => {\n  logger = logger.child({\n    class: 'ns'\n  });\n  const authenticate = data => {\n    if (!isFinished) {\n      hash = (0, crypto_1.sha256)(Buffer.concat([hash, data]));\n    }\n  };\n  const encrypt = plaintext => {\n    const result = (0, crypto_1.aesEncryptGCM)(plaintext, encKey, generateIV(writeCounter), hash);\n    writeCounter += 1;\n    authenticate(result);\n    return result;\n  };\n  const decrypt = ciphertext => {\n    // before the handshake is finished, we use the same counter\n    // after handshake, the counters are different\n    const iv = generateIV(isFinished ? readCounter : writeCounter);\n    const result = (0, crypto_1.aesDecryptGCM)(ciphertext, decKey, iv, hash);\n    if (isFinished) {\n      readCounter += 1;\n    } else {\n      writeCounter += 1;\n    }\n    authenticate(ciphertext);\n    return result;\n  };\n  const localHKDF = data => {\n    const key = (0, crypto_1.hkdf)(Buffer.from(data), 64, {\n      salt,\n      info: ''\n    });\n    return [key.slice(0, 32), key.slice(32)];\n  };\n  const mixIntoKey = data => {\n    const [write, read] = localHKDF(data);\n    salt = write;\n    encKey = read;\n    decKey = read;\n    readCounter = 0;\n    writeCounter = 0;\n  };\n  const finishInit = () => {\n    const [write, read] = localHKDF(new Uint8Array(0));\n    encKey = write;\n    decKey = read;\n    hash = Buffer.from([]);\n    readCounter = 0;\n    writeCounter = 0;\n    isFinished = true;\n  };\n  const data = Buffer.from(Defaults_1.NOISE_MODE);\n  let hash = Buffer.from(data.byteLength === 32 ? data : (0, crypto_1.sha256)(data));\n  let salt = hash;\n  let encKey = hash;\n  let decKey = hash;\n  let readCounter = 0;\n  let writeCounter = 0;\n  let isFinished = false;\n  let sentIntro = false;\n  let inBytes = Buffer.alloc(0);\n  authenticate(NOISE_HEADER);\n  authenticate(publicKey);\n  return {\n    encrypt,\n    decrypt,\n    authenticate,\n    mixIntoKey,\n    finishInit,\n    processHandshake: ({\n      serverHello\n    }, noiseKey) => {\n      authenticate(serverHello.ephemeral);\n      mixIntoKey(crypto_1.Curve.sharedKey(privateKey, serverHello.ephemeral));\n      const decStaticContent = decrypt(serverHello.static);\n      mixIntoKey(crypto_1.Curve.sharedKey(privateKey, decStaticContent));\n      const certDecoded = decrypt(serverHello.payload);\n      if (mobile) {\n        WAProto_1.proto.CertChain.NoiseCertificate.decode(certDecoded);\n      } else {\n        const {\n          intermediate: certIntermediate\n        } = WAProto_1.proto.CertChain.decode(certDecoded);\n        const {\n          issuerSerial\n        } = WAProto_1.proto.CertChain.NoiseCertificate.Details.decode(certIntermediate.details);\n        if (issuerSerial !== Defaults_1.WA_CERT_DETAILS.SERIAL) {\n          throw new boom_1.Boom('certification match failed', {\n            statusCode: 400\n          });\n        }\n      }\n      const keyEnc = encrypt(noiseKey.public);\n      mixIntoKey(crypto_1.Curve.sharedKey(noiseKey.private, serverHello.ephemeral));\n      return keyEnc;\n    },\n    encodeFrame: data => {\n      if (isFinished) {\n        data = encrypt(data);\n      }\n      let header;\n      if (routingInfo) {\n        header = Buffer.alloc(7);\n        header.write('ED', 0, 'utf8');\n        header.writeUint8(0, 2);\n        header.writeUint8(1, 3);\n        header.writeUint8(routingInfo.byteLength >> 16, 4);\n        header.writeUint16BE(routingInfo.byteLength & 65535, 5);\n        header = Buffer.concat([header, routingInfo, NOISE_HEADER]);\n      } else {\n        header = Buffer.from(NOISE_HEADER);\n      }\n      const introSize = sentIntro ? 0 : header.length;\n      const frame = Buffer.alloc(introSize + 3 + data.byteLength);\n      if (!sentIntro) {\n        frame.set(header);\n        sentIntro = true;\n      }\n      frame.writeUInt8(data.byteLength >> 16, introSize);\n      frame.writeUInt16BE(65535 & data.byteLength, introSize + 1);\n      frame.set(data, introSize + 3);\n      return frame;\n    },\n    decodeFrame: async (newData, onFrame) => {\n      var _a;\n      // the binary protocol uses its own framing mechanism\n      // on top of the WS frames\n      // so we get this data and separate out the frames\n      const getBytesSize = () => {\n        if (inBytes.length >= 3) {\n          return inBytes.readUInt8() << 16 | inBytes.readUInt16BE(1);\n        }\n      };\n      inBytes = Buffer.concat([inBytes, newData]);\n      logger.trace(`recv ${newData.length} bytes, total recv ${inBytes.length} bytes`);\n      let size = getBytesSize();\n      while (size && inBytes.length >= size + 3) {\n        let frame = inBytes.slice(3, size + 3);\n        inBytes = inBytes.slice(size + 3);\n        if (isFinished) {\n          const result = decrypt(frame);\n          frame = await (0, WABinary_1.decodeBinaryNode)(result);\n        }\n        logger.trace({\n          msg: (_a = frame === null || frame === void 0 ? void 0 : frame.attrs) === null || _a === void 0 ? void 0 : _a.id\n        }, 'recv frame');\n        onFrame(frame);\n        size = getBytesSize();\n      }\n    }\n  };\n};\nexports.makeNoiseHandler = makeNoiseHandler;","map":{"version":3,"names":["Object","defineProperty","exports","value","makeNoiseHandler","boom_1","require","WAProto_1","Defaults_1","WABinary_1","crypto_1","generateIV","counter","iv","ArrayBuffer","DataView","setUint32","Uint8Array","keyPair","private","privateKey","public","publicKey","NOISE_HEADER","mobile","logger","routingInfo","child","class","authenticate","data","isFinished","hash","sha256","Buffer","concat","encrypt","plaintext","result","aesEncryptGCM","encKey","writeCounter","decrypt","ciphertext","readCounter","aesDecryptGCM","decKey","localHKDF","key","hkdf","from","salt","info","slice","mixIntoKey","write","read","finishInit","NOISE_MODE","byteLength","sentIntro","inBytes","alloc","processHandshake","serverHello","noiseKey","ephemeral","Curve","sharedKey","decStaticContent","static","certDecoded","payload","proto","CertChain","NoiseCertificate","decode","intermediate","certIntermediate","issuerSerial","Details","details","WA_CERT_DETAILS","SERIAL","Boom","statusCode","keyEnc","encodeFrame","header","writeUint8","writeUint16BE","introSize","length","frame","set","writeUInt8","writeUInt16BE","decodeFrame","newData","onFrame","_a","getBytesSize","readUInt8","readUInt16BE","trace","size","decodeBinaryNode","msg","attrs","id"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Utils/noise-handler.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeNoiseHandler = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst WABinary_1 = require(\"../WABinary\");\nconst crypto_1 = require(\"./crypto\");\nconst generateIV = (counter) => {\n    const iv = new ArrayBuffer(12);\n    new DataView(iv).setUint32(8, counter);\n    return new Uint8Array(iv);\n};\nconst makeNoiseHandler = ({ keyPair: { private: privateKey, public: publicKey }, NOISE_HEADER, mobile, logger, routingInfo }) => {\n    logger = logger.child({ class: 'ns' });\n    const authenticate = (data) => {\n        if (!isFinished) {\n            hash = (0, crypto_1.sha256)(Buffer.concat([hash, data]));\n        }\n    };\n    const encrypt = (plaintext) => {\n        const result = (0, crypto_1.aesEncryptGCM)(plaintext, encKey, generateIV(writeCounter), hash);\n        writeCounter += 1;\n        authenticate(result);\n        return result;\n    };\n    const decrypt = (ciphertext) => {\n        // before the handshake is finished, we use the same counter\n        // after handshake, the counters are different\n        const iv = generateIV(isFinished ? readCounter : writeCounter);\n        const result = (0, crypto_1.aesDecryptGCM)(ciphertext, decKey, iv, hash);\n        if (isFinished) {\n            readCounter += 1;\n        }\n        else {\n            writeCounter += 1;\n        }\n        authenticate(ciphertext);\n        return result;\n    };\n    const localHKDF = (data) => {\n        const key = (0, crypto_1.hkdf)(Buffer.from(data), 64, { salt, info: '' });\n        return [key.slice(0, 32), key.slice(32)];\n    };\n    const mixIntoKey = (data) => {\n        const [write, read] = localHKDF(data);\n        salt = write;\n        encKey = read;\n        decKey = read;\n        readCounter = 0;\n        writeCounter = 0;\n    };\n    const finishInit = () => {\n        const [write, read] = localHKDF(new Uint8Array(0));\n        encKey = write;\n        decKey = read;\n        hash = Buffer.from([]);\n        readCounter = 0;\n        writeCounter = 0;\n        isFinished = true;\n    };\n    const data = Buffer.from(Defaults_1.NOISE_MODE);\n    let hash = Buffer.from(data.byteLength === 32 ? data : (0, crypto_1.sha256)(data));\n    let salt = hash;\n    let encKey = hash;\n    let decKey = hash;\n    let readCounter = 0;\n    let writeCounter = 0;\n    let isFinished = false;\n    let sentIntro = false;\n    let inBytes = Buffer.alloc(0);\n    authenticate(NOISE_HEADER);\n    authenticate(publicKey);\n    return {\n        encrypt,\n        decrypt,\n        authenticate,\n        mixIntoKey,\n        finishInit,\n        processHandshake: ({ serverHello }, noiseKey) => {\n            authenticate(serverHello.ephemeral);\n            mixIntoKey(crypto_1.Curve.sharedKey(privateKey, serverHello.ephemeral));\n            const decStaticContent = decrypt(serverHello.static);\n            mixIntoKey(crypto_1.Curve.sharedKey(privateKey, decStaticContent));\n            const certDecoded = decrypt(serverHello.payload);\n            if (mobile) {\n                WAProto_1.proto.CertChain.NoiseCertificate.decode(certDecoded);\n            }\n            else {\n                const { intermediate: certIntermediate } = WAProto_1.proto.CertChain.decode(certDecoded);\n                const { issuerSerial } = WAProto_1.proto.CertChain.NoiseCertificate.Details.decode(certIntermediate.details);\n                if (issuerSerial !== Defaults_1.WA_CERT_DETAILS.SERIAL) {\n                    throw new boom_1.Boom('certification match failed', { statusCode: 400 });\n                }\n            }\n            const keyEnc = encrypt(noiseKey.public);\n            mixIntoKey(crypto_1.Curve.sharedKey(noiseKey.private, serverHello.ephemeral));\n            return keyEnc;\n        },\n        encodeFrame: (data) => {\n            if (isFinished) {\n                data = encrypt(data);\n            }\n            let header;\n            if (routingInfo) {\n                header = Buffer.alloc(7);\n                header.write('ED', 0, 'utf8');\n                header.writeUint8(0, 2);\n                header.writeUint8(1, 3);\n                header.writeUint8(routingInfo.byteLength >> 16, 4);\n                header.writeUint16BE(routingInfo.byteLength & 65535, 5);\n                header = Buffer.concat([header, routingInfo, NOISE_HEADER]);\n            }\n            else {\n                header = Buffer.from(NOISE_HEADER);\n            }\n            const introSize = sentIntro ? 0 : header.length;\n            const frame = Buffer.alloc(introSize + 3 + data.byteLength);\n            if (!sentIntro) {\n                frame.set(header);\n                sentIntro = true;\n            }\n            frame.writeUInt8(data.byteLength >> 16, introSize);\n            frame.writeUInt16BE(65535 & data.byteLength, introSize + 1);\n            frame.set(data, introSize + 3);\n            return frame;\n        },\n        decodeFrame: async (newData, onFrame) => {\n            var _a;\n            // the binary protocol uses its own framing mechanism\n            // on top of the WS frames\n            // so we get this data and separate out the frames\n            const getBytesSize = () => {\n                if (inBytes.length >= 3) {\n                    return (inBytes.readUInt8() << 16) | inBytes.readUInt16BE(1);\n                }\n            };\n            inBytes = Buffer.concat([inBytes, newData]);\n            logger.trace(`recv ${newData.length} bytes, total recv ${inBytes.length} bytes`);\n            let size = getBytesSize();\n            while (size && inBytes.length >= size + 3) {\n                let frame = inBytes.slice(3, size + 3);\n                inBytes = inBytes.slice(size + 3);\n                if (isFinished) {\n                    const result = decrypt(frame);\n                    frame = await (0, WABinary_1.decodeBinaryNode)(result);\n                }\n                logger.trace({ msg: (_a = frame === null || frame === void 0 ? void 0 : frame.attrs) === null || _a === void 0 ? void 0 : _a.id }, 'recv frame');\n                onFrame(frame);\n                size = getBytesSize();\n            }\n        }\n    };\n};\nexports.makeNoiseHandler = makeNoiseHandler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}