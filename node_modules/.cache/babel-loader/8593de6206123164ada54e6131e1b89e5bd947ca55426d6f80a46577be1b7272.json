{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WavPack = void 0;\nconst Token = require(\"token-types\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst SampleRates = [6000, 8000, 9600, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000, 64000, 88200, 96000, 192000, -1];\nclass WavPack {\n  static isBitSet(flags, bitOffset) {\n    return WavPack.getBitAllignedNumber(flags, bitOffset, 1) === 1;\n  }\n  static getBitAllignedNumber(flags, bitOffset, len) {\n    return flags >>> bitOffset & 0xffffffff >>> 32 - len;\n  }\n}\n/**\n * WavPack Block Header\n *\n * 32-byte little-endian header at the front of every WavPack block\n *\n * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 2/6: 2.0 \"Block Header\")\n */\nWavPack.BlockHeaderToken = {\n  len: 32,\n  get: (buf, off) => {\n    const flags = Token.UINT32_LE.get(buf, off + 24);\n    const res = {\n      // should equal 'wvpk'\n      BlockID: FourCC_1.FourCcToken.get(buf, off),\n      //  0x402 to 0x410 are valid for decode\n      blockSize: Token.UINT32_LE.get(buf, off + 4),\n      //  0x402 (1026) to 0x410 are valid for decode\n      version: Token.UINT16_LE.get(buf, off + 8),\n      //  40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)\n      totalSamples: /* replace with bigint? (Token.UINT8.get(buf, off + 11) << 32) + */Token.UINT32_LE.get(buf, off + 12),\n      // 40-bit block_index\n      blockIndex: /* replace with bigint? (Token.UINT8.get(buf, off + 10) << 32) + */Token.UINT32_LE.get(buf, off + 16),\n      // 40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)\n      blockSamples: Token.UINT32_LE.get(buf, off + 20),\n      // various flags for id and decoding\n      flags: {\n        bitsPerSample: (1 + WavPack.getBitAllignedNumber(flags, 0, 2)) * 8,\n        isMono: WavPack.isBitSet(flags, 2),\n        isHybrid: WavPack.isBitSet(flags, 3),\n        isJointStereo: WavPack.isBitSet(flags, 4),\n        crossChannel: WavPack.isBitSet(flags, 5),\n        hybridNoiseShaping: WavPack.isBitSet(flags, 6),\n        floatingPoint: WavPack.isBitSet(flags, 7),\n        samplingRate: SampleRates[WavPack.getBitAllignedNumber(flags, 23, 4)],\n        isDSD: WavPack.isBitSet(flags, 31)\n      },\n      // crc for actual decoded data\n      crc: new Token.Uint8ArrayType(4).get(buf, off + 28)\n    };\n    if (res.flags.isDSD) {\n      res.totalSamples *= 8;\n    }\n    return res;\n  }\n};\n/**\n * 3.0 Metadata Sub-Blocks\n * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 4/6: 3.0 \"Metadata Sub-Block\")\n */\nWavPack.MetadataIdToken = {\n  len: 1,\n  get: (buf, off) => {\n    return {\n      functionId: WavPack.getBitAllignedNumber(buf[off], 0, 6),\n      isOptional: WavPack.isBitSet(buf[off], 5),\n      isOddSize: WavPack.isBitSet(buf[off], 6),\n      largeBlock: WavPack.isBitSet(buf[off], 7)\n    };\n  }\n};\nexports.WavPack = WavPack;","map":{"version":3,"names":["Object","defineProperty","exports","value","WavPack","Token","require","FourCC_1","SampleRates","isBitSet","flags","bitOffset","getBitAllignedNumber","len","BlockHeaderToken","get","buf","off","UINT32_LE","res","BlockID","FourCcToken","blockSize","version","UINT16_LE","totalSamples","blockIndex","blockSamples","bitsPerSample","isMono","isHybrid","isJointStereo","crossChannel","hybridNoiseShaping","floatingPoint","samplingRate","isDSD","crc","Uint8ArrayType","MetadataIdToken","functionId","isOptional","isOddSize","largeBlock"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/wavpack/WavPackToken.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WavPack = void 0;\nconst Token = require(\"token-types\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst SampleRates = [6000, 8000, 9600, 11025, 12000, 16000, 22050, 24000, 32000, 44100,\n    48000, 64000, 88200, 96000, 192000, -1];\nclass WavPack {\n    static isBitSet(flags, bitOffset) {\n        return WavPack.getBitAllignedNumber(flags, bitOffset, 1) === 1;\n    }\n    static getBitAllignedNumber(flags, bitOffset, len) {\n        return (flags >>> bitOffset) & (0xffffffff >>> (32 - len));\n    }\n}\n/**\n * WavPack Block Header\n *\n * 32-byte little-endian header at the front of every WavPack block\n *\n * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 2/6: 2.0 \"Block Header\")\n */\nWavPack.BlockHeaderToken = {\n    len: 32,\n    get: (buf, off) => {\n        const flags = Token.UINT32_LE.get(buf, off + 24);\n        const res = {\n            // should equal 'wvpk'\n            BlockID: FourCC_1.FourCcToken.get(buf, off),\n            //  0x402 to 0x410 are valid for decode\n            blockSize: Token.UINT32_LE.get(buf, off + 4),\n            //  0x402 (1026) to 0x410 are valid for decode\n            version: Token.UINT16_LE.get(buf, off + 8),\n            //  40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)\n            totalSamples: /* replace with bigint? (Token.UINT8.get(buf, off + 11) << 32) + */ Token.UINT32_LE.get(buf, off + 12),\n            // 40-bit block_index\n            blockIndex: /* replace with bigint? (Token.UINT8.get(buf, off + 10) << 32) + */ Token.UINT32_LE.get(buf, off + 16),\n            // 40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)\n            blockSamples: Token.UINT32_LE.get(buf, off + 20),\n            // various flags for id and decoding\n            flags: {\n                bitsPerSample: (1 + WavPack.getBitAllignedNumber(flags, 0, 2)) * 8,\n                isMono: WavPack.isBitSet(flags, 2),\n                isHybrid: WavPack.isBitSet(flags, 3),\n                isJointStereo: WavPack.isBitSet(flags, 4),\n                crossChannel: WavPack.isBitSet(flags, 5),\n                hybridNoiseShaping: WavPack.isBitSet(flags, 6),\n                floatingPoint: WavPack.isBitSet(flags, 7),\n                samplingRate: SampleRates[WavPack.getBitAllignedNumber(flags, 23, 4)],\n                isDSD: WavPack.isBitSet(flags, 31)\n            },\n            // crc for actual decoded data\n            crc: new Token.Uint8ArrayType(4).get(buf, off + 28)\n        };\n        if (res.flags.isDSD) {\n            res.totalSamples *= 8;\n        }\n        return res;\n    }\n};\n/**\n * 3.0 Metadata Sub-Blocks\n * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 4/6: 3.0 \"Metadata Sub-Block\")\n */\nWavPack.MetadataIdToken = {\n    len: 1,\n    get: (buf, off) => {\n        return {\n            functionId: WavPack.getBitAllignedNumber(buf[off], 0, 6),\n            isOptional: WavPack.isBitSet(buf[off], 5),\n            isOddSize: WavPack.isBitSet(buf[off], 6),\n            largeBlock: WavPack.isBitSet(buf[off], 7)\n        };\n    }\n};\nexports.WavPack = WavPack;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,OAAO,GAAG,KAAK,CAAC;AACxB,MAAMC,KAAK,GAAGC,OAAO,CAAC,aAAa,CAAC;AACpC,MAAMC,QAAQ,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AAC5C,MAAME,WAAW,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAClF,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,CAAC,CAAC,CAAC;AAC3C,MAAMJ,OAAO,CAAC;EACV,OAAOK,QAAQA,CAACC,KAAK,EAAEC,SAAS,EAAE;IAC9B,OAAOP,OAAO,CAACQ,oBAAoB,CAACF,KAAK,EAAEC,SAAS,EAAE,CAAC,CAAC,KAAK,CAAC;EAClE;EACA,OAAOC,oBAAoBA,CAACF,KAAK,EAAEC,SAAS,EAAEE,GAAG,EAAE;IAC/C,OAAQH,KAAK,KAAKC,SAAS,GAAK,UAAU,KAAM,EAAE,GAAGE,GAAK;EAC9D;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAT,OAAO,CAACU,gBAAgB,GAAG;EACvBD,GAAG,EAAE,EAAE;EACPE,GAAG,EAAEA,CAACC,GAAG,EAAEC,GAAG,KAAK;IACf,MAAMP,KAAK,GAAGL,KAAK,CAACa,SAAS,CAACH,GAAG,CAACC,GAAG,EAAEC,GAAG,GAAG,EAAE,CAAC;IAChD,MAAME,GAAG,GAAG;MACR;MACAC,OAAO,EAAEb,QAAQ,CAACc,WAAW,CAACN,GAAG,CAACC,GAAG,EAAEC,GAAG,CAAC;MAC3C;MACAK,SAAS,EAAEjB,KAAK,CAACa,SAAS,CAACH,GAAG,CAACC,GAAG,EAAEC,GAAG,GAAG,CAAC,CAAC;MAC5C;MACAM,OAAO,EAAElB,KAAK,CAACmB,SAAS,CAACT,GAAG,CAACC,GAAG,EAAEC,GAAG,GAAG,CAAC,CAAC;MAC1C;MACAQ,YAAY,EAAE,mEAAoEpB,KAAK,CAACa,SAAS,CAACH,GAAG,CAACC,GAAG,EAAEC,GAAG,GAAG,EAAE,CAAC;MACpH;MACAS,UAAU,EAAE,mEAAoErB,KAAK,CAACa,SAAS,CAACH,GAAG,CAACC,GAAG,EAAEC,GAAG,GAAG,EAAE,CAAC;MAClH;MACAU,YAAY,EAAEtB,KAAK,CAACa,SAAS,CAACH,GAAG,CAACC,GAAG,EAAEC,GAAG,GAAG,EAAE,CAAC;MAChD;MACAP,KAAK,EAAE;QACHkB,aAAa,EAAE,CAAC,CAAC,GAAGxB,OAAO,CAACQ,oBAAoB,CAACF,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC;QAClEmB,MAAM,EAAEzB,OAAO,CAACK,QAAQ,CAACC,KAAK,EAAE,CAAC,CAAC;QAClCoB,QAAQ,EAAE1B,OAAO,CAACK,QAAQ,CAACC,KAAK,EAAE,CAAC,CAAC;QACpCqB,aAAa,EAAE3B,OAAO,CAACK,QAAQ,CAACC,KAAK,EAAE,CAAC,CAAC;QACzCsB,YAAY,EAAE5B,OAAO,CAACK,QAAQ,CAACC,KAAK,EAAE,CAAC,CAAC;QACxCuB,kBAAkB,EAAE7B,OAAO,CAACK,QAAQ,CAACC,KAAK,EAAE,CAAC,CAAC;QAC9CwB,aAAa,EAAE9B,OAAO,CAACK,QAAQ,CAACC,KAAK,EAAE,CAAC,CAAC;QACzCyB,YAAY,EAAE3B,WAAW,CAACJ,OAAO,CAACQ,oBAAoB,CAACF,KAAK,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;QACrE0B,KAAK,EAAEhC,OAAO,CAACK,QAAQ,CAACC,KAAK,EAAE,EAAE;MACrC,CAAC;MACD;MACA2B,GAAG,EAAE,IAAIhC,KAAK,CAACiC,cAAc,CAAC,CAAC,CAAC,CAACvB,GAAG,CAACC,GAAG,EAAEC,GAAG,GAAG,EAAE;IACtD,CAAC;IACD,IAAIE,GAAG,CAACT,KAAK,CAAC0B,KAAK,EAAE;MACjBjB,GAAG,CAACM,YAAY,IAAI,CAAC;IACzB;IACA,OAAON,GAAG;EACd;AACJ,CAAC;AACD;AACA;AACA;AACA;AACAf,OAAO,CAACmC,eAAe,GAAG;EACtB1B,GAAG,EAAE,CAAC;EACNE,GAAG,EAAEA,CAACC,GAAG,EAAEC,GAAG,KAAK;IACf,OAAO;MACHuB,UAAU,EAAEpC,OAAO,CAACQ,oBAAoB,CAACI,GAAG,CAACC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACxDwB,UAAU,EAAErC,OAAO,CAACK,QAAQ,CAACO,GAAG,CAACC,GAAG,CAAC,EAAE,CAAC,CAAC;MACzCyB,SAAS,EAAEtC,OAAO,CAACK,QAAQ,CAACO,GAAG,CAACC,GAAG,CAAC,EAAE,CAAC,CAAC;MACxC0B,UAAU,EAAEvC,OAAO,CAACK,QAAQ,CAACO,GAAG,CAACC,GAAG,CAAC,EAAE,CAAC;IAC5C,CAAC;EACL;AACJ,CAAC;AACDf,OAAO,CAACE,OAAO,GAAGA,OAAO","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}