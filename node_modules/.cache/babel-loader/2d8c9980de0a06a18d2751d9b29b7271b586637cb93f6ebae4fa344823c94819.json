{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MpcSv8Parser = void 0;\nconst debug_1 = require(\"debug\");\nconst BasicParser_1 = require(\"../../common/BasicParser\");\nconst APEv2Parser_1 = require(\"../../apev2/APEv2Parser\");\nconst FourCC_1 = require(\"../../common/FourCC\");\nconst SV8 = require(\"./StreamVersion8\");\nconst debug = (0, debug_1.default)('music-metadata:parser:musepack');\nclass MpcSv8Parser extends BasicParser_1.BasicParser {\n  constructor() {\n    super(...arguments);\n    this.audioLength = 0;\n  }\n  async parse() {\n    const signature = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n    if (signature !== 'MPCK') throw new Error('Invalid Magic number');\n    this.metadata.setFormat('container', 'Musepack, SV8');\n    return this.parsePacket();\n  }\n  async parsePacket() {\n    const sv8reader = new SV8.StreamReader(this.tokenizer);\n    do {\n      const header = await sv8reader.readPacketHeader();\n      debug(`packet-header key=${header.key}, payloadLength=${header.payloadLength}`);\n      switch (header.key) {\n        case 'SH':\n          // Stream Header\n          const sh = await sv8reader.readStreamHeader(header.payloadLength);\n          this.metadata.setFormat('numberOfSamples', sh.sampleCount);\n          this.metadata.setFormat('sampleRate', sh.sampleFrequency);\n          this.metadata.setFormat('duration', sh.sampleCount / sh.sampleFrequency);\n          this.metadata.setFormat('numberOfChannels', sh.channelCount);\n          break;\n        case 'AP':\n          // Audio Packet\n          this.audioLength += header.payloadLength;\n          await this.tokenizer.ignore(header.payloadLength);\n          break;\n        case 'RG': // Replaygain\n        case 'EI': // Encoder Info\n        case 'SO': // Seek Table Offset\n        case 'ST': // Seek Table\n        case 'CT':\n          // Chapter-Tag\n          await this.tokenizer.ignore(header.payloadLength);\n          break;\n        case 'SE':\n          // Stream End\n          this.metadata.setFormat('bitrate', this.audioLength * 8 / this.metadata.format.duration);\n          return APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);\n        default:\n          throw new Error(`Unexpected header: ${header.key}`);\n      }\n    } while (true);\n  }\n}\nexports.MpcSv8Parser = MpcSv8Parser;","map":{"version":3,"names":["Object","defineProperty","exports","value","MpcSv8Parser","debug_1","require","BasicParser_1","APEv2Parser_1","FourCC_1","SV8","debug","default","BasicParser","constructor","arguments","audioLength","parse","signature","tokenizer","readToken","FourCcToken","Error","metadata","setFormat","parsePacket","sv8reader","StreamReader","header","readPacketHeader","key","payloadLength","sh","readStreamHeader","sampleCount","sampleFrequency","channelCount","ignore","format","duration","APEv2Parser","tryParseApeHeader","options"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/musepack/sv8/MpcSv8Parser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MpcSv8Parser = void 0;\nconst debug_1 = require(\"debug\");\nconst BasicParser_1 = require(\"../../common/BasicParser\");\nconst APEv2Parser_1 = require(\"../../apev2/APEv2Parser\");\nconst FourCC_1 = require(\"../../common/FourCC\");\nconst SV8 = require(\"./StreamVersion8\");\nconst debug = (0, debug_1.default)('music-metadata:parser:musepack');\nclass MpcSv8Parser extends BasicParser_1.BasicParser {\n    constructor() {\n        super(...arguments);\n        this.audioLength = 0;\n    }\n    async parse() {\n        const signature = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        if (signature !== 'MPCK')\n            throw new Error('Invalid Magic number');\n        this.metadata.setFormat('container', 'Musepack, SV8');\n        return this.parsePacket();\n    }\n    async parsePacket() {\n        const sv8reader = new SV8.StreamReader(this.tokenizer);\n        do {\n            const header = await sv8reader.readPacketHeader();\n            debug(`packet-header key=${header.key}, payloadLength=${header.payloadLength}`);\n            switch (header.key) {\n                case 'SH': // Stream Header\n                    const sh = await sv8reader.readStreamHeader(header.payloadLength);\n                    this.metadata.setFormat('numberOfSamples', sh.sampleCount);\n                    this.metadata.setFormat('sampleRate', sh.sampleFrequency);\n                    this.metadata.setFormat('duration', sh.sampleCount / sh.sampleFrequency);\n                    this.metadata.setFormat('numberOfChannels', sh.channelCount);\n                    break;\n                case 'AP': // Audio Packet\n                    this.audioLength += header.payloadLength;\n                    await this.tokenizer.ignore(header.payloadLength);\n                    break;\n                case 'RG': // Replaygain\n                case 'EI': // Encoder Info\n                case 'SO': // Seek Table Offset\n                case 'ST': // Seek Table\n                case 'CT': // Chapter-Tag\n                    await this.tokenizer.ignore(header.payloadLength);\n                    break;\n                case 'SE': // Stream End\n                    this.metadata.setFormat('bitrate', this.audioLength * 8 / this.metadata.format.duration);\n                    return APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);\n                default:\n                    throw new Error(`Unexpected header: ${header.key}`);\n            }\n        } while (true);\n    }\n}\nexports.MpcSv8Parser = MpcSv8Parser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}