{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VorbisParser = void 0;\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst VorbisDecoder_1 = require(\"./VorbisDecoder\");\nconst Vorbis_1 = require(\"./Vorbis\");\nconst debug = (0, debug_1.default)('music-metadata:parser:ogg:vorbis1');\n/**\n * Vorbis 1 Parser.\n * Used by OggParser\n */\nclass VorbisParser {\n  constructor(metadata, options) {\n    this.metadata = metadata;\n    this.options = options;\n    this.pageSegments = [];\n  }\n  /**\n   * Vorbis 1 parser\n   * @param header Ogg Page Header\n   * @param pageData Page data\n   */\n  parsePage(header, pageData) {\n    if (header.headerType.firstPage) {\n      this.parseFirstPage(header, pageData);\n    } else {\n      if (header.headerType.continued) {\n        if (this.pageSegments.length === 0) {\n          throw new Error(\"Cannot continue on previous page\");\n        }\n        this.pageSegments.push(pageData);\n      }\n      if (header.headerType.lastPage || !header.headerType.continued) {\n        // Flush page segments\n        if (this.pageSegments.length > 0) {\n          const fullPage = Buffer.concat(this.pageSegments);\n          this.parseFullPage(fullPage);\n        }\n        // Reset page segments\n        this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n      }\n    }\n    if (header.headerType.lastPage) {\n      this.calculateDuration(header);\n    }\n  }\n  flush() {\n    this.parseFullPage(Buffer.concat(this.pageSegments));\n  }\n  parseUserComment(pageData, offset) {\n    const decoder = new VorbisDecoder_1.VorbisDecoder(pageData, offset);\n    const tag = decoder.parseUserComment();\n    this.addTag(tag.key, tag.value);\n    return tag.len;\n  }\n  addTag(id, value) {\n    if (id === 'METADATA_BLOCK_PICTURE' && typeof value === 'string') {\n      if (this.options.skipCovers) {\n        debug(`Ignore picture`);\n        return;\n      }\n      value = Vorbis_1.VorbisPictureToken.fromBase64(value);\n      debug(`Push picture: id=${id}, format=${value.format}`);\n    } else {\n      debug(`Push tag: id=${id}, value=${value}`);\n    }\n    this.metadata.addTag('vorbis', id, value);\n  }\n  calculateDuration(header) {\n    if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n      // Calculate duration\n      this.metadata.setFormat('numberOfSamples', header.absoluteGranulePosition);\n      this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n    }\n  }\n  /**\n   * Parse first Ogg/Vorbis page\n   * @param {IPageHeader} header\n   * @param {Buffer} pageData\n   */\n  parseFirstPage(header, pageData) {\n    this.metadata.setFormat('codec', 'Vorbis I');\n    debug(\"Parse first page\");\n    // Parse  Vorbis common header\n    const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n    if (commonHeader.vorbis !== 'vorbis') throw new Error('Metadata does not look like Vorbis');\n    if (commonHeader.packetType === 1) {\n      const idHeader = Vorbis_1.IdentificationHeader.get(pageData, Vorbis_1.CommonHeader.len);\n      this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n      this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n      this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n      debug(\"sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s\", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n    } else throw new Error('First Ogg page should be type 1: the identification header');\n  }\n  parseFullPage(pageData) {\n    // New page\n    const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n    debug(\"Parse full page: type=%s, byteLength=%s\", commonHeader.packetType, pageData.byteLength);\n    switch (commonHeader.packetType) {\n      case 3:\n        //  type 3: comment header\n        return this.parseUserCommentList(pageData, Vorbis_1.CommonHeader.len);\n      case 1: // type 1: the identification header\n      case 5:\n        // type 5: setup header type\n        break;\n      // ignore\n    }\n  }\n  /**\n   * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n   */\n  parseUserCommentList(pageData, offset) {\n    const strLen = Token.UINT32_LE.get(pageData, offset);\n    offset += 4;\n    // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n    offset += strLen;\n    let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n    offset += 4;\n    while (userCommentListLength-- > 0) {\n      offset += this.parseUserComment(pageData, offset);\n    }\n  }\n}\nexports.VorbisParser = VorbisParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","VorbisParser","Token","require","debug_1","VorbisDecoder_1","Vorbis_1","debug","default","constructor","metadata","options","pageSegments","parsePage","header","pageData","headerType","firstPage","parseFirstPage","continued","length","Error","push","lastPage","fullPage","Buffer","concat","parseFullPage","calculateDuration","flush","parseUserComment","offset","decoder","VorbisDecoder","tag","addTag","key","len","id","skipCovers","VorbisPictureToken","fromBase64","format","sampleRate","absoluteGranulePosition","setFormat","numberOfSamples","commonHeader","CommonHeader","get","vorbis","packetType","idHeader","IdentificationHeader","bitrateNominal","channelMode","byteLength","parseUserCommentList","strLen","UINT32_LE","userCommentListLength"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VorbisParser = void 0;\nconst Token = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst VorbisDecoder_1 = require(\"./VorbisDecoder\");\nconst Vorbis_1 = require(\"./Vorbis\");\nconst debug = (0, debug_1.default)('music-metadata:parser:ogg:vorbis1');\n/**\n * Vorbis 1 Parser.\n * Used by OggParser\n */\nclass VorbisParser {\n    constructor(metadata, options) {\n        this.metadata = metadata;\n        this.options = options;\n        this.pageSegments = [];\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    parsePage(header, pageData) {\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n        else {\n            if (header.headerType.continued) {\n                if (this.pageSegments.length === 0) {\n                    throw new Error(\"Cannot continue on previous page\");\n                }\n                this.pageSegments.push(pageData);\n            }\n            if (header.headerType.lastPage || !header.headerType.continued) {\n                // Flush page segments\n                if (this.pageSegments.length > 0) {\n                    const fullPage = Buffer.concat(this.pageSegments);\n                    this.parseFullPage(fullPage);\n                }\n                // Reset page segments\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n            }\n        }\n        if (header.headerType.lastPage) {\n            this.calculateDuration(header);\n        }\n    }\n    flush() {\n        this.parseFullPage(Buffer.concat(this.pageSegments));\n    }\n    parseUserComment(pageData, offset) {\n        const decoder = new VorbisDecoder_1.VorbisDecoder(pageData, offset);\n        const tag = decoder.parseUserComment();\n        this.addTag(tag.key, tag.value);\n        return tag.len;\n    }\n    addTag(id, value) {\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\n            if (this.options.skipCovers) {\n                debug(`Ignore picture`);\n                return;\n            }\n            value = Vorbis_1.VorbisPictureToken.fromBase64(value);\n            debug(`Push picture: id=${id}, format=${value.format}`);\n        }\n        else {\n            debug(`Push tag: id=${id}, value=${value}`);\n        }\n        this.metadata.addTag('vorbis', id, value);\n    }\n    calculateDuration(header) {\n        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            this.metadata.setFormat('numberOfSamples', header.absoluteGranulePosition);\n            this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n        }\n    }\n    /**\n     * Parse first Ogg/Vorbis page\n     * @param {IPageHeader} header\n     * @param {Buffer} pageData\n     */\n    parseFirstPage(header, pageData) {\n        this.metadata.setFormat('codec', 'Vorbis I');\n        debug(\"Parse first page\");\n        // Parse  Vorbis common header\n        const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n        if (commonHeader.vorbis !== 'vorbis')\n            throw new Error('Metadata does not look like Vorbis');\n        if (commonHeader.packetType === 1) {\n            const idHeader = Vorbis_1.IdentificationHeader.get(pageData, Vorbis_1.CommonHeader.len);\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n            debug(\"sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s\", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n        }\n        else\n            throw new Error('First Ogg page should be type 1: the identification header');\n    }\n    parseFullPage(pageData) {\n        // New page\n        const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n        debug(\"Parse full page: type=%s, byteLength=%s\", commonHeader.packetType, pageData.byteLength);\n        switch (commonHeader.packetType) {\n            case 3: //  type 3: comment header\n                return this.parseUserCommentList(pageData, Vorbis_1.CommonHeader.len);\n            case 1: // type 1: the identification header\n            case 5: // type 5: setup header type\n                break; // ignore\n        }\n    }\n    /**\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n     */\n    parseUserCommentList(pageData, offset) {\n        const strLen = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n        offset += strLen;\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        while (userCommentListLength-- > 0) {\n            offset += this.parseUserComment(pageData, offset);\n        }\n    }\n}\nexports.VorbisParser = VorbisParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}