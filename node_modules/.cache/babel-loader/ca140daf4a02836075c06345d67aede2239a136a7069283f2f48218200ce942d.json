{"ast":null,"code":"/**\n * Web-Audio-API decoder\n * @module  audio-decode\n */\n\nimport getType from 'audio-type';\nimport AudioBufferShim from 'audio-buffer';\nconst AudioBuffer = globalThis.AudioBuffer || AudioBufferShim;\n\n/**\n * Decode an audio buffer.\n *\n * @param {ArrayBuffer | Uint8Array} buf - The audio data to decode.\n * @returns {Promise<AudioBuffer>} A promise that resolves to the decoded audio buffer.\n * @throws {Error} Throws an error if the decode target is invalid or if the audio format is not supported.\n */\nexport default async function audioDecode(buf) {\n  if (!buf && !(buf.length || buf.buffer)) throw Error('Bad decode target');\n  buf = new Uint8Array(buf.buffer || buf);\n  let type = getType(buf);\n  if (!type) throw Error('Cannot detect audio format');\n  if (!decoders[type]) throw Error('Missing decoder for ' + type + ' format');\n  return decoders[type](buf);\n}\n;\nexport const decoders = {\n  async oga(buf) {\n    let {\n      decoder\n    } = decoders.oga;\n    if (!decoder) {\n      let {\n        OggVorbisDecoder\n      } = await import('@wasm-audio-decoders/ogg-vorbis');\n      await (decoders.oga.decoder = decoder = new OggVorbisDecoder()).ready;\n    } else await decoder.reset();\n    return buf && createBuffer(await decoder.decodeFile(buf));\n  },\n  async mp3(buf) {\n    let {\n      decoder\n    } = decoders.mp3;\n    if (!decoder) {\n      const {\n        MPEGDecoder\n      } = await import('mpg123-decoder');\n      await (decoders.mp3.decoder = decoder = new MPEGDecoder()).ready;\n    } else await decoder.reset();\n    return buf && createBuffer(await decoder.decode(buf));\n  },\n  async flac(buf) {\n    let {\n      decoder\n    } = decoders.flac;\n    if (!decoder) {\n      const {\n        FLACDecoder\n      } = await import('@wasm-audio-decoders/flac');\n      await (decoders.flac.decoder = decoder = new FLACDecoder()).ready;\n    } else await decoder.reset();\n    return buf && createBuffer(await decoder.decode(buf));\n  },\n  async opus(buf) {\n    let {\n      decoder\n    } = decoders.opus;\n    if (!decoder) {\n      const {\n        OggOpusDecoder\n      } = await import('ogg-opus-decoder');\n      await (decoders.opus.decoder = decoder = new OggOpusDecoder()).ready;\n    } else await decoder.reset();\n    return buf && createBuffer(await decoder.decodeFile(buf));\n  },\n  async wav(buf) {\n    let {\n      decode\n    } = decoders.wav;\n    if (!decode) {\n      let module = await import('node-wav');\n      decode = decoders.wav.decode = module.default.decode;\n    }\n    return buf && createBuffer(await decode(buf));\n  },\n  async qoa(buf) {\n    let {\n      decode\n    } = decoders.qoa;\n    if (!decode) {\n      decoders.qoa.decode = decode = (await import('qoa-format')).decode;\n    }\n    return buf && createBuffer(await decode(buf));\n  }\n};\nfunction createBuffer({\n  channelData,\n  sampleRate\n}) {\n  let audioBuffer = new AudioBuffer({\n    sampleRate,\n    length: channelData[0].length,\n    numberOfChannels: channelData.length\n  });\n  for (let ch = 0; ch < channelData.length; ch++) audioBuffer.getChannelData(ch).set(channelData[ch]);\n  return audioBuffer;\n}","map":{"version":3,"names":["getType","AudioBufferShim","AudioBuffer","globalThis","audioDecode","buf","length","buffer","Error","Uint8Array","type","decoders","oga","decoder","OggVorbisDecoder","ready","reset","createBuffer","decodeFile","mp3","MPEGDecoder","decode","flac","FLACDecoder","opus","OggOpusDecoder","wav","module","default","qoa","channelData","sampleRate","audioBuffer","numberOfChannels","ch","getChannelData","set"],"sources":["C:/Users/vanitas/node_modules/audio-decode/audio-decode.js"],"sourcesContent":["/**\n * Web-Audio-API decoder\n * @module  audio-decode\n */\n\nimport getType from 'audio-type';\nimport AudioBufferShim from 'audio-buffer';\n\nconst AudioBuffer = globalThis.AudioBuffer || AudioBufferShim;\n\n/**\n * Decode an audio buffer.\n *\n * @param {ArrayBuffer | Uint8Array} buf - The audio data to decode.\n * @returns {Promise<AudioBuffer>} A promise that resolves to the decoded audio buffer.\n * @throws {Error} Throws an error if the decode target is invalid or if the audio format is not supported.\n */\nexport default async function audioDecode(buf) {\n\tif (!buf && !(buf.length || buf.buffer)) throw Error('Bad decode target')\n\tbuf = new Uint8Array(buf.buffer || buf)\n\n\tlet type = getType(buf);\n\n\tif (!type) throw Error('Cannot detect audio format');\n\n\tif (!decoders[type]) throw Error('Missing decoder for ' + type + ' format')\n\n\treturn decoders[type](buf)\n};\n\nexport const decoders = {\n\tasync oga(buf) {\n\t\tlet { decoder } = decoders.oga\n\t\tif (!decoder) {\n\t\t\tlet { OggVorbisDecoder } = await import('@wasm-audio-decoders/ogg-vorbis')\n\t\t\tawait (decoders.oga.decoder = decoder = new OggVorbisDecoder()).ready;\n\t\t} else await decoder.reset()\n\t\treturn buf && createBuffer(await decoder.decodeFile(buf))\n\t},\n\tasync mp3(buf) {\n\t\tlet { decoder } = decoders.mp3\n\t\tif (!decoder) {\n\t\t\tconst { MPEGDecoder } = await import('mpg123-decoder')\n\t\t\tawait (decoders.mp3.decoder = decoder = new MPEGDecoder()).ready;\n\t\t}\n\t\telse await decoder.reset()\n\t\treturn buf && createBuffer(await decoder.decode(buf))\n\t},\n\tasync flac(buf) {\n\t\tlet { decoder } = decoders.flac\n\t\tif (!decoder) {\n\t\t\tconst { FLACDecoder } = await import('@wasm-audio-decoders/flac')\n\t\t\tawait (decoders.flac.decoder = decoder = new FLACDecoder()).ready\n\t\t}\n\t\telse await decoder.reset()\n\t\treturn buf && createBuffer(await decoder.decode(buf))\n\t},\n\tasync opus(buf) {\n\t\tlet { decoder } = decoders.opus\n\t\tif (!decoder) {\n\t\t\tconst { OggOpusDecoder } = await import('ogg-opus-decoder')\n\t\t\tawait (decoders.opus.decoder = decoder = new OggOpusDecoder()).ready\n\t\t}\n\t\telse await decoder.reset()\n\t\treturn buf && createBuffer(await decoder.decodeFile(buf))\n\t},\n\tasync wav(buf) {\n\t\tlet { decode } = decoders.wav\n\t\tif (!decode) {\n\t\t\tlet module = await import('node-wav')\n\t\t\tdecode = decoders.wav.decode = module.default.decode\n\t\t}\n\t\treturn buf && createBuffer(await decode(buf))\n\t},\n\tasync qoa(buf) {\n\t\tlet { decode } = decoders.qoa\n\t\tif (!decode) {\n\t\t\tdecoders.qoa.decode = decode = (await import('qoa-format')).decode\n\t\t}\n\t\treturn buf && createBuffer(await decode(buf))\n\t}\n}\n\nfunction createBuffer({ channelData, sampleRate }) {\n\tlet audioBuffer = new AudioBuffer({\n\t\tsampleRate,\n\t\tlength: channelData[0].length,\n\t\tnumberOfChannels: channelData.length\n\t})\n\tfor (let ch = 0; ch < channelData.length; ch++) audioBuffer.getChannelData(ch).set(channelData[ch])\n\treturn audioBuffer\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}