{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeLibSignalRepository = void 0;\nconst libsignal = __importStar(require(\"libsignal\"));\nconst WASignalGroup_1 = require(\"../../WASignalGroup\");\nconst Utils_1 = require(\"../Utils\");\nconst WABinary_1 = require(\"../WABinary\");\nfunction makeLibSignalRepository(auth) {\n  const storage = signalStorage(auth);\n  return {\n    decryptGroupMessage({\n      group,\n      authorJid,\n      msg\n    }) {\n      const senderName = jidToSignalSenderKeyName(group, authorJid);\n      const cipher = new WASignalGroup_1.GroupCipher(storage, senderName);\n      return cipher.decrypt(msg);\n    },\n    async processSenderKeyDistributionMessage({\n      item,\n      authorJid\n    }) {\n      const builder = new WASignalGroup_1.GroupSessionBuilder(storage);\n      const senderName = jidToSignalSenderKeyName(item.groupId, authorJid);\n      const senderMsg = new WASignalGroup_1.SenderKeyDistributionMessage(null, null, null, null, item.axolotlSenderKeyDistributionMessage);\n      const {\n        [senderName]: senderKey\n      } = await auth.keys.get('sender-key', [senderName]);\n      if (!senderKey) {\n        await storage.storeSenderKey(senderName, new WASignalGroup_1.SenderKeyRecord());\n      }\n      await builder.process(senderName, senderMsg);\n    },\n    async decryptMessage({\n      jid,\n      type,\n      ciphertext\n    }) {\n      const addr = jidToSignalProtocolAddress(jid);\n      const session = new libsignal.SessionCipher(storage, addr);\n      let result;\n      switch (type) {\n        case 'pkmsg':\n          result = await session.decryptPreKeyWhisperMessage(ciphertext);\n          break;\n        case 'msg':\n          result = await session.decryptWhisperMessage(ciphertext);\n          break;\n      }\n      return result;\n    },\n    async encryptMessage({\n      jid,\n      data\n    }) {\n      const addr = jidToSignalProtocolAddress(jid);\n      const cipher = new libsignal.SessionCipher(storage, addr);\n      const {\n        type: sigType,\n        body\n      } = await cipher.encrypt(data);\n      const type = sigType === 3 ? 'pkmsg' : 'msg';\n      return {\n        type,\n        ciphertext: Buffer.from(body, 'binary')\n      };\n    },\n    async encryptGroupMessage({\n      group,\n      meId,\n      data\n    }) {\n      const senderName = jidToSignalSenderKeyName(group, meId);\n      const builder = new WASignalGroup_1.GroupSessionBuilder(storage);\n      const {\n        [senderName]: senderKey\n      } = await auth.keys.get('sender-key', [senderName]);\n      if (!senderKey) {\n        await storage.storeSenderKey(senderName, new WASignalGroup_1.SenderKeyRecord());\n      }\n      const senderKeyDistributionMessage = await builder.create(senderName);\n      const session = new WASignalGroup_1.GroupCipher(storage, senderName);\n      const ciphertext = await session.encrypt(data);\n      return {\n        ciphertext,\n        senderKeyDistributionMessage: senderKeyDistributionMessage.serialize()\n      };\n    },\n    async injectE2ESession({\n      jid,\n      session\n    }) {\n      const cipher = new libsignal.SessionBuilder(storage, jidToSignalProtocolAddress(jid));\n      await cipher.initOutgoing(session);\n    },\n    jidToSignalProtocolAddress(jid) {\n      return jidToSignalProtocolAddress(jid).toString();\n    }\n  };\n}\nexports.makeLibSignalRepository = makeLibSignalRepository;\nconst jidToSignalProtocolAddress = jid => {\n  const {\n    user,\n    device\n  } = (0, WABinary_1.jidDecode)(jid);\n  return new libsignal.ProtocolAddress(user, device || 0);\n};\nconst jidToSignalSenderKeyName = (group, user) => {\n  return new WASignalGroup_1.SenderKeyName(group, jidToSignalProtocolAddress(user)).toString();\n};\nfunction signalStorage({\n  creds,\n  keys\n}) {\n  return {\n    loadSession: async id => {\n      const {\n        [id]: sess\n      } = await keys.get('session', [id]);\n      if (sess) {\n        return libsignal.SessionRecord.deserialize(sess);\n      }\n    },\n    storeSession: async (id, session) => {\n      await keys.set({\n        'session': {\n          [id]: session.serialize()\n        }\n      });\n    },\n    isTrustedIdentity: () => {\n      return true;\n    },\n    loadPreKey: async id => {\n      const keyId = id.toString();\n      const {\n        [keyId]: key\n      } = await keys.get('pre-key', [keyId]);\n      if (key) {\n        return {\n          privKey: Buffer.from(key.private),\n          pubKey: Buffer.from(key.public)\n        };\n      }\n    },\n    removePreKey: id => keys.set({\n      'pre-key': {\n        [id]: null\n      }\n    }),\n    loadSignedPreKey: () => {\n      const key = creds.signedPreKey;\n      return {\n        privKey: Buffer.from(key.keyPair.private),\n        pubKey: Buffer.from(key.keyPair.public)\n      };\n    },\n    loadSenderKey: async keyId => {\n      const {\n        [keyId]: key\n      } = await keys.get('sender-key', [keyId]);\n      if (key) {\n        return new WASignalGroup_1.SenderKeyRecord(key);\n      }\n    },\n    storeSenderKey: async (keyId, key) => {\n      await keys.set({\n        'sender-key': {\n          [keyId]: key.serialize()\n        }\n      });\n    },\n    getOurRegistrationId: () => creds.registrationId,\n    getOurIdentity: () => {\n      const {\n        signedIdentityKey\n      } = creds;\n      return {\n        privKey: Buffer.from(signedIdentityKey.private),\n        pubKey: (0, Utils_1.generateSignalPubKey)(signedIdentityKey.public)\n      };\n    }\n  };\n}","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","makeLibSignalRepository","libsignal","require","WASignalGroup_1","Utils_1","WABinary_1","auth","storage","signalStorage","decryptGroupMessage","group","authorJid","msg","senderName","jidToSignalSenderKeyName","cipher","GroupCipher","decrypt","processSenderKeyDistributionMessage","item","builder","GroupSessionBuilder","groupId","senderMsg","SenderKeyDistributionMessage","axolotlSenderKeyDistributionMessage","senderKey","keys","storeSenderKey","SenderKeyRecord","process","decryptMessage","jid","type","ciphertext","addr","jidToSignalProtocolAddress","session","SessionCipher","decryptPreKeyWhisperMessage","decryptWhisperMessage","encryptMessage","data","sigType","body","encrypt","Buffer","from","encryptGroupMessage","meId","senderKeyDistributionMessage","serialize","injectE2ESession","SessionBuilder","initOutgoing","toString","user","device","jidDecode","ProtocolAddress","SenderKeyName","creds","loadSession","id","sess","SessionRecord","deserialize","storeSession","set","isTrustedIdentity","loadPreKey","keyId","key","privKey","private","pubKey","public","removePreKey","loadSignedPreKey","signedPreKey","keyPair","loadSenderKey","getOurRegistrationId","registrationId","getOurIdentity","signedIdentityKey","generateSignalPubKey"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Signal/libsignal.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeLibSignalRepository = void 0;\nconst libsignal = __importStar(require(\"libsignal\"));\nconst WASignalGroup_1 = require(\"../../WASignalGroup\");\nconst Utils_1 = require(\"../Utils\");\nconst WABinary_1 = require(\"../WABinary\");\nfunction makeLibSignalRepository(auth) {\n    const storage = signalStorage(auth);\n    return {\n        decryptGroupMessage({ group, authorJid, msg }) {\n            const senderName = jidToSignalSenderKeyName(group, authorJid);\n            const cipher = new WASignalGroup_1.GroupCipher(storage, senderName);\n            return cipher.decrypt(msg);\n        },\n        async processSenderKeyDistributionMessage({ item, authorJid }) {\n            const builder = new WASignalGroup_1.GroupSessionBuilder(storage);\n            const senderName = jidToSignalSenderKeyName(item.groupId, authorJid);\n            const senderMsg = new WASignalGroup_1.SenderKeyDistributionMessage(null, null, null, null, item.axolotlSenderKeyDistributionMessage);\n            const { [senderName]: senderKey } = await auth.keys.get('sender-key', [senderName]);\n            if (!senderKey) {\n                await storage.storeSenderKey(senderName, new WASignalGroup_1.SenderKeyRecord());\n            }\n            await builder.process(senderName, senderMsg);\n        },\n        async decryptMessage({ jid, type, ciphertext }) {\n            const addr = jidToSignalProtocolAddress(jid);\n            const session = new libsignal.SessionCipher(storage, addr);\n            let result;\n            switch (type) {\n                case 'pkmsg':\n                    result = await session.decryptPreKeyWhisperMessage(ciphertext);\n                    break;\n                case 'msg':\n                    result = await session.decryptWhisperMessage(ciphertext);\n                    break;\n            }\n            return result;\n        },\n        async encryptMessage({ jid, data }) {\n            const addr = jidToSignalProtocolAddress(jid);\n            const cipher = new libsignal.SessionCipher(storage, addr);\n            const { type: sigType, body } = await cipher.encrypt(data);\n            const type = sigType === 3 ? 'pkmsg' : 'msg';\n            return { type, ciphertext: Buffer.from(body, 'binary') };\n        },\n        async encryptGroupMessage({ group, meId, data }) {\n            const senderName = jidToSignalSenderKeyName(group, meId);\n            const builder = new WASignalGroup_1.GroupSessionBuilder(storage);\n            const { [senderName]: senderKey } = await auth.keys.get('sender-key', [senderName]);\n            if (!senderKey) {\n                await storage.storeSenderKey(senderName, new WASignalGroup_1.SenderKeyRecord());\n            }\n            const senderKeyDistributionMessage = await builder.create(senderName);\n            const session = new WASignalGroup_1.GroupCipher(storage, senderName);\n            const ciphertext = await session.encrypt(data);\n            return {\n                ciphertext,\n                senderKeyDistributionMessage: senderKeyDistributionMessage.serialize(),\n            };\n        },\n        async injectE2ESession({ jid, session }) {\n            const cipher = new libsignal.SessionBuilder(storage, jidToSignalProtocolAddress(jid));\n            await cipher.initOutgoing(session);\n        },\n        jidToSignalProtocolAddress(jid) {\n            return jidToSignalProtocolAddress(jid).toString();\n        },\n    };\n}\nexports.makeLibSignalRepository = makeLibSignalRepository;\nconst jidToSignalProtocolAddress = (jid) => {\n    const { user, device } = (0, WABinary_1.jidDecode)(jid);\n    return new libsignal.ProtocolAddress(user, device || 0);\n};\nconst jidToSignalSenderKeyName = (group, user) => {\n    return new WASignalGroup_1.SenderKeyName(group, jidToSignalProtocolAddress(user)).toString();\n};\nfunction signalStorage({ creds, keys }) {\n    return {\n        loadSession: async (id) => {\n            const { [id]: sess } = await keys.get('session', [id]);\n            if (sess) {\n                return libsignal.SessionRecord.deserialize(sess);\n            }\n        },\n        storeSession: async (id, session) => {\n            await keys.set({ 'session': { [id]: session.serialize() } });\n        },\n        isTrustedIdentity: () => {\n            return true;\n        },\n        loadPreKey: async (id) => {\n            const keyId = id.toString();\n            const { [keyId]: key } = await keys.get('pre-key', [keyId]);\n            if (key) {\n                return {\n                    privKey: Buffer.from(key.private),\n                    pubKey: Buffer.from(key.public)\n                };\n            }\n        },\n        removePreKey: (id) => keys.set({ 'pre-key': { [id]: null } }),\n        loadSignedPreKey: () => {\n            const key = creds.signedPreKey;\n            return {\n                privKey: Buffer.from(key.keyPair.private),\n                pubKey: Buffer.from(key.keyPair.public)\n            };\n        },\n        loadSenderKey: async (keyId) => {\n            const { [keyId]: key } = await keys.get('sender-key', [keyId]);\n            if (key) {\n                return new WASignalGroup_1.SenderKeyRecord(key);\n            }\n        },\n        storeSenderKey: async (keyId, key) => {\n            await keys.set({ 'sender-key': { [keyId]: key.serialize() } });\n        },\n        getOurRegistrationId: () => (creds.registrationId),\n        getOurIdentity: () => {\n            const { signedIdentityKey } = creds;\n            return {\n                privKey: Buffer.from(signedIdentityKey.private),\n                pubKey: (0, Utils_1.generateSignalPubKey)(signedIdentityKey.public),\n            };\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}