{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DsfParser = void 0;\nconst debug_1 = require(\"debug\");\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\nconst DsfChunk_1 = require(\"./DsfChunk\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst debug = (0, debug_1.default)('music-metadata:parser:DSF');\n/**\n * DSF (dsd stream file) File Parser\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\n */\nclass DsfParser extends AbstractID3Parser_1.AbstractID3Parser {\n  async postId3v2Parse() {\n    const p0 = this.tokenizer.position; // mark start position, normally 0\n    const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n    if (chunkHeader.id !== 'DSD ') throw new Error('Invalid chunk signature');\n    this.metadata.setFormat('container', 'DSF');\n    this.metadata.setFormat('lossless', true);\n    const dsdChunk = await this.tokenizer.readToken(DsfChunk_1.DsdChunk);\n    if (dsdChunk.metadataPointer === BigInt(0)) {\n      debug(`No ID3v2 tag present`);\n    } else {\n      debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\n      await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);\n      // Jump to ID3 header\n      await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);\n      return new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\n    }\n  }\n  async parseChunks(bytesRemaining) {\n    while (bytesRemaining >= DsfChunk_1.ChunkHeader.len) {\n      const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n      debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\n      switch (chunkHeader.id) {\n        case 'fmt ':\n          const formatChunk = await this.tokenizer.readToken(DsfChunk_1.FormatChunk);\n          this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\n          this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\n          this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\n          this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\n          this.metadata.setFormat('duration', Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);\n          const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\n          this.metadata.setFormat('bitrate', bitrate);\n          return;\n        // We got what we want, stop further processing of chunks\n        default:\n          this.tokenizer.ignore(Number(chunkHeader.size) - DsfChunk_1.ChunkHeader.len);\n          break;\n      }\n      bytesRemaining -= chunkHeader.size;\n    }\n  }\n}\nexports.DsfParser = DsfParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","DsfParser","debug_1","require","AbstractID3Parser_1","DsfChunk_1","ID3v2Parser_1","debug","default","AbstractID3Parser","postId3v2Parse","p0","tokenizer","position","chunkHeader","readToken","ChunkHeader","id","Error","metadata","setFormat","dsdChunk","DsdChunk","metadataPointer","BigInt","parseChunks","fileSize","size","ignore","Number","ID3v2Parser","parse","options","bytesRemaining","len","formatChunk","FormatChunk","channelNum","samplingFrequency","bitsPerSample","sampleCount","bitrate"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/dsf/DsfParser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DsfParser = void 0;\nconst debug_1 = require(\"debug\");\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\nconst DsfChunk_1 = require(\"./DsfChunk\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst debug = (0, debug_1.default)('music-metadata:parser:DSF');\n/**\n * DSF (dsd stream file) File Parser\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\n */\nclass DsfParser extends AbstractID3Parser_1.AbstractID3Parser {\n    async postId3v2Parse() {\n        const p0 = this.tokenizer.position; // mark start position, normally 0\n        const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n        if (chunkHeader.id !== 'DSD ')\n            throw new Error('Invalid chunk signature');\n        this.metadata.setFormat('container', 'DSF');\n        this.metadata.setFormat('lossless', true);\n        const dsdChunk = await this.tokenizer.readToken(DsfChunk_1.DsdChunk);\n        if (dsdChunk.metadataPointer === BigInt(0)) {\n            debug(`No ID3v2 tag present`);\n        }\n        else {\n            debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\n            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);\n            // Jump to ID3 header\n            await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);\n            return new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\n        }\n    }\n    async parseChunks(bytesRemaining) {\n        while (bytesRemaining >= DsfChunk_1.ChunkHeader.len) {\n            const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n            debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\n            switch (chunkHeader.id) {\n                case 'fmt ':\n                    const formatChunk = await this.tokenizer.readToken(DsfChunk_1.FormatChunk);\n                    this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\n                    this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\n                    this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\n                    this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\n                    this.metadata.setFormat('duration', Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);\n                    const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\n                    this.metadata.setFormat('bitrate', bitrate);\n                    return; // We got what we want, stop further processing of chunks\n                default:\n                    this.tokenizer.ignore(Number(chunkHeader.size) - DsfChunk_1.ChunkHeader.len);\n                    break;\n            }\n            bytesRemaining -= chunkHeader.size;\n        }\n    }\n}\nexports.DsfParser = DsfParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}