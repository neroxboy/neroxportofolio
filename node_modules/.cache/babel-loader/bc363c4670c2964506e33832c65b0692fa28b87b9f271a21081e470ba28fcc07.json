{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultConfig = exports[\"default\"] = void 0;\nvar _reactFastCompare = _interopRequireDefault(require(\"react-fast-compare\"));\nvar _utils = require(\"./utils\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar defaultConfig = {\n  color: '#dee4fd',\n  radius: [0.5, 3.0],\n  speed: [1.0, 3.0],\n  wind: [-0.5, 2.0],\n  changeFrequency: 200,\n  rotationSpeed: [-1.0, 1.0]\n};\nexports.defaultConfig = defaultConfig;\n\n/**\r\n * An individual snowflake that will update it's location every call to `update`\r\n * and draw itself to the canvas every call to `draw`.\r\n */\nvar Snowflake = /*#__PURE__*/function () {\n  function Snowflake(canvas) {\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Snowflake);\n    _defineProperty(this, \"config\", void 0);\n    _defineProperty(this, \"params\", void 0);\n    _defineProperty(this, \"framesSinceLastUpdate\", void 0);\n    _defineProperty(this, \"image\", void 0);\n\n    // Set custom config\n    this.updateConfig(config); // Setting initial parameters\n\n    var _this$config = this.config,\n      radius = _this$config.radius,\n      wind = _this$config.wind,\n      speed = _this$config.speed,\n      rotationSpeed = _this$config.rotationSpeed;\n    this.params = {\n      x: (0, _utils.random)(0, canvas.offsetWidth),\n      y: (0, _utils.random)(-canvas.offsetHeight, 0),\n      rotation: (0, _utils.random)(0, 360),\n      radius: _utils.random.apply(void 0, _toConsumableArray(radius)),\n      speed: _utils.random.apply(void 0, _toConsumableArray(speed)),\n      wind: _utils.random.apply(void 0, _toConsumableArray(wind)),\n      rotationSpeed: _utils.random.apply(void 0, _toConsumableArray(rotationSpeed)),\n      nextSpeed: _utils.random.apply(void 0, _toConsumableArray(wind)),\n      nextWind: _utils.random.apply(void 0, _toConsumableArray(speed)),\n      nextRotationSpeed: _utils.random.apply(void 0, _toConsumableArray(rotationSpeed))\n    };\n    this.framesSinceLastUpdate = 0;\n  }\n  _createClass(Snowflake, [{\n    key: \"selectImage\",\n    value: function selectImage() {\n      if (this.config.images && this.config.images.length > 0) {\n        this.image = (0, _utils.randomElement)(this.config.images);\n      } else {\n        this.image = undefined;\n      }\n    }\n  }, {\n    key: \"updateConfig\",\n    value: function updateConfig(config) {\n      var previousConfig = this.config;\n      this.config = _objectSpread(_objectSpread({}, defaultConfig), config);\n      this.config.changeFrequency = (0, _utils.random)(this.config.changeFrequency, this.config.changeFrequency * 1.5); // Update the radius if the config has changed, it won't gradually update on it's own\n\n      if (this.params && !(0, _reactFastCompare[\"default\"])(this.config.radius, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.radius)) {\n        this.params.radius = _utils.random.apply(void 0, _toConsumableArray(this.config.radius));\n      }\n      if (!(0, _reactFastCompare[\"default\"])(this.config.images, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.images)) {\n        this.selectImage();\n      }\n    }\n  }, {\n    key: \"updateTargetParams\",\n    value: function updateTargetParams() {\n      this.params.nextSpeed = _utils.random.apply(void 0, _toConsumableArray(this.config.speed));\n      this.params.nextWind = _utils.random.apply(void 0, _toConsumableArray(this.config.wind));\n      if (this.image) {\n        this.params.nextRotationSpeed = _utils.random.apply(void 0, _toConsumableArray(this.config.rotationSpeed));\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(canvas) {\n      var framesPassed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var _this$params = this.params,\n        x = _this$params.x,\n        y = _this$params.y,\n        rotation = _this$params.rotation,\n        rotationSpeed = _this$params.rotationSpeed,\n        nextRotationSpeed = _this$params.nextRotationSpeed,\n        wind = _this$params.wind,\n        speed = _this$params.speed,\n        nextWind = _this$params.nextWind,\n        nextSpeed = _this$params.nextSpeed,\n        radius = _this$params.radius; // Update current location, wrapping around if going off the canvas\n\n      this.params.x = (x + wind * framesPassed) % (canvas.offsetWidth + radius * 2);\n      if (this.params.x > canvas.offsetWidth + radius) this.params.x = -radius;\n      this.params.y = (y + speed * framesPassed) % (canvas.offsetHeight + radius * 2);\n      if (this.params.y > canvas.offsetHeight + radius) this.params.y = -radius; // Apply rotation\n\n      if (this.image) {\n        this.params.rotation = (rotation + rotationSpeed) % 360;\n      } // Update the wind, speed and rotation towards the desired values\n\n      this.params.speed = (0, _utils.lerp)(speed, nextSpeed, 0.01);\n      this.params.wind = (0, _utils.lerp)(wind, nextWind, 0.01);\n      this.params.rotationSpeed = (0, _utils.lerp)(rotationSpeed, nextRotationSpeed, 0.01);\n      if (this.framesSinceLastUpdate++ > this.config.changeFrequency) {\n        this.updateTargetParams();\n        this.framesSinceLastUpdate = 0;\n      }\n    }\n  }, {\n    key: \"getImageOffscreenCanvas\",\n    value: function getImageOffscreenCanvas(image, size) {\n      var _sizes$size;\n      if (image instanceof HTMLImageElement && image.loading) return image;\n      var sizes = Snowflake.offscreenCanvases.get(image);\n      if (!sizes) {\n        sizes = {};\n        Snowflake.offscreenCanvases.set(image, sizes);\n      }\n      if (!(size in sizes)) {\n        var _canvas$getContext;\n        var canvas = document.createElement('canvas');\n        canvas.width = size;\n        canvas.height = size;\n        (_canvas$getContext = canvas.getContext('2d')) === null || _canvas$getContext === void 0 ? void 0 : _canvas$getContext.drawImage(image, 0, 0, size, size);\n        sizes[size] = canvas;\n      }\n      return (_sizes$size = sizes[size]) !== null && _sizes$size !== void 0 ? _sizes$size : image;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      if (this.image) {\n        // ctx.save()\n        // ctx.translate(this.params.x, this.params.y)\n        ctx.setTransform(1, 0, 0, 1, this.params.x, this.params.y);\n        var radius = Math.ceil(this.params.radius);\n        ctx.rotate(this.params.rotation * Math.PI / 180);\n        ctx.drawImage(this.getImageOffscreenCanvas(this.image, radius), -Math.ceil(radius / 2), -Math.ceil(radius / 2), radius, radius); // ctx.restore()\n      } else {\n        ctx.beginPath();\n        ctx.arc(this.params.x, this.params.y, this.params.radius, 0, 2 * Math.PI);\n        ctx.fillStyle = this.config.color;\n        ctx.closePath();\n        ctx.fill();\n      }\n    }\n  }]);\n  return Snowflake;\n}();\n_defineProperty(Snowflake, \"offscreenCanvases\", new WeakMap());\nvar _default = Snowflake;\nexports[\"default\"] = _default;","map":{"version":3,"names":["_reactFastCompare","_interopRequireDefault","require","_utils","defaultConfig","color","radius","speed","wind","changeFrequency","rotationSpeed","Snowflake","canvas","config","arguments","length","undefined","_classCallCheck","_defineProperty","updateConfig","_this$config","params","x","random","offsetWidth","y","offsetHeight","rotation","apply","_toConsumableArray","nextSpeed","nextWind","nextRotationSpeed","framesSinceLastUpdate","selectImage","images","image","randomElement","previousConfig","_objectSpread","updateTargetParams","update","framesPassed","_this$params","lerp","getImageOffscreenCanvas","size","_sizes$size","HTMLImageElement","loading","sizes","offscreenCanvases","get","set","_canvas$getContext","document","createElement","width","height","getContext","drawImage","draw","ctx","setTransform","Math","ceil","rotate","PI","beginPath","arc","fillStyle","closePath","fill","WeakMap"],"sources":["C:\\Users\\vanitas\\Downloads\\tesskil\\node_modules\\react-snowfall\\src\\Snowflake.ts"],"sourcesContent":["import isEqual from 'react-fast-compare'\r\nimport { lerp, random, randomElement } from './utils'\r\n\r\nexport interface SnowflakeProps {\r\n  /** The color of the snowflake, can be any valid CSS color. */\r\n  color: string\r\n  /**\r\n   * The minimum and maximum radius of the snowflake, will be\r\n   * randomly selected within this range.\r\n   *\r\n   * The default value is `[0.5, 3.0]`.\r\n   */\r\n  radius: [number, number]\r\n  /**\r\n   * The minimum and maximum speed of the snowflake.\r\n   *\r\n   * The speed determines how quickly the snowflake moves\r\n   * along the y axis (vertical speed).\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[1.0, 3.0]`.\r\n   */\r\n  speed: [number, number]\r\n  /**\r\n   * The minimum and maximum wind of the snowflake.\r\n   *\r\n   * The wind determines how quickly the snowflake moves\r\n   * along the x axis (horizontal speed).\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[-0.5, 2.0]`.\r\n   */\r\n  wind: [number, number]\r\n  /**\r\n   * The frequency in frames that the wind and speed values\r\n   * will update.\r\n   *\r\n   * The default value is 200.\r\n   */\r\n  changeFrequency: number\r\n  /**\r\n   * An array of images that will be rendered as the snowflakes instead\r\n   * of the default circle shapes.\r\n   */\r\n  images?: CanvasImageSource[]\r\n  /**\r\n   * The minimum and maximum rotation speed of the snowflake (in degrees of\r\n   * rotation per frame).\r\n   *\r\n   * The rotation speed determines how quickly the snowflake rotates when\r\n   * an image is being rendered.\r\n   *\r\n   * The values will be randomly selected within this range.\r\n   *\r\n   * The default value is `[-1.0, 1.0]`.\r\n   */\r\n  rotationSpeed: [number, number]\r\n}\r\n\r\nexport type SnowflakeConfig = Partial<SnowflakeProps>\r\n\r\nexport const defaultConfig: SnowflakeProps = {\r\n  color: '#dee4fd',\r\n  radius: [0.5, 3.0],\r\n  speed: [1.0, 3.0],\r\n  wind: [-0.5, 2.0],\r\n  changeFrequency: 200,\r\n  rotationSpeed: [-1.0, 1.0],\r\n}\r\n\r\ninterface SnowflakeParams {\r\n  x: number\r\n  y: number\r\n  radius: number\r\n  rotation: number\r\n  rotationSpeed: number\r\n  speed: number\r\n  wind: number\r\n  nextSpeed: number\r\n  nextWind: number\r\n  nextRotationSpeed: number\r\n}\r\n\r\n/**\r\n * An individual snowflake that will update it's location every call to `update`\r\n * and draw itself to the canvas every call to `draw`.\r\n */\r\nclass Snowflake {\r\n  static offscreenCanvases = new WeakMap<CanvasImageSource, Record<number, HTMLCanvasElement>>()\r\n\r\n  private config!: SnowflakeProps\r\n  private params: SnowflakeParams\r\n  private framesSinceLastUpdate: number\r\n  private image?: CanvasImageSource\r\n\r\n  public constructor(canvas: HTMLCanvasElement, config: SnowflakeConfig = {}) {\r\n    // Set custom config\r\n    this.updateConfig(config)\r\n\r\n    // Setting initial parameters\r\n    const { radius, wind, speed, rotationSpeed } = this.config\r\n\r\n    this.params = {\r\n      x: random(0, canvas.offsetWidth),\r\n      y: random(-canvas.offsetHeight, 0),\r\n      rotation: random(0, 360),\r\n      radius: random(...radius),\r\n      speed: random(...speed),\r\n      wind: random(...wind),\r\n      rotationSpeed: random(...rotationSpeed),\r\n      nextSpeed: random(...wind),\r\n      nextWind: random(...speed),\r\n      nextRotationSpeed: random(...rotationSpeed),\r\n    }\r\n\r\n    this.framesSinceLastUpdate = 0\r\n  }\r\n\r\n  private selectImage() {\r\n    if (this.config.images && this.config.images.length > 0) {\r\n      this.image = randomElement(this.config.images)\r\n    } else {\r\n      this.image = undefined\r\n    }\r\n  }\r\n\r\n  public updateConfig(config: SnowflakeConfig): void {\r\n    const previousConfig = this.config\r\n    this.config = { ...defaultConfig, ...config }\r\n    this.config.changeFrequency = random(this.config.changeFrequency, this.config.changeFrequency * 1.5)\r\n\r\n    // Update the radius if the config has changed, it won't gradually update on it's own\r\n    if (this.params && !isEqual(this.config.radius, previousConfig?.radius)) {\r\n      this.params.radius = random(...this.config.radius)\r\n    }\r\n\r\n    if (!isEqual(this.config.images, previousConfig?.images)) {\r\n      this.selectImage()\r\n    }\r\n  }\r\n\r\n  private updateTargetParams(): void {\r\n    this.params.nextSpeed = random(...this.config.speed)\r\n    this.params.nextWind = random(...this.config.wind)\r\n    if (this.image) {\r\n      this.params.nextRotationSpeed = random(...this.config.rotationSpeed)\r\n    }\r\n  }\r\n\r\n  public update(canvas: HTMLCanvasElement, framesPassed = 1): void {\r\n    const { x, y, rotation, rotationSpeed, nextRotationSpeed, wind, speed, nextWind, nextSpeed, radius } = this.params\r\n\r\n    // Update current location, wrapping around if going off the canvas\r\n    this.params.x = (x + wind * framesPassed) % (canvas.offsetWidth + radius * 2)\r\n    if (this.params.x > canvas.offsetWidth + radius) this.params.x = -radius\r\n    this.params.y = (y + speed * framesPassed) % (canvas.offsetHeight + radius * 2)\r\n    if (this.params.y > canvas.offsetHeight + radius) this.params.y = -radius\r\n\r\n    // Apply rotation\r\n    if (this.image) {\r\n      this.params.rotation = (rotation + rotationSpeed) % 360\r\n    }\r\n\r\n    // Update the wind, speed and rotation towards the desired values\r\n    this.params.speed = lerp(speed, nextSpeed, 0.01)\r\n    this.params.wind = lerp(wind, nextWind, 0.01)\r\n    this.params.rotationSpeed = lerp(rotationSpeed, nextRotationSpeed, 0.01)\r\n\r\n    if (this.framesSinceLastUpdate++ > this.config.changeFrequency) {\r\n      this.updateTargetParams()\r\n      this.framesSinceLastUpdate = 0\r\n    }\r\n  }\r\n\r\n  private getImageOffscreenCanvas(image: CanvasImageSource, size: number): CanvasImageSource {\r\n    if (image instanceof HTMLImageElement && image.loading) return image\r\n    let sizes = Snowflake.offscreenCanvases.get(image)\r\n\r\n    if (!sizes) {\r\n      sizes = {}\r\n      Snowflake.offscreenCanvases.set(image, sizes)\r\n    }\r\n\r\n    if (!(size in sizes)) {\r\n      const canvas = document.createElement('canvas')\r\n      canvas.width = size\r\n      canvas.height = size\r\n      canvas.getContext('2d')?.drawImage(image, 0, 0, size, size)\r\n      sizes[size] = canvas\r\n    }\r\n\r\n    return sizes[size] ?? image\r\n  }\r\n\r\n  public draw(ctx: CanvasRenderingContext2D): void {\r\n    if (this.image) {\r\n      // ctx.save()\r\n      // ctx.translate(this.params.x, this.params.y)\r\n      ctx.setTransform(1, 0, 0, 1, this.params.x, this.params.y)\r\n\r\n      const radius = Math.ceil(this.params.radius)\r\n      ctx.rotate((this.params.rotation * Math.PI) / 180)\r\n      ctx.drawImage(\r\n        this.getImageOffscreenCanvas(this.image, radius),\r\n        -Math.ceil(radius / 2),\r\n        -Math.ceil(radius / 2),\r\n        radius,\r\n        radius,\r\n      )\r\n\r\n      // ctx.restore()\r\n    } else {\r\n      ctx.beginPath()\r\n      ctx.arc(this.params.x, this.params.y, this.params.radius, 0, 2 * Math.PI)\r\n      ctx.fillStyle = this.config.color\r\n      ctx.closePath()\r\n      ctx.fill()\r\n    }\r\n  }\r\n}\r\n\r\nexport default Snowflake\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}