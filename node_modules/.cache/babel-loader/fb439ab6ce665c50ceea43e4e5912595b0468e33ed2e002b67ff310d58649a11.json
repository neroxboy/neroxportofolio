{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeMessagesSocket = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst node_cache_1 = __importDefault(require(\"node-cache\"));\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst Utils_1 = require(\"../Utils\");\nconst link_preview_1 = require(\"../Utils/link-preview\");\nconst WABinary_1 = require(\"../WABinary\");\nconst groups_1 = require(\"./groups\");\nconst makeMessagesSocket = config => {\n  const {\n    logger,\n    linkPreviewImageThumbnailWidth,\n    generateHighQualityLinkPreview,\n    options: axiosOptions,\n    patchMessageBeforeSending,\n    cachedGroupMetadata\n  } = config;\n  const sock = (0, groups_1.makeGroupsSocket)(config);\n  const {\n    ev,\n    authState,\n    processingMutex,\n    signalRepository,\n    upsertMessage,\n    query,\n    fetchPrivacySettings,\n    generateMessageTag,\n    sendNode,\n    groupMetadata,\n    groupToggleEphemeral\n  } = sock;\n  const userDevicesCache = config.userDevicesCache || new node_cache_1.default({\n    stdTTL: Defaults_1.DEFAULT_CACHE_TTLS.USER_DEVICES,\n    useClones: false\n  });\n  let mediaConn;\n  const refreshMediaConn = async (forceGet = false) => {\n    const media = await mediaConn;\n    if (!media || forceGet || new Date().getTime() - media.fetchDate.getTime() > media.ttl * 1000) {\n      mediaConn = (async () => {\n        const result = await query({\n          tag: 'iq',\n          attrs: {\n            type: 'set',\n            xmlns: 'w:m',\n            to: WABinary_1.S_WHATSAPP_NET\n          },\n          content: [{\n            tag: 'media_conn',\n            attrs: {}\n          }]\n        });\n        const mediaConnNode = (0, WABinary_1.getBinaryNodeChild)(result, 'media_conn');\n        const node = {\n          hosts: (0, WABinary_1.getBinaryNodeChildren)(mediaConnNode, 'host').map(({\n            attrs\n          }) => ({\n            hostname: attrs.hostname,\n            maxContentLengthBytes: +attrs.maxContentLengthBytes\n          })),\n          auth: mediaConnNode.attrs.auth,\n          ttl: +mediaConnNode.attrs.ttl,\n          fetchDate: new Date()\n        };\n        logger.debug('fetched media conn');\n        return node;\n      })();\n    }\n    return mediaConn;\n  };\n  /**\n   * generic send receipt function\n   * used for receipts of phone call, read, delivery etc.\n   * */\n  const sendReceipt = async (jid, participant, messageIds, type) => {\n    const node = {\n      tag: 'receipt',\n      attrs: {\n        id: messageIds[0]\n      }\n    };\n    const isReadReceipt = type === 'read' || type === 'read-self';\n    if (isReadReceipt) {\n      node.attrs.t = (0, Utils_1.unixTimestampSeconds)().toString();\n    }\n    if (type === 'sender' && (0, WABinary_1.isJidUser)(jid)) {\n      node.attrs.recipient = jid;\n      node.attrs.to = participant;\n    } else {\n      node.attrs.to = jid;\n      if (participant) {\n        node.attrs.participant = participant;\n      }\n    }\n    if (type) {\n      node.attrs.type = type;\n    }\n    const remainingMessageIds = messageIds.slice(1);\n    if (remainingMessageIds.length) {\n      node.content = [{\n        tag: 'list',\n        attrs: {},\n        content: remainingMessageIds.map(id => ({\n          tag: 'item',\n          attrs: {\n            id\n          }\n        }))\n      }];\n    }\n    logger.debug({\n      attrs: node.attrs,\n      messageIds\n    }, 'sending receipt for messages');\n    await sendNode(node);\n  };\n  /** Correctly bulk send receipts to multiple chats, participants */\n  const sendReceipts = async (keys, type) => {\n    const recps = (0, Utils_1.aggregateMessageKeysNotFromMe)(keys);\n    for (const {\n      jid,\n      participant,\n      messageIds\n    } of recps) {\n      await sendReceipt(jid, participant, messageIds, type);\n    }\n  };\n  /** Bulk read messages. Keys can be from different chats & participants */\n  const readMessages = async keys => {\n    const privacySettings = await fetchPrivacySettings();\n    // based on privacy settings, we have to change the read type\n    const readType = privacySettings.readreceipts === 'all' ? 'read' : 'read-self';\n    await sendReceipts(keys, readType);\n  };\n  /** Fetch all the devices we've to send a message to */\n  const getUSyncDevices = async (jids, useCache, ignoreZeroDevices) => {\n    var _a;\n    const deviceResults = [];\n    if (!useCache) {\n      logger.debug('not using cache for devices');\n    }\n    const users = [];\n    jids = Array.from(new Set(jids));\n    for (let jid of jids) {\n      const user = (_a = (0, WABinary_1.jidDecode)(jid)) === null || _a === void 0 ? void 0 : _a.user;\n      jid = (0, WABinary_1.jidNormalizedUser)(jid);\n      const devices = userDevicesCache.get(user);\n      if (devices && useCache) {\n        deviceResults.push(...devices);\n        logger.trace({\n          user\n        }, 'using cache for devices');\n      } else {\n        users.push({\n          tag: 'user',\n          attrs: {\n            jid\n          }\n        });\n      }\n    }\n    if (!users.length) {\n      return deviceResults;\n    }\n    const iq = {\n      tag: 'iq',\n      attrs: {\n        to: WABinary_1.S_WHATSAPP_NET,\n        type: 'get',\n        xmlns: 'usync'\n      },\n      content: [{\n        tag: 'usync',\n        attrs: {\n          sid: generateMessageTag(),\n          mode: 'query',\n          last: 'true',\n          index: '0',\n          context: 'message'\n        },\n        content: [{\n          tag: 'query',\n          attrs: {},\n          content: [{\n            tag: 'devices',\n            attrs: {\n              version: '2'\n            }\n          }]\n        }, {\n          tag: 'list',\n          attrs: {},\n          content: users\n        }]\n      }]\n    };\n    const result = await query(iq);\n    const extracted = (0, Utils_1.extractDeviceJids)(result, authState.creds.me.id, ignoreZeroDevices);\n    const deviceMap = {};\n    for (const item of extracted) {\n      deviceMap[item.user] = deviceMap[item.user] || [];\n      deviceMap[item.user].push(item);\n      deviceResults.push(item);\n    }\n    for (const key in deviceMap) {\n      userDevicesCache.set(key, deviceMap[key]);\n    }\n    return deviceResults;\n  };\n  const assertSessions = async (jids, force) => {\n    let didFetchNewSession = false;\n    let jidsRequiringFetch = [];\n    if (force) {\n      jidsRequiringFetch = jids;\n    } else {\n      const addrs = jids.map(jid => signalRepository.jidToSignalProtocolAddress(jid));\n      const sessions = await authState.keys.get('session', addrs);\n      for (const jid of jids) {\n        const signalId = signalRepository.jidToSignalProtocolAddress(jid);\n        if (!sessions[signalId]) {\n          jidsRequiringFetch.push(jid);\n        }\n      }\n    }\n    if (jidsRequiringFetch.length) {\n      logger.debug({\n        jidsRequiringFetch\n      }, 'fetching sessions');\n      const result = await query({\n        tag: 'iq',\n        attrs: {\n          xmlns: 'encrypt',\n          type: 'get',\n          to: WABinary_1.S_WHATSAPP_NET\n        },\n        content: [{\n          tag: 'key',\n          attrs: {},\n          content: jidsRequiringFetch.map(jid => ({\n            tag: 'user',\n            attrs: {\n              jid\n            }\n          }))\n        }]\n      });\n      await (0, Utils_1.parseAndInjectE2ESessions)(result, signalRepository);\n      didFetchNewSession = true;\n    }\n    return didFetchNewSession;\n  };\n  const sendPeerDataOperationMessage = async pdoMessage => {\n    var _a;\n    //TODO: for later, abstract the logic to send a Peer Message instead of just PDO - useful for App State Key Resync with phone\n    if (!((_a = authState.creds.me) === null || _a === void 0 ? void 0 : _a.id)) {\n      throw new boom_1.Boom('Not authenticated');\n    }\n    const protocolMessage = {\n      protocolMessage: {\n        peerDataOperationRequestMessage: pdoMessage,\n        type: WAProto_1.proto.Message.ProtocolMessage.Type.PEER_DATA_OPERATION_REQUEST_MESSAGE\n      }\n    };\n    const meJid = (0, WABinary_1.jidNormalizedUser)(authState.creds.me.id);\n    const msgId = await relayMessage(meJid, protocolMessage, {\n      additionalAttributes: {\n        category: 'peer',\n        // eslint-disable-next-line camelcase\n        push_priority: 'high_force'\n      }\n    });\n    return msgId;\n  };\n  const createParticipantNodes = async (jids, message, extraAttrs) => {\n    const patched = await patchMessageBeforeSending(message, jids);\n    const bytes = (0, Utils_1.encodeWAMessage)(patched);\n    let shouldIncludeDeviceIdentity = false;\n    const nodes = await Promise.all(jids.map(async jid => {\n      const {\n        type,\n        ciphertext\n      } = await signalRepository.encryptMessage({\n        jid,\n        data: bytes\n      });\n      if (type === 'pkmsg') {\n        shouldIncludeDeviceIdentity = true;\n      }\n      const node = {\n        tag: 'to',\n        attrs: {\n          jid\n        },\n        content: [{\n          tag: 'enc',\n          attrs: {\n            v: '2',\n            type,\n            ...(extraAttrs || {})\n          },\n          content: ciphertext\n        }]\n      };\n      return node;\n    }));\n    return {\n      nodes,\n      shouldIncludeDeviceIdentity\n    };\n  };\n  const relayMessage = async (jid, message, {\n    messageId: msgId,\n    participant,\n    additionalAttributes,\n    additionalNodes,\n    useUserDevicesCache,\n    useCachedGroupMetadata,\n    statusJidList\n  }) => {\n    var _a;\n    const meId = authState.creds.me.id;\n    let shouldIncludeDeviceIdentity = false;\n    const {\n      user,\n      server\n    } = (0, WABinary_1.jidDecode)(jid);\n    const statusJid = 'status@broadcast';\n    const isGroup = server === 'g.us';\n    const isStatus = jid === statusJid;\n    const isLid = server === 'lid';\n    msgId = msgId || (0, Utils_1.generateMessageIDV2)((_a = sock.user) === null || _a === void 0 ? void 0 : _a.id);\n    useUserDevicesCache = useUserDevicesCache !== false;\n    useCachedGroupMetadata = useCachedGroupMetadata !== false && !isStatus;\n    const participants = [];\n    const destinationJid = !isStatus ? (0, WABinary_1.jidEncode)(user, isLid ? 'lid' : isGroup ? 'g.us' : 's.whatsapp.net') : statusJid;\n    const binaryNodeContent = [];\n    const devices = [];\n    const meMsg = {\n      deviceSentMessage: {\n        destinationJid,\n        message\n      }\n    };\n    const extraAttrs = {};\n    if (participant) {\n      // when the retry request is not for a group\n      // only send to the specific device that asked for a retry\n      // otherwise the message is sent out to every device that should be a recipient\n      if (!isGroup && !isStatus) {\n        additionalAttributes = {\n          ...additionalAttributes,\n          'device_fanout': 'false'\n        };\n      }\n      const {\n        user,\n        device\n      } = (0, WABinary_1.jidDecode)(participant.jid);\n      devices.push({\n        user,\n        device\n      });\n    }\n    await authState.keys.transaction(async () => {\n      var _a, _b, _c, _d, _e;\n      const mediaType = getMediaType(message);\n      if (mediaType) {\n        extraAttrs['mediatype'] = mediaType;\n      }\n      if ((_a = (0, Utils_1.normalizeMessageContent)(message)) === null || _a === void 0 ? void 0 : _a.pinInChatMessage) {\n        extraAttrs['decrypt-fail'] = 'hide';\n      }\n      if (isGroup || isStatus) {\n        const [groupData, senderKeyMap] = await Promise.all([(async () => {\n          let groupData = useCachedGroupMetadata && cachedGroupMetadata ? await cachedGroupMetadata(jid) : undefined;\n          if (groupData && Array.isArray(groupData === null || groupData === void 0 ? void 0 : groupData.participants)) {\n            logger.trace({\n              jid,\n              participants: groupData.participants.length\n            }, 'using cached group metadata');\n          } else if (!isStatus) {\n            groupData = await groupMetadata(jid);\n          }\n          return groupData;\n        })(), (async () => {\n          if (!participant && !isStatus) {\n            const result = await authState.keys.get('sender-key-memory', [jid]);\n            return result[jid] || {};\n          }\n          return {};\n        })()]);\n        if (!participant) {\n          const participantsList = groupData && !isStatus ? groupData.participants.map(p => p.id) : [];\n          if (isStatus && statusJidList) {\n            participantsList.push(...statusJidList);\n          }\n          const additionalDevices = await getUSyncDevices(participantsList, !!useUserDevicesCache, false);\n          devices.push(...additionalDevices);\n        }\n        const patched = await patchMessageBeforeSending(message, devices.map(d => (0, WABinary_1.jidEncode)(d.user, isLid ? 'lid' : 's.whatsapp.net', d.device)));\n        const bytes = (0, Utils_1.encodeWAMessage)(patched);\n        const {\n          ciphertext,\n          senderKeyDistributionMessage\n        } = await signalRepository.encryptGroupMessage({\n          group: destinationJid,\n          data: bytes,\n          meId\n        });\n        const senderKeyJids = [];\n        // ensure a connection is established with every device\n        for (const {\n          user,\n          device\n        } of devices) {\n          const jid = (0, WABinary_1.jidEncode)(user, isLid ? 'lid' : 's.whatsapp.net', device);\n          if (!senderKeyMap[jid] || !!participant) {\n            senderKeyJids.push(jid);\n            // store that this person has had the sender keys sent to them\n            senderKeyMap[jid] = true;\n          }\n        }\n        // if there are some participants with whom the session has not been established\n        // if there are, we re-send the senderkey\n        if (senderKeyJids.length) {\n          logger.debug({\n            senderKeyJids\n          }, 'sending new sender key');\n          const senderKeyMsg = {\n            senderKeyDistributionMessage: {\n              axolotlSenderKeyDistributionMessage: senderKeyDistributionMessage,\n              groupId: destinationJid\n            }\n          };\n          await assertSessions(senderKeyJids, false);\n          const result = await createParticipantNodes(senderKeyJids, senderKeyMsg, extraAttrs);\n          shouldIncludeDeviceIdentity = shouldIncludeDeviceIdentity || result.shouldIncludeDeviceIdentity;\n          participants.push(...result.nodes);\n        }\n        binaryNodeContent.push({\n          tag: 'enc',\n          attrs: {\n            v: '2',\n            type: 'skmsg'\n          },\n          content: ciphertext\n        });\n        await authState.keys.set({\n          'sender-key-memory': {\n            [jid]: senderKeyMap\n          }\n        });\n      } else {\n        const {\n          user: meUser,\n          device: meDevice\n        } = (0, WABinary_1.jidDecode)(meId);\n        if (!participant) {\n          devices.push({\n            user\n          });\n          // do not send message to self if the device is 0 (mobile)\n          if (!((additionalAttributes === null || additionalAttributes === void 0 ? void 0 : additionalAttributes['category']) === 'peer' && user === meUser)) {\n            if (meDevice !== undefined && meDevice !== 0) {\n              devices.push({\n                user: meUser\n              });\n            }\n            const additionalDevices = await getUSyncDevices([meId, jid], !!useUserDevicesCache, true);\n            devices.push(...additionalDevices);\n          }\n        }\n        const allJids = [];\n        const meJids = [];\n        const otherJids = [];\n        for (const {\n          user,\n          device\n        } of devices) {\n          const isMe = user === meUser;\n          const jid = (0, WABinary_1.jidEncode)(isMe && isLid ? ((_c = (_b = authState.creds) === null || _b === void 0 ? void 0 : _b.me) === null || _c === void 0 ? void 0 : _c.lid.split(':')[0]) || user : user, isLid ? 'lid' : 's.whatsapp.net', device);\n          if (isMe) {\n            meJids.push(jid);\n          } else {\n            otherJids.push(jid);\n          }\n          allJids.push(jid);\n        }\n        await assertSessions(allJids, false);\n        const [{\n          nodes: meNodes,\n          shouldIncludeDeviceIdentity: s1\n        }, {\n          nodes: otherNodes,\n          shouldIncludeDeviceIdentity: s2\n        }] = await Promise.all([createParticipantNodes(meJids, meMsg, extraAttrs), createParticipantNodes(otherJids, message, extraAttrs)]);\n        participants.push(...meNodes);\n        participants.push(...otherNodes);\n        shouldIncludeDeviceIdentity = shouldIncludeDeviceIdentity || s1 || s2;\n      }\n      if (participants.length) {\n        if ((additionalAttributes === null || additionalAttributes === void 0 ? void 0 : additionalAttributes['category']) === 'peer') {\n          const peerNode = (_e = (_d = participants[0]) === null || _d === void 0 ? void 0 : _d.content) === null || _e === void 0 ? void 0 : _e[0];\n          if (peerNode) {\n            binaryNodeContent.push(peerNode); // push only enc\n          }\n        } else {\n          binaryNodeContent.push({\n            tag: 'participants',\n            attrs: {},\n            content: participants\n          });\n        }\n      }\n      const stanza = {\n        tag: 'message',\n        attrs: {\n          id: msgId,\n          type: 'text',\n          ...(additionalAttributes || {})\n        },\n        content: binaryNodeContent\n      };\n      // if the participant to send to is explicitly specified (generally retry recp)\n      // ensure the message is only sent to that person\n      // if a retry receipt is sent to everyone -- it'll fail decryption for everyone else who received the msg\n      if (participant) {\n        if ((0, WABinary_1.isJidGroup)(destinationJid)) {\n          stanza.attrs.to = destinationJid;\n          stanza.attrs.participant = participant.jid;\n        } else if ((0, WABinary_1.areJidsSameUser)(participant.jid, meId)) {\n          stanza.attrs.to = participant.jid;\n          stanza.attrs.recipient = destinationJid;\n        } else {\n          stanza.attrs.to = participant.jid;\n        }\n      } else {\n        stanza.attrs.to = destinationJid;\n      }\n      if (shouldIncludeDeviceIdentity) {\n        stanza.content.push({\n          tag: 'device-identity',\n          attrs: {},\n          content: (0, Utils_1.encodeSignedDeviceIdentity)(authState.creds.account, true)\n        });\n        logger.debug({\n          jid\n        }, 'adding device identity');\n      }\n      if (additionalNodes && additionalNodes.length > 0) {\n        stanza.content.push(...additionalNodes);\n      }\n      logger.debug({\n        msgId\n      }, `sending message to ${participants.length} devices`);\n      await sendNode(stanza);\n    });\n    return msgId;\n  };\n  const getMediaType = message => {\n    if (message.imageMessage) {\n      return 'image';\n    } else if (message.videoMessage) {\n      return message.videoMessage.gifPlayback ? 'gif' : 'video';\n    } else if (message.audioMessage) {\n      return message.audioMessage.ptt ? 'ptt' : 'audio';\n    } else if (message.contactMessage) {\n      return 'vcard';\n    } else if (message.documentMessage) {\n      return 'document';\n    } else if (message.contactsArrayMessage) {\n      return 'contact_array';\n    } else if (message.liveLocationMessage) {\n      return 'livelocation';\n    } else if (message.stickerMessage) {\n      return 'sticker';\n    } else if (message.listMessage) {\n      return 'list';\n    } else if (message.listResponseMessage) {\n      return 'list_response';\n    } else if (message.buttonsResponseMessage) {\n      return 'buttons_response';\n    } else if (message.orderMessage) {\n      return 'order';\n    } else if (message.productMessage) {\n      return 'product';\n    } else if (message.interactiveResponseMessage) {\n      return 'native_flow_response';\n    } else if (message.groupInviteMessage) {\n      return 'url';\n    }\n  };\n  const getPrivacyTokens = async jids => {\n    const t = (0, Utils_1.unixTimestampSeconds)().toString();\n    const result = await query({\n      tag: 'iq',\n      attrs: {\n        to: WABinary_1.S_WHATSAPP_NET,\n        type: 'set',\n        xmlns: 'privacy'\n      },\n      content: [{\n        tag: 'tokens',\n        attrs: {},\n        content: jids.map(jid => ({\n          tag: 'token',\n          attrs: {\n            jid: (0, WABinary_1.jidNormalizedUser)(jid),\n            t,\n            type: 'trusted_contact'\n          }\n        }))\n      }]\n    });\n    return result;\n  };\n  const waUploadToServer = (0, Utils_1.getWAUploadToServer)(config, refreshMediaConn);\n  const waitForMsgMediaUpdate = (0, Utils_1.bindWaitForEvent)(ev, 'messages.media-update');\n  return {\n    ...sock,\n    getPrivacyTokens,\n    assertSessions,\n    relayMessage,\n    sendReceipt,\n    sendReceipts,\n    readMessages,\n    refreshMediaConn,\n    waUploadToServer,\n    fetchPrivacySettings,\n    sendPeerDataOperationMessage,\n    createParticipantNodes,\n    getUSyncDevices,\n    updateMediaMessage: async message => {\n      const content = (0, Utils_1.assertMediaContent)(message.message);\n      const mediaKey = content.mediaKey;\n      const meId = authState.creds.me.id;\n      const node = (0, Utils_1.encryptMediaRetryRequest)(message.key, mediaKey, meId);\n      let error = undefined;\n      await Promise.all([sendNode(node), waitForMsgMediaUpdate(update => {\n        const result = update.find(c => c.key.id === message.key.id);\n        if (result) {\n          if (result.error) {\n            error = result.error;\n          } else {\n            try {\n              const media = (0, Utils_1.decryptMediaRetryData)(result.media, mediaKey, result.key.id);\n              if (media.result !== WAProto_1.proto.MediaRetryNotification.ResultType.SUCCESS) {\n                const resultStr = WAProto_1.proto.MediaRetryNotification.ResultType[media.result];\n                throw new boom_1.Boom(`Media re-upload failed by device (${resultStr})`, {\n                  data: media,\n                  statusCode: (0, Utils_1.getStatusCodeForMediaRetry)(media.result) || 404\n                });\n              }\n              content.directPath = media.directPath;\n              content.url = (0, Utils_1.getUrlFromDirectPath)(content.directPath);\n              logger.debug({\n                directPath: media.directPath,\n                key: result.key\n              }, 'media update successful');\n            } catch (err) {\n              error = err;\n            }\n          }\n          return true;\n        }\n      })]);\n      if (error) {\n        throw error;\n      }\n      ev.emit('messages.update', [{\n        key: message.key,\n        update: {\n          message: message.message\n        }\n      }]);\n      return message;\n    },\n    sendMessage: async (jid, content, options = {}) => {\n      var _a, _b, _c;\n      const userJid = authState.creds.me.id;\n      if (typeof content === 'object' && 'disappearingMessagesInChat' in content && typeof content['disappearingMessagesInChat'] !== 'undefined' && (0, WABinary_1.isJidGroup)(jid)) {\n        const {\n          disappearingMessagesInChat\n        } = content;\n        const value = typeof disappearingMessagesInChat === 'boolean' ? disappearingMessagesInChat ? Defaults_1.WA_DEFAULT_EPHEMERAL : 0 : disappearingMessagesInChat;\n        await groupToggleEphemeral(jid, value);\n      } else {\n        const fullMsg = await (0, Utils_1.generateWAMessage)(jid, content, {\n          logger,\n          userJid,\n          getUrlInfo: text => (0, link_preview_1.getUrlInfo)(text, {\n            thumbnailWidth: linkPreviewImageThumbnailWidth,\n            fetchOpts: {\n              timeout: 3000,\n              ...(axiosOptions || {})\n            },\n            logger,\n            uploadImage: generateHighQualityLinkPreview ? waUploadToServer : undefined\n          }),\n          //TODO: CACHE\n          getProfilePicUrl: sock.profilePictureUrl,\n          upload: waUploadToServer,\n          mediaCache: config.mediaCache,\n          options: config.options,\n          messageId: (0, Utils_1.generateMessageIDV2)((_a = sock.user) === null || _a === void 0 ? void 0 : _a.id),\n          ...options\n        });\n        const isDeleteMsg = 'delete' in content && !!content.delete;\n        const isEditMsg = 'edit' in content && !!content.edit;\n        const isPinMsg = 'pin' in content && !!content.pin;\n        const additionalAttributes = {};\n        // required for delete\n        if (isDeleteMsg) {\n          // if the chat is a group, and I am not the author, then delete the message as an admin\n          if ((0, WABinary_1.isJidGroup)((_b = content.delete) === null || _b === void 0 ? void 0 : _b.remoteJid) && !((_c = content.delete) === null || _c === void 0 ? void 0 : _c.fromMe)) {\n            additionalAttributes.edit = '8';\n          } else {\n            additionalAttributes.edit = '7';\n          }\n        } else if (isEditMsg) {\n          additionalAttributes.edit = '1';\n        } else if (isPinMsg) {\n          additionalAttributes.edit = '2';\n        }\n        if ('cachedGroupMetadata' in options) {\n          console.warn('cachedGroupMetadata in sendMessage are deprecated, now cachedGroupMetadata is part of the socket config.');\n        }\n        await relayMessage(jid, fullMsg.message, {\n          messageId: fullMsg.key.id,\n          useCachedGroupMetadata: options.useCachedGroupMetadata,\n          additionalAttributes,\n          statusJidList: options.statusJidList\n        });\n        if (config.emitOwnEvents) {\n          process.nextTick(() => {\n            processingMutex.mutex(() => upsertMessage(fullMsg, 'append'));\n          });\n        }\n        return fullMsg;\n      }\n    }\n  };\n};\nexports.makeMessagesSocket = makeMessagesSocket;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","makeMessagesSocket","boom_1","require","node_cache_1","WAProto_1","Defaults_1","Utils_1","link_preview_1","WABinary_1","groups_1","config","logger","linkPreviewImageThumbnailWidth","generateHighQualityLinkPreview","options","axiosOptions","patchMessageBeforeSending","cachedGroupMetadata","sock","makeGroupsSocket","ev","authState","processingMutex","signalRepository","upsertMessage","query","fetchPrivacySettings","generateMessageTag","sendNode","groupMetadata","groupToggleEphemeral","userDevicesCache","default","stdTTL","DEFAULT_CACHE_TTLS","USER_DEVICES","useClones","mediaConn","refreshMediaConn","forceGet","media","Date","getTime","fetchDate","ttl","result","tag","attrs","type","xmlns","to","S_WHATSAPP_NET","content","mediaConnNode","getBinaryNodeChild","node","hosts","getBinaryNodeChildren","map","hostname","maxContentLengthBytes","auth","debug","sendReceipt","jid","participant","messageIds","id","isReadReceipt","t","unixTimestampSeconds","toString","isJidUser","recipient","remainingMessageIds","slice","length","sendReceipts","keys","recps","aggregateMessageKeysNotFromMe","readMessages","privacySettings","readType","readreceipts","getUSyncDevices","jids","useCache","ignoreZeroDevices","_a","deviceResults","users","Array","from","Set","user","jidDecode","jidNormalizedUser","devices","get","push","trace","iq","sid","mode","last","index","context","version","extracted","extractDeviceJids","creds","me","deviceMap","item","key","set","assertSessions","force","didFetchNewSession","jidsRequiringFetch","addrs","jidToSignalProtocolAddress","sessions","signalId","parseAndInjectE2ESessions","sendPeerDataOperationMessage","pdoMessage","Boom","protocolMessage","peerDataOperationRequestMessage","proto","Message","ProtocolMessage","Type","PEER_DATA_OPERATION_REQUEST_MESSAGE","meJid","msgId","relayMessage","additionalAttributes","category","push_priority","createParticipantNodes","message","extraAttrs","patched","bytes","encodeWAMessage","shouldIncludeDeviceIdentity","nodes","Promise","all","ciphertext","encryptMessage","data","v","messageId","additionalNodes","useUserDevicesCache","useCachedGroupMetadata","statusJidList","meId","server","statusJid","isGroup","isStatus","isLid","generateMessageIDV2","participants","destinationJid","jidEncode","binaryNodeContent","meMsg","deviceSentMessage","device","transaction","_b","_c","_d","_e","mediaType","getMediaType","normalizeMessageContent","pinInChatMessage","groupData","senderKeyMap","undefined","isArray","participantsList","p","additionalDevices","d","senderKeyDistributionMessage","encryptGroupMessage","group","senderKeyJids","senderKeyMsg","axolotlSenderKeyDistributionMessage","groupId","meUser","meDevice","allJids","meJids","otherJids","isMe","lid","split","meNodes","s1","otherNodes","s2","peerNode","stanza","isJidGroup","areJidsSameUser","encodeSignedDeviceIdentity","account","imageMessage","videoMessage","gifPlayback","audioMessage","ptt","contactMessage","documentMessage","contactsArrayMessage","liveLocationMessage","stickerMessage","listMessage","listResponseMessage","buttonsResponseMessage","orderMessage","productMessage","interactiveResponseMessage","groupInviteMessage","getPrivacyTokens","waUploadToServer","getWAUploadToServer","waitForMsgMediaUpdate","bindWaitForEvent","updateMediaMessage","assertMediaContent","mediaKey","encryptMediaRetryRequest","error","update","find","c","decryptMediaRetryData","MediaRetryNotification","ResultType","SUCCESS","resultStr","statusCode","getStatusCodeForMediaRetry","directPath","url","getUrlFromDirectPath","err","emit","sendMessage","userJid","disappearingMessagesInChat","WA_DEFAULT_EPHEMERAL","fullMsg","generateWAMessage","getUrlInfo","text","thumbnailWidth","fetchOpts","timeout","uploadImage","getProfilePicUrl","profilePictureUrl","upload","mediaCache","isDeleteMsg","delete","isEditMsg","edit","isPinMsg","pin","remoteJid","fromMe","console","warn","emitOwnEvents","process","nextTick","mutex"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Socket/messages-send.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeMessagesSocket = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst node_cache_1 = __importDefault(require(\"node-cache\"));\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst Utils_1 = require(\"../Utils\");\nconst link_preview_1 = require(\"../Utils/link-preview\");\nconst WABinary_1 = require(\"../WABinary\");\nconst groups_1 = require(\"./groups\");\nconst makeMessagesSocket = (config) => {\n    const { logger, linkPreviewImageThumbnailWidth, generateHighQualityLinkPreview, options: axiosOptions, patchMessageBeforeSending, cachedGroupMetadata, } = config;\n    const sock = (0, groups_1.makeGroupsSocket)(config);\n    const { ev, authState, processingMutex, signalRepository, upsertMessage, query, fetchPrivacySettings, generateMessageTag, sendNode, groupMetadata, groupToggleEphemeral, } = sock;\n    const userDevicesCache = config.userDevicesCache || new node_cache_1.default({\n        stdTTL: Defaults_1.DEFAULT_CACHE_TTLS.USER_DEVICES,\n        useClones: false\n    });\n    let mediaConn;\n    const refreshMediaConn = async (forceGet = false) => {\n        const media = await mediaConn;\n        if (!media || forceGet || (new Date().getTime() - media.fetchDate.getTime()) > media.ttl * 1000) {\n            mediaConn = (async () => {\n                const result = await query({\n                    tag: 'iq',\n                    attrs: {\n                        type: 'set',\n                        xmlns: 'w:m',\n                        to: WABinary_1.S_WHATSAPP_NET,\n                    },\n                    content: [{ tag: 'media_conn', attrs: {} }]\n                });\n                const mediaConnNode = (0, WABinary_1.getBinaryNodeChild)(result, 'media_conn');\n                const node = {\n                    hosts: (0, WABinary_1.getBinaryNodeChildren)(mediaConnNode, 'host').map(({ attrs }) => ({\n                        hostname: attrs.hostname,\n                        maxContentLengthBytes: +attrs.maxContentLengthBytes,\n                    })),\n                    auth: mediaConnNode.attrs.auth,\n                    ttl: +mediaConnNode.attrs.ttl,\n                    fetchDate: new Date()\n                };\n                logger.debug('fetched media conn');\n                return node;\n            })();\n        }\n        return mediaConn;\n    };\n    /**\n     * generic send receipt function\n     * used for receipts of phone call, read, delivery etc.\n     * */\n    const sendReceipt = async (jid, participant, messageIds, type) => {\n        const node = {\n            tag: 'receipt',\n            attrs: {\n                id: messageIds[0],\n            },\n        };\n        const isReadReceipt = type === 'read' || type === 'read-self';\n        if (isReadReceipt) {\n            node.attrs.t = (0, Utils_1.unixTimestampSeconds)().toString();\n        }\n        if (type === 'sender' && (0, WABinary_1.isJidUser)(jid)) {\n            node.attrs.recipient = jid;\n            node.attrs.to = participant;\n        }\n        else {\n            node.attrs.to = jid;\n            if (participant) {\n                node.attrs.participant = participant;\n            }\n        }\n        if (type) {\n            node.attrs.type = type;\n        }\n        const remainingMessageIds = messageIds.slice(1);\n        if (remainingMessageIds.length) {\n            node.content = [\n                {\n                    tag: 'list',\n                    attrs: {},\n                    content: remainingMessageIds.map(id => ({\n                        tag: 'item',\n                        attrs: { id }\n                    }))\n                }\n            ];\n        }\n        logger.debug({ attrs: node.attrs, messageIds }, 'sending receipt for messages');\n        await sendNode(node);\n    };\n    /** Correctly bulk send receipts to multiple chats, participants */\n    const sendReceipts = async (keys, type) => {\n        const recps = (0, Utils_1.aggregateMessageKeysNotFromMe)(keys);\n        for (const { jid, participant, messageIds } of recps) {\n            await sendReceipt(jid, participant, messageIds, type);\n        }\n    };\n    /** Bulk read messages. Keys can be from different chats & participants */\n    const readMessages = async (keys) => {\n        const privacySettings = await fetchPrivacySettings();\n        // based on privacy settings, we have to change the read type\n        const readType = privacySettings.readreceipts === 'all' ? 'read' : 'read-self';\n        await sendReceipts(keys, readType);\n    };\n    /** Fetch all the devices we've to send a message to */\n    const getUSyncDevices = async (jids, useCache, ignoreZeroDevices) => {\n        var _a;\n        const deviceResults = [];\n        if (!useCache) {\n            logger.debug('not using cache for devices');\n        }\n        const users = [];\n        jids = Array.from(new Set(jids));\n        for (let jid of jids) {\n            const user = (_a = (0, WABinary_1.jidDecode)(jid)) === null || _a === void 0 ? void 0 : _a.user;\n            jid = (0, WABinary_1.jidNormalizedUser)(jid);\n            const devices = userDevicesCache.get(user);\n            if (devices && useCache) {\n                deviceResults.push(...devices);\n                logger.trace({ user }, 'using cache for devices');\n            }\n            else {\n                users.push({ tag: 'user', attrs: { jid } });\n            }\n        }\n        if (!users.length) {\n            return deviceResults;\n        }\n        const iq = {\n            tag: 'iq',\n            attrs: {\n                to: WABinary_1.S_WHATSAPP_NET,\n                type: 'get',\n                xmlns: 'usync',\n            },\n            content: [\n                {\n                    tag: 'usync',\n                    attrs: {\n                        sid: generateMessageTag(),\n                        mode: 'query',\n                        last: 'true',\n                        index: '0',\n                        context: 'message',\n                    },\n                    content: [\n                        {\n                            tag: 'query',\n                            attrs: {},\n                            content: [\n                                {\n                                    tag: 'devices',\n                                    attrs: { version: '2' }\n                                }\n                            ]\n                        },\n                        { tag: 'list', attrs: {}, content: users }\n                    ]\n                },\n            ],\n        };\n        const result = await query(iq);\n        const extracted = (0, Utils_1.extractDeviceJids)(result, authState.creds.me.id, ignoreZeroDevices);\n        const deviceMap = {};\n        for (const item of extracted) {\n            deviceMap[item.user] = deviceMap[item.user] || [];\n            deviceMap[item.user].push(item);\n            deviceResults.push(item);\n        }\n        for (const key in deviceMap) {\n            userDevicesCache.set(key, deviceMap[key]);\n        }\n        return deviceResults;\n    };\n    const assertSessions = async (jids, force) => {\n        let didFetchNewSession = false;\n        let jidsRequiringFetch = [];\n        if (force) {\n            jidsRequiringFetch = jids;\n        }\n        else {\n            const addrs = jids.map(jid => (signalRepository\n                .jidToSignalProtocolAddress(jid)));\n            const sessions = await authState.keys.get('session', addrs);\n            for (const jid of jids) {\n                const signalId = signalRepository\n                    .jidToSignalProtocolAddress(jid);\n                if (!sessions[signalId]) {\n                    jidsRequiringFetch.push(jid);\n                }\n            }\n        }\n        if (jidsRequiringFetch.length) {\n            logger.debug({ jidsRequiringFetch }, 'fetching sessions');\n            const result = await query({\n                tag: 'iq',\n                attrs: {\n                    xmlns: 'encrypt',\n                    type: 'get',\n                    to: WABinary_1.S_WHATSAPP_NET,\n                },\n                content: [\n                    {\n                        tag: 'key',\n                        attrs: {},\n                        content: jidsRequiringFetch.map(jid => ({\n                            tag: 'user',\n                            attrs: { jid },\n                        }))\n                    }\n                ]\n            });\n            await (0, Utils_1.parseAndInjectE2ESessions)(result, signalRepository);\n            didFetchNewSession = true;\n        }\n        return didFetchNewSession;\n    };\n    const sendPeerDataOperationMessage = async (pdoMessage) => {\n        var _a;\n        //TODO: for later, abstract the logic to send a Peer Message instead of just PDO - useful for App State Key Resync with phone\n        if (!((_a = authState.creds.me) === null || _a === void 0 ? void 0 : _a.id)) {\n            throw new boom_1.Boom('Not authenticated');\n        }\n        const protocolMessage = {\n            protocolMessage: {\n                peerDataOperationRequestMessage: pdoMessage,\n                type: WAProto_1.proto.Message.ProtocolMessage.Type.PEER_DATA_OPERATION_REQUEST_MESSAGE\n            }\n        };\n        const meJid = (0, WABinary_1.jidNormalizedUser)(authState.creds.me.id);\n        const msgId = await relayMessage(meJid, protocolMessage, {\n            additionalAttributes: {\n                category: 'peer',\n                // eslint-disable-next-line camelcase\n                push_priority: 'high_force',\n            },\n        });\n        return msgId;\n    };\n    const createParticipantNodes = async (jids, message, extraAttrs) => {\n        const patched = await patchMessageBeforeSending(message, jids);\n        const bytes = (0, Utils_1.encodeWAMessage)(patched);\n        let shouldIncludeDeviceIdentity = false;\n        const nodes = await Promise.all(jids.map(async (jid) => {\n            const { type, ciphertext } = await signalRepository\n                .encryptMessage({ jid, data: bytes });\n            if (type === 'pkmsg') {\n                shouldIncludeDeviceIdentity = true;\n            }\n            const node = {\n                tag: 'to',\n                attrs: { jid },\n                content: [{\n                        tag: 'enc',\n                        attrs: {\n                            v: '2',\n                            type,\n                            ...extraAttrs || {}\n                        },\n                        content: ciphertext\n                    }]\n            };\n            return node;\n        }));\n        return { nodes, shouldIncludeDeviceIdentity };\n    };\n    const relayMessage = async (jid, message, { messageId: msgId, participant, additionalAttributes, additionalNodes, useUserDevicesCache, useCachedGroupMetadata, statusJidList }) => {\n        var _a;\n        const meId = authState.creds.me.id;\n        let shouldIncludeDeviceIdentity = false;\n        const { user, server } = (0, WABinary_1.jidDecode)(jid);\n        const statusJid = 'status@broadcast';\n        const isGroup = server === 'g.us';\n        const isStatus = jid === statusJid;\n        const isLid = server === 'lid';\n        msgId = msgId || (0, Utils_1.generateMessageIDV2)((_a = sock.user) === null || _a === void 0 ? void 0 : _a.id);\n        useUserDevicesCache = useUserDevicesCache !== false;\n        useCachedGroupMetadata = useCachedGroupMetadata !== false && !isStatus;\n        const participants = [];\n        const destinationJid = (!isStatus) ? (0, WABinary_1.jidEncode)(user, isLid ? 'lid' : isGroup ? 'g.us' : 's.whatsapp.net') : statusJid;\n        const binaryNodeContent = [];\n        const devices = [];\n        const meMsg = {\n            deviceSentMessage: {\n                destinationJid,\n                message\n            }\n        };\n        const extraAttrs = {};\n        if (participant) {\n            // when the retry request is not for a group\n            // only send to the specific device that asked for a retry\n            // otherwise the message is sent out to every device that should be a recipient\n            if (!isGroup && !isStatus) {\n                additionalAttributes = { ...additionalAttributes, 'device_fanout': 'false' };\n            }\n            const { user, device } = (0, WABinary_1.jidDecode)(participant.jid);\n            devices.push({ user, device });\n        }\n        await authState.keys.transaction(async () => {\n            var _a, _b, _c, _d, _e;\n            const mediaType = getMediaType(message);\n            if (mediaType) {\n                extraAttrs['mediatype'] = mediaType;\n            }\n            if ((_a = (0, Utils_1.normalizeMessageContent)(message)) === null || _a === void 0 ? void 0 : _a.pinInChatMessage) {\n                extraAttrs['decrypt-fail'] = 'hide';\n            }\n            if (isGroup || isStatus) {\n                const [groupData, senderKeyMap] = await Promise.all([\n                    (async () => {\n                        let groupData = useCachedGroupMetadata && cachedGroupMetadata ? await cachedGroupMetadata(jid) : undefined;\n                        if (groupData && Array.isArray(groupData === null || groupData === void 0 ? void 0 : groupData.participants)) {\n                            logger.trace({ jid, participants: groupData.participants.length }, 'using cached group metadata');\n                        }\n                        else if (!isStatus) {\n                            groupData = await groupMetadata(jid);\n                        }\n                        return groupData;\n                    })(),\n                    (async () => {\n                        if (!participant && !isStatus) {\n                            const result = await authState.keys.get('sender-key-memory', [jid]);\n                            return result[jid] || {};\n                        }\n                        return {};\n                    })()\n                ]);\n                if (!participant) {\n                    const participantsList = (groupData && !isStatus) ? groupData.participants.map(p => p.id) : [];\n                    if (isStatus && statusJidList) {\n                        participantsList.push(...statusJidList);\n                    }\n                    const additionalDevices = await getUSyncDevices(participantsList, !!useUserDevicesCache, false);\n                    devices.push(...additionalDevices);\n                }\n                const patched = await patchMessageBeforeSending(message, devices.map(d => (0, WABinary_1.jidEncode)(d.user, isLid ? 'lid' : 's.whatsapp.net', d.device)));\n                const bytes = (0, Utils_1.encodeWAMessage)(patched);\n                const { ciphertext, senderKeyDistributionMessage } = await signalRepository.encryptGroupMessage({\n                    group: destinationJid,\n                    data: bytes,\n                    meId,\n                });\n                const senderKeyJids = [];\n                // ensure a connection is established with every device\n                for (const { user, device } of devices) {\n                    const jid = (0, WABinary_1.jidEncode)(user, isLid ? 'lid' : 's.whatsapp.net', device);\n                    if (!senderKeyMap[jid] || !!participant) {\n                        senderKeyJids.push(jid);\n                        // store that this person has had the sender keys sent to them\n                        senderKeyMap[jid] = true;\n                    }\n                }\n                // if there are some participants with whom the session has not been established\n                // if there are, we re-send the senderkey\n                if (senderKeyJids.length) {\n                    logger.debug({ senderKeyJids }, 'sending new sender key');\n                    const senderKeyMsg = {\n                        senderKeyDistributionMessage: {\n                            axolotlSenderKeyDistributionMessage: senderKeyDistributionMessage,\n                            groupId: destinationJid\n                        }\n                    };\n                    await assertSessions(senderKeyJids, false);\n                    const result = await createParticipantNodes(senderKeyJids, senderKeyMsg, extraAttrs);\n                    shouldIncludeDeviceIdentity = shouldIncludeDeviceIdentity || result.shouldIncludeDeviceIdentity;\n                    participants.push(...result.nodes);\n                }\n                binaryNodeContent.push({\n                    tag: 'enc',\n                    attrs: { v: '2', type: 'skmsg' },\n                    content: ciphertext\n                });\n                await authState.keys.set({ 'sender-key-memory': { [jid]: senderKeyMap } });\n            }\n            else {\n                const { user: meUser, device: meDevice } = (0, WABinary_1.jidDecode)(meId);\n                if (!participant) {\n                    devices.push({ user });\n                    // do not send message to self if the device is 0 (mobile)\n                    if (!((additionalAttributes === null || additionalAttributes === void 0 ? void 0 : additionalAttributes['category']) === 'peer' && user === meUser)) {\n                        if (meDevice !== undefined && meDevice !== 0) {\n                            devices.push({ user: meUser });\n                        }\n                        const additionalDevices = await getUSyncDevices([meId, jid], !!useUserDevicesCache, true);\n                        devices.push(...additionalDevices);\n                    }\n                }\n                const allJids = [];\n                const meJids = [];\n                const otherJids = [];\n                for (const { user, device } of devices) {\n                    const isMe = user === meUser;\n                    const jid = (0, WABinary_1.jidEncode)(isMe && isLid ? ((_c = (_b = authState.creds) === null || _b === void 0 ? void 0 : _b.me) === null || _c === void 0 ? void 0 : _c.lid.split(':')[0]) || user : user, isLid ? 'lid' : 's.whatsapp.net', device);\n                    if (isMe) {\n                        meJids.push(jid);\n                    }\n                    else {\n                        otherJids.push(jid);\n                    }\n                    allJids.push(jid);\n                }\n                await assertSessions(allJids, false);\n                const [{ nodes: meNodes, shouldIncludeDeviceIdentity: s1 }, { nodes: otherNodes, shouldIncludeDeviceIdentity: s2 }] = await Promise.all([\n                    createParticipantNodes(meJids, meMsg, extraAttrs),\n                    createParticipantNodes(otherJids, message, extraAttrs)\n                ]);\n                participants.push(...meNodes);\n                participants.push(...otherNodes);\n                shouldIncludeDeviceIdentity = shouldIncludeDeviceIdentity || s1 || s2;\n            }\n            if (participants.length) {\n                if ((additionalAttributes === null || additionalAttributes === void 0 ? void 0 : additionalAttributes['category']) === 'peer') {\n                    const peerNode = (_e = (_d = participants[0]) === null || _d === void 0 ? void 0 : _d.content) === null || _e === void 0 ? void 0 : _e[0];\n                    if (peerNode) {\n                        binaryNodeContent.push(peerNode); // push only enc\n                    }\n                }\n                else {\n                    binaryNodeContent.push({\n                        tag: 'participants',\n                        attrs: {},\n                        content: participants\n                    });\n                }\n            }\n            const stanza = {\n                tag: 'message',\n                attrs: {\n                    id: msgId,\n                    type: 'text',\n                    ...(additionalAttributes || {})\n                },\n                content: binaryNodeContent\n            };\n            // if the participant to send to is explicitly specified (generally retry recp)\n            // ensure the message is only sent to that person\n            // if a retry receipt is sent to everyone -- it'll fail decryption for everyone else who received the msg\n            if (participant) {\n                if ((0, WABinary_1.isJidGroup)(destinationJid)) {\n                    stanza.attrs.to = destinationJid;\n                    stanza.attrs.participant = participant.jid;\n                }\n                else if ((0, WABinary_1.areJidsSameUser)(participant.jid, meId)) {\n                    stanza.attrs.to = participant.jid;\n                    stanza.attrs.recipient = destinationJid;\n                }\n                else {\n                    stanza.attrs.to = participant.jid;\n                }\n            }\n            else {\n                stanza.attrs.to = destinationJid;\n            }\n            if (shouldIncludeDeviceIdentity) {\n                stanza.content.push({\n                    tag: 'device-identity',\n                    attrs: {},\n                    content: (0, Utils_1.encodeSignedDeviceIdentity)(authState.creds.account, true)\n                });\n                logger.debug({ jid }, 'adding device identity');\n            }\n            if (additionalNodes && additionalNodes.length > 0) {\n                stanza.content.push(...additionalNodes);\n            }\n            logger.debug({ msgId }, `sending message to ${participants.length} devices`);\n            await sendNode(stanza);\n        });\n        return msgId;\n    };\n    const getMediaType = (message) => {\n        if (message.imageMessage) {\n            return 'image';\n        }\n        else if (message.videoMessage) {\n            return message.videoMessage.gifPlayback ? 'gif' : 'video';\n        }\n        else if (message.audioMessage) {\n            return message.audioMessage.ptt ? 'ptt' : 'audio';\n        }\n        else if (message.contactMessage) {\n            return 'vcard';\n        }\n        else if (message.documentMessage) {\n            return 'document';\n        }\n        else if (message.contactsArrayMessage) {\n            return 'contact_array';\n        }\n        else if (message.liveLocationMessage) {\n            return 'livelocation';\n        }\n        else if (message.stickerMessage) {\n            return 'sticker';\n        }\n        else if (message.listMessage) {\n            return 'list';\n        }\n        else if (message.listResponseMessage) {\n            return 'list_response';\n        }\n        else if (message.buttonsResponseMessage) {\n            return 'buttons_response';\n        }\n        else if (message.orderMessage) {\n            return 'order';\n        }\n        else if (message.productMessage) {\n            return 'product';\n        }\n        else if (message.interactiveResponseMessage) {\n            return 'native_flow_response';\n        }\n        else if (message.groupInviteMessage) {\n            return 'url';\n        }\n    };\n    const getPrivacyTokens = async (jids) => {\n        const t = (0, Utils_1.unixTimestampSeconds)().toString();\n        const result = await query({\n            tag: 'iq',\n            attrs: {\n                to: WABinary_1.S_WHATSAPP_NET,\n                type: 'set',\n                xmlns: 'privacy'\n            },\n            content: [\n                {\n                    tag: 'tokens',\n                    attrs: {},\n                    content: jids.map(jid => ({\n                        tag: 'token',\n                        attrs: {\n                            jid: (0, WABinary_1.jidNormalizedUser)(jid),\n                            t,\n                            type: 'trusted_contact'\n                        }\n                    }))\n                }\n            ]\n        });\n        return result;\n    };\n    const waUploadToServer = (0, Utils_1.getWAUploadToServer)(config, refreshMediaConn);\n    const waitForMsgMediaUpdate = (0, Utils_1.bindWaitForEvent)(ev, 'messages.media-update');\n    return {\n        ...sock,\n        getPrivacyTokens,\n        assertSessions,\n        relayMessage,\n        sendReceipt,\n        sendReceipts,\n        readMessages,\n        refreshMediaConn,\n        waUploadToServer,\n        fetchPrivacySettings,\n        sendPeerDataOperationMessage,\n        createParticipantNodes,\n        getUSyncDevices,\n        updateMediaMessage: async (message) => {\n            const content = (0, Utils_1.assertMediaContent)(message.message);\n            const mediaKey = content.mediaKey;\n            const meId = authState.creds.me.id;\n            const node = (0, Utils_1.encryptMediaRetryRequest)(message.key, mediaKey, meId);\n            let error = undefined;\n            await Promise.all([\n                sendNode(node),\n                waitForMsgMediaUpdate(update => {\n                    const result = update.find(c => c.key.id === message.key.id);\n                    if (result) {\n                        if (result.error) {\n                            error = result.error;\n                        }\n                        else {\n                            try {\n                                const media = (0, Utils_1.decryptMediaRetryData)(result.media, mediaKey, result.key.id);\n                                if (media.result !== WAProto_1.proto.MediaRetryNotification.ResultType.SUCCESS) {\n                                    const resultStr = WAProto_1.proto.MediaRetryNotification.ResultType[media.result];\n                                    throw new boom_1.Boom(`Media re-upload failed by device (${resultStr})`, { data: media, statusCode: (0, Utils_1.getStatusCodeForMediaRetry)(media.result) || 404 });\n                                }\n                                content.directPath = media.directPath;\n                                content.url = (0, Utils_1.getUrlFromDirectPath)(content.directPath);\n                                logger.debug({ directPath: media.directPath, key: result.key }, 'media update successful');\n                            }\n                            catch (err) {\n                                error = err;\n                            }\n                        }\n                        return true;\n                    }\n                })\n            ]);\n            if (error) {\n                throw error;\n            }\n            ev.emit('messages.update', [\n                { key: message.key, update: { message: message.message } }\n            ]);\n            return message;\n        },\n        sendMessage: async (jid, content, options = {}) => {\n            var _a, _b, _c;\n            const userJid = authState.creds.me.id;\n            if (typeof content === 'object' &&\n                'disappearingMessagesInChat' in content &&\n                typeof content['disappearingMessagesInChat'] !== 'undefined' &&\n                (0, WABinary_1.isJidGroup)(jid)) {\n                const { disappearingMessagesInChat } = content;\n                const value = typeof disappearingMessagesInChat === 'boolean' ?\n                    (disappearingMessagesInChat ? Defaults_1.WA_DEFAULT_EPHEMERAL : 0) :\n                    disappearingMessagesInChat;\n                await groupToggleEphemeral(jid, value);\n            }\n            else {\n                const fullMsg = await (0, Utils_1.generateWAMessage)(jid, content, {\n                    logger,\n                    userJid,\n                    getUrlInfo: text => (0, link_preview_1.getUrlInfo)(text, {\n                        thumbnailWidth: linkPreviewImageThumbnailWidth,\n                        fetchOpts: {\n                            timeout: 3000,\n                            ...axiosOptions || {}\n                        },\n                        logger,\n                        uploadImage: generateHighQualityLinkPreview\n                            ? waUploadToServer\n                            : undefined\n                    }),\n                    //TODO: CACHE\n                    getProfilePicUrl: sock.profilePictureUrl,\n                    upload: waUploadToServer,\n                    mediaCache: config.mediaCache,\n                    options: config.options,\n                    messageId: (0, Utils_1.generateMessageIDV2)((_a = sock.user) === null || _a === void 0 ? void 0 : _a.id),\n                    ...options,\n                });\n                const isDeleteMsg = 'delete' in content && !!content.delete;\n                const isEditMsg = 'edit' in content && !!content.edit;\n                const isPinMsg = 'pin' in content && !!content.pin;\n                const additionalAttributes = {};\n                // required for delete\n                if (isDeleteMsg) {\n                    // if the chat is a group, and I am not the author, then delete the message as an admin\n                    if ((0, WABinary_1.isJidGroup)((_b = content.delete) === null || _b === void 0 ? void 0 : _b.remoteJid) && !((_c = content.delete) === null || _c === void 0 ? void 0 : _c.fromMe)) {\n                        additionalAttributes.edit = '8';\n                    }\n                    else {\n                        additionalAttributes.edit = '7';\n                    }\n                }\n                else if (isEditMsg) {\n                    additionalAttributes.edit = '1';\n                }\n                else if (isPinMsg) {\n                    additionalAttributes.edit = '2';\n                }\n                if ('cachedGroupMetadata' in options) {\n                    console.warn('cachedGroupMetadata in sendMessage are deprecated, now cachedGroupMetadata is part of the socket config.');\n                }\n                await relayMessage(jid, fullMsg.message, { messageId: fullMsg.key.id, useCachedGroupMetadata: options.useCachedGroupMetadata, additionalAttributes, statusJidList: options.statusJidList });\n                if (config.emitOwnEvents) {\n                    process.nextTick(() => {\n                        processingMutex.mutex(() => (upsertMessage(fullMsg, 'append')));\n                    });\n                }\n                return fullMsg;\n            }\n        }\n    };\n};\nexports.makeMessagesSocket = makeMessagesSocket;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}