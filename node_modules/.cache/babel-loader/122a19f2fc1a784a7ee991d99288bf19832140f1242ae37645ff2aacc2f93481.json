{"ast":null,"code":"import { WASMAudioDecoderCommon } from \"@wasm-audio-decoders/common\";\nimport CodecParser, { data, absoluteGranulePosition, samples, codecFrames, isLastPage } from \"codec-parser\";\nimport EmscriptenWASM from \"./EmscriptenWasm.js\";\nexport function Decoder() {\n  // injects dependencies when running as a web worker\n  // async\n  this._init = () => {\n    return new this._WASMAudioDecoderCommon().instantiate(this._EmscriptenWASM, this._module).then(common => {\n      this._common = common;\n      this._inputBytes = 0;\n      this._outputSamples = 0;\n      this._frameNumber = 0;\n      this._channels = this._common.allocateTypedArray(1, Uint32Array);\n      this._sampleRate = this._common.allocateTypedArray(1, Uint32Array);\n      this._bitsPerSample = this._common.allocateTypedArray(1, Uint32Array);\n      this._samplesDecoded = this._common.allocateTypedArray(1, Uint32Array);\n      this._outputBufferPtr = this._common.allocateTypedArray(1, Uint32Array);\n      this._outputBufferLen = this._common.allocateTypedArray(1, Uint32Array);\n      this._errorStringPtr = this._common.allocateTypedArray(1, Uint32Array);\n      this._stateStringPtr = this._common.allocateTypedArray(1, Uint32Array);\n      this._decoder = this._common.wasm.create_decoder(this._channels.ptr, this._sampleRate.ptr, this._bitsPerSample.ptr, this._samplesDecoded.ptr, this._outputBufferPtr.ptr, this._outputBufferLen.ptr, this._errorStringPtr.ptr, this._stateStringPtr.ptr);\n    });\n  };\n  Object.defineProperty(this, \"ready\", {\n    enumerable: true,\n    get: () => this._ready\n  });\n\n  // async\n  this.reset = () => {\n    this.free();\n    return this._init();\n  };\n  this.free = () => {\n    this._common.wasm.destroy_decoder(this._decoder);\n    this._common.free();\n  };\n  this._decode = data => {\n    if (!(data instanceof Uint8Array)) throw Error(\"Data to decode must be Uint8Array. Instead got \" + typeof data);\n    const input = this._common.allocateTypedArray(data.length, Uint8Array, false);\n    input.buf.set(data);\n    this._common.wasm.decode_frame(this._decoder, input.ptr, input.len);\n    let errorMessage = [],\n      error;\n    if (this._errorStringPtr.buf[0]) errorMessage.push(\"Error: \" + this._common.codeToString(this._errorStringPtr.buf[0]));\n    if (this._stateStringPtr.buf[0]) errorMessage.push(\"State: \" + this._common.codeToString(this._stateStringPtr.buf[0]));\n    if (errorMessage.length) {\n      error = errorMessage.join(\"; \");\n      console.error(\"@wasm-audio-decoders/flac: \\n\\t\" + errorMessage.join(\"\\n\\t\"));\n    }\n    const output = new Float32Array(this._common.wasm.HEAP, this._outputBufferPtr.buf[0], this._outputBufferLen.buf[0]);\n    const decoded = {\n      error: error,\n      outputBuffer: this._common.getOutputChannels(output, this._channels.buf[0], this._samplesDecoded.buf[0]),\n      samplesDecoded: this._samplesDecoded.buf[0]\n    };\n    this._common.wasm.free(this._outputBufferPtr.buf[0]);\n    this._outputBufferLen.buf[0] = 0;\n    this._samplesDecoded.buf[0] = 0;\n    return decoded;\n  };\n  this.decodeFrames = frames => {\n    let outputBuffers = [],\n      errors = [],\n      outputSamples = 0;\n    for (let i = 0; i < frames.length; i++) {\n      let offset = 0;\n      const data = frames[i];\n      while (offset < data.length) {\n        const chunk = data.subarray(offset, offset + this._MAX_INPUT_SIZE);\n        offset += chunk.length;\n        const decoded = this._decode(chunk);\n        outputBuffers.push(decoded.outputBuffer);\n        outputSamples += decoded.samplesDecoded;\n        if (decoded.error) this._common.addError(errors, decoded.error, data.length, this._frameNumber, this._inputBytes, this._outputSamples);\n        this._inputBytes += data.length;\n        this._outputSamples += decoded.samplesDecoded;\n      }\n      this._frameNumber++;\n    }\n    return this._WASMAudioDecoderCommon.getDecodedAudioMultiChannel(errors, outputBuffers, this._channels.buf[0], outputSamples, this._sampleRate.buf[0], this._bitsPerSample.buf[0]);\n  };\n\n  // injects dependencies when running as a web worker\n  this._isWebWorker = Decoder.isWebWorker;\n  this._WASMAudioDecoderCommon = Decoder.WASMAudioDecoderCommon || WASMAudioDecoderCommon;\n  this._EmscriptenWASM = Decoder.EmscriptenWASM || EmscriptenWASM;\n  this._module = Decoder.module;\n  this._MAX_INPUT_SIZE = 65535 * 8;\n  this._ready = this._init();\n  return this;\n}\nexport const setDecoderClass = Symbol();\nconst determineDecodeMethod = Symbol();\nconst decodeFlac = Symbol();\nconst decodeOggFlac = Symbol();\nconst placeholderDecodeMethod = Symbol();\nconst decodeMethod = Symbol();\nconst init = Symbol();\nexport default class FLACDecoder {\n  constructor() {\n    this._onCodec = codec => {\n      if (codec !== \"flac\") throw new Error(\"@wasm-audio-decoders/flac does not support this codec \" + codec);\n    };\n\n    // instantiate to create static properties\n    new WASMAudioDecoderCommon();\n    this[init]();\n    this[setDecoderClass](Decoder);\n  }\n  [init]() {\n    this[decodeMethod] = placeholderDecodeMethod;\n    this._codecParser = null;\n    this._beginningSampleOffset = undefined;\n  }\n  [determineDecodeMethod](data) {\n    if (!this._codecParser && data.length >= 4) {\n      let codec = \"audio/\";\n      if (data[0] !== 0x4f ||\n      // O\n      data[1] !== 0x67 ||\n      // g\n      data[2] !== 0x67 ||\n      // g\n      data[3] !== 0x53 //    S\n      ) {\n        codec += \"flac\";\n        this[decodeMethod] = decodeFlac;\n      } else {\n        codec += \"ogg\";\n        this[decodeMethod] = decodeOggFlac;\n      }\n      this._codecParser = new CodecParser(codec, {\n        onCodec: this._onCodec,\n        enableFrameCRC32: false\n      });\n    }\n  }\n  [setDecoderClass](decoderClass) {\n    if (this._decoder) {\n      const oldDecoder = this._decoder;\n      oldDecoder.ready.then(() => oldDecoder.free());\n    }\n    this._decoder = new decoderClass();\n    this._ready = this._decoder.ready;\n  }\n  [decodeFlac](flacFrames) {\n    return this._decoder.decodeFrames(flacFrames.map(f => f[data] || f));\n  }\n  [decodeOggFlac](oggPages) {\n    const frames = oggPages.map(page => page[codecFrames].map(f => f[data])).flat();\n    const decoded = this._decoder.decodeFrames(frames);\n    const oggPage = oggPages[oggPages.length - 1];\n    if (oggPages.length && Number(oggPage[absoluteGranulePosition]) > -1) {\n      if (this._beginningSampleOffset === undefined) {\n        this._beginningSampleOffset = oggPage[absoluteGranulePosition] - BigInt(oggPage[samples]);\n      }\n      if (oggPage[isLastPage]) {\n        // trim any extra samples that are decoded beyond the absoluteGranulePosition, relative to where we started in the stream\n        const samplesToTrim = decoded.samplesDecoded - Number(oggPage[absoluteGranulePosition]);\n        if (samplesToTrim > 0) {\n          for (let i = 0; i < decoded.channelData.length; i++) decoded.channelData[i] = decoded.channelData[i].subarray(0, decoded.samplesDecoded - samplesToTrim);\n          decoded.samplesDecoded -= samplesToTrim;\n        }\n      }\n    }\n    return decoded;\n  }\n  [placeholderDecodeMethod]() {\n    return WASMAudioDecoderCommon.getDecodedAudio([], [], 0, 0, 0);\n  }\n  get ready() {\n    return this._ready;\n  }\n  async reset() {\n    this[init]();\n    return this._decoder.reset();\n  }\n  free() {\n    this._decoder.free();\n  }\n  async decode(flacData) {\n    if (this[decodeMethod] === placeholderDecodeMethod) this[determineDecodeMethod](flacData);\n    return this[this[decodeMethod]]([...this._codecParser.parseChunk(flacData)]);\n  }\n  async flush() {\n    const decoded = this[this[decodeMethod]]([...this._codecParser.flush()]);\n    await this.reset();\n    return decoded;\n  }\n  async decodeFile(flacData) {\n    this[determineDecodeMethod](flacData);\n    const decoded = this[this[decodeMethod]]([...this._codecParser.parseAll(flacData)]);\n    await this.reset();\n    return decoded;\n  }\n  async decodeFrames(flacFrames) {\n    return this[decodeFlac](flacFrames);\n  }\n}","map":{"version":3,"names":["WASMAudioDecoderCommon","CodecParser","data","absoluteGranulePosition","samples","codecFrames","isLastPage","EmscriptenWASM","Decoder","_init","_WASMAudioDecoderCommon","instantiate","_EmscriptenWASM","_module","then","common","_common","_inputBytes","_outputSamples","_frameNumber","_channels","allocateTypedArray","Uint32Array","_sampleRate","_bitsPerSample","_samplesDecoded","_outputBufferPtr","_outputBufferLen","_errorStringPtr","_stateStringPtr","_decoder","wasm","create_decoder","ptr","Object","defineProperty","enumerable","get","_ready","reset","free","destroy_decoder","_decode","Uint8Array","Error","input","length","buf","set","decode_frame","len","errorMessage","error","push","codeToString","join","console","output","Float32Array","HEAP","decoded","outputBuffer","getOutputChannels","samplesDecoded","decodeFrames","frames","outputBuffers","errors","outputSamples","i","offset","chunk","subarray","_MAX_INPUT_SIZE","addError","getDecodedAudioMultiChannel","_isWebWorker","isWebWorker","module","setDecoderClass","Symbol","determineDecodeMethod","decodeFlac","decodeOggFlac","placeholderDecodeMethod","decodeMethod","init","FLACDecoder","constructor","_onCodec","codec","_codecParser","_beginningSampleOffset","undefined","onCodec","enableFrameCRC32","decoderClass","oldDecoder","ready","flacFrames","map","f","oggPages","page","flat","oggPage","Number","BigInt","samplesToTrim","channelData","getDecodedAudio","decode","flacData","parseChunk","flush","decodeFile","parseAll"],"sources":["C:/Users/vanitas/node_modules/@wasm-audio-decoders/flac/src/FLACDecoder.js"],"sourcesContent":["import { WASMAudioDecoderCommon } from \"@wasm-audio-decoders/common\";\nimport CodecParser, {\n  data,\n  absoluteGranulePosition,\n  samples,\n  codecFrames,\n  isLastPage,\n} from \"codec-parser\";\n\nimport EmscriptenWASM from \"./EmscriptenWasm.js\";\n\nexport function Decoder() {\n  // injects dependencies when running as a web worker\n  // async\n  this._init = () => {\n    return new this._WASMAudioDecoderCommon()\n      .instantiate(this._EmscriptenWASM, this._module)\n      .then((common) => {\n        this._common = common;\n\n        this._inputBytes = 0;\n        this._outputSamples = 0;\n        this._frameNumber = 0;\n\n        this._channels = this._common.allocateTypedArray(1, Uint32Array);\n        this._sampleRate = this._common.allocateTypedArray(1, Uint32Array);\n        this._bitsPerSample = this._common.allocateTypedArray(1, Uint32Array);\n        this._samplesDecoded = this._common.allocateTypedArray(1, Uint32Array);\n        this._outputBufferPtr = this._common.allocateTypedArray(1, Uint32Array);\n        this._outputBufferLen = this._common.allocateTypedArray(1, Uint32Array);\n\n        this._errorStringPtr = this._common.allocateTypedArray(1, Uint32Array);\n        this._stateStringPtr = this._common.allocateTypedArray(1, Uint32Array);\n\n        this._decoder = this._common.wasm.create_decoder(\n          this._channels.ptr,\n          this._sampleRate.ptr,\n          this._bitsPerSample.ptr,\n          this._samplesDecoded.ptr,\n          this._outputBufferPtr.ptr,\n          this._outputBufferLen.ptr,\n          this._errorStringPtr.ptr,\n          this._stateStringPtr.ptr,\n        );\n      });\n  };\n\n  Object.defineProperty(this, \"ready\", {\n    enumerable: true,\n    get: () => this._ready,\n  });\n\n  // async\n  this.reset = () => {\n    this.free();\n    return this._init();\n  };\n\n  this.free = () => {\n    this._common.wasm.destroy_decoder(this._decoder);\n\n    this._common.free();\n  };\n\n  this._decode = (data) => {\n    if (!(data instanceof Uint8Array))\n      throw Error(\n        \"Data to decode must be Uint8Array. Instead got \" + typeof data,\n      );\n\n    const input = this._common.allocateTypedArray(\n      data.length,\n      Uint8Array,\n      false,\n    );\n    input.buf.set(data);\n\n    this._common.wasm.decode_frame(this._decoder, input.ptr, input.len);\n\n    let errorMessage = [],\n      error;\n    if (this._errorStringPtr.buf[0])\n      errorMessage.push(\n        \"Error: \" + this._common.codeToString(this._errorStringPtr.buf[0]),\n      );\n\n    if (this._stateStringPtr.buf[0])\n      errorMessage.push(\n        \"State: \" + this._common.codeToString(this._stateStringPtr.buf[0]),\n      );\n\n    if (errorMessage.length) {\n      error = errorMessage.join(\"; \");\n      console.error(\n        \"@wasm-audio-decoders/flac: \\n\\t\" + errorMessage.join(\"\\n\\t\"),\n      );\n    }\n\n    const output = new Float32Array(\n      this._common.wasm.HEAP,\n      this._outputBufferPtr.buf[0],\n      this._outputBufferLen.buf[0],\n    );\n\n    const decoded = {\n      error: error,\n      outputBuffer: this._common.getOutputChannels(\n        output,\n        this._channels.buf[0],\n        this._samplesDecoded.buf[0],\n      ),\n      samplesDecoded: this._samplesDecoded.buf[0],\n    };\n\n    this._common.wasm.free(this._outputBufferPtr.buf[0]);\n    this._outputBufferLen.buf[0] = 0;\n    this._samplesDecoded.buf[0] = 0;\n\n    return decoded;\n  };\n\n  this.decodeFrames = (frames) => {\n    let outputBuffers = [],\n      errors = [],\n      outputSamples = 0;\n\n    for (let i = 0; i < frames.length; i++) {\n      let offset = 0;\n      const data = frames[i];\n\n      while (offset < data.length) {\n        const chunk = data.subarray(offset, offset + this._MAX_INPUT_SIZE);\n        offset += chunk.length;\n\n        const decoded = this._decode(chunk);\n\n        outputBuffers.push(decoded.outputBuffer);\n        outputSamples += decoded.samplesDecoded;\n\n        if (decoded.error)\n          this._common.addError(\n            errors,\n            decoded.error,\n            data.length,\n            this._frameNumber,\n            this._inputBytes,\n            this._outputSamples,\n          );\n\n        this._inputBytes += data.length;\n        this._outputSamples += decoded.samplesDecoded;\n      }\n\n      this._frameNumber++;\n    }\n\n    return this._WASMAudioDecoderCommon.getDecodedAudioMultiChannel(\n      errors,\n      outputBuffers,\n      this._channels.buf[0],\n      outputSamples,\n      this._sampleRate.buf[0],\n      this._bitsPerSample.buf[0],\n    );\n  };\n\n  // injects dependencies when running as a web worker\n  this._isWebWorker = Decoder.isWebWorker;\n  this._WASMAudioDecoderCommon =\n    Decoder.WASMAudioDecoderCommon || WASMAudioDecoderCommon;\n  this._EmscriptenWASM = Decoder.EmscriptenWASM || EmscriptenWASM;\n  this._module = Decoder.module;\n\n  this._MAX_INPUT_SIZE = 65535 * 8;\n\n  this._ready = this._init();\n\n  return this;\n}\n\nexport const setDecoderClass = Symbol();\n\nconst determineDecodeMethod = Symbol();\nconst decodeFlac = Symbol();\nconst decodeOggFlac = Symbol();\nconst placeholderDecodeMethod = Symbol();\nconst decodeMethod = Symbol();\nconst init = Symbol();\n\nexport default class FLACDecoder {\n  constructor() {\n    this._onCodec = (codec) => {\n      if (codec !== \"flac\")\n        throw new Error(\n          \"@wasm-audio-decoders/flac does not support this codec \" + codec,\n        );\n    };\n\n    // instantiate to create static properties\n    new WASMAudioDecoderCommon();\n\n    this[init]();\n    this[setDecoderClass](Decoder);\n  }\n\n  [init]() {\n    this[decodeMethod] = placeholderDecodeMethod;\n    this._codecParser = null;\n    this._beginningSampleOffset = undefined;\n  }\n\n  [determineDecodeMethod](data) {\n    if (!this._codecParser && data.length >= 4) {\n      let codec = \"audio/\";\n\n      if (\n        data[0] !== 0x4f || // O\n        data[1] !== 0x67 || // g\n        data[2] !== 0x67 || // g\n        data[3] !== 0x53 //    S\n      ) {\n        codec += \"flac\";\n        this[decodeMethod] = decodeFlac;\n      } else {\n        codec += \"ogg\";\n        this[decodeMethod] = decodeOggFlac;\n      }\n\n      this._codecParser = new CodecParser(codec, {\n        onCodec: this._onCodec,\n        enableFrameCRC32: false,\n      });\n    }\n  }\n\n  [setDecoderClass](decoderClass) {\n    if (this._decoder) {\n      const oldDecoder = this._decoder;\n      oldDecoder.ready.then(() => oldDecoder.free());\n    }\n\n    this._decoder = new decoderClass();\n    this._ready = this._decoder.ready;\n  }\n\n  [decodeFlac](flacFrames) {\n    return this._decoder.decodeFrames(flacFrames.map((f) => f[data] || f));\n  }\n\n  [decodeOggFlac](oggPages) {\n    const frames = oggPages\n      .map((page) => page[codecFrames].map((f) => f[data]))\n      .flat();\n\n    const decoded = this._decoder.decodeFrames(frames);\n\n    const oggPage = oggPages[oggPages.length - 1];\n    if (oggPages.length && Number(oggPage[absoluteGranulePosition]) > -1) {\n      if (this._beginningSampleOffset === undefined) {\n        this._beginningSampleOffset =\n          oggPage[absoluteGranulePosition] - BigInt(oggPage[samples]);\n      }\n\n      if (oggPage[isLastPage]) {\n        // trim any extra samples that are decoded beyond the absoluteGranulePosition, relative to where we started in the stream\n        const samplesToTrim =\n          decoded.samplesDecoded - Number(oggPage[absoluteGranulePosition]);\n\n        if (samplesToTrim > 0) {\n          for (let i = 0; i < decoded.channelData.length; i++)\n            decoded.channelData[i] = decoded.channelData[i].subarray(\n              0,\n              decoded.samplesDecoded - samplesToTrim,\n            );\n\n          decoded.samplesDecoded -= samplesToTrim;\n        }\n      }\n    }\n\n    return decoded;\n  }\n\n  [placeholderDecodeMethod]() {\n    return WASMAudioDecoderCommon.getDecodedAudio([], [], 0, 0, 0);\n  }\n\n  get ready() {\n    return this._ready;\n  }\n\n  async reset() {\n    this[init]();\n    return this._decoder.reset();\n  }\n\n  free() {\n    this._decoder.free();\n  }\n\n  async decode(flacData) {\n    if (this[decodeMethod] === placeholderDecodeMethod)\n      this[determineDecodeMethod](flacData);\n\n    return this[this[decodeMethod]]([\n      ...this._codecParser.parseChunk(flacData),\n    ]);\n  }\n\n  async flush() {\n    const decoded = this[this[decodeMethod]]([...this._codecParser.flush()]);\n\n    await this.reset();\n    return decoded;\n  }\n\n  async decodeFile(flacData) {\n    this[determineDecodeMethod](flacData);\n\n    const decoded = this[this[decodeMethod]]([\n      ...this._codecParser.parseAll(flacData),\n    ]);\n\n    await this.reset();\n    return decoded;\n  }\n\n  async decodeFrames(flacFrames) {\n    return this[decodeFlac](flacFrames);\n  }\n}\n"],"mappings":"AAAA,SAASA,sBAAsB,QAAQ,6BAA6B;AACpE,OAAOC,WAAW,IAChBC,IAAI,EACJC,uBAAuB,EACvBC,OAAO,EACPC,WAAW,EACXC,UAAU,QACL,cAAc;AAErB,OAAOC,cAAc,MAAM,qBAAqB;AAEhD,OAAO,SAASC,OAAOA,CAAA,EAAG;EACxB;EACA;EACA,IAAI,CAACC,KAAK,GAAG,MAAM;IACjB,OAAO,IAAI,IAAI,CAACC,uBAAuB,CAAC,CAAC,CACtCC,WAAW,CAAC,IAAI,CAACC,eAAe,EAAE,IAAI,CAACC,OAAO,CAAC,CAC/CC,IAAI,CAAEC,MAAM,IAAK;MAChB,IAAI,CAACC,OAAO,GAAGD,MAAM;MAErB,IAAI,CAACE,WAAW,GAAG,CAAC;MACpB,IAAI,CAACC,cAAc,GAAG,CAAC;MACvB,IAAI,CAACC,YAAY,GAAG,CAAC;MAErB,IAAI,CAACC,SAAS,GAAG,IAAI,CAACJ,OAAO,CAACK,kBAAkB,CAAC,CAAC,EAAEC,WAAW,CAAC;MAChE,IAAI,CAACC,WAAW,GAAG,IAAI,CAACP,OAAO,CAACK,kBAAkB,CAAC,CAAC,EAAEC,WAAW,CAAC;MAClE,IAAI,CAACE,cAAc,GAAG,IAAI,CAACR,OAAO,CAACK,kBAAkB,CAAC,CAAC,EAAEC,WAAW,CAAC;MACrE,IAAI,CAACG,eAAe,GAAG,IAAI,CAACT,OAAO,CAACK,kBAAkB,CAAC,CAAC,EAAEC,WAAW,CAAC;MACtE,IAAI,CAACI,gBAAgB,GAAG,IAAI,CAACV,OAAO,CAACK,kBAAkB,CAAC,CAAC,EAAEC,WAAW,CAAC;MACvE,IAAI,CAACK,gBAAgB,GAAG,IAAI,CAACX,OAAO,CAACK,kBAAkB,CAAC,CAAC,EAAEC,WAAW,CAAC;MAEvE,IAAI,CAACM,eAAe,GAAG,IAAI,CAACZ,OAAO,CAACK,kBAAkB,CAAC,CAAC,EAAEC,WAAW,CAAC;MACtE,IAAI,CAACO,eAAe,GAAG,IAAI,CAACb,OAAO,CAACK,kBAAkB,CAAC,CAAC,EAAEC,WAAW,CAAC;MAEtE,IAAI,CAACQ,QAAQ,GAAG,IAAI,CAACd,OAAO,CAACe,IAAI,CAACC,cAAc,CAC9C,IAAI,CAACZ,SAAS,CAACa,GAAG,EAClB,IAAI,CAACV,WAAW,CAACU,GAAG,EACpB,IAAI,CAACT,cAAc,CAACS,GAAG,EACvB,IAAI,CAACR,eAAe,CAACQ,GAAG,EACxB,IAAI,CAACP,gBAAgB,CAACO,GAAG,EACzB,IAAI,CAACN,gBAAgB,CAACM,GAAG,EACzB,IAAI,CAACL,eAAe,CAACK,GAAG,EACxB,IAAI,CAACJ,eAAe,CAACI,GACvB,CAAC;IACH,CAAC,CAAC;EACN,CAAC;EAEDC,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,OAAO,EAAE;IACnCC,UAAU,EAAE,IAAI;IAChBC,GAAG,EAAEA,CAAA,KAAM,IAAI,CAACC;EAClB,CAAC,CAAC;;EAEF;EACA,IAAI,CAACC,KAAK,GAAG,MAAM;IACjB,IAAI,CAACC,IAAI,CAAC,CAAC;IACX,OAAO,IAAI,CAAC/B,KAAK,CAAC,CAAC;EACrB,CAAC;EAED,IAAI,CAAC+B,IAAI,GAAG,MAAM;IAChB,IAAI,CAACxB,OAAO,CAACe,IAAI,CAACU,eAAe,CAAC,IAAI,CAACX,QAAQ,CAAC;IAEhD,IAAI,CAACd,OAAO,CAACwB,IAAI,CAAC,CAAC;EACrB,CAAC;EAED,IAAI,CAACE,OAAO,GAAIxC,IAAI,IAAK;IACvB,IAAI,EAAEA,IAAI,YAAYyC,UAAU,CAAC,EAC/B,MAAMC,KAAK,CACT,iDAAiD,GAAG,OAAO1C,IAC7D,CAAC;IAEH,MAAM2C,KAAK,GAAG,IAAI,CAAC7B,OAAO,CAACK,kBAAkB,CAC3CnB,IAAI,CAAC4C,MAAM,EACXH,UAAU,EACV,KACF,CAAC;IACDE,KAAK,CAACE,GAAG,CAACC,GAAG,CAAC9C,IAAI,CAAC;IAEnB,IAAI,CAACc,OAAO,CAACe,IAAI,CAACkB,YAAY,CAAC,IAAI,CAACnB,QAAQ,EAAEe,KAAK,CAACZ,GAAG,EAAEY,KAAK,CAACK,GAAG,CAAC;IAEnE,IAAIC,YAAY,GAAG,EAAE;MACnBC,KAAK;IACP,IAAI,IAAI,CAACxB,eAAe,CAACmB,GAAG,CAAC,CAAC,CAAC,EAC7BI,YAAY,CAACE,IAAI,CACf,SAAS,GAAG,IAAI,CAACrC,OAAO,CAACsC,YAAY,CAAC,IAAI,CAAC1B,eAAe,CAACmB,GAAG,CAAC,CAAC,CAAC,CACnE,CAAC;IAEH,IAAI,IAAI,CAAClB,eAAe,CAACkB,GAAG,CAAC,CAAC,CAAC,EAC7BI,YAAY,CAACE,IAAI,CACf,SAAS,GAAG,IAAI,CAACrC,OAAO,CAACsC,YAAY,CAAC,IAAI,CAACzB,eAAe,CAACkB,GAAG,CAAC,CAAC,CAAC,CACnE,CAAC;IAEH,IAAII,YAAY,CAACL,MAAM,EAAE;MACvBM,KAAK,GAAGD,YAAY,CAACI,IAAI,CAAC,IAAI,CAAC;MAC/BC,OAAO,CAACJ,KAAK,CACX,iCAAiC,GAAGD,YAAY,CAACI,IAAI,CAAC,MAAM,CAC9D,CAAC;IACH;IAEA,MAAME,MAAM,GAAG,IAAIC,YAAY,CAC7B,IAAI,CAAC1C,OAAO,CAACe,IAAI,CAAC4B,IAAI,EACtB,IAAI,CAACjC,gBAAgB,CAACqB,GAAG,CAAC,CAAC,CAAC,EAC5B,IAAI,CAACpB,gBAAgB,CAACoB,GAAG,CAAC,CAAC,CAC7B,CAAC;IAED,MAAMa,OAAO,GAAG;MACdR,KAAK,EAAEA,KAAK;MACZS,YAAY,EAAE,IAAI,CAAC7C,OAAO,CAAC8C,iBAAiB,CAC1CL,MAAM,EACN,IAAI,CAACrC,SAAS,CAAC2B,GAAG,CAAC,CAAC,CAAC,EACrB,IAAI,CAACtB,eAAe,CAACsB,GAAG,CAAC,CAAC,CAC5B,CAAC;MACDgB,cAAc,EAAE,IAAI,CAACtC,eAAe,CAACsB,GAAG,CAAC,CAAC;IAC5C,CAAC;IAED,IAAI,CAAC/B,OAAO,CAACe,IAAI,CAACS,IAAI,CAAC,IAAI,CAACd,gBAAgB,CAACqB,GAAG,CAAC,CAAC,CAAC,CAAC;IACpD,IAAI,CAACpB,gBAAgB,CAACoB,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;IAChC,IAAI,CAACtB,eAAe,CAACsB,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;IAE/B,OAAOa,OAAO;EAChB,CAAC;EAED,IAAI,CAACI,YAAY,GAAIC,MAAM,IAAK;IAC9B,IAAIC,aAAa,GAAG,EAAE;MACpBC,MAAM,GAAG,EAAE;MACXC,aAAa,GAAG,CAAC;IAEnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,MAAM,CAACnB,MAAM,EAAEuB,CAAC,EAAE,EAAE;MACtC,IAAIC,MAAM,GAAG,CAAC;MACd,MAAMpE,IAAI,GAAG+D,MAAM,CAACI,CAAC,CAAC;MAEtB,OAAOC,MAAM,GAAGpE,IAAI,CAAC4C,MAAM,EAAE;QAC3B,MAAMyB,KAAK,GAAGrE,IAAI,CAACsE,QAAQ,CAACF,MAAM,EAAEA,MAAM,GAAG,IAAI,CAACG,eAAe,CAAC;QAClEH,MAAM,IAAIC,KAAK,CAACzB,MAAM;QAEtB,MAAMc,OAAO,GAAG,IAAI,CAAClB,OAAO,CAAC6B,KAAK,CAAC;QAEnCL,aAAa,CAACb,IAAI,CAACO,OAAO,CAACC,YAAY,CAAC;QACxCO,aAAa,IAAIR,OAAO,CAACG,cAAc;QAEvC,IAAIH,OAAO,CAACR,KAAK,EACf,IAAI,CAACpC,OAAO,CAAC0D,QAAQ,CACnBP,MAAM,EACNP,OAAO,CAACR,KAAK,EACblD,IAAI,CAAC4C,MAAM,EACX,IAAI,CAAC3B,YAAY,EACjB,IAAI,CAACF,WAAW,EAChB,IAAI,CAACC,cACP,CAAC;QAEH,IAAI,CAACD,WAAW,IAAIf,IAAI,CAAC4C,MAAM;QAC/B,IAAI,CAAC5B,cAAc,IAAI0C,OAAO,CAACG,cAAc;MAC/C;MAEA,IAAI,CAAC5C,YAAY,EAAE;IACrB;IAEA,OAAO,IAAI,CAACT,uBAAuB,CAACiE,2BAA2B,CAC7DR,MAAM,EACND,aAAa,EACb,IAAI,CAAC9C,SAAS,CAAC2B,GAAG,CAAC,CAAC,CAAC,EACrBqB,aAAa,EACb,IAAI,CAAC7C,WAAW,CAACwB,GAAG,CAAC,CAAC,CAAC,EACvB,IAAI,CAACvB,cAAc,CAACuB,GAAG,CAAC,CAAC,CAC3B,CAAC;EACH,CAAC;;EAED;EACA,IAAI,CAAC6B,YAAY,GAAGpE,OAAO,CAACqE,WAAW;EACvC,IAAI,CAACnE,uBAAuB,GAC1BF,OAAO,CAACR,sBAAsB,IAAIA,sBAAsB;EAC1D,IAAI,CAACY,eAAe,GAAGJ,OAAO,CAACD,cAAc,IAAIA,cAAc;EAC/D,IAAI,CAACM,OAAO,GAAGL,OAAO,CAACsE,MAAM;EAE7B,IAAI,CAACL,eAAe,GAAG,KAAK,GAAG,CAAC;EAEhC,IAAI,CAACnC,MAAM,GAAG,IAAI,CAAC7B,KAAK,CAAC,CAAC;EAE1B,OAAO,IAAI;AACb;AAEA,OAAO,MAAMsE,eAAe,GAAGC,MAAM,CAAC,CAAC;AAEvC,MAAMC,qBAAqB,GAAGD,MAAM,CAAC,CAAC;AACtC,MAAME,UAAU,GAAGF,MAAM,CAAC,CAAC;AAC3B,MAAMG,aAAa,GAAGH,MAAM,CAAC,CAAC;AAC9B,MAAMI,uBAAuB,GAAGJ,MAAM,CAAC,CAAC;AACxC,MAAMK,YAAY,GAAGL,MAAM,CAAC,CAAC;AAC7B,MAAMM,IAAI,GAAGN,MAAM,CAAC,CAAC;AAErB,eAAe,MAAMO,WAAW,CAAC;EAC/BC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,QAAQ,GAAIC,KAAK,IAAK;MACzB,IAAIA,KAAK,KAAK,MAAM,EAClB,MAAM,IAAI9C,KAAK,CACb,wDAAwD,GAAG8C,KAC7D,CAAC;IACL,CAAC;;IAED;IACA,IAAI1F,sBAAsB,CAAC,CAAC;IAE5B,IAAI,CAACsF,IAAI,CAAC,CAAC,CAAC;IACZ,IAAI,CAACP,eAAe,CAAC,CAACvE,OAAO,CAAC;EAChC;EAEA,CAAC8E,IAAI,IAAI;IACP,IAAI,CAACD,YAAY,CAAC,GAAGD,uBAAuB;IAC5C,IAAI,CAACO,YAAY,GAAG,IAAI;IACxB,IAAI,CAACC,sBAAsB,GAAGC,SAAS;EACzC;EAEA,CAACZ,qBAAqB,EAAE/E,IAAI,EAAE;IAC5B,IAAI,CAAC,IAAI,CAACyF,YAAY,IAAIzF,IAAI,CAAC4C,MAAM,IAAI,CAAC,EAAE;MAC1C,IAAI4C,KAAK,GAAG,QAAQ;MAEpB,IACExF,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI;MAAI;MACpBA,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI;MAAI;MACpBA,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI;MAAI;MACpBA,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC;MAAA,EACjB;QACAwF,KAAK,IAAI,MAAM;QACf,IAAI,CAACL,YAAY,CAAC,GAAGH,UAAU;MACjC,CAAC,MAAM;QACLQ,KAAK,IAAI,KAAK;QACd,IAAI,CAACL,YAAY,CAAC,GAAGF,aAAa;MACpC;MAEA,IAAI,CAACQ,YAAY,GAAG,IAAI1F,WAAW,CAACyF,KAAK,EAAE;QACzCI,OAAO,EAAE,IAAI,CAACL,QAAQ;QACtBM,gBAAgB,EAAE;MACpB,CAAC,CAAC;IACJ;EACF;EAEA,CAAChB,eAAe,EAAEiB,YAAY,EAAE;IAC9B,IAAI,IAAI,CAAClE,QAAQ,EAAE;MACjB,MAAMmE,UAAU,GAAG,IAAI,CAACnE,QAAQ;MAChCmE,UAAU,CAACC,KAAK,CAACpF,IAAI,CAAC,MAAMmF,UAAU,CAACzD,IAAI,CAAC,CAAC,CAAC;IAChD;IAEA,IAAI,CAACV,QAAQ,GAAG,IAAIkE,YAAY,CAAC,CAAC;IAClC,IAAI,CAAC1D,MAAM,GAAG,IAAI,CAACR,QAAQ,CAACoE,KAAK;EACnC;EAEA,CAAChB,UAAU,EAAEiB,UAAU,EAAE;IACvB,OAAO,IAAI,CAACrE,QAAQ,CAACkC,YAAY,CAACmC,UAAU,CAACC,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACnG,IAAI,CAAC,IAAImG,CAAC,CAAC,CAAC;EACxE;EAEA,CAAClB,aAAa,EAAEmB,QAAQ,EAAE;IACxB,MAAMrC,MAAM,GAAGqC,QAAQ,CACpBF,GAAG,CAAEG,IAAI,IAAKA,IAAI,CAAClG,WAAW,CAAC,CAAC+F,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACnG,IAAI,CAAC,CAAC,CAAC,CACpDsG,IAAI,CAAC,CAAC;IAET,MAAM5C,OAAO,GAAG,IAAI,CAAC9B,QAAQ,CAACkC,YAAY,CAACC,MAAM,CAAC;IAElD,MAAMwC,OAAO,GAAGH,QAAQ,CAACA,QAAQ,CAACxD,MAAM,GAAG,CAAC,CAAC;IAC7C,IAAIwD,QAAQ,CAACxD,MAAM,IAAI4D,MAAM,CAACD,OAAO,CAACtG,uBAAuB,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;MACpE,IAAI,IAAI,CAACyF,sBAAsB,KAAKC,SAAS,EAAE;QAC7C,IAAI,CAACD,sBAAsB,GACzBa,OAAO,CAACtG,uBAAuB,CAAC,GAAGwG,MAAM,CAACF,OAAO,CAACrG,OAAO,CAAC,CAAC;MAC/D;MAEA,IAAIqG,OAAO,CAACnG,UAAU,CAAC,EAAE;QACvB;QACA,MAAMsG,aAAa,GACjBhD,OAAO,CAACG,cAAc,GAAG2C,MAAM,CAACD,OAAO,CAACtG,uBAAuB,CAAC,CAAC;QAEnE,IAAIyG,aAAa,GAAG,CAAC,EAAE;UACrB,KAAK,IAAIvC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,OAAO,CAACiD,WAAW,CAAC/D,MAAM,EAAEuB,CAAC,EAAE,EACjDT,OAAO,CAACiD,WAAW,CAACxC,CAAC,CAAC,GAAGT,OAAO,CAACiD,WAAW,CAACxC,CAAC,CAAC,CAACG,QAAQ,CACtD,CAAC,EACDZ,OAAO,CAACG,cAAc,GAAG6C,aAC3B,CAAC;UAEHhD,OAAO,CAACG,cAAc,IAAI6C,aAAa;QACzC;MACF;IACF;IAEA,OAAOhD,OAAO;EAChB;EAEA,CAACwB,uBAAuB,IAAI;IAC1B,OAAOpF,sBAAsB,CAAC8G,eAAe,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAChE;EAEA,IAAIZ,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAAC5D,MAAM;EACpB;EAEA,MAAMC,KAAKA,CAAA,EAAG;IACZ,IAAI,CAAC+C,IAAI,CAAC,CAAC,CAAC;IACZ,OAAO,IAAI,CAACxD,QAAQ,CAACS,KAAK,CAAC,CAAC;EAC9B;EAEAC,IAAIA,CAAA,EAAG;IACL,IAAI,CAACV,QAAQ,CAACU,IAAI,CAAC,CAAC;EACtB;EAEA,MAAMuE,MAAMA,CAACC,QAAQ,EAAE;IACrB,IAAI,IAAI,CAAC3B,YAAY,CAAC,KAAKD,uBAAuB,EAChD,IAAI,CAACH,qBAAqB,CAAC,CAAC+B,QAAQ,CAAC;IAEvC,OAAO,IAAI,CAAC,IAAI,CAAC3B,YAAY,CAAC,CAAC,CAAC,CAC9B,GAAG,IAAI,CAACM,YAAY,CAACsB,UAAU,CAACD,QAAQ,CAAC,CAC1C,CAAC;EACJ;EAEA,MAAME,KAAKA,CAAA,EAAG;IACZ,MAAMtD,OAAO,GAAG,IAAI,CAAC,IAAI,CAACyB,YAAY,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAACM,YAAY,CAACuB,KAAK,CAAC,CAAC,CAAC,CAAC;IAExE,MAAM,IAAI,CAAC3E,KAAK,CAAC,CAAC;IAClB,OAAOqB,OAAO;EAChB;EAEA,MAAMuD,UAAUA,CAACH,QAAQ,EAAE;IACzB,IAAI,CAAC/B,qBAAqB,CAAC,CAAC+B,QAAQ,CAAC;IAErC,MAAMpD,OAAO,GAAG,IAAI,CAAC,IAAI,CAACyB,YAAY,CAAC,CAAC,CAAC,CACvC,GAAG,IAAI,CAACM,YAAY,CAACyB,QAAQ,CAACJ,QAAQ,CAAC,CACxC,CAAC;IAEF,MAAM,IAAI,CAACzE,KAAK,CAAC,CAAC;IAClB,OAAOqB,OAAO;EAChB;EAEA,MAAMI,YAAYA,CAACmC,UAAU,EAAE;IAC7B,OAAO,IAAI,CAACjB,UAAU,CAAC,CAACiB,UAAU,CAAC;EACrC;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}