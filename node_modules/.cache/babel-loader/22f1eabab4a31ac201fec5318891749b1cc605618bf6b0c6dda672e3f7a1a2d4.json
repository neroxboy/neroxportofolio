{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.APEv2Parser = void 0;\nconst debug_1 = require(\"debug\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst token_types_1 = require(\"token-types\");\nconst util = require(\"../common/Util\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst APEv2Token_1 = require(\"./APEv2Token\");\nconst debug = (0, debug_1.default)('music-metadata:parser:APEv2');\nconst tagFormat = 'APEv2';\nconst preamble = 'APETAGEX';\nclass APEv2Parser extends BasicParser_1.BasicParser {\n  constructor() {\n    super(...arguments);\n    this.ape = {};\n  }\n  static tryParseApeHeader(metadata, tokenizer, options) {\n    const apeParser = new APEv2Parser();\n    apeParser.init(metadata, tokenizer, options);\n    return apeParser.tryParseApeHeader();\n  }\n  /**\n   * Calculate the media file duration\n   * @param ah ApeHeader\n   * @return {number} duration in seconds\n   */\n  static calculateDuration(ah) {\n    let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n    duration += ah.finalFrameBlocks;\n    return duration / ah.sampleRate;\n  }\n  /**\n   * Calculates the APEv1 / APEv2 first field offset\n   * @param reader\n   * @param offset\n   */\n  static async findApeFooterOffset(reader, offset) {\n    // Search for APE footer header at the end of the file\n    const apeBuf = Buffer.alloc(APEv2Token_1.TagFooter.len);\n    await reader.randomRead(apeBuf, 0, APEv2Token_1.TagFooter.len, offset - APEv2Token_1.TagFooter.len);\n    const tagFooter = APEv2Token_1.TagFooter.get(apeBuf, 0);\n    if (tagFooter.ID === 'APETAGEX') {\n      debug(`APE footer header at offset=${offset}`);\n      return {\n        footer: tagFooter,\n        offset: offset - tagFooter.size\n      };\n    }\n  }\n  static parseTagFooter(metadata, buffer, options) {\n    const footer = APEv2Token_1.TagFooter.get(buffer, buffer.length - APEv2Token_1.TagFooter.len);\n    if (footer.ID !== preamble) throw new Error('Unexpected APEv2 Footer ID preamble value.');\n    strtok3.fromBuffer(buffer);\n    const apeParser = new APEv2Parser();\n    apeParser.init(metadata, strtok3.fromBuffer(buffer), options);\n    return apeParser.parseTags(footer);\n  }\n  /**\n   * Parse APEv1 / APEv2 header if header signature found\n   */\n  async tryParseApeHeader() {\n    if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len) {\n      debug(`No APEv2 header found, end-of-file reached`);\n      return;\n    }\n    const footer = await this.tokenizer.peekToken(APEv2Token_1.TagFooter);\n    if (footer.ID === preamble) {\n      await this.tokenizer.ignore(APEv2Token_1.TagFooter.len);\n      return this.parseTags(footer);\n    } else {\n      debug(`APEv2 header not found at offset=${this.tokenizer.position}`);\n      if (this.tokenizer.fileInfo.size) {\n        // Try to read the APEv2 header using just the footer-header\n        const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\n        const buffer = Buffer.alloc(remaining);\n        await this.tokenizer.readBuffer(buffer);\n        return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\n      }\n    }\n  }\n  async parse() {\n    const descriptor = await this.tokenizer.readToken(APEv2Token_1.DescriptorParser);\n    if (descriptor.ID !== 'MAC ') throw new Error('Unexpected descriptor ID');\n    this.ape.descriptor = descriptor;\n    const lenExp = descriptor.descriptorBytes - APEv2Token_1.DescriptorParser.len;\n    const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\n    await this.tokenizer.ignore(header.forwardBytes);\n    return this.tryParseApeHeader();\n  }\n  async parseTags(footer) {\n    const keyBuffer = Buffer.alloc(256); // maximum tag key length\n    let bytesRemaining = footer.size - APEv2Token_1.TagFooter.len;\n    debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);\n    for (let i = 0; i < footer.fields; i++) {\n      if (bytesRemaining < APEv2Token_1.TagItemHeader.len) {\n        this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);\n        break;\n      }\n      // Only APEv2 tag has tag item headers\n      const tagItemHeader = await this.tokenizer.readToken(APEv2Token_1.TagItemHeader);\n      bytesRemaining -= APEv2Token_1.TagItemHeader.len + tagItemHeader.size;\n      await this.tokenizer.peekBuffer(keyBuffer, {\n        length: Math.min(keyBuffer.length, bytesRemaining)\n      });\n      let zero = util.findZero(keyBuffer, 0, keyBuffer.length);\n      const key = await this.tokenizer.readToken(new token_types_1.StringType(zero, 'ascii'));\n      await this.tokenizer.ignore(1);\n      bytesRemaining -= key.length + 1;\n      switch (tagItemHeader.flags.dataType) {\n        case APEv2Token_1.DataType.text_utf8:\n          {\n            // utf-8 text-string\n            const value = await this.tokenizer.readToken(new token_types_1.StringType(tagItemHeader.size, 'utf8'));\n            const values = value.split(/\\x00/g);\n            for (const val of values) {\n              this.metadata.addTag(tagFormat, key, val);\n            }\n            break;\n          }\n        case APEv2Token_1.DataType.binary:\n          // binary (probably artwork)\n          if (this.options.skipCovers) {\n            await this.tokenizer.ignore(tagItemHeader.size);\n          } else {\n            const picData = Buffer.alloc(tagItemHeader.size);\n            await this.tokenizer.readBuffer(picData);\n            zero = util.findZero(picData, 0, picData.length);\n            const description = picData.toString('utf8', 0, zero);\n            const data = Buffer.from(picData.slice(zero + 1));\n            this.metadata.addTag(tagFormat, key, {\n              description,\n              data\n            });\n          }\n          break;\n        case APEv2Token_1.DataType.external_info:\n          debug(`Ignore external info ${key}`);\n          await this.tokenizer.ignore(tagItemHeader.size);\n          break;\n        case APEv2Token_1.DataType.reserved:\n          debug(`Ignore external info ${key}`);\n          this.metadata.addWarning(`APEv2 header declares a reserved datatype for \"${key}\"`);\n          await this.tokenizer.ignore(tagItemHeader.size);\n          break;\n      }\n    }\n  }\n  async parseDescriptorExpansion(lenExp) {\n    await this.tokenizer.ignore(lenExp);\n    return this.parseHeader();\n  }\n  async parseHeader() {\n    const header = await this.tokenizer.readToken(APEv2Token_1.Header);\n    // ToDo before\n    this.metadata.setFormat('lossless', true);\n    this.metadata.setFormat('container', 'Monkey\\'s Audio');\n    this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\n    this.metadata.setFormat('sampleRate', header.sampleRate);\n    this.metadata.setFormat('numberOfChannels', header.channel);\n    this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\n    return {\n      forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\n    };\n  }\n}\nexports.APEv2Parser = APEv2Parser;","map":{"version":3,"names":["Object","defineProperty","exports","value","APEv2Parser","debug_1","require","strtok3","token_types_1","util","BasicParser_1","APEv2Token_1","debug","default","tagFormat","preamble","BasicParser","constructor","arguments","ape","tryParseApeHeader","metadata","tokenizer","options","apeParser","init","calculateDuration","ah","duration","totalFrames","blocksPerFrame","finalFrameBlocks","sampleRate","findApeFooterOffset","reader","offset","apeBuf","Buffer","alloc","TagFooter","len","randomRead","tagFooter","get","ID","footer","size","parseTagFooter","buffer","length","Error","fromBuffer","parseTags","fileInfo","position","peekToken","ignore","remaining","readBuffer","parse","descriptor","readToken","DescriptorParser","lenExp","descriptorBytes","header","parseDescriptorExpansion","parseHeader","forwardBytes","keyBuffer","bytesRemaining","i","fields","TagItemHeader","addWarning","tagItemHeader","peekBuffer","Math","min","zero","findZero","key","StringType","flags","dataType","DataType","text_utf8","values","split","val","addTag","binary","skipCovers","picData","description","toString","data","from","slice","external_info","reserved","Header","setFormat","bitsPerSample","channel","seekTableBytes","headerDataBytes","apeFrameDataBytes","terminatingDataBytes"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/apev2/APEv2Parser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.APEv2Parser = void 0;\nconst debug_1 = require(\"debug\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst token_types_1 = require(\"token-types\");\nconst util = require(\"../common/Util\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst APEv2Token_1 = require(\"./APEv2Token\");\nconst debug = (0, debug_1.default)('music-metadata:parser:APEv2');\nconst tagFormat = 'APEv2';\nconst preamble = 'APETAGEX';\nclass APEv2Parser extends BasicParser_1.BasicParser {\n    constructor() {\n        super(...arguments);\n        this.ape = {};\n    }\n    static tryParseApeHeader(metadata, tokenizer, options) {\n        const apeParser = new APEv2Parser();\n        apeParser.init(metadata, tokenizer, options);\n        return apeParser.tryParseApeHeader();\n    }\n    /**\n     * Calculate the media file duration\n     * @param ah ApeHeader\n     * @return {number} duration in seconds\n     */\n    static calculateDuration(ah) {\n        let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n        duration += ah.finalFrameBlocks;\n        return duration / ah.sampleRate;\n    }\n    /**\n     * Calculates the APEv1 / APEv2 first field offset\n     * @param reader\n     * @param offset\n     */\n    static async findApeFooterOffset(reader, offset) {\n        // Search for APE footer header at the end of the file\n        const apeBuf = Buffer.alloc(APEv2Token_1.TagFooter.len);\n        await reader.randomRead(apeBuf, 0, APEv2Token_1.TagFooter.len, offset - APEv2Token_1.TagFooter.len);\n        const tagFooter = APEv2Token_1.TagFooter.get(apeBuf, 0);\n        if (tagFooter.ID === 'APETAGEX') {\n            debug(`APE footer header at offset=${offset}`);\n            return { footer: tagFooter, offset: offset - tagFooter.size };\n        }\n    }\n    static parseTagFooter(metadata, buffer, options) {\n        const footer = APEv2Token_1.TagFooter.get(buffer, buffer.length - APEv2Token_1.TagFooter.len);\n        if (footer.ID !== preamble)\n            throw new Error('Unexpected APEv2 Footer ID preamble value.');\n        strtok3.fromBuffer(buffer);\n        const apeParser = new APEv2Parser();\n        apeParser.init(metadata, strtok3.fromBuffer(buffer), options);\n        return apeParser.parseTags(footer);\n    }\n    /**\n     * Parse APEv1 / APEv2 header if header signature found\n     */\n    async tryParseApeHeader() {\n        if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len) {\n            debug(`No APEv2 header found, end-of-file reached`);\n            return;\n        }\n        const footer = await this.tokenizer.peekToken(APEv2Token_1.TagFooter);\n        if (footer.ID === preamble) {\n            await this.tokenizer.ignore(APEv2Token_1.TagFooter.len);\n            return this.parseTags(footer);\n        }\n        else {\n            debug(`APEv2 header not found at offset=${this.tokenizer.position}`);\n            if (this.tokenizer.fileInfo.size) {\n                // Try to read the APEv2 header using just the footer-header\n                const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\n                const buffer = Buffer.alloc(remaining);\n                await this.tokenizer.readBuffer(buffer);\n                return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\n            }\n        }\n    }\n    async parse() {\n        const descriptor = await this.tokenizer.readToken(APEv2Token_1.DescriptorParser);\n        if (descriptor.ID !== 'MAC ')\n            throw new Error('Unexpected descriptor ID');\n        this.ape.descriptor = descriptor;\n        const lenExp = descriptor.descriptorBytes - APEv2Token_1.DescriptorParser.len;\n        const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\n        await this.tokenizer.ignore(header.forwardBytes);\n        return this.tryParseApeHeader();\n    }\n    async parseTags(footer) {\n        const keyBuffer = Buffer.alloc(256); // maximum tag key length\n        let bytesRemaining = footer.size - APEv2Token_1.TagFooter.len;\n        debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);\n        for (let i = 0; i < footer.fields; i++) {\n            if (bytesRemaining < APEv2Token_1.TagItemHeader.len) {\n                this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);\n                break;\n            }\n            // Only APEv2 tag has tag item headers\n            const tagItemHeader = await this.tokenizer.readToken(APEv2Token_1.TagItemHeader);\n            bytesRemaining -= APEv2Token_1.TagItemHeader.len + tagItemHeader.size;\n            await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });\n            let zero = util.findZero(keyBuffer, 0, keyBuffer.length);\n            const key = await this.tokenizer.readToken(new token_types_1.StringType(zero, 'ascii'));\n            await this.tokenizer.ignore(1);\n            bytesRemaining -= key.length + 1;\n            switch (tagItemHeader.flags.dataType) {\n                case APEv2Token_1.DataType.text_utf8: { // utf-8 text-string\n                    const value = await this.tokenizer.readToken(new token_types_1.StringType(tagItemHeader.size, 'utf8'));\n                    const values = value.split(/\\x00/g);\n                    for (const val of values) {\n                        this.metadata.addTag(tagFormat, key, val);\n                    }\n                    break;\n                }\n                case APEv2Token_1.DataType.binary: // binary (probably artwork)\n                    if (this.options.skipCovers) {\n                        await this.tokenizer.ignore(tagItemHeader.size);\n                    }\n                    else {\n                        const picData = Buffer.alloc(tagItemHeader.size);\n                        await this.tokenizer.readBuffer(picData);\n                        zero = util.findZero(picData, 0, picData.length);\n                        const description = picData.toString('utf8', 0, zero);\n                        const data = Buffer.from(picData.slice(zero + 1));\n                        this.metadata.addTag(tagFormat, key, {\n                            description,\n                            data\n                        });\n                    }\n                    break;\n                case APEv2Token_1.DataType.external_info:\n                    debug(`Ignore external info ${key}`);\n                    await this.tokenizer.ignore(tagItemHeader.size);\n                    break;\n                case APEv2Token_1.DataType.reserved:\n                    debug(`Ignore external info ${key}`);\n                    this.metadata.addWarning(`APEv2 header declares a reserved datatype for \"${key}\"`);\n                    await this.tokenizer.ignore(tagItemHeader.size);\n                    break;\n            }\n        }\n    }\n    async parseDescriptorExpansion(lenExp) {\n        await this.tokenizer.ignore(lenExp);\n        return this.parseHeader();\n    }\n    async parseHeader() {\n        const header = await this.tokenizer.readToken(APEv2Token_1.Header);\n        // ToDo before\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('container', 'Monkey\\'s Audio');\n        this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\n        this.metadata.setFormat('sampleRate', header.sampleRate);\n        this.metadata.setFormat('numberOfChannels', header.channel);\n        this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\n        return {\n            forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes +\n                this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\n        };\n    }\n}\nexports.APEv2Parser = APEv2Parser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}