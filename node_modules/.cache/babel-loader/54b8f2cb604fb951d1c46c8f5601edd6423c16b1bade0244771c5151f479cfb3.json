{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeBinaryNode = exports.decodeDecompressedBinaryNode = exports.decompressingIfRequired = void 0;\nconst util_1 = require(\"util\");\nconst zlib_1 = require(\"zlib\");\nconst constants = __importStar(require(\"./constants\"));\nconst jid_utils_1 = require(\"./jid-utils\");\nconst inflatePromise = (0, util_1.promisify)(zlib_1.inflate);\nconst decompressingIfRequired = async buffer => {\n  if (2 & buffer.readUInt8()) {\n    buffer = await inflatePromise(buffer.slice(1));\n  } else {\n    // nodes with no compression have a 0x00 prefix, we remove that\n    buffer = buffer.slice(1);\n  }\n  return buffer;\n};\nexports.decompressingIfRequired = decompressingIfRequired;\nconst decodeDecompressedBinaryNode = (buffer, opts, indexRef = {\n  index: 0\n}) => {\n  const {\n    DOUBLE_BYTE_TOKENS,\n    SINGLE_BYTE_TOKENS,\n    TAGS\n  } = opts;\n  const checkEOS = length => {\n    if (indexRef.index + length > buffer.length) {\n      throw new Error('end of stream');\n    }\n  };\n  const next = () => {\n    const value = buffer[indexRef.index];\n    indexRef.index += 1;\n    return value;\n  };\n  const readByte = () => {\n    checkEOS(1);\n    return next();\n  };\n  const readBytes = n => {\n    checkEOS(n);\n    const value = buffer.slice(indexRef.index, indexRef.index + n);\n    indexRef.index += n;\n    return value;\n  };\n  const readStringFromChars = length => {\n    return readBytes(length).toString('utf-8');\n  };\n  const readInt = (n, littleEndian = false) => {\n    checkEOS(n);\n    let val = 0;\n    for (let i = 0; i < n; i++) {\n      const shift = littleEndian ? i : n - 1 - i;\n      val |= next() << shift * 8;\n    }\n    return val;\n  };\n  const readInt20 = () => {\n    checkEOS(3);\n    return ((next() & 15) << 16) + (next() << 8) + next();\n  };\n  const unpackHex = value => {\n    if (value >= 0 && value < 16) {\n      return value < 10 ? '0'.charCodeAt(0) + value : 'A'.charCodeAt(0) + value - 10;\n    }\n    throw new Error('invalid hex: ' + value);\n  };\n  const unpackNibble = value => {\n    if (value >= 0 && value <= 9) {\n      return '0'.charCodeAt(0) + value;\n    }\n    switch (value) {\n      case 10:\n        return '-'.charCodeAt(0);\n      case 11:\n        return '.'.charCodeAt(0);\n      case 15:\n        return '\\0'.charCodeAt(0);\n      default:\n        throw new Error('invalid nibble: ' + value);\n    }\n  };\n  const unpackByte = (tag, value) => {\n    if (tag === TAGS.NIBBLE_8) {\n      return unpackNibble(value);\n    } else if (tag === TAGS.HEX_8) {\n      return unpackHex(value);\n    } else {\n      throw new Error('unknown tag: ' + tag);\n    }\n  };\n  const readPacked8 = tag => {\n    const startByte = readByte();\n    let value = '';\n    for (let i = 0; i < (startByte & 127); i++) {\n      const curByte = readByte();\n      value += String.fromCharCode(unpackByte(tag, (curByte & 0xf0) >> 4));\n      value += String.fromCharCode(unpackByte(tag, curByte & 0x0f));\n    }\n    if (startByte >> 7 !== 0) {\n      value = value.slice(0, -1);\n    }\n    return value;\n  };\n  const isListTag = tag => {\n    return tag === TAGS.LIST_EMPTY || tag === TAGS.LIST_8 || tag === TAGS.LIST_16;\n  };\n  const readListSize = tag => {\n    switch (tag) {\n      case TAGS.LIST_EMPTY:\n        return 0;\n      case TAGS.LIST_8:\n        return readByte();\n      case TAGS.LIST_16:\n        return readInt(2);\n      default:\n        throw new Error('invalid tag for list size: ' + tag);\n    }\n  };\n  const readJidPair = () => {\n    const i = readString(readByte());\n    const j = readString(readByte());\n    if (j) {\n      return (i || '') + '@' + j;\n    }\n    throw new Error('invalid jid pair: ' + i + ', ' + j);\n  };\n  const readAdJid = () => {\n    const agent = readByte();\n    const device = readByte();\n    const user = readString(readByte());\n    return (0, jid_utils_1.jidEncode)(user, agent === 0 ? 's.whatsapp.net' : 'lid', device);\n  };\n  const readString = tag => {\n    if (tag >= 1 && tag < SINGLE_BYTE_TOKENS.length) {\n      return SINGLE_BYTE_TOKENS[tag] || '';\n    }\n    switch (tag) {\n      case TAGS.DICTIONARY_0:\n      case TAGS.DICTIONARY_1:\n      case TAGS.DICTIONARY_2:\n      case TAGS.DICTIONARY_3:\n        return getTokenDouble(tag - TAGS.DICTIONARY_0, readByte());\n      case TAGS.LIST_EMPTY:\n        return '';\n      case TAGS.BINARY_8:\n        return readStringFromChars(readByte());\n      case TAGS.BINARY_20:\n        return readStringFromChars(readInt20());\n      case TAGS.BINARY_32:\n        return readStringFromChars(readInt(4));\n      case TAGS.JID_PAIR:\n        return readJidPair();\n      case TAGS.AD_JID:\n        return readAdJid();\n      case TAGS.HEX_8:\n      case TAGS.NIBBLE_8:\n        return readPacked8(tag);\n      default:\n        throw new Error('invalid string with tag: ' + tag);\n    }\n  };\n  const readList = tag => {\n    const items = [];\n    const size = readListSize(tag);\n    for (let i = 0; i < size; i++) {\n      items.push((0, exports.decodeDecompressedBinaryNode)(buffer, opts, indexRef));\n    }\n    return items;\n  };\n  const getTokenDouble = (index1, index2) => {\n    const dict = DOUBLE_BYTE_TOKENS[index1];\n    if (!dict) {\n      throw new Error(`Invalid double token dict (${index1})`);\n    }\n    const value = dict[index2];\n    if (typeof value === 'undefined') {\n      throw new Error(`Invalid double token (${index2})`);\n    }\n    return value;\n  };\n  const listSize = readListSize(readByte());\n  const header = readString(readByte());\n  if (!listSize || !header.length) {\n    throw new Error('invalid node');\n  }\n  const attrs = {};\n  let data;\n  if (listSize === 0 || !header) {\n    throw new Error('invalid node');\n  }\n  // read the attributes in\n  const attributesLength = listSize - 1 >> 1;\n  for (let i = 0; i < attributesLength; i++) {\n    const key = readString(readByte());\n    const value = readString(readByte());\n    attrs[key] = value;\n  }\n  if (listSize % 2 === 0) {\n    const tag = readByte();\n    if (isListTag(tag)) {\n      data = readList(tag);\n    } else {\n      let decoded;\n      switch (tag) {\n        case TAGS.BINARY_8:\n          decoded = readBytes(readByte());\n          break;\n        case TAGS.BINARY_20:\n          decoded = readBytes(readInt20());\n          break;\n        case TAGS.BINARY_32:\n          decoded = readBytes(readInt(4));\n          break;\n        default:\n          decoded = readString(tag);\n          break;\n      }\n      data = decoded;\n    }\n  }\n  return {\n    tag: header,\n    attrs,\n    content: data\n  };\n};\nexports.decodeDecompressedBinaryNode = decodeDecompressedBinaryNode;\nconst decodeBinaryNode = async buff => {\n  const decompBuff = await (0, exports.decompressingIfRequired)(buff);\n  return (0, exports.decodeDecompressedBinaryNode)(decompBuff, constants);\n};\nexports.decodeBinaryNode = decodeBinaryNode;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","decodeBinaryNode","decodeDecompressedBinaryNode","decompressingIfRequired","util_1","require","zlib_1","constants","jid_utils_1","inflatePromise","promisify","inflate","buffer","readUInt8","slice","opts","indexRef","index","DOUBLE_BYTE_TOKENS","SINGLE_BYTE_TOKENS","TAGS","checkEOS","length","Error","next","readByte","readBytes","n","readStringFromChars","toString","readInt","littleEndian","val","i","shift","readInt20","unpackHex","charCodeAt","unpackNibble","unpackByte","tag","NIBBLE_8","HEX_8","readPacked8","startByte","curByte","String","fromCharCode","isListTag","LIST_EMPTY","LIST_8","LIST_16","readListSize","readJidPair","readString","j","readAdJid","agent","device","user","jidEncode","DICTIONARY_0","DICTIONARY_1","DICTIONARY_2","DICTIONARY_3","getTokenDouble","BINARY_8","BINARY_20","BINARY_32","JID_PAIR","AD_JID","readList","items","size","push","index1","index2","dict","listSize","header","attrs","data","attributesLength","key","decoded","content","buff","decompBuff"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/WABinary/decode.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeBinaryNode = exports.decodeDecompressedBinaryNode = exports.decompressingIfRequired = void 0;\nconst util_1 = require(\"util\");\nconst zlib_1 = require(\"zlib\");\nconst constants = __importStar(require(\"./constants\"));\nconst jid_utils_1 = require(\"./jid-utils\");\nconst inflatePromise = (0, util_1.promisify)(zlib_1.inflate);\nconst decompressingIfRequired = async (buffer) => {\n    if (2 & buffer.readUInt8()) {\n        buffer = await inflatePromise(buffer.slice(1));\n    }\n    else { // nodes with no compression have a 0x00 prefix, we remove that\n        buffer = buffer.slice(1);\n    }\n    return buffer;\n};\nexports.decompressingIfRequired = decompressingIfRequired;\nconst decodeDecompressedBinaryNode = (buffer, opts, indexRef = { index: 0 }) => {\n    const { DOUBLE_BYTE_TOKENS, SINGLE_BYTE_TOKENS, TAGS } = opts;\n    const checkEOS = (length) => {\n        if (indexRef.index + length > buffer.length) {\n            throw new Error('end of stream');\n        }\n    };\n    const next = () => {\n        const value = buffer[indexRef.index];\n        indexRef.index += 1;\n        return value;\n    };\n    const readByte = () => {\n        checkEOS(1);\n        return next();\n    };\n    const readBytes = (n) => {\n        checkEOS(n);\n        const value = buffer.slice(indexRef.index, indexRef.index + n);\n        indexRef.index += n;\n        return value;\n    };\n    const readStringFromChars = (length) => {\n        return readBytes(length).toString('utf-8');\n    };\n    const readInt = (n, littleEndian = false) => {\n        checkEOS(n);\n        let val = 0;\n        for (let i = 0; i < n; i++) {\n            const shift = littleEndian ? i : n - 1 - i;\n            val |= next() << (shift * 8);\n        }\n        return val;\n    };\n    const readInt20 = () => {\n        checkEOS(3);\n        return ((next() & 15) << 16) + (next() << 8) + next();\n    };\n    const unpackHex = (value) => {\n        if (value >= 0 && value < 16) {\n            return value < 10 ? '0'.charCodeAt(0) + value : 'A'.charCodeAt(0) + value - 10;\n        }\n        throw new Error('invalid hex: ' + value);\n    };\n    const unpackNibble = (value) => {\n        if (value >= 0 && value <= 9) {\n            return '0'.charCodeAt(0) + value;\n        }\n        switch (value) {\n            case 10:\n                return '-'.charCodeAt(0);\n            case 11:\n                return '.'.charCodeAt(0);\n            case 15:\n                return '\\0'.charCodeAt(0);\n            default:\n                throw new Error('invalid nibble: ' + value);\n        }\n    };\n    const unpackByte = (tag, value) => {\n        if (tag === TAGS.NIBBLE_8) {\n            return unpackNibble(value);\n        }\n        else if (tag === TAGS.HEX_8) {\n            return unpackHex(value);\n        }\n        else {\n            throw new Error('unknown tag: ' + tag);\n        }\n    };\n    const readPacked8 = (tag) => {\n        const startByte = readByte();\n        let value = '';\n        for (let i = 0; i < (startByte & 127); i++) {\n            const curByte = readByte();\n            value += String.fromCharCode(unpackByte(tag, (curByte & 0xf0) >> 4));\n            value += String.fromCharCode(unpackByte(tag, curByte & 0x0f));\n        }\n        if (startByte >> 7 !== 0) {\n            value = value.slice(0, -1);\n        }\n        return value;\n    };\n    const isListTag = (tag) => {\n        return tag === TAGS.LIST_EMPTY || tag === TAGS.LIST_8 || tag === TAGS.LIST_16;\n    };\n    const readListSize = (tag) => {\n        switch (tag) {\n            case TAGS.LIST_EMPTY:\n                return 0;\n            case TAGS.LIST_8:\n                return readByte();\n            case TAGS.LIST_16:\n                return readInt(2);\n            default:\n                throw new Error('invalid tag for list size: ' + tag);\n        }\n    };\n    const readJidPair = () => {\n        const i = readString(readByte());\n        const j = readString(readByte());\n        if (j) {\n            return (i || '') + '@' + j;\n        }\n        throw new Error('invalid jid pair: ' + i + ', ' + j);\n    };\n    const readAdJid = () => {\n        const agent = readByte();\n        const device = readByte();\n        const user = readString(readByte());\n        return (0, jid_utils_1.jidEncode)(user, agent === 0 ? 's.whatsapp.net' : 'lid', device);\n    };\n    const readString = (tag) => {\n        if (tag >= 1 && tag < SINGLE_BYTE_TOKENS.length) {\n            return SINGLE_BYTE_TOKENS[tag] || '';\n        }\n        switch (tag) {\n            case TAGS.DICTIONARY_0:\n            case TAGS.DICTIONARY_1:\n            case TAGS.DICTIONARY_2:\n            case TAGS.DICTIONARY_3:\n                return getTokenDouble(tag - TAGS.DICTIONARY_0, readByte());\n            case TAGS.LIST_EMPTY:\n                return '';\n            case TAGS.BINARY_8:\n                return readStringFromChars(readByte());\n            case TAGS.BINARY_20:\n                return readStringFromChars(readInt20());\n            case TAGS.BINARY_32:\n                return readStringFromChars(readInt(4));\n            case TAGS.JID_PAIR:\n                return readJidPair();\n            case TAGS.AD_JID:\n                return readAdJid();\n            case TAGS.HEX_8:\n            case TAGS.NIBBLE_8:\n                return readPacked8(tag);\n            default:\n                throw new Error('invalid string with tag: ' + tag);\n        }\n    };\n    const readList = (tag) => {\n        const items = [];\n        const size = readListSize(tag);\n        for (let i = 0; i < size; i++) {\n            items.push((0, exports.decodeDecompressedBinaryNode)(buffer, opts, indexRef));\n        }\n        return items;\n    };\n    const getTokenDouble = (index1, index2) => {\n        const dict = DOUBLE_BYTE_TOKENS[index1];\n        if (!dict) {\n            throw new Error(`Invalid double token dict (${index1})`);\n        }\n        const value = dict[index2];\n        if (typeof value === 'undefined') {\n            throw new Error(`Invalid double token (${index2})`);\n        }\n        return value;\n    };\n    const listSize = readListSize(readByte());\n    const header = readString(readByte());\n    if (!listSize || !header.length) {\n        throw new Error('invalid node');\n    }\n    const attrs = {};\n    let data;\n    if (listSize === 0 || !header) {\n        throw new Error('invalid node');\n    }\n    // read the attributes in\n    const attributesLength = (listSize - 1) >> 1;\n    for (let i = 0; i < attributesLength; i++) {\n        const key = readString(readByte());\n        const value = readString(readByte());\n        attrs[key] = value;\n    }\n    if (listSize % 2 === 0) {\n        const tag = readByte();\n        if (isListTag(tag)) {\n            data = readList(tag);\n        }\n        else {\n            let decoded;\n            switch (tag) {\n                case TAGS.BINARY_8:\n                    decoded = readBytes(readByte());\n                    break;\n                case TAGS.BINARY_20:\n                    decoded = readBytes(readInt20());\n                    break;\n                case TAGS.BINARY_32:\n                    decoded = readBytes(readInt(4));\n                    break;\n                default:\n                    decoded = readString(tag);\n                    break;\n            }\n            data = decoded;\n        }\n    }\n    return {\n        tag: header,\n        attrs,\n        content: data\n    };\n};\nexports.decodeDecompressedBinaryNode = decodeDecompressedBinaryNode;\nconst decodeBinaryNode = async (buff) => {\n    const decompBuff = await (0, exports.decompressingIfRequired)(buff);\n    return (0, exports.decodeDecompressedBinaryNode)(decompBuff, constants);\n};\nexports.decodeBinaryNode = decodeBinaryNode;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}