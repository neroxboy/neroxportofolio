{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MatroskaParser = void 0;\nconst token_types_1 = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst types_1 = require(\"./types\");\nconst matroskaDtd = require(\"./MatroskaDtd\");\nconst debug = (0, debug_1.default)('music-metadata:parser:matroska');\n/**\n * Extensible Binary Meta Language (EBML) parser\n * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language\n * http://matroska.sourceforge.net/technical/specs/rfc/index.html\n *\n * WEBM VP8 AUDIO FILE\n */\nclass MatroskaParser extends BasicParser_1.BasicParser {\n  constructor() {\n    super();\n    this.padding = 0;\n    this.parserMap = new Map();\n    this.ebmlMaxIDLength = 4;\n    this.ebmlMaxSizeLength = 8;\n    this.parserMap.set(types_1.DataType.uint, e => this.readUint(e));\n    this.parserMap.set(types_1.DataType.string, e => this.readString(e));\n    this.parserMap.set(types_1.DataType.binary, e => this.readBuffer(e));\n    this.parserMap.set(types_1.DataType.uid, async e => (await this.readUint(e)) === 1);\n    this.parserMap.set(types_1.DataType.bool, e => this.readFlag(e));\n    this.parserMap.set(types_1.DataType.float, e => this.readFloat(e));\n  }\n  /**\n   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n   * @param {INativeMetadataCollector} metadata Output\n   * @param {ITokenizer} tokenizer Input\n   * @param {IOptions} options Parsing options\n   */\n  init(metadata, tokenizer, options) {\n    super.init(metadata, tokenizer, options);\n    return this;\n  }\n  async parse() {\n    const matroska = await this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);\n    this.metadata.setFormat('container', `EBML/${matroska.ebml.docType}`);\n    if (matroska.segment) {\n      const info = matroska.segment.info;\n      if (info) {\n        const timecodeScale = info.timecodeScale ? info.timecodeScale : 1000000;\n        if (typeof info.duration === 'number') {\n          const duration = info.duration * timecodeScale / 1000000000;\n          this.addTag('segment:title', info.title);\n          this.metadata.setFormat('duration', duration);\n        }\n      }\n      const audioTracks = matroska.segment.tracks;\n      if (audioTracks && audioTracks.entries) {\n        audioTracks.entries.forEach(entry => {\n          const stream = {\n            codecName: entry.codecID.replace('A_', '').replace('V_', ''),\n            codecSettings: entry.codecSettings,\n            flagDefault: entry.flagDefault,\n            flagLacing: entry.flagLacing,\n            flagEnabled: entry.flagEnabled,\n            language: entry.language,\n            name: entry.name,\n            type: entry.trackType,\n            audio: entry.audio,\n            video: entry.video\n          };\n          this.metadata.addStreamInfo(stream);\n        });\n        const audioTrack = audioTracks.entries.filter(entry => {\n          return entry.trackType === types_1.TrackType.audio.valueOf();\n        }).reduce((acc, cur) => {\n          if (!acc) {\n            return cur;\n          }\n          if (!acc.flagDefault && cur.flagDefault) {\n            return cur;\n          }\n          if (cur.trackNumber && cur.trackNumber < acc.trackNumber) {\n            return cur;\n          }\n          return acc;\n        }, null);\n        if (audioTrack) {\n          this.metadata.setFormat('codec', audioTrack.codecID.replace('A_', ''));\n          this.metadata.setFormat('sampleRate', audioTrack.audio.samplingFrequency);\n          this.metadata.setFormat('numberOfChannels', audioTrack.audio.channels);\n        }\n        if (matroska.segment.tags) {\n          matroska.segment.tags.tag.forEach(tag => {\n            const target = tag.target;\n            const targetType = (target === null || target === void 0 ? void 0 : target.targetTypeValue) ? types_1.TargetType[target.targetTypeValue] : (target === null || target === void 0 ? void 0 : target.targetType) ? target.targetType : 'track';\n            tag.simpleTags.forEach(simpleTag => {\n              const value = simpleTag.string ? simpleTag.string : simpleTag.binary;\n              this.addTag(`${targetType}:${simpleTag.name}`, value);\n            });\n          });\n        }\n        if (matroska.segment.attachments) {\n          matroska.segment.attachments.attachedFiles.filter(file => file.mimeType.startsWith('image/')).map(file => {\n            return {\n              data: file.data,\n              format: file.mimeType,\n              description: file.description,\n              name: file.name\n            };\n          }).forEach(picture => {\n            this.addTag('picture', picture);\n          });\n        }\n      }\n    }\n  }\n  async parseContainer(container, posDone, path) {\n    const tree = {};\n    while (this.tokenizer.position < posDone) {\n      let element;\n      try {\n        element = await this.readElement();\n      } catch (error) {\n        if (error.message === 'End-Of-Stream') {\n          break;\n        }\n        throw error;\n      }\n      const type = container[element.id];\n      if (type) {\n        debug(`Element: name=${type.name}, container=${!!type.container}`);\n        if (type.container) {\n          const res = await this.parseContainer(type.container, element.len >= 0 ? this.tokenizer.position + element.len : -1, path.concat([type.name]));\n          if (type.multiple) {\n            if (!tree[type.name]) {\n              tree[type.name] = [];\n            }\n            tree[type.name].push(res);\n          } else {\n            tree[type.name] = res;\n          }\n        } else {\n          tree[type.name] = await this.parserMap.get(type.value)(element);\n        }\n      } else {\n        switch (element.id) {\n          case 0xec:\n            // void\n            this.padding += element.len;\n            await this.tokenizer.ignore(element.len);\n            break;\n          default:\n            debug(`parseEbml: path=${path.join('/')}, unknown element: id=${element.id.toString(16)}`);\n            this.padding += element.len;\n            await this.tokenizer.ignore(element.len);\n        }\n      }\n    }\n    return tree;\n  }\n  async readVintData(maxLength) {\n    const msb = await this.tokenizer.peekNumber(token_types_1.UINT8);\n    let mask = 0x80;\n    let oc = 1;\n    // Calculate VINT_WIDTH\n    while ((msb & mask) === 0) {\n      if (oc > maxLength) {\n        throw new Error('VINT value exceeding maximum size');\n      }\n      ++oc;\n      mask >>= 1;\n    }\n    const id = Buffer.alloc(oc);\n    await this.tokenizer.readBuffer(id);\n    return id;\n  }\n  async readElement() {\n    const id = await this.readVintData(this.ebmlMaxIDLength);\n    const lenField = await this.readVintData(this.ebmlMaxSizeLength);\n    lenField[0] ^= 0x80 >> lenField.length - 1;\n    const nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer\n    return {\n      id: id.readUIntBE(0, id.length),\n      len: lenField.readUIntBE(lenField.length - nrLen, nrLen)\n    };\n  }\n  isMaxValue(vintData) {\n    if (vintData.length === this.ebmlMaxSizeLength) {\n      for (let n = 1; n < this.ebmlMaxSizeLength; ++n) {\n        if (vintData[n] !== 0xff) return false;\n      }\n      return true;\n    }\n    return false;\n  }\n  async readFloat(e) {\n    switch (e.len) {\n      case 0:\n        return 0.0;\n      case 4:\n        return this.tokenizer.readNumber(token_types_1.Float32_BE);\n      case 8:\n        return this.tokenizer.readNumber(token_types_1.Float64_BE);\n      case 10:\n        return this.tokenizer.readNumber(token_types_1.Float64_BE);\n      default:\n        throw new Error(`Invalid IEEE-754 float length: ${e.len}`);\n    }\n  }\n  async readFlag(e) {\n    return (await this.readUint(e)) === 1;\n  }\n  async readUint(e) {\n    const buf = await this.readBuffer(e);\n    const nrLen = Math.min(6, e.len); // JavaScript can max read 6 bytes integer\n    return buf.readUIntBE(e.len - nrLen, nrLen);\n  }\n  async readString(e) {\n    const rawString = await this.tokenizer.readToken(new token_types_1.StringType(e.len, 'utf-8'));\n    return rawString.replace(/\\00.*$/g, '');\n  }\n  async readBuffer(e) {\n    const buf = Buffer.alloc(e.len);\n    await this.tokenizer.readBuffer(buf);\n    return buf;\n  }\n  addTag(tagId, value) {\n    this.metadata.addTag('matroska', tagId, value);\n  }\n}\nexports.MatroskaParser = MatroskaParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","MatroskaParser","token_types_1","require","debug_1","BasicParser_1","types_1","matroskaDtd","debug","default","BasicParser","constructor","padding","parserMap","Map","ebmlMaxIDLength","ebmlMaxSizeLength","set","DataType","uint","e","readUint","string","readString","binary","readBuffer","uid","bool","readFlag","float","readFloat","init","metadata","tokenizer","options","parse","matroska","parseContainer","elements","fileInfo","size","setFormat","ebml","docType","segment","info","timecodeScale","duration","addTag","title","audioTracks","tracks","entries","forEach","entry","stream","codecName","codecID","replace","codecSettings","flagDefault","flagLacing","flagEnabled","language","name","type","trackType","audio","video","addStreamInfo","audioTrack","filter","TrackType","valueOf","reduce","acc","cur","trackNumber","samplingFrequency","channels","tags","tag","target","targetType","targetTypeValue","TargetType","simpleTags","simpleTag","attachments","attachedFiles","file","mimeType","startsWith","map","data","format","description","picture","container","posDone","path","tree","position","element","readElement","error","message","id","res","len","concat","multiple","push","get","ignore","join","toString","readVintData","maxLength","msb","peekNumber","UINT8","mask","oc","Error","Buffer","alloc","lenField","length","nrLen","Math","min","readUIntBE","isMaxValue","vintData","n","readNumber","Float32_BE","Float64_BE","buf","rawString","readToken","StringType","tagId"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/matroska/MatroskaParser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MatroskaParser = void 0;\nconst token_types_1 = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst types_1 = require(\"./types\");\nconst matroskaDtd = require(\"./MatroskaDtd\");\nconst debug = (0, debug_1.default)('music-metadata:parser:matroska');\n/**\n * Extensible Binary Meta Language (EBML) parser\n * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language\n * http://matroska.sourceforge.net/technical/specs/rfc/index.html\n *\n * WEBM VP8 AUDIO FILE\n */\nclass MatroskaParser extends BasicParser_1.BasicParser {\n    constructor() {\n        super();\n        this.padding = 0;\n        this.parserMap = new Map();\n        this.ebmlMaxIDLength = 4;\n        this.ebmlMaxSizeLength = 8;\n        this.parserMap.set(types_1.DataType.uint, e => this.readUint(e));\n        this.parserMap.set(types_1.DataType.string, e => this.readString(e));\n        this.parserMap.set(types_1.DataType.binary, e => this.readBuffer(e));\n        this.parserMap.set(types_1.DataType.uid, async (e) => await this.readUint(e) === 1);\n        this.parserMap.set(types_1.DataType.bool, e => this.readFlag(e));\n        this.parserMap.set(types_1.DataType.float, e => this.readFloat(e));\n    }\n    /**\n     * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n     * @param {INativeMetadataCollector} metadata Output\n     * @param {ITokenizer} tokenizer Input\n     * @param {IOptions} options Parsing options\n     */\n    init(metadata, tokenizer, options) {\n        super.init(metadata, tokenizer, options);\n        return this;\n    }\n    async parse() {\n        const matroska = await this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);\n        this.metadata.setFormat('container', `EBML/${matroska.ebml.docType}`);\n        if (matroska.segment) {\n            const info = matroska.segment.info;\n            if (info) {\n                const timecodeScale = info.timecodeScale ? info.timecodeScale : 1000000;\n                if (typeof info.duration === 'number') {\n                    const duration = info.duration * timecodeScale / 1000000000;\n                    this.addTag('segment:title', info.title);\n                    this.metadata.setFormat('duration', duration);\n                }\n            }\n            const audioTracks = matroska.segment.tracks;\n            if (audioTracks && audioTracks.entries) {\n                audioTracks.entries.forEach(entry => {\n                    const stream = {\n                        codecName: entry.codecID.replace('A_', '').replace('V_', ''),\n                        codecSettings: entry.codecSettings,\n                        flagDefault: entry.flagDefault,\n                        flagLacing: entry.flagLacing,\n                        flagEnabled: entry.flagEnabled,\n                        language: entry.language,\n                        name: entry.name,\n                        type: entry.trackType,\n                        audio: entry.audio,\n                        video: entry.video\n                    };\n                    this.metadata.addStreamInfo(stream);\n                });\n                const audioTrack = audioTracks.entries\n                    .filter(entry => {\n                    return entry.trackType === types_1.TrackType.audio.valueOf();\n                })\n                    .reduce((acc, cur) => {\n                    if (!acc) {\n                        return cur;\n                    }\n                    if (!acc.flagDefault && cur.flagDefault) {\n                        return cur;\n                    }\n                    if (cur.trackNumber && cur.trackNumber < acc.trackNumber) {\n                        return cur;\n                    }\n                    return acc;\n                }, null);\n                if (audioTrack) {\n                    this.metadata.setFormat('codec', audioTrack.codecID.replace('A_', ''));\n                    this.metadata.setFormat('sampleRate', audioTrack.audio.samplingFrequency);\n                    this.metadata.setFormat('numberOfChannels', audioTrack.audio.channels);\n                }\n                if (matroska.segment.tags) {\n                    matroska.segment.tags.tag.forEach(tag => {\n                        const target = tag.target;\n                        const targetType = (target === null || target === void 0 ? void 0 : target.targetTypeValue) ? types_1.TargetType[target.targetTypeValue] : ((target === null || target === void 0 ? void 0 : target.targetType) ? target.targetType : 'track');\n                        tag.simpleTags.forEach(simpleTag => {\n                            const value = simpleTag.string ? simpleTag.string : simpleTag.binary;\n                            this.addTag(`${targetType}:${simpleTag.name}`, value);\n                        });\n                    });\n                }\n                if (matroska.segment.attachments) {\n                    matroska.segment.attachments.attachedFiles\n                        .filter(file => file.mimeType.startsWith('image/'))\n                        .map(file => {\n                        return {\n                            data: file.data,\n                            format: file.mimeType,\n                            description: file.description,\n                            name: file.name\n                        };\n                    }).forEach(picture => {\n                        this.addTag('picture', picture);\n                    });\n                }\n            }\n        }\n    }\n    async parseContainer(container, posDone, path) {\n        const tree = {};\n        while (this.tokenizer.position < posDone) {\n            let element;\n            try {\n                element = await this.readElement();\n            }\n            catch (error) {\n                if (error.message === 'End-Of-Stream') {\n                    break;\n                }\n                throw error;\n            }\n            const type = container[element.id];\n            if (type) {\n                debug(`Element: name=${type.name}, container=${!!type.container}`);\n                if (type.container) {\n                    const res = await this.parseContainer(type.container, element.len >= 0 ? this.tokenizer.position + element.len : -1, path.concat([type.name]));\n                    if (type.multiple) {\n                        if (!tree[type.name]) {\n                            tree[type.name] = [];\n                        }\n                        tree[type.name].push(res);\n                    }\n                    else {\n                        tree[type.name] = res;\n                    }\n                }\n                else {\n                    tree[type.name] = await this.parserMap.get(type.value)(element);\n                }\n            }\n            else {\n                switch (element.id) {\n                    case 0xec: // void\n                        this.padding += element.len;\n                        await this.tokenizer.ignore(element.len);\n                        break;\n                    default:\n                        debug(`parseEbml: path=${path.join('/')}, unknown element: id=${element.id.toString(16)}`);\n                        this.padding += element.len;\n                        await this.tokenizer.ignore(element.len);\n                }\n            }\n        }\n        return tree;\n    }\n    async readVintData(maxLength) {\n        const msb = await this.tokenizer.peekNumber(token_types_1.UINT8);\n        let mask = 0x80;\n        let oc = 1;\n        // Calculate VINT_WIDTH\n        while ((msb & mask) === 0) {\n            if (oc > maxLength) {\n                throw new Error('VINT value exceeding maximum size');\n            }\n            ++oc;\n            mask >>= 1;\n        }\n        const id = Buffer.alloc(oc);\n        await this.tokenizer.readBuffer(id);\n        return id;\n    }\n    async readElement() {\n        const id = await this.readVintData(this.ebmlMaxIDLength);\n        const lenField = await this.readVintData(this.ebmlMaxSizeLength);\n        lenField[0] ^= 0x80 >> (lenField.length - 1);\n        const nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer\n        return {\n            id: id.readUIntBE(0, id.length),\n            len: lenField.readUIntBE(lenField.length - nrLen, nrLen)\n        };\n    }\n    isMaxValue(vintData) {\n        if (vintData.length === this.ebmlMaxSizeLength) {\n            for (let n = 1; n < this.ebmlMaxSizeLength; ++n) {\n                if (vintData[n] !== 0xff)\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    async readFloat(e) {\n        switch (e.len) {\n            case 0:\n                return 0.0;\n            case 4:\n                return this.tokenizer.readNumber(token_types_1.Float32_BE);\n            case 8:\n                return this.tokenizer.readNumber(token_types_1.Float64_BE);\n            case 10:\n                return this.tokenizer.readNumber(token_types_1.Float64_BE);\n            default:\n                throw new Error(`Invalid IEEE-754 float length: ${e.len}`);\n        }\n    }\n    async readFlag(e) {\n        return (await this.readUint(e)) === 1;\n    }\n    async readUint(e) {\n        const buf = await this.readBuffer(e);\n        const nrLen = Math.min(6, e.len); // JavaScript can max read 6 bytes integer\n        return buf.readUIntBE(e.len - nrLen, nrLen);\n    }\n    async readString(e) {\n        const rawString = await this.tokenizer.readToken(new token_types_1.StringType(e.len, 'utf-8'));\n        return rawString.replace(/\\00.*$/g, '');\n    }\n    async readBuffer(e) {\n        const buf = Buffer.alloc(e.len);\n        await this.tokenizer.readBuffer(buf);\n        return buf;\n    }\n    addTag(tagId, value) {\n        this.metadata.addTag('matroska', tagId, value);\n    }\n}\nexports.MatroskaParser = MatroskaParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}