{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FrameParser = exports.parseGenre = void 0;\nconst debug_1 = require(\"debug\");\nconst Token = require(\"token-types\");\nconst util = require(\"../common/Util\");\nconst ID3v2Token_1 = require(\"./ID3v2Token\");\nconst ID3v1Parser_1 = require(\"../id3v1/ID3v1Parser\");\nconst debug = (0, debug_1.default)('music-metadata:id3v2:frame-parser');\nconst defaultEnc = 'latin1'; // latin1 == iso-8859-1;\nfunction parseGenre(origVal) {\n  // match everything inside parentheses\n  const genres = [];\n  let code;\n  let word = '';\n  for (const c of origVal) {\n    if (typeof code === 'string') {\n      if (c === '(' && code === '') {\n        word += '(';\n        code = undefined;\n      } else if (c === ')') {\n        if (word !== '') {\n          genres.push(word);\n          word = '';\n        }\n        const genre = parseGenreCode(code);\n        if (genre) {\n          genres.push(genre);\n        }\n        code = undefined;\n      } else code += c;\n    } else if (c === '(') {\n      code = '';\n    } else {\n      word += c;\n    }\n  }\n  if (word) {\n    if (genres.length === 0 && word.match(/^\\d*$/)) {\n      word = ID3v1Parser_1.Genres[word];\n    }\n    genres.push(word);\n  }\n  return genres;\n}\nexports.parseGenre = parseGenre;\nfunction parseGenreCode(code) {\n  if (code === 'RX') return 'Remix';\n  if (code === 'CR') return 'Cover';\n  if (code.match(/^\\d*$/)) {\n    return ID3v1Parser_1.Genres[code];\n  }\n}\nclass FrameParser {\n  /**\n   * Create id3v2 frame parser\n   * @param major - Major version, e.g. (4) for  id3v2.4\n   * @param warningCollector - Used to collect decode issue\n   */\n  constructor(major, warningCollector) {\n    this.major = major;\n    this.warningCollector = warningCollector;\n  }\n  readData(uint8Array, type, includeCovers) {\n    if (uint8Array.length === 0) {\n      this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${type}`);\n      return;\n    }\n    const {\n      encoding,\n      bom\n    } = ID3v2Token_1.TextEncodingToken.get(uint8Array, 0);\n    const length = uint8Array.length;\n    let offset = 0;\n    let output = []; // ToDo\n    const nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);\n    let fzero;\n    const out = {};\n    debug(`Parsing tag type=${type}, encoding=${encoding}, bom=${bom}`);\n    switch (type !== 'TXXX' && type[0] === 'T' ? 'T*' : type) {\n      case 'T*': // 4.2.1. Text information frames - details\n      case 'IPLS': // v2.3: Involved people list\n      case 'MVIN':\n      case 'MVNM':\n      case 'PCS':\n      case 'PCST':\n        let text;\n        try {\n          text = util.decodeString(uint8Array.slice(1), encoding).replace(/\\x00+$/, '');\n        } catch (error) {\n          this.warningCollector.addWarning(`id3v2.${this.major} type=${type} header has invalid string value: ${error.message}`);\n        }\n        switch (type) {\n          case 'TMCL': // Musician credits list\n          case 'TIPL': // Involved people list\n          case 'IPLS':\n            // Involved people list\n            output = this.splitValue(type, text);\n            output = FrameParser.functionList(output);\n            break;\n          case 'TRK':\n          case 'TRCK':\n          case 'TPOS':\n            output = text;\n            break;\n          case 'TCOM':\n          case 'TEXT':\n          case 'TOLY':\n          case 'TOPE':\n          case 'TPE1':\n          case 'TSRC':\n            // id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\n            output = this.splitValue(type, text);\n            break;\n          case 'TCO':\n          case 'TCON':\n            output = this.splitValue(type, text).map(v => parseGenre(v)).reduce((acc, val) => acc.concat(val), []);\n            break;\n          case 'PCS':\n          case 'PCST':\n            // TODO: Why `default` not results `1` but `''`?\n            output = this.major >= 4 ? this.splitValue(type, text) : [text];\n            output = Array.isArray(output) && output[0] === '' ? 1 : 0;\n            break;\n          default:\n            output = this.major >= 4 ? this.splitValue(type, text) : [text];\n        }\n        break;\n      case 'TXXX':\n        output = FrameParser.readIdentifierAndData(uint8Array, offset + 1, length, encoding);\n        output = {\n          description: output.id,\n          text: this.splitValue(type, util.decodeString(output.data, encoding).replace(/\\x00+$/, ''))\n        };\n        break;\n      case 'PIC':\n      case 'APIC':\n        if (includeCovers) {\n          const pic = {};\n          offset += 1;\n          switch (this.major) {\n            case 2:\n              pic.format = util.decodeString(uint8Array.slice(offset, offset + 3), 'latin1'); // 'latin1'; // latin1 == iso-8859-1;\n              offset += 3;\n              break;\n            case 3:\n            case 4:\n              fzero = util.findZero(uint8Array, offset, length, defaultEnc);\n              pic.format = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n              offset = fzero + 1;\n              break;\n            default:\n              throw new Error('Warning: unexpected major versionIndex: ' + this.major);\n          }\n          pic.format = FrameParser.fixPictureMimeType(pic.format);\n          pic.type = ID3v2Token_1.AttachedPictureType[uint8Array[offset]];\n          offset += 1;\n          fzero = util.findZero(uint8Array, offset, length, encoding);\n          pic.description = util.decodeString(uint8Array.slice(offset, fzero), encoding);\n          offset = fzero + nullTerminatorLength;\n          pic.data = Buffer.from(uint8Array.slice(offset, length));\n          output = pic;\n        }\n        break;\n      case 'CNT':\n      case 'PCNT':\n        output = Token.UINT32_BE.get(uint8Array, 0);\n        break;\n      case 'SYLT':\n        // skip text encoding (1 byte),\n        //      language (3 bytes),\n        //      time stamp format (1 byte),\n        //      content tagTypes (1 byte),\n        //      content descriptor (1 byte)\n        offset += 7;\n        output = [];\n        while (offset < length) {\n          const txt = uint8Array.slice(offset, offset = util.findZero(uint8Array, offset, length, encoding));\n          offset += 5; // push offset forward one +  4 byte timestamp\n          output.push(util.decodeString(txt, encoding));\n        }\n        break;\n      case 'ULT':\n      case 'USLT':\n      case 'COM':\n      case 'COMM':\n        offset += 1;\n        out.language = util.decodeString(uint8Array.slice(offset, offset + 3), defaultEnc);\n        offset += 3;\n        fzero = util.findZero(uint8Array, offset, length, encoding);\n        out.description = util.decodeString(uint8Array.slice(offset, fzero), encoding);\n        offset = fzero + nullTerminatorLength;\n        out.text = util.decodeString(uint8Array.slice(offset, length), encoding).replace(/\\x00+$/, '');\n        output = [out];\n        break;\n      case 'UFID':\n        output = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);\n        output = {\n          owner_identifier: output.id,\n          identifier: output.data\n        };\n        break;\n      case 'PRIV':\n        // private frame\n        output = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);\n        output = {\n          owner_identifier: output.id,\n          data: output.data\n        };\n        break;\n      case 'POPM':\n        // Popularimeter\n        fzero = util.findZero(uint8Array, offset, length, defaultEnc);\n        const email = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n        offset = fzero + 1;\n        const dataLen = length - offset;\n        output = {\n          email,\n          rating: Token.UINT8.get(uint8Array, offset),\n          counter: dataLen >= 5 ? Token.UINT32_BE.get(uint8Array, offset + 1) : undefined\n        };\n        break;\n      case 'GEOB':\n        {\n          // General encapsulated object\n          fzero = util.findZero(uint8Array, offset + 1, length, encoding);\n          const mimeType = util.decodeString(uint8Array.slice(offset + 1, fzero), defaultEnc);\n          offset = fzero + 1;\n          fzero = util.findZero(uint8Array, offset, length - offset, encoding);\n          const filename = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n          offset = fzero + 1;\n          fzero = util.findZero(uint8Array, offset, length - offset, encoding);\n          const description = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n          output = {\n            type: mimeType,\n            filename,\n            description,\n            data: uint8Array.slice(offset + 1, length)\n          };\n          break;\n        }\n      // W-Frames:\n      case 'WCOM':\n      case 'WCOP':\n      case 'WOAF':\n      case 'WOAR':\n      case 'WOAS':\n      case 'WORS':\n      case 'WPAY':\n      case 'WPUB':\n        // Decode URL\n        output = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n        break;\n      case 'WXXX':\n        {\n          // Decode URL\n          fzero = util.findZero(uint8Array, offset + 1, length, encoding);\n          const description = util.decodeString(uint8Array.slice(offset + 1, fzero), encoding);\n          offset = fzero + (encoding === 'utf16le' ? 2 : 1);\n          output = {\n            description,\n            url: util.decodeString(uint8Array.slice(offset, length), defaultEnc)\n          };\n          break;\n        }\n      case 'WFD':\n      case 'WFED':\n        output = util.decodeString(uint8Array.slice(offset + 1, util.findZero(uint8Array, offset + 1, length, encoding)), encoding);\n        break;\n      case 'MCDI':\n        {\n          // Music CD identifier\n          output = uint8Array.slice(0, length);\n          break;\n        }\n      default:\n        debug('Warning: unsupported id3v2-tag-type: ' + type);\n        break;\n    }\n    return output;\n  }\n  static fixPictureMimeType(pictureType) {\n    pictureType = pictureType.toLocaleLowerCase();\n    switch (pictureType) {\n      case 'jpg':\n        return 'image/jpeg';\n      case 'png':\n        return 'image/png';\n    }\n    return pictureType;\n  }\n  /**\n   * Converts TMCL (Musician credits list) or TIPL (Involved people list)\n   * @param entries\n   */\n  static functionList(entries) {\n    const res = {};\n    for (let i = 0; i + 1 < entries.length; i += 2) {\n      const names = entries[i + 1].split(',');\n      res[entries[i]] = res.hasOwnProperty(entries[i]) ? res[entries[i]].concat(names) : names;\n    }\n    return res;\n  }\n  /**\n   * id3v2.4 defines that multiple T* values are separated by 0x00\n   * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\n   * @param tag - Tag name\n   * @param text - Concatenated tag value\n   * @returns Split tag value\n   */\n  splitValue(tag, text) {\n    let values;\n    if (this.major < 4) {\n      values = text.split(/\\x00/g);\n      if (values.length > 1) {\n        this.warningCollector.addWarning(`ID3v2.${this.major} ${tag} uses non standard null-separator.`);\n      } else {\n        values = text.split(/\\//g);\n      }\n    } else {\n      values = text.split(/\\x00/g);\n    }\n    return FrameParser.trimArray(values);\n  }\n  static trimArray(values) {\n    return values.map(value => value.replace(/\\x00+$/, '').trim());\n  }\n  static readIdentifierAndData(uint8Array, offset, length, encoding) {\n    const fzero = util.findZero(uint8Array, offset, length, encoding);\n    const id = util.decodeString(uint8Array.slice(offset, fzero), encoding);\n    offset = fzero + FrameParser.getNullTerminatorLength(encoding);\n    return {\n      id,\n      data: uint8Array.slice(offset, length)\n    };\n  }\n  static getNullTerminatorLength(enc) {\n    return enc === 'utf16le' ? 2 : 1;\n  }\n}\nexports.FrameParser = FrameParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","FrameParser","parseGenre","debug_1","require","Token","util","ID3v2Token_1","ID3v1Parser_1","debug","default","defaultEnc","origVal","genres","code","word","c","undefined","push","genre","parseGenreCode","length","match","Genres","constructor","major","warningCollector","readData","uint8Array","type","includeCovers","addWarning","encoding","bom","TextEncodingToken","get","offset","output","nullTerminatorLength","getNullTerminatorLength","fzero","out","text","decodeString","slice","replace","error","message","splitValue","functionList","map","v","reduce","acc","val","concat","Array","isArray","readIdentifierAndData","description","id","data","pic","format","findZero","Error","fixPictureMimeType","AttachedPictureType","Buffer","from","UINT32_BE","txt","language","owner_identifier","identifier","email","dataLen","rating","UINT8","counter","mimeType","filename","url","pictureType","toLocaleLowerCase","entries","res","i","names","split","hasOwnProperty","tag","values","trimArray","trim","enc"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/id3v2/FrameParser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FrameParser = exports.parseGenre = void 0;\nconst debug_1 = require(\"debug\");\nconst Token = require(\"token-types\");\nconst util = require(\"../common/Util\");\nconst ID3v2Token_1 = require(\"./ID3v2Token\");\nconst ID3v1Parser_1 = require(\"../id3v1/ID3v1Parser\");\nconst debug = (0, debug_1.default)('music-metadata:id3v2:frame-parser');\nconst defaultEnc = 'latin1'; // latin1 == iso-8859-1;\nfunction parseGenre(origVal) {\n    // match everything inside parentheses\n    const genres = [];\n    let code;\n    let word = '';\n    for (const c of origVal) {\n        if (typeof code === 'string') {\n            if (c === '(' && code === '') {\n                word += '(';\n                code = undefined;\n            }\n            else if (c === ')') {\n                if (word !== '') {\n                    genres.push(word);\n                    word = '';\n                }\n                const genre = parseGenreCode(code);\n                if (genre) {\n                    genres.push(genre);\n                }\n                code = undefined;\n            }\n            else\n                code += c;\n        }\n        else if (c === '(') {\n            code = '';\n        }\n        else {\n            word += c;\n        }\n    }\n    if (word) {\n        if (genres.length === 0 && word.match(/^\\d*$/)) {\n            word = ID3v1Parser_1.Genres[word];\n        }\n        genres.push(word);\n    }\n    return genres;\n}\nexports.parseGenre = parseGenre;\nfunction parseGenreCode(code) {\n    if (code === 'RX')\n        return 'Remix';\n    if (code === 'CR')\n        return 'Cover';\n    if (code.match(/^\\d*$/)) {\n        return ID3v1Parser_1.Genres[code];\n    }\n}\nclass FrameParser {\n    /**\n     * Create id3v2 frame parser\n     * @param major - Major version, e.g. (4) for  id3v2.4\n     * @param warningCollector - Used to collect decode issue\n     */\n    constructor(major, warningCollector) {\n        this.major = major;\n        this.warningCollector = warningCollector;\n    }\n    readData(uint8Array, type, includeCovers) {\n        if (uint8Array.length === 0) {\n            this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${type}`);\n            return;\n        }\n        const { encoding, bom } = ID3v2Token_1.TextEncodingToken.get(uint8Array, 0);\n        const length = uint8Array.length;\n        let offset = 0;\n        let output = []; // ToDo\n        const nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);\n        let fzero;\n        const out = {};\n        debug(`Parsing tag type=${type}, encoding=${encoding}, bom=${bom}`);\n        switch (type !== 'TXXX' && type[0] === 'T' ? 'T*' : type) {\n            case 'T*': // 4.2.1. Text information frames - details\n            case 'IPLS': // v2.3: Involved people list\n            case 'MVIN':\n            case 'MVNM':\n            case 'PCS':\n            case 'PCST':\n                let text;\n                try {\n                    text = util.decodeString(uint8Array.slice(1), encoding).replace(/\\x00+$/, '');\n                }\n                catch (error) {\n                    this.warningCollector.addWarning(`id3v2.${this.major} type=${type} header has invalid string value: ${error.message}`);\n                }\n                switch (type) {\n                    case 'TMCL': // Musician credits list\n                    case 'TIPL': // Involved people list\n                    case 'IPLS': // Involved people list\n                        output = this.splitValue(type, text);\n                        output = FrameParser.functionList(output);\n                        break;\n                    case 'TRK':\n                    case 'TRCK':\n                    case 'TPOS':\n                        output = text;\n                        break;\n                    case 'TCOM':\n                    case 'TEXT':\n                    case 'TOLY':\n                    case 'TOPE':\n                    case 'TPE1':\n                    case 'TSRC':\n                        // id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\n                        output = this.splitValue(type, text);\n                        break;\n                    case 'TCO':\n                    case 'TCON':\n                        output = this.splitValue(type, text).map(v => parseGenre(v)).reduce((acc, val) => acc.concat(val), []);\n                        break;\n                    case 'PCS':\n                    case 'PCST':\n                        // TODO: Why `default` not results `1` but `''`?\n                        output = this.major >= 4 ? this.splitValue(type, text) : [text];\n                        output = (Array.isArray(output) && output[0] === '') ? 1 : 0;\n                        break;\n                    default:\n                        output = this.major >= 4 ? this.splitValue(type, text) : [text];\n                }\n                break;\n            case 'TXXX':\n                output = FrameParser.readIdentifierAndData(uint8Array, offset + 1, length, encoding);\n                output = {\n                    description: output.id,\n                    text: this.splitValue(type, util.decodeString(output.data, encoding).replace(/\\x00+$/, ''))\n                };\n                break;\n            case 'PIC':\n            case 'APIC':\n                if (includeCovers) {\n                    const pic = {};\n                    offset += 1;\n                    switch (this.major) {\n                        case 2:\n                            pic.format = util.decodeString(uint8Array.slice(offset, offset + 3), 'latin1'); // 'latin1'; // latin1 == iso-8859-1;\n                            offset += 3;\n                            break;\n                        case 3:\n                        case 4:\n                            fzero = util.findZero(uint8Array, offset, length, defaultEnc);\n                            pic.format = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n                            offset = fzero + 1;\n                            break;\n                        default:\n                            throw new Error('Warning: unexpected major versionIndex: ' + this.major);\n                    }\n                    pic.format = FrameParser.fixPictureMimeType(pic.format);\n                    pic.type = ID3v2Token_1.AttachedPictureType[uint8Array[offset]];\n                    offset += 1;\n                    fzero = util.findZero(uint8Array, offset, length, encoding);\n                    pic.description = util.decodeString(uint8Array.slice(offset, fzero), encoding);\n                    offset = fzero + nullTerminatorLength;\n                    pic.data = Buffer.from(uint8Array.slice(offset, length));\n                    output = pic;\n                }\n                break;\n            case 'CNT':\n            case 'PCNT':\n                output = Token.UINT32_BE.get(uint8Array, 0);\n                break;\n            case 'SYLT':\n                // skip text encoding (1 byte),\n                //      language (3 bytes),\n                //      time stamp format (1 byte),\n                //      content tagTypes (1 byte),\n                //      content descriptor (1 byte)\n                offset += 7;\n                output = [];\n                while (offset < length) {\n                    const txt = uint8Array.slice(offset, offset = util.findZero(uint8Array, offset, length, encoding));\n                    offset += 5; // push offset forward one +  4 byte timestamp\n                    output.push(util.decodeString(txt, encoding));\n                }\n                break;\n            case 'ULT':\n            case 'USLT':\n            case 'COM':\n            case 'COMM':\n                offset += 1;\n                out.language = util.decodeString(uint8Array.slice(offset, offset + 3), defaultEnc);\n                offset += 3;\n                fzero = util.findZero(uint8Array, offset, length, encoding);\n                out.description = util.decodeString(uint8Array.slice(offset, fzero), encoding);\n                offset = fzero + nullTerminatorLength;\n                out.text = util.decodeString(uint8Array.slice(offset, length), encoding).replace(/\\x00+$/, '');\n                output = [out];\n                break;\n            case 'UFID':\n                output = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);\n                output = { owner_identifier: output.id, identifier: output.data };\n                break;\n            case 'PRIV': // private frame\n                output = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);\n                output = { owner_identifier: output.id, data: output.data };\n                break;\n            case 'POPM': // Popularimeter\n                fzero = util.findZero(uint8Array, offset, length, defaultEnc);\n                const email = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n                offset = fzero + 1;\n                const dataLen = length - offset;\n                output = {\n                    email,\n                    rating: Token.UINT8.get(uint8Array, offset),\n                    counter: dataLen >= 5 ? Token.UINT32_BE.get(uint8Array, offset + 1) : undefined\n                };\n                break;\n            case 'GEOB': { // General encapsulated object\n                fzero = util.findZero(uint8Array, offset + 1, length, encoding);\n                const mimeType = util.decodeString(uint8Array.slice(offset + 1, fzero), defaultEnc);\n                offset = fzero + 1;\n                fzero = util.findZero(uint8Array, offset, length - offset, encoding);\n                const filename = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n                offset = fzero + 1;\n                fzero = util.findZero(uint8Array, offset, length - offset, encoding);\n                const description = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n                output = {\n                    type: mimeType,\n                    filename,\n                    description,\n                    data: uint8Array.slice(offset + 1, length)\n                };\n                break;\n            }\n            // W-Frames:\n            case 'WCOM':\n            case 'WCOP':\n            case 'WOAF':\n            case 'WOAR':\n            case 'WOAS':\n            case 'WORS':\n            case 'WPAY':\n            case 'WPUB':\n                // Decode URL\n                output = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n                break;\n            case 'WXXX': {\n                // Decode URL\n                fzero = util.findZero(uint8Array, offset + 1, length, encoding);\n                const description = util.decodeString(uint8Array.slice(offset + 1, fzero), encoding);\n                offset = fzero + (encoding === 'utf16le' ? 2 : 1);\n                output = { description, url: util.decodeString(uint8Array.slice(offset, length), defaultEnc) };\n                break;\n            }\n            case 'WFD':\n            case 'WFED':\n                output = util.decodeString(uint8Array.slice(offset + 1, util.findZero(uint8Array, offset + 1, length, encoding)), encoding);\n                break;\n            case 'MCDI': {\n                // Music CD identifier\n                output = uint8Array.slice(0, length);\n                break;\n            }\n            default:\n                debug('Warning: unsupported id3v2-tag-type: ' + type);\n                break;\n        }\n        return output;\n    }\n    static fixPictureMimeType(pictureType) {\n        pictureType = pictureType.toLocaleLowerCase();\n        switch (pictureType) {\n            case 'jpg':\n                return 'image/jpeg';\n            case 'png':\n                return 'image/png';\n        }\n        return pictureType;\n    }\n    /**\n     * Converts TMCL (Musician credits list) or TIPL (Involved people list)\n     * @param entries\n     */\n    static functionList(entries) {\n        const res = {};\n        for (let i = 0; i + 1 < entries.length; i += 2) {\n            const names = entries[i + 1].split(',');\n            res[entries[i]] = res.hasOwnProperty(entries[i]) ? res[entries[i]].concat(names) : names;\n        }\n        return res;\n    }\n    /**\n     * id3v2.4 defines that multiple T* values are separated by 0x00\n     * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\n     * @param tag - Tag name\n     * @param text - Concatenated tag value\n     * @returns Split tag value\n     */\n    splitValue(tag, text) {\n        let values;\n        if (this.major < 4) {\n            values = text.split(/\\x00/g);\n            if (values.length > 1) {\n                this.warningCollector.addWarning(`ID3v2.${this.major} ${tag} uses non standard null-separator.`);\n            }\n            else {\n                values = text.split(/\\//g);\n            }\n        }\n        else {\n            values = text.split(/\\x00/g);\n        }\n        return FrameParser.trimArray(values);\n    }\n    static trimArray(values) {\n        return values.map(value => value.replace(/\\x00+$/, '').trim());\n    }\n    static readIdentifierAndData(uint8Array, offset, length, encoding) {\n        const fzero = util.findZero(uint8Array, offset, length, encoding);\n        const id = util.decodeString(uint8Array.slice(offset, fzero), encoding);\n        offset = fzero + FrameParser.getNullTerminatorLength(encoding);\n        return { id, data: uint8Array.slice(offset, length) };\n    }\n    static getNullTerminatorLength(enc) {\n        return enc === 'utf16le' ? 2 : 1;\n    }\n}\nexports.FrameParser = FrameParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}