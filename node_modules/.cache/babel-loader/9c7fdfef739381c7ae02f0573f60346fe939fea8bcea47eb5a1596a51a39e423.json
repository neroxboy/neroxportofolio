{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeKeyedMutex = exports.makeMutex = void 0;\nconst makeMutex = () => {\n  let task = Promise.resolve();\n  let taskTimeout;\n  return {\n    mutex(code) {\n      task = (async () => {\n        // wait for the previous task to complete\n        // if there is an error, we swallow so as to not block the queue\n        try {\n          await task;\n        } catch (_a) {}\n        try {\n          // execute the current task\n          const result = await code();\n          return result;\n        } finally {\n          clearTimeout(taskTimeout);\n        }\n      })();\n      // we replace the existing task, appending the new piece of execution to it\n      // so the next task will have to wait for this one to finish\n      return task;\n    }\n  };\n};\nexports.makeMutex = makeMutex;\nconst makeKeyedMutex = () => {\n  const map = {};\n  return {\n    mutex(key, task) {\n      if (!map[key]) {\n        map[key] = (0, exports.makeMutex)();\n      }\n      return map[key].mutex(task);\n    }\n  };\n};\nexports.makeKeyedMutex = makeKeyedMutex;","map":{"version":3,"names":["Object","defineProperty","exports","value","makeKeyedMutex","makeMutex","task","Promise","resolve","taskTimeout","mutex","code","_a","result","clearTimeout","map","key"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Utils/make-mutex.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeKeyedMutex = exports.makeMutex = void 0;\nconst makeMutex = () => {\n    let task = Promise.resolve();\n    let taskTimeout;\n    return {\n        mutex(code) {\n            task = (async () => {\n                // wait for the previous task to complete\n                // if there is an error, we swallow so as to not block the queue\n                try {\n                    await task;\n                }\n                catch (_a) { }\n                try {\n                    // execute the current task\n                    const result = await code();\n                    return result;\n                }\n                finally {\n                    clearTimeout(taskTimeout);\n                }\n            })();\n            // we replace the existing task, appending the new piece of execution to it\n            // so the next task will have to wait for this one to finish\n            return task;\n        },\n    };\n};\nexports.makeMutex = makeMutex;\nconst makeKeyedMutex = () => {\n    const map = {};\n    return {\n        mutex(key, task) {\n            if (!map[key]) {\n                map[key] = (0, exports.makeMutex)();\n            }\n            return map[key].mutex(task);\n        }\n    };\n};\nexports.makeKeyedMutex = makeKeyedMutex;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,cAAc,GAAGF,OAAO,CAACG,SAAS,GAAG,KAAK,CAAC;AACnD,MAAMA,SAAS,GAAGA,CAAA,KAAM;EACpB,IAAIC,IAAI,GAAGC,OAAO,CAACC,OAAO,CAAC,CAAC;EAC5B,IAAIC,WAAW;EACf,OAAO;IACHC,KAAKA,CAACC,IAAI,EAAE;MACRL,IAAI,GAAG,CAAC,YAAY;QAChB;QACA;QACA,IAAI;UACA,MAAMA,IAAI;QACd,CAAC,CACD,OAAOM,EAAE,EAAE,CAAE;QACb,IAAI;UACA;UACA,MAAMC,MAAM,GAAG,MAAMF,IAAI,CAAC,CAAC;UAC3B,OAAOE,MAAM;QACjB,CAAC,SACO;UACJC,YAAY,CAACL,WAAW,CAAC;QAC7B;MACJ,CAAC,EAAE,CAAC;MACJ;MACA;MACA,OAAOH,IAAI;IACf;EACJ,CAAC;AACL,CAAC;AACDJ,OAAO,CAACG,SAAS,GAAGA,SAAS;AAC7B,MAAMD,cAAc,GAAGA,CAAA,KAAM;EACzB,MAAMW,GAAG,GAAG,CAAC,CAAC;EACd,OAAO;IACHL,KAAKA,CAACM,GAAG,EAAEV,IAAI,EAAE;MACb,IAAI,CAACS,GAAG,CAACC,GAAG,CAAC,EAAE;QACXD,GAAG,CAACC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEd,OAAO,CAACG,SAAS,EAAE,CAAC;MACvC;MACA,OAAOU,GAAG,CAACC,GAAG,CAAC,CAACN,KAAK,CAACJ,IAAI,CAAC;IAC/B;EACJ,CAAC;AACL,CAAC;AACDJ,OAAO,CAACE,cAAc,GAAGA,cAAc","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}