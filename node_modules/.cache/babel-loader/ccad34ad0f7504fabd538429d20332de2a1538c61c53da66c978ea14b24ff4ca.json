{"ast":null,"code":"import { BitOutputStream } from \"@thi.ng/bitstream\";\nimport { qoa_lms_predict, qoa_lms_update, qoa_clamp, qoa_dequant_tab, qoa_scalefactor_tab, LMS, QOA_SLICE_LEN, QOA_FRAME_LEN, QOA_MAGIC, QOA_LMS_LEN, QOA_FRAME_SIZE } from \"./lib/common.js\";\n\n/* The reciprocal_tab maps each of the 16 scalefactors to their rounded \nreciprocals 1/scalefactor. This allows us to calculate the scaled residuals in \nthe encoder with just one multiplication instead of an expensive division. We \ndo this in .16 fixed point with integers, instead of floats.\n\nThe reciprocal_tab is computed as:\nreciprocal_tab[s] <- ((1<<16) + scalefactor_tab[s] - 1) / scalefactor_tab[s] */\n\nconst qoa_reciprocal_tab = qoa_scalefactor_tab.map(s => Math.floor(((1 << 16) + s - 1) / s));\n\n/* The quant_tab provides an index into the dequant_tab for residuals in the\nrange of -8 .. 8. It maps this range to just 3bits and becommes less accurate at \nthe higher end. Note that the residual zero is identical to the lowest positive \nvalue. This is mostly fine, since the qoa_div() function always rounds away \nfrom zero. */\n\nconst qoa_quant_tab = [\n// -8..-1\n7, 7, 7, 5, 5, 3, 3, 1,\n// 0\n0,\n//  1.. 8\n0, 2, 2, 4, 4, 6, 6, 6];\n\n/* qoa_div() implements a rounding division, but avoids rounding to zero for \nsmall numbers. E.g. 0.1 will be rounded to 1. Note that 0 itself still \nreturns as 0, which is handled in the qoa_quant_tab[].\nqoa_div() takes an index into the .16 fixed point qoa_reciprocal_tab as an\nargument, so it can do the division with a cheaper integer multiplication. */\n\nfunction qoa_div(v, scalefactor) {\n  const reciprocal = qoa_reciprocal_tab[scalefactor];\n  let n = v * reciprocal + (1 << 15) >> 16;\n  n = n + ((v > 0) - (v < 0)) - ((n > 0) - (n < 0)); /* round away from 0 */\n  return n;\n}\nfunction qoa_encode_frame(stream, audio, lmses, sample_offset, frame_len) {\n  const channels = audio.channels;\n  const sampleRate = audio.sampleRate;\n  const channelData = audio.channelData;\n  const samples = audio.samples;\n  const slices = Math.floor((frame_len + QOA_SLICE_LEN - 1) / QOA_SLICE_LEN);\n  const frame_size = QOA_FRAME_SIZE(channels, slices);\n\n  // Frame header\n  stream.write(channels, 8);\n  stream.write(sampleRate, 24);\n  stream.write(frame_len, 16); // frame samples\n  stream.write(frame_size, 16);\n\n  // write current LMS weights and history state\n  for (let c = 0; c < channels; c++) {\n    const lms = lmses[c];\n\n    /* If the weights have grown too large, reset them to 0. This may happen\n    with certain high-frequency sounds. This is a last resort and will \n    introduce quite a bit of noise, but should at least prevent pops/clicks */\n    const weights_sum = lms.weights[0] * lms.weights[0] + lms.weights[1] * lms.weights[1] + lms.weights[2] * lms.weights[2] + lms.weights[3] * lms.weights[3];\n    if (weights_sum > 0x2fffffff) {\n      lms.weights[0] = 0;\n      lms.weights[1] = 0;\n      lms.weights[2] = 0;\n      lms.weights[3] = 0;\n    }\n    for (let i = 0; i < QOA_LMS_LEN; i++) {\n      stream.write(lms.history[i], 16);\n    }\n    for (let i = 0; i < QOA_LMS_LEN; i++) {\n      stream.write(lms.weights[i], 16);\n    }\n  }\n\n  /* We encode all samples with the channels interleaved on a slice level.\n  E.g. for stereo: (ch-0, slice 0), (ch 1, slice 0), (ch 0, slice 1), ...*/\n  for (let sample_index = 0; sample_index < frame_len; sample_index += QOA_SLICE_LEN) {\n    for (let c = 0; c < channels; c++) {\n      const slice_len = qoa_clamp(QOA_SLICE_LEN, 0, frame_len - sample_index);\n      const slice_start = sample_index;\n\n      /* Brute for search for the best scalefactor. Just go through all\n      16 scalefactors, encode all samples for the current slice and \n      meassure the total squared error. */\n      let best_error = Number.MAX_SAFE_INTEGER;\n      let best_slice;\n      let best_slice_scalefactor;\n      let best_lms;\n      const sampleData = channelData[c];\n      for (let scalefactor = 0; scalefactor < 16; scalefactor++) {\n        /* We have to reset the LMS state to the last known good one\n        before trying each scalefactor, as each pass updates the LMS\n        state when encoding. */\n        let lms = LMS(lmses[c].history, lmses[c].weights);\n        const table = qoa_dequant_tab[scalefactor];\n\n        // an array of slice data\n        let slice = [];\n        let current_error = 0;\n        let idx = slice_start + sample_offset;\n        for (let i = 0; i < slice_len; i++) {\n          let sample = sampleData[idx++];\n\n          // turn into 16 bit signed integer\n          sample = Math.floor(Math.fround(sample < 0 ? sample * 32768 : sample * 32767));\n          sample = qoa_clamp(sample, -32768, 32767);\n          let predicted = qoa_lms_predict(lms.weights, lms.history);\n          let residual = sample - predicted;\n          let scaled = qoa_div(residual, scalefactor);\n          let clamped = qoa_clamp(scaled, -8, 8);\n          let quantized = qoa_quant_tab[clamped + 8];\n          let dequantized = table[quantized];\n          let reconstructed = qoa_clamp(predicted + dequantized, -32768, 32767);\n          let error = sample - reconstructed;\n          current_error += error * error;\n          if (current_error > best_error) {\n            break;\n          }\n          qoa_lms_update(lms.weights, lms.history, reconstructed, dequantized);\n          slice.push(quantized);\n        }\n        if (current_error < best_error) {\n          best_error = current_error;\n          best_slice = slice;\n          best_slice_scalefactor = scalefactor;\n          best_lms = lms;\n        }\n      }\n      lmses[c] = best_lms;\n      // first, write the 4bit scalefactor\n      stream.write(best_slice_scalefactor, 4);\n      // now write each 3bit datum in the slice\n      for (let i = 0; i < QOA_SLICE_LEN; i++) {\n        // the last frame of a file might be smaller than QOA_SLICE_LEN\n        const v = i < best_slice.length ? best_slice[i] : 0;\n        stream.write(v, 3);\n      }\n    }\n  }\n}\nexport default function encode({\n  channelData,\n  sampleRate = 44100\n} = {}) {\n  const channels = channelData.length;\n  const samples = channels >= 1 ? channelData[0].length : 0;\n  const audio = {\n    samples,\n    channels,\n    channelData,\n    sampleRate\n  };\n  const num_frames = (samples + QOA_FRAME_LEN - 1) / QOA_FRAME_LEN;\n  const num_slices = (samples + QOA_SLICE_LEN - 1) / QOA_SLICE_LEN;\n  const encoded_size = 8 /* 8 byte file header */ + num_frames * 8 /* 8 byte frame headers */ + num_frames * QOA_LMS_LEN * 4 * audio.channels /* 4 * 4 bytes lms state per channel */ + num_slices * 8 * audio.channels; /* 8 byte slices */\n\n  const lmses = [];\n  for (let c = 0; c < audio.channels; c++) {\n    const lms = LMS();\n    lms.weights[0] = 0;\n    lms.weights[1] = 0;\n    lms.weights[2] = -(1 << 13);\n    lms.weights[3] = 1 << 14;\n    lmses.push(lms);\n  }\n\n  // write header\n  const stream = new BitOutputStream(encoded_size);\n  stream.write(QOA_MAGIC, 32);\n  stream.write(samples, 32);\n  let frame_len = QOA_FRAME_LEN;\n  for (let sample_index = 0; sample_index < samples; sample_index += frame_len) {\n    frame_len = qoa_clamp(QOA_FRAME_LEN, 0, samples - sample_index);\n    qoa_encode_frame(stream, audio, lmses, sample_index, frame_len);\n  }\n  return stream.bytes();\n}","map":{"version":3,"names":["BitOutputStream","qoa_lms_predict","qoa_lms_update","qoa_clamp","qoa_dequant_tab","qoa_scalefactor_tab","LMS","QOA_SLICE_LEN","QOA_FRAME_LEN","QOA_MAGIC","QOA_LMS_LEN","QOA_FRAME_SIZE","qoa_reciprocal_tab","map","s","Math","floor","qoa_quant_tab","qoa_div","v","scalefactor","reciprocal","n","qoa_encode_frame","stream","audio","lmses","sample_offset","frame_len","channels","sampleRate","channelData","samples","slices","frame_size","write","c","lms","weights_sum","weights","i","history","sample_index","slice_len","slice_start","best_error","Number","MAX_SAFE_INTEGER","best_slice","best_slice_scalefactor","best_lms","sampleData","table","slice","current_error","idx","sample","fround","predicted","residual","scaled","clamped","quantized","dequantized","reconstructed","error","push","length","encode","num_frames","num_slices","encoded_size","bytes"],"sources":["C:/Users/vanitas/node_modules/qoa-format/encode.js"],"sourcesContent":["import { BitOutputStream } from \"@thi.ng/bitstream\";\nimport {\n  qoa_lms_predict,\n  qoa_lms_update,\n  qoa_clamp,\n  qoa_dequant_tab,\n  qoa_scalefactor_tab,\n  LMS,\n  QOA_SLICE_LEN,\n  QOA_FRAME_LEN,\n  QOA_MAGIC,\n  QOA_LMS_LEN,\n  QOA_FRAME_SIZE,\n} from \"./lib/common.js\";\n\n/* The reciprocal_tab maps each of the 16 scalefactors to their rounded \nreciprocals 1/scalefactor. This allows us to calculate the scaled residuals in \nthe encoder with just one multiplication instead of an expensive division. We \ndo this in .16 fixed point with integers, instead of floats.\n\nThe reciprocal_tab is computed as:\nreciprocal_tab[s] <- ((1<<16) + scalefactor_tab[s] - 1) / scalefactor_tab[s] */\n\nconst qoa_reciprocal_tab = qoa_scalefactor_tab.map((s) =>\n  Math.floor(((1 << 16) + s - 1) / s)\n);\n\n/* The quant_tab provides an index into the dequant_tab for residuals in the\nrange of -8 .. 8. It maps this range to just 3bits and becommes less accurate at \nthe higher end. Note that the residual zero is identical to the lowest positive \nvalue. This is mostly fine, since the qoa_div() function always rounds away \nfrom zero. */\n\nconst qoa_quant_tab = [\n  // -8..-1\n  7, 7, 7, 5, 5, 3, 3, 1,\n  // 0\n  0,\n  //  1.. 8\n  0, 2, 2, 4, 4, 6, 6, 6,\n];\n\n/* qoa_div() implements a rounding division, but avoids rounding to zero for \nsmall numbers. E.g. 0.1 will be rounded to 1. Note that 0 itself still \nreturns as 0, which is handled in the qoa_quant_tab[].\nqoa_div() takes an index into the .16 fixed point qoa_reciprocal_tab as an\nargument, so it can do the division with a cheaper integer multiplication. */\n\nfunction qoa_div(v, scalefactor) {\n  const reciprocal = qoa_reciprocal_tab[scalefactor];\n  let n = (v * reciprocal + (1 << 15)) >> 16;\n  n = n + ((v > 0) - (v < 0)) - ((n > 0) - (n < 0)); /* round away from 0 */\n  return n;\n}\n\nfunction qoa_encode_frame(stream, audio, lmses, sample_offset, frame_len) {\n  const channels = audio.channels;\n  const sampleRate = audio.sampleRate;\n  const channelData = audio.channelData;\n  const samples = audio.samples;\n\n  const slices = Math.floor((frame_len + QOA_SLICE_LEN - 1) / QOA_SLICE_LEN);\n  const frame_size = QOA_FRAME_SIZE(channels, slices);\n\n  // Frame header\n  stream.write(channels, 8);\n  stream.write(sampleRate, 24);\n  stream.write(frame_len, 16); // frame samples\n  stream.write(frame_size, 16);\n\n  // write current LMS weights and history state\n  for (let c = 0; c < channels; c++) {\n    const lms = lmses[c];\n\n    /* If the weights have grown too large, reset them to 0. This may happen\n\t\twith certain high-frequency sounds. This is a last resort and will \n\t\tintroduce quite a bit of noise, but should at least prevent pops/clicks */\n    const weights_sum =\n      lms.weights[0] * lms.weights[0] +\n      lms.weights[1] * lms.weights[1] +\n      lms.weights[2] * lms.weights[2] +\n      lms.weights[3] * lms.weights[3];\n    if (weights_sum > 0x2fffffff) {\n      lms.weights[0] = 0;\n      lms.weights[1] = 0;\n      lms.weights[2] = 0;\n      lms.weights[3] = 0;\n    }\n\n    for (let i = 0; i < QOA_LMS_LEN; i++) {\n      stream.write(lms.history[i], 16);\n    }\n    for (let i = 0; i < QOA_LMS_LEN; i++) {\n      stream.write(lms.weights[i], 16);\n    }\n  }\n\n  /* We encode all samples with the channels interleaved on a slice level.\n\tE.g. for stereo: (ch-0, slice 0), (ch 1, slice 0), (ch 0, slice 1), ...*/\n  for (\n    let sample_index = 0;\n    sample_index < frame_len;\n    sample_index += QOA_SLICE_LEN\n  ) {\n    for (let c = 0; c < channels; c++) {\n      const slice_len = qoa_clamp(QOA_SLICE_LEN, 0, frame_len - sample_index);\n      const slice_start = sample_index;\n\n      /* Brute for search for the best scalefactor. Just go through all\n\t\t\t16 scalefactors, encode all samples for the current slice and \n\t\t\tmeassure the total squared error. */\n      let best_error = Number.MAX_SAFE_INTEGER;\n      let best_slice;\n      let best_slice_scalefactor;\n      let best_lms;\n      const sampleData = channelData[c];\n\n      for (let scalefactor = 0; scalefactor < 16; scalefactor++) {\n        /* We have to reset the LMS state to the last known good one\n\t\t\t\tbefore trying each scalefactor, as each pass updates the LMS\n\t\t\t\tstate when encoding. */\n        let lms = LMS(lmses[c].history, lmses[c].weights);\n\n        const table = qoa_dequant_tab[scalefactor];\n\n        // an array of slice data\n        let slice = [];\n        let current_error = 0;\n        let idx = slice_start + sample_offset;\n\n        for (let i = 0; i < slice_len; i++) {\n          let sample = sampleData[idx++];\n\n          // turn into 16 bit signed integer\n          sample = Math.floor(\n            Math.fround(sample < 0 ? sample * 32768 : sample * 32767)\n          );\n          sample = qoa_clamp(sample, -32768, 32767);\n\n          let predicted = qoa_lms_predict(lms.weights, lms.history);\n          let residual = sample - predicted;\n          let scaled = qoa_div(residual, scalefactor);\n          let clamped = qoa_clamp(scaled, -8, 8);\n          let quantized = qoa_quant_tab[clamped + 8];\n          let dequantized = table[quantized];\n          let reconstructed = qoa_clamp(predicted + dequantized, -32768, 32767);\n          let error = sample - reconstructed;\n          current_error += error * error;\n          if (current_error > best_error) {\n            break;\n          }\n\n          qoa_lms_update(lms.weights, lms.history, reconstructed, dequantized);\n          slice.push(quantized);\n        }\n\n        if (current_error < best_error) {\n          best_error = current_error;\n          best_slice = slice;\n          best_slice_scalefactor = scalefactor;\n          best_lms = lms;\n        }\n      }\n\n      lmses[c] = best_lms;\n      // first, write the 4bit scalefactor\n      stream.write(best_slice_scalefactor, 4);\n      // now write each 3bit datum in the slice\n      for (let i = 0; i < QOA_SLICE_LEN; i++) {\n        // the last frame of a file might be smaller than QOA_SLICE_LEN\n        const v = i < best_slice.length ? best_slice[i] : 0;\n        stream.write(v, 3);\n      }\n    }\n  }\n}\n\nexport default function encode({ channelData, sampleRate = 44100 } = {}) {\n  const channels = channelData.length;\n  const samples = channels >= 1 ? channelData[0].length : 0;\n  const audio = {\n    samples,\n    channels,\n    channelData,\n    sampleRate,\n  };\n\n  const num_frames = (samples + QOA_FRAME_LEN - 1) / QOA_FRAME_LEN;\n  const num_slices = (samples + QOA_SLICE_LEN - 1) / QOA_SLICE_LEN;\n  const encoded_size =\n    8 /* 8 byte file header */ +\n    num_frames * 8 /* 8 byte frame headers */ +\n    num_frames *\n      QOA_LMS_LEN *\n      4 *\n      audio.channels /* 4 * 4 bytes lms state per channel */ +\n    num_slices * 8 * audio.channels; /* 8 byte slices */\n\n  const lmses = [];\n  for (let c = 0; c < audio.channels; c++) {\n    const lms = LMS();\n    lms.weights[0] = 0;\n    lms.weights[1] = 0;\n    lms.weights[2] = -(1 << 13);\n    lms.weights[3] = 1 << 14;\n    lmses.push(lms);\n  }\n\n  // write header\n  const stream = new BitOutputStream(encoded_size);\n  stream.write(QOA_MAGIC, 32);\n  stream.write(samples, 32);\n\n  let frame_len = QOA_FRAME_LEN;\n  for (\n    let sample_index = 0;\n    sample_index < samples;\n    sample_index += frame_len\n  ) {\n    frame_len = qoa_clamp(QOA_FRAME_LEN, 0, samples - sample_index);\n    qoa_encode_frame(stream, audio, lmses, sample_index, frame_len);\n  }\n\n  return stream.bytes();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}