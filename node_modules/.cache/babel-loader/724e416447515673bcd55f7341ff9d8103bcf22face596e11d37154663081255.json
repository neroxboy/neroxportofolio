{"ast":null,"code":"/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { frameStore } from \"../../globals.js\";\nimport { BitReader, reverse } from \"../../utilities.js\";\nimport { data, codec, blocksize0, blocksize1, codecFrames, segments, vorbis, logWarning, parseOggPage, enable, getHeaderFromUint8Array } from \"../../constants.js\";\nimport Parser from \"../Parser.js\";\nimport VorbisFrame from \"./VorbisFrame.js\";\nimport VorbisHeader from \"./VorbisHeader.js\";\nexport default class VorbisParser extends Parser {\n  constructor(codecParser, headerCache, onCodec) {\n    super(codecParser, headerCache);\n    this.Frame = VorbisFrame;\n    onCodec(this[codec]);\n    this._identificationHeader = null;\n    this._setupComplete = false;\n    this._prevBlockSize = null;\n  }\n  get [codec]() {\n    return vorbis;\n  }\n  [parseOggPage](oggPage) {\n    oggPage[codecFrames] = [];\n    for (const oggPageSegment of frameStore.get(oggPage)[segments]) {\n      if (oggPageSegment[0] === 1) {\n        // Identification header\n\n        this._headerCache[enable]();\n        this._identificationHeader = oggPage[data];\n        this._setupComplete = false;\n      } else if (oggPageSegment[0] === 3) {\n        // comment header\n\n        this._vorbisComments = oggPageSegment;\n      } else if (oggPageSegment[0] === 5) {\n        // setup header\n\n        this._vorbisSetup = oggPageSegment;\n        this._mode = this._parseSetupHeader(oggPageSegment);\n        this._setupComplete = true;\n      } else if (this._setupComplete) {\n        const header = VorbisHeader[getHeaderFromUint8Array](this._identificationHeader, this._headerCache, this._vorbisComments, this._vorbisSetup);\n        if (header) {\n          oggPage[codecFrames].push(new VorbisFrame(oggPageSegment, header, this._getSamples(oggPageSegment, header)));\n        } else {\n          this._codecParser[logError](\"Failed to parse Ogg Vorbis Header\", \"Not a valid Ogg Vorbis file\");\n        }\n      }\n    }\n    return oggPage;\n  }\n  _getSamples(segment, header) {\n    const blockFlag = this._mode.blockFlags[segment[0] >> 1 & this._mode.mask];\n    const currentBlockSize = blockFlag ? header[blocksize1] : header[blocksize0];\n\n    // data is not returned on the first frame, but is used to prime the decoder\n    // https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-590004\n    const samplesValue = this._prevBlockSize === null ? 0 : (this._prevBlockSize + currentBlockSize) / 4;\n    this._prevBlockSize = currentBlockSize;\n    return samplesValue;\n  }\n\n  // https://gitlab.xiph.org/xiph/liboggz/-/blob/master/src/liboggz/oggz_auto.c#L911\n  // https://github.com/FFmpeg/FFmpeg/blob/master/libavcodec/vorbis_parser.c\n  /*\n   * This is the format of the mode data at the end of the packet for all\n   * Vorbis Version 1 :\n   *\n   * [ 6:number_of_modes ]\n   * [ 1:size | 16:window_type(0) | 16:transform_type(0) | 8:mapping ]\n   * [ 1:size | 16:window_type(0) | 16:transform_type(0) | 8:mapping ]\n   * [ 1:size | 16:window_type(0) | 16:transform_type(0) | 8:mapping ]\n   * [ 1:framing(1) ]\n   *\n   * e.g.:\n   *\n   * MsB         LsB\n   *              <-\n   * 0 0 0 0 0 1 0 0\n   * 0 0 1 0 0 0 0 0\n   * 0 0 1 0 0 0 0 0\n   * 0 0 1|0 0 0 0 0\n   * 0 0 0 0|0|0 0 0\n   * 0 0 0 0 0 0 0 0\n   * 0 0 0 0|0 0 0 0\n   * 0 0 0 0 0 0 0 0\n   * 0 0 0 0|0 0 0 0\n   * 0 0 0|1|0 0 0 0 |\n   * 0 0 0 0 0 0 0 0 V\n   * 0 0 0|0 0 0 0 0\n   * 0 0 0 0 0 0 0 0\n   * 0 0|1 0 0 0 0 0\n   *\n   * The simplest way to approach this is to start at the end\n   * and read backwards to determine the mode configuration.\n   *\n   * liboggz and ffmpeg both use this method.\n   */\n  _parseSetupHeader(setup) {\n    const bitReader = new BitReader(setup);\n    const mode = {\n      count: 0,\n      blockFlags: []\n    };\n\n    // sync with the framing bit\n    while ((bitReader.read(1) & 0x01) !== 1) {}\n    let modeBits;\n    // search in reverse to parse out the mode entries\n    // limit mode count to 63 so previous block flag will be in first packet byte\n    while (mode.count < 64 && bitReader.position > 0) {\n      reverse(bitReader.read(8)); // read mapping\n\n      // 16 bits transform type, 16 bits window type, all values must be zero\n      let currentByte = 0;\n      while (bitReader.read(8) === 0x00 && currentByte++ < 3) {} // a non-zero value may indicate the end of the mode entries, or invalid data\n\n      if (currentByte === 4) {\n        // transform type and window type were all zeros\n        modeBits = bitReader.read(7); // modeBits may need to be used in the next iteration if this is the last mode entry\n        mode.blockFlags.unshift(modeBits & 0x01); // read and store mode number -> block flag\n        bitReader.position += 6; // go back 6 bits so next iteration starts right after the block flag\n        mode.count++;\n      } else {\n        // transform type and window type were not all zeros\n        // check for mode count using previous iteration modeBits\n        if (((reverse(modeBits) & 0b01111110) >> 1) + 1 !== mode.count) {\n          this._codecParser[logWarning](\"vorbis derived mode count did not match actual mode count\");\n        }\n        break;\n      }\n    }\n\n    // xxxxxxxa packet type\n    // xxxxxxbx mode count (number of mode count bits)\n    // xxxxxcxx previous window flag\n    // xxxxdxxx next window flag\n    mode.mask = (1 << Math.log2(mode.count)) - 1;\n    return mode;\n  }\n}","map":{"version":3,"names":["frameStore","BitReader","reverse","data","codec","blocksize0","blocksize1","codecFrames","segments","vorbis","logWarning","parseOggPage","enable","getHeaderFromUint8Array","Parser","VorbisFrame","VorbisHeader","VorbisParser","constructor","codecParser","headerCache","onCodec","Frame","_identificationHeader","_setupComplete","_prevBlockSize","oggPage","oggPageSegment","get","_headerCache","_vorbisComments","_vorbisSetup","_mode","_parseSetupHeader","header","push","_getSamples","_codecParser","logError","segment","blockFlag","blockFlags","mask","currentBlockSize","samplesValue","setup","bitReader","mode","count","read","modeBits","position","currentByte","unshift","Math","log2"],"sources":["C:/Users/vanitas/node_modules/codec-parser/src/codecs/vorbis/VorbisParser.js"],"sourcesContent":["/* Copyright 2020-2023 Ethan Halsall\n    \n    This file is part of codec-parser.\n    \n    codec-parser is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    codec-parser is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport { frameStore } from \"../../globals.js\";\nimport { BitReader, reverse } from \"../../utilities.js\";\nimport {\n  data,\n  codec,\n  blocksize0,\n  blocksize1,\n  codecFrames,\n  segments,\n  vorbis,\n  logWarning,\n  parseOggPage,\n  enable,\n  getHeaderFromUint8Array,\n} from \"../../constants.js\";\n\nimport Parser from \"../Parser.js\";\nimport VorbisFrame from \"./VorbisFrame.js\";\nimport VorbisHeader from \"./VorbisHeader.js\";\n\nexport default class VorbisParser extends Parser {\n  constructor(codecParser, headerCache, onCodec) {\n    super(codecParser, headerCache);\n    this.Frame = VorbisFrame;\n\n    onCodec(this[codec]);\n\n    this._identificationHeader = null;\n    this._setupComplete = false;\n\n    this._prevBlockSize = null;\n  }\n\n  get [codec]() {\n    return vorbis;\n  }\n\n  [parseOggPage](oggPage) {\n    oggPage[codecFrames] = [];\n\n    for (const oggPageSegment of frameStore.get(oggPage)[segments]) {\n      if (oggPageSegment[0] === 1) {\n        // Identification header\n\n        this._headerCache[enable]();\n        this._identificationHeader = oggPage[data];\n        this._setupComplete = false;\n      } else if (oggPageSegment[0] === 3) {\n        // comment header\n\n        this._vorbisComments = oggPageSegment;\n      } else if (oggPageSegment[0] === 5) {\n        // setup header\n\n        this._vorbisSetup = oggPageSegment;\n        this._mode = this._parseSetupHeader(oggPageSegment);\n        this._setupComplete = true;\n      } else if (this._setupComplete) {\n        const header = VorbisHeader[getHeaderFromUint8Array](\n          this._identificationHeader,\n          this._headerCache,\n          this._vorbisComments,\n          this._vorbisSetup,\n        );\n\n        if (header) {\n          oggPage[codecFrames].push(\n            new VorbisFrame(\n              oggPageSegment,\n              header,\n              this._getSamples(oggPageSegment, header),\n            ),\n          );\n        } else {\n          this._codecParser[logError](\n            \"Failed to parse Ogg Vorbis Header\",\n            \"Not a valid Ogg Vorbis file\",\n          );\n        }\n      }\n    }\n\n    return oggPage;\n  }\n\n  _getSamples(segment, header) {\n    const blockFlag =\n      this._mode.blockFlags[(segment[0] >> 1) & this._mode.mask];\n\n    const currentBlockSize = blockFlag\n      ? header[blocksize1]\n      : header[blocksize0];\n\n    // data is not returned on the first frame, but is used to prime the decoder\n    // https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-590004\n    const samplesValue =\n      this._prevBlockSize === null\n        ? 0\n        : (this._prevBlockSize + currentBlockSize) / 4;\n\n    this._prevBlockSize = currentBlockSize;\n\n    return samplesValue;\n  }\n\n  // https://gitlab.xiph.org/xiph/liboggz/-/blob/master/src/liboggz/oggz_auto.c#L911\n  // https://github.com/FFmpeg/FFmpeg/blob/master/libavcodec/vorbis_parser.c\n  /*\n   * This is the format of the mode data at the end of the packet for all\n   * Vorbis Version 1 :\n   *\n   * [ 6:number_of_modes ]\n   * [ 1:size | 16:window_type(0) | 16:transform_type(0) | 8:mapping ]\n   * [ 1:size | 16:window_type(0) | 16:transform_type(0) | 8:mapping ]\n   * [ 1:size | 16:window_type(0) | 16:transform_type(0) | 8:mapping ]\n   * [ 1:framing(1) ]\n   *\n   * e.g.:\n   *\n   * MsB         LsB\n   *              <-\n   * 0 0 0 0 0 1 0 0\n   * 0 0 1 0 0 0 0 0\n   * 0 0 1 0 0 0 0 0\n   * 0 0 1|0 0 0 0 0\n   * 0 0 0 0|0|0 0 0\n   * 0 0 0 0 0 0 0 0\n   * 0 0 0 0|0 0 0 0\n   * 0 0 0 0 0 0 0 0\n   * 0 0 0 0|0 0 0 0\n   * 0 0 0|1|0 0 0 0 |\n   * 0 0 0 0 0 0 0 0 V\n   * 0 0 0|0 0 0 0 0\n   * 0 0 0 0 0 0 0 0\n   * 0 0|1 0 0 0 0 0\n   *\n   * The simplest way to approach this is to start at the end\n   * and read backwards to determine the mode configuration.\n   *\n   * liboggz and ffmpeg both use this method.\n   */\n  _parseSetupHeader(setup) {\n    const bitReader = new BitReader(setup);\n    const mode = {\n      count: 0,\n      blockFlags: [],\n    };\n\n    // sync with the framing bit\n    while ((bitReader.read(1) & 0x01) !== 1) {}\n\n    let modeBits;\n    // search in reverse to parse out the mode entries\n    // limit mode count to 63 so previous block flag will be in first packet byte\n    while (mode.count < 64 && bitReader.position > 0) {\n      reverse(bitReader.read(8)); // read mapping\n\n      // 16 bits transform type, 16 bits window type, all values must be zero\n      let currentByte = 0;\n      while (bitReader.read(8) === 0x00 && currentByte++ < 3) {} // a non-zero value may indicate the end of the mode entries, or invalid data\n\n      if (currentByte === 4) {\n        // transform type and window type were all zeros\n        modeBits = bitReader.read(7); // modeBits may need to be used in the next iteration if this is the last mode entry\n        mode.blockFlags.unshift(modeBits & 0x01); // read and store mode number -> block flag\n        bitReader.position += 6; // go back 6 bits so next iteration starts right after the block flag\n        mode.count++;\n      } else {\n        // transform type and window type were not all zeros\n        // check for mode count using previous iteration modeBits\n        if (((reverse(modeBits) & 0b01111110) >> 1) + 1 !== mode.count) {\n          this._codecParser[logWarning](\n            \"vorbis derived mode count did not match actual mode count\",\n          );\n        }\n\n        break;\n      }\n    }\n\n    // xxxxxxxa packet type\n    // xxxxxxbx mode count (number of mode count bits)\n    // xxxxxcxx previous window flag\n    // xxxxdxxx next window flag\n    mode.mask = (1 << Math.log2(mode.count)) - 1;\n\n    return mode;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}