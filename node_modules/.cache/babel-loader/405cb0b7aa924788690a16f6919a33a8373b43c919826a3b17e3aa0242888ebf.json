{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decryptPollVote = exports.getChatId = exports.shouldIncrementChatUnread = exports.isRealMessage = exports.cleanMessage = void 0;\nconst WAProto_1 = require(\"../../WAProto\");\nconst Types_1 = require(\"../Types\");\nconst messages_1 = require(\"../Utils/messages\");\nconst WABinary_1 = require(\"../WABinary\");\nconst crypto_1 = require(\"./crypto\");\nconst generics_1 = require(\"./generics\");\nconst history_1 = require(\"./history\");\nconst REAL_MSG_STUB_TYPES = new Set([Types_1.WAMessageStubType.CALL_MISSED_GROUP_VIDEO, Types_1.WAMessageStubType.CALL_MISSED_GROUP_VOICE, Types_1.WAMessageStubType.CALL_MISSED_VIDEO, Types_1.WAMessageStubType.CALL_MISSED_VOICE]);\nconst REAL_MSG_REQ_ME_STUB_TYPES = new Set([Types_1.WAMessageStubType.GROUP_PARTICIPANT_ADD]);\n/** Cleans a received message to further processing */\nconst cleanMessage = (message, meId) => {\n  // ensure remoteJid and participant doesn't have device or agent in it\n  message.key.remoteJid = (0, WABinary_1.jidNormalizedUser)(message.key.remoteJid);\n  message.key.participant = message.key.participant ? (0, WABinary_1.jidNormalizedUser)(message.key.participant) : undefined;\n  const content = (0, messages_1.normalizeMessageContent)(message.message);\n  // if the message has a reaction, ensure fromMe & remoteJid are from our perspective\n  if (content === null || content === void 0 ? void 0 : content.reactionMessage) {\n    normaliseKey(content.reactionMessage.key);\n  }\n  if (content === null || content === void 0 ? void 0 : content.pollUpdateMessage) {\n    normaliseKey(content.pollUpdateMessage.pollCreationMessageKey);\n  }\n  function normaliseKey(msgKey) {\n    // if the reaction is from another user\n    // we've to correctly map the key to this user's perspective\n    if (!message.key.fromMe) {\n      // if the sender believed the message being reacted to is not from them\n      // we've to correct the key to be from them, or some other participant\n      msgKey.fromMe = !msgKey.fromMe ? (0, WABinary_1.areJidsSameUser)(msgKey.participant || msgKey.remoteJid, meId)\n      // if the message being reacted to, was from them\n      // fromMe automatically becomes false\n      : false;\n      // set the remoteJid to being the same as the chat the message came from\n      msgKey.remoteJid = message.key.remoteJid;\n      // set participant of the message\n      msgKey.participant = msgKey.participant || message.key.participant;\n    }\n  }\n};\nexports.cleanMessage = cleanMessage;\nconst isRealMessage = (message, meId) => {\n  var _a;\n  const normalizedContent = (0, messages_1.normalizeMessageContent)(message.message);\n  const hasSomeContent = !!(0, messages_1.getContentType)(normalizedContent);\n  return (!!normalizedContent || REAL_MSG_STUB_TYPES.has(message.messageStubType) || REAL_MSG_REQ_ME_STUB_TYPES.has(message.messageStubType) && ((_a = message.messageStubParameters) === null || _a === void 0 ? void 0 : _a.some(p => (0, WABinary_1.areJidsSameUser)(meId, p)))) && hasSomeContent && !(normalizedContent === null || normalizedContent === void 0 ? void 0 : normalizedContent.protocolMessage) && !(normalizedContent === null || normalizedContent === void 0 ? void 0 : normalizedContent.reactionMessage) && !(normalizedContent === null || normalizedContent === void 0 ? void 0 : normalizedContent.pollUpdateMessage);\n};\nexports.isRealMessage = isRealMessage;\nconst shouldIncrementChatUnread = message => !message.key.fromMe && !message.messageStubType;\nexports.shouldIncrementChatUnread = shouldIncrementChatUnread;\n/**\n * Get the ID of the chat from the given key.\n * Typically -- that'll be the remoteJid, but for broadcasts, it'll be the participant\n */\nconst getChatId = ({\n  remoteJid,\n  participant,\n  fromMe\n}) => {\n  if ((0, WABinary_1.isJidBroadcast)(remoteJid) && !(0, WABinary_1.isJidStatusBroadcast)(remoteJid) && !fromMe) {\n    return participant;\n  }\n  return remoteJid;\n};\nexports.getChatId = getChatId;\n/**\n * Decrypt a poll vote\n * @param vote encrypted vote\n * @param ctx additional info about the poll required for decryption\n * @returns list of SHA256 options\n */\nfunction decryptPollVote({\n  encPayload,\n  encIv\n}, {\n  pollCreatorJid,\n  pollMsgId,\n  pollEncKey,\n  voterJid\n}) {\n  const sign = Buffer.concat([toBinary(pollMsgId), toBinary(pollCreatorJid), toBinary(voterJid), toBinary('Poll Vote'), new Uint8Array([1])]);\n  const key0 = (0, crypto_1.hmacSign)(pollEncKey, new Uint8Array(32), 'sha256');\n  const decKey = (0, crypto_1.hmacSign)(sign, key0, 'sha256');\n  const aad = toBinary(`${pollMsgId}\\u0000${voterJid}`);\n  const decrypted = (0, crypto_1.aesDecryptGCM)(encPayload, decKey, encIv, aad);\n  return WAProto_1.proto.Message.PollVoteMessage.decode(decrypted);\n  function toBinary(txt) {\n    return Buffer.from(txt);\n  }\n}\nexports.decryptPollVote = decryptPollVote;\nconst processMessage = async (message, {\n  shouldProcessHistoryMsg,\n  placeholderResendCache,\n  ev,\n  creds,\n  keyStore,\n  logger,\n  options,\n  getMessage\n}) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n  const meId = creds.me.id;\n  const {\n    accountSettings\n  } = creds;\n  const chat = {\n    id: (0, WABinary_1.jidNormalizedUser)((0, exports.getChatId)(message.key))\n  };\n  const isRealMsg = (0, exports.isRealMessage)(message, meId);\n  if (isRealMsg) {\n    chat.conversationTimestamp = (0, generics_1.toNumber)(message.messageTimestamp);\n    // only increment unread count if not CIPHERTEXT and from another person\n    if ((0, exports.shouldIncrementChatUnread)(message)) {\n      chat.unreadCount = (chat.unreadCount || 0) + 1;\n    }\n  }\n  const content = (0, messages_1.normalizeMessageContent)(message.message);\n  // unarchive chat if it's a real message, or someone reacted to our message\n  // and we've the unarchive chats setting on\n  if ((isRealMsg || ((_b = (_a = content === null || content === void 0 ? void 0 : content.reactionMessage) === null || _a === void 0 ? void 0 : _a.key) === null || _b === void 0 ? void 0 : _b.fromMe)) && (accountSettings === null || accountSettings === void 0 ? void 0 : accountSettings.unarchiveChats)) {\n    chat.archived = false;\n    chat.readOnly = false;\n  }\n  const protocolMsg = content === null || content === void 0 ? void 0 : content.protocolMessage;\n  if (protocolMsg) {\n    switch (protocolMsg.type) {\n      case WAProto_1.proto.Message.ProtocolMessage.Type.HISTORY_SYNC_NOTIFICATION:\n        const histNotification = protocolMsg.historySyncNotification;\n        const process = shouldProcessHistoryMsg;\n        const isLatest = !((_c = creds.processedHistoryMessages) === null || _c === void 0 ? void 0 : _c.length);\n        logger === null || logger === void 0 ? void 0 : logger.info({\n          histNotification,\n          process,\n          id: message.key.id,\n          isLatest\n        }, 'got history notification');\n        if (process) {\n          if (histNotification.syncType !== WAProto_1.proto.HistorySync.HistorySyncType.ON_DEMAND) {\n            ev.emit('creds.update', {\n              processedHistoryMessages: [...(creds.processedHistoryMessages || []), {\n                key: message.key,\n                messageTimestamp: message.messageTimestamp\n              }]\n            });\n          }\n          const data = await (0, history_1.downloadAndProcessHistorySyncNotification)(histNotification, options);\n          ev.emit('messaging-history.set', {\n            ...data,\n            isLatest: histNotification.syncType !== WAProto_1.proto.HistorySync.HistorySyncType.ON_DEMAND ? isLatest : undefined,\n            peerDataRequestSessionId: histNotification.peerDataRequestSessionId\n          });\n        }\n        break;\n      case WAProto_1.proto.Message.ProtocolMessage.Type.APP_STATE_SYNC_KEY_SHARE:\n        const keys = protocolMsg.appStateSyncKeyShare.keys;\n        if (keys === null || keys === void 0 ? void 0 : keys.length) {\n          let newAppStateSyncKeyId = '';\n          await keyStore.transaction(async () => {\n            const newKeys = [];\n            for (const {\n              keyData,\n              keyId\n            } of keys) {\n              const strKeyId = Buffer.from(keyId.keyId).toString('base64');\n              newKeys.push(strKeyId);\n              await keyStore.set({\n                'app-state-sync-key': {\n                  [strKeyId]: keyData\n                }\n              });\n              newAppStateSyncKeyId = strKeyId;\n            }\n            logger === null || logger === void 0 ? void 0 : logger.info({\n              newAppStateSyncKeyId,\n              newKeys\n            }, 'injecting new app state sync keys');\n          });\n          ev.emit('creds.update', {\n            myAppStateKeyId: newAppStateSyncKeyId\n          });\n        } else {\n          logger === null || logger === void 0 ? void 0 : logger.info({\n            protocolMsg\n          }, 'recv app state sync with 0 keys');\n        }\n        break;\n      case WAProto_1.proto.Message.ProtocolMessage.Type.REVOKE:\n        ev.emit('messages.update', [{\n          key: {\n            ...message.key,\n            id: protocolMsg.key.id\n          },\n          update: {\n            message: null,\n            messageStubType: Types_1.WAMessageStubType.REVOKE,\n            key: message.key\n          }\n        }]);\n        break;\n      case WAProto_1.proto.Message.ProtocolMessage.Type.EPHEMERAL_SETTING:\n        Object.assign(chat, {\n          ephemeralSettingTimestamp: (0, generics_1.toNumber)(message.messageTimestamp),\n          ephemeralExpiration: protocolMsg.ephemeralExpiration || null\n        });\n        break;\n      case WAProto_1.proto.Message.ProtocolMessage.Type.PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE:\n        const response = protocolMsg.peerDataOperationRequestResponseMessage;\n        if (response) {\n          placeholderResendCache === null || placeholderResendCache === void 0 ? void 0 : placeholderResendCache.del(response.stanzaId);\n          // TODO: IMPLEMENT HISTORY SYNC ETC (sticker uploads etc.).\n          const {\n            peerDataOperationResult\n          } = response;\n          for (const result of peerDataOperationResult) {\n            const {\n              placeholderMessageResendResponse: retryResponse\n            } = result;\n            if (retryResponse) {\n              const webMessageInfo = WAProto_1.proto.WebMessageInfo.decode(retryResponse.webMessageInfoBytes);\n              // wait till another upsert event is available, don't want it to be part of the PDO response message\n              setTimeout(() => {\n                ev.emit('messages.upsert', {\n                  messages: [webMessageInfo],\n                  type: 'notify',\n                  requestId: response.stanzaId\n                });\n              }, 500);\n            }\n          }\n        }\n        break;\n    }\n  } else if (content === null || content === void 0 ? void 0 : content.reactionMessage) {\n    const reaction = {\n      ...content.reactionMessage,\n      key: message.key\n    };\n    ev.emit('messages.reaction', [{\n      reaction,\n      key: (_d = content.reactionMessage) === null || _d === void 0 ? void 0 : _d.key\n    }]);\n  } else if (message.messageStubType) {\n    const jid = (_e = message.key) === null || _e === void 0 ? void 0 : _e.remoteJid;\n    //let actor = whatsappID (message.participant)\n    let participants;\n    const emitParticipantsUpdate = action => ev.emit('group-participants.update', {\n      id: jid,\n      author: message.participant,\n      participants,\n      action\n    });\n    const emitGroupUpdate = update => {\n      var _a;\n      ev.emit('groups.update', [{\n        id: jid,\n        ...update,\n        author: (_a = message.participant) !== null && _a !== void 0 ? _a : undefined\n      }]);\n    };\n    const emitGroupRequestJoin = (participant, action, method) => {\n      ev.emit('group.join-request', {\n        id: jid,\n        author: message.participant,\n        participant,\n        action,\n        method: method\n      });\n    };\n    const participantsIncludesMe = () => participants.find(jid => (0, WABinary_1.areJidsSameUser)(meId, jid));\n    switch (message.messageStubType) {\n      case Types_1.WAMessageStubType.GROUP_PARTICIPANT_CHANGE_NUMBER:\n        participants = message.messageStubParameters || [];\n        emitParticipantsUpdate('modify');\n        break;\n      case Types_1.WAMessageStubType.GROUP_PARTICIPANT_LEAVE:\n      case Types_1.WAMessageStubType.GROUP_PARTICIPANT_REMOVE:\n        participants = message.messageStubParameters || [];\n        emitParticipantsUpdate('remove');\n        // mark the chat read only if you left the group\n        if (participantsIncludesMe()) {\n          chat.readOnly = true;\n        }\n        break;\n      case Types_1.WAMessageStubType.GROUP_PARTICIPANT_ADD:\n      case Types_1.WAMessageStubType.GROUP_PARTICIPANT_INVITE:\n      case Types_1.WAMessageStubType.GROUP_PARTICIPANT_ADD_REQUEST_JOIN:\n        participants = message.messageStubParameters || [];\n        if (participantsIncludesMe()) {\n          chat.readOnly = false;\n        }\n        emitParticipantsUpdate('add');\n        break;\n      case Types_1.WAMessageStubType.GROUP_PARTICIPANT_DEMOTE:\n        participants = message.messageStubParameters || [];\n        emitParticipantsUpdate('demote');\n        break;\n      case Types_1.WAMessageStubType.GROUP_PARTICIPANT_PROMOTE:\n        participants = message.messageStubParameters || [];\n        emitParticipantsUpdate('promote');\n        break;\n      case Types_1.WAMessageStubType.GROUP_CHANGE_ANNOUNCE:\n        const announceValue = (_f = message.messageStubParameters) === null || _f === void 0 ? void 0 : _f[0];\n        emitGroupUpdate({\n          announce: announceValue === 'true' || announceValue === 'on'\n        });\n        break;\n      case Types_1.WAMessageStubType.GROUP_CHANGE_RESTRICT:\n        const restrictValue = (_g = message.messageStubParameters) === null || _g === void 0 ? void 0 : _g[0];\n        emitGroupUpdate({\n          restrict: restrictValue === 'true' || restrictValue === 'on'\n        });\n        break;\n      case Types_1.WAMessageStubType.GROUP_CHANGE_SUBJECT:\n        const name = (_h = message.messageStubParameters) === null || _h === void 0 ? void 0 : _h[0];\n        chat.name = name;\n        emitGroupUpdate({\n          subject: name\n        });\n        break;\n      case Types_1.WAMessageStubType.GROUP_CHANGE_DESCRIPTION:\n        const description = (_j = message.messageStubParameters) === null || _j === void 0 ? void 0 : _j[0];\n        chat.description = description;\n        emitGroupUpdate({\n          desc: description\n        });\n        break;\n      case Types_1.WAMessageStubType.GROUP_CHANGE_INVITE_LINK:\n        const code = (_k = message.messageStubParameters) === null || _k === void 0 ? void 0 : _k[0];\n        emitGroupUpdate({\n          inviteCode: code\n        });\n        break;\n      case Types_1.WAMessageStubType.GROUP_MEMBER_ADD_MODE:\n        const memberAddValue = (_l = message.messageStubParameters) === null || _l === void 0 ? void 0 : _l[0];\n        emitGroupUpdate({\n          memberAddMode: memberAddValue === 'all_member_add'\n        });\n        break;\n      case Types_1.WAMessageStubType.GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE:\n        const approvalMode = (_m = message.messageStubParameters) === null || _m === void 0 ? void 0 : _m[0];\n        emitGroupUpdate({\n          joinApprovalMode: approvalMode === 'on'\n        });\n        break;\n      case Types_1.WAMessageStubType.GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST_NON_ADMIN_ADD:\n        const participant = (_o = message.messageStubParameters) === null || _o === void 0 ? void 0 : _o[0];\n        const action = (_p = message.messageStubParameters) === null || _p === void 0 ? void 0 : _p[1];\n        const method = (_q = message.messageStubParameters) === null || _q === void 0 ? void 0 : _q[2];\n        emitGroupRequestJoin(participant, action, method);\n        break;\n    }\n  } else if (content === null || content === void 0 ? void 0 : content.pollUpdateMessage) {\n    const creationMsgKey = content.pollUpdateMessage.pollCreationMessageKey;\n    // we need to fetch the poll creation message to get the poll enc key\n    const pollMsg = await getMessage(creationMsgKey);\n    if (pollMsg) {\n      const meIdNormalised = (0, WABinary_1.jidNormalizedUser)(meId);\n      const pollCreatorJid = (0, generics_1.getKeyAuthor)(creationMsgKey, meIdNormalised);\n      const voterJid = (0, generics_1.getKeyAuthor)(message.key, meIdNormalised);\n      const pollEncKey = (_r = pollMsg.messageContextInfo) === null || _r === void 0 ? void 0 : _r.messageSecret;\n      try {\n        const voteMsg = decryptPollVote(content.pollUpdateMessage.vote, {\n          pollEncKey,\n          pollCreatorJid,\n          pollMsgId: creationMsgKey.id,\n          voterJid\n        });\n        ev.emit('messages.update', [{\n          key: creationMsgKey,\n          update: {\n            pollUpdates: [{\n              pollUpdateMessageKey: message.key,\n              vote: voteMsg,\n              senderTimestampMs: content.pollUpdateMessage.senderTimestampMs.toNumber()\n            }]\n          }\n        }]);\n      } catch (err) {\n        logger === null || logger === void 0 ? void 0 : logger.warn({\n          err,\n          creationMsgKey\n        }, 'failed to decrypt poll vote');\n      }\n    } else {\n      logger === null || logger === void 0 ? void 0 : logger.warn({\n        creationMsgKey\n      }, 'poll creation message not found, cannot decrypt update');\n    }\n  }\n  if (Object.keys(chat).length > 1) {\n    ev.emit('chats.update', [chat]);\n  }\n};\nexports.default = processMessage;","map":{"version":3,"names":["Object","defineProperty","exports","value","decryptPollVote","getChatId","shouldIncrementChatUnread","isRealMessage","cleanMessage","WAProto_1","require","Types_1","messages_1","WABinary_1","crypto_1","generics_1","history_1","REAL_MSG_STUB_TYPES","Set","WAMessageStubType","CALL_MISSED_GROUP_VIDEO","CALL_MISSED_GROUP_VOICE","CALL_MISSED_VIDEO","CALL_MISSED_VOICE","REAL_MSG_REQ_ME_STUB_TYPES","GROUP_PARTICIPANT_ADD","message","meId","key","remoteJid","jidNormalizedUser","participant","undefined","content","normalizeMessageContent","reactionMessage","normaliseKey","pollUpdateMessage","pollCreationMessageKey","msgKey","fromMe","areJidsSameUser","_a","normalizedContent","hasSomeContent","getContentType","has","messageStubType","messageStubParameters","some","p","protocolMessage","isJidBroadcast","isJidStatusBroadcast","encPayload","encIv","pollCreatorJid","pollMsgId","pollEncKey","voterJid","sign","Buffer","concat","toBinary","Uint8Array","key0","hmacSign","decKey","aad","decrypted","aesDecryptGCM","proto","Message","PollVoteMessage","decode","txt","from","processMessage","shouldProcessHistoryMsg","placeholderResendCache","ev","creds","keyStore","logger","options","getMessage","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","me","id","accountSettings","chat","isRealMsg","conversationTimestamp","toNumber","messageTimestamp","unreadCount","unarchiveChats","archived","readOnly","protocolMsg","type","ProtocolMessage","Type","HISTORY_SYNC_NOTIFICATION","histNotification","historySyncNotification","process","isLatest","processedHistoryMessages","length","info","syncType","HistorySync","HistorySyncType","ON_DEMAND","emit","data","downloadAndProcessHistorySyncNotification","peerDataRequestSessionId","APP_STATE_SYNC_KEY_SHARE","keys","appStateSyncKeyShare","newAppStateSyncKeyId","transaction","newKeys","keyData","keyId","strKeyId","toString","push","set","myAppStateKeyId","REVOKE","update","EPHEMERAL_SETTING","assign","ephemeralSettingTimestamp","ephemeralExpiration","PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE","response","peerDataOperationRequestResponseMessage","del","stanzaId","peerDataOperationResult","result","placeholderMessageResendResponse","retryResponse","webMessageInfo","WebMessageInfo","webMessageInfoBytes","setTimeout","messages","requestId","reaction","jid","participants","emitParticipantsUpdate","action","author","emitGroupUpdate","emitGroupRequestJoin","method","participantsIncludesMe","find","GROUP_PARTICIPANT_CHANGE_NUMBER","GROUP_PARTICIPANT_LEAVE","GROUP_PARTICIPANT_REMOVE","GROUP_PARTICIPANT_INVITE","GROUP_PARTICIPANT_ADD_REQUEST_JOIN","GROUP_PARTICIPANT_DEMOTE","GROUP_PARTICIPANT_PROMOTE","GROUP_CHANGE_ANNOUNCE","announceValue","announce","GROUP_CHANGE_RESTRICT","restrictValue","restrict","GROUP_CHANGE_SUBJECT","name","subject","GROUP_CHANGE_DESCRIPTION","description","desc","GROUP_CHANGE_INVITE_LINK","code","inviteCode","GROUP_MEMBER_ADD_MODE","memberAddValue","memberAddMode","GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE","approvalMode","joinApprovalMode","GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST_NON_ADMIN_ADD","creationMsgKey","pollMsg","meIdNormalised","getKeyAuthor","messageContextInfo","messageSecret","voteMsg","vote","pollUpdates","pollUpdateMessageKey","senderTimestampMs","err","warn","default"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Utils/process-message.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decryptPollVote = exports.getChatId = exports.shouldIncrementChatUnread = exports.isRealMessage = exports.cleanMessage = void 0;\nconst WAProto_1 = require(\"../../WAProto\");\nconst Types_1 = require(\"../Types\");\nconst messages_1 = require(\"../Utils/messages\");\nconst WABinary_1 = require(\"../WABinary\");\nconst crypto_1 = require(\"./crypto\");\nconst generics_1 = require(\"./generics\");\nconst history_1 = require(\"./history\");\nconst REAL_MSG_STUB_TYPES = new Set([\n    Types_1.WAMessageStubType.CALL_MISSED_GROUP_VIDEO,\n    Types_1.WAMessageStubType.CALL_MISSED_GROUP_VOICE,\n    Types_1.WAMessageStubType.CALL_MISSED_VIDEO,\n    Types_1.WAMessageStubType.CALL_MISSED_VOICE\n]);\nconst REAL_MSG_REQ_ME_STUB_TYPES = new Set([\n    Types_1.WAMessageStubType.GROUP_PARTICIPANT_ADD\n]);\n/** Cleans a received message to further processing */\nconst cleanMessage = (message, meId) => {\n    // ensure remoteJid and participant doesn't have device or agent in it\n    message.key.remoteJid = (0, WABinary_1.jidNormalizedUser)(message.key.remoteJid);\n    message.key.participant = message.key.participant ? (0, WABinary_1.jidNormalizedUser)(message.key.participant) : undefined;\n    const content = (0, messages_1.normalizeMessageContent)(message.message);\n    // if the message has a reaction, ensure fromMe & remoteJid are from our perspective\n    if (content === null || content === void 0 ? void 0 : content.reactionMessage) {\n        normaliseKey(content.reactionMessage.key);\n    }\n    if (content === null || content === void 0 ? void 0 : content.pollUpdateMessage) {\n        normaliseKey(content.pollUpdateMessage.pollCreationMessageKey);\n    }\n    function normaliseKey(msgKey) {\n        // if the reaction is from another user\n        // we've to correctly map the key to this user's perspective\n        if (!message.key.fromMe) {\n            // if the sender believed the message being reacted to is not from them\n            // we've to correct the key to be from them, or some other participant\n            msgKey.fromMe = !msgKey.fromMe\n                ? (0, WABinary_1.areJidsSameUser)(msgKey.participant || msgKey.remoteJid, meId)\n                // if the message being reacted to, was from them\n                // fromMe automatically becomes false\n                : false;\n            // set the remoteJid to being the same as the chat the message came from\n            msgKey.remoteJid = message.key.remoteJid;\n            // set participant of the message\n            msgKey.participant = msgKey.participant || message.key.participant;\n        }\n    }\n};\nexports.cleanMessage = cleanMessage;\nconst isRealMessage = (message, meId) => {\n    var _a;\n    const normalizedContent = (0, messages_1.normalizeMessageContent)(message.message);\n    const hasSomeContent = !!(0, messages_1.getContentType)(normalizedContent);\n    return (!!normalizedContent\n        || REAL_MSG_STUB_TYPES.has(message.messageStubType)\n        || (REAL_MSG_REQ_ME_STUB_TYPES.has(message.messageStubType)\n            && ((_a = message.messageStubParameters) === null || _a === void 0 ? void 0 : _a.some(p => (0, WABinary_1.areJidsSameUser)(meId, p)))))\n        && hasSomeContent\n        && !(normalizedContent === null || normalizedContent === void 0 ? void 0 : normalizedContent.protocolMessage)\n        && !(normalizedContent === null || normalizedContent === void 0 ? void 0 : normalizedContent.reactionMessage)\n        && !(normalizedContent === null || normalizedContent === void 0 ? void 0 : normalizedContent.pollUpdateMessage);\n};\nexports.isRealMessage = isRealMessage;\nconst shouldIncrementChatUnread = (message) => (!message.key.fromMe && !message.messageStubType);\nexports.shouldIncrementChatUnread = shouldIncrementChatUnread;\n/**\n * Get the ID of the chat from the given key.\n * Typically -- that'll be the remoteJid, but for broadcasts, it'll be the participant\n */\nconst getChatId = ({ remoteJid, participant, fromMe }) => {\n    if ((0, WABinary_1.isJidBroadcast)(remoteJid)\n        && !(0, WABinary_1.isJidStatusBroadcast)(remoteJid)\n        && !fromMe) {\n        return participant;\n    }\n    return remoteJid;\n};\nexports.getChatId = getChatId;\n/**\n * Decrypt a poll vote\n * @param vote encrypted vote\n * @param ctx additional info about the poll required for decryption\n * @returns list of SHA256 options\n */\nfunction decryptPollVote({ encPayload, encIv }, { pollCreatorJid, pollMsgId, pollEncKey, voterJid, }) {\n    const sign = Buffer.concat([\n        toBinary(pollMsgId),\n        toBinary(pollCreatorJid),\n        toBinary(voterJid),\n        toBinary('Poll Vote'),\n        new Uint8Array([1])\n    ]);\n    const key0 = (0, crypto_1.hmacSign)(pollEncKey, new Uint8Array(32), 'sha256');\n    const decKey = (0, crypto_1.hmacSign)(sign, key0, 'sha256');\n    const aad = toBinary(`${pollMsgId}\\u0000${voterJid}`);\n    const decrypted = (0, crypto_1.aesDecryptGCM)(encPayload, decKey, encIv, aad);\n    return WAProto_1.proto.Message.PollVoteMessage.decode(decrypted);\n    function toBinary(txt) {\n        return Buffer.from(txt);\n    }\n}\nexports.decryptPollVote = decryptPollVote;\nconst processMessage = async (message, { shouldProcessHistoryMsg, placeholderResendCache, ev, creds, keyStore, logger, options, getMessage }) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n    const meId = creds.me.id;\n    const { accountSettings } = creds;\n    const chat = { id: (0, WABinary_1.jidNormalizedUser)((0, exports.getChatId)(message.key)) };\n    const isRealMsg = (0, exports.isRealMessage)(message, meId);\n    if (isRealMsg) {\n        chat.conversationTimestamp = (0, generics_1.toNumber)(message.messageTimestamp);\n        // only increment unread count if not CIPHERTEXT and from another person\n        if ((0, exports.shouldIncrementChatUnread)(message)) {\n            chat.unreadCount = (chat.unreadCount || 0) + 1;\n        }\n    }\n    const content = (0, messages_1.normalizeMessageContent)(message.message);\n    // unarchive chat if it's a real message, or someone reacted to our message\n    // and we've the unarchive chats setting on\n    if ((isRealMsg || ((_b = (_a = content === null || content === void 0 ? void 0 : content.reactionMessage) === null || _a === void 0 ? void 0 : _a.key) === null || _b === void 0 ? void 0 : _b.fromMe))\n        && (accountSettings === null || accountSettings === void 0 ? void 0 : accountSettings.unarchiveChats)) {\n        chat.archived = false;\n        chat.readOnly = false;\n    }\n    const protocolMsg = content === null || content === void 0 ? void 0 : content.protocolMessage;\n    if (protocolMsg) {\n        switch (protocolMsg.type) {\n            case WAProto_1.proto.Message.ProtocolMessage.Type.HISTORY_SYNC_NOTIFICATION:\n                const histNotification = protocolMsg.historySyncNotification;\n                const process = shouldProcessHistoryMsg;\n                const isLatest = !((_c = creds.processedHistoryMessages) === null || _c === void 0 ? void 0 : _c.length);\n                logger === null || logger === void 0 ? void 0 : logger.info({\n                    histNotification,\n                    process,\n                    id: message.key.id,\n                    isLatest,\n                }, 'got history notification');\n                if (process) {\n                    if (histNotification.syncType !== WAProto_1.proto.HistorySync.HistorySyncType.ON_DEMAND) {\n                        ev.emit('creds.update', {\n                            processedHistoryMessages: [\n                                ...(creds.processedHistoryMessages || []),\n                                { key: message.key, messageTimestamp: message.messageTimestamp }\n                            ]\n                        });\n                    }\n                    const data = await (0, history_1.downloadAndProcessHistorySyncNotification)(histNotification, options);\n                    ev.emit('messaging-history.set', {\n                        ...data,\n                        isLatest: histNotification.syncType !== WAProto_1.proto.HistorySync.HistorySyncType.ON_DEMAND\n                            ? isLatest\n                            : undefined,\n                        peerDataRequestSessionId: histNotification.peerDataRequestSessionId\n                    });\n                }\n                break;\n            case WAProto_1.proto.Message.ProtocolMessage.Type.APP_STATE_SYNC_KEY_SHARE:\n                const keys = protocolMsg.appStateSyncKeyShare.keys;\n                if (keys === null || keys === void 0 ? void 0 : keys.length) {\n                    let newAppStateSyncKeyId = '';\n                    await keyStore.transaction(async () => {\n                        const newKeys = [];\n                        for (const { keyData, keyId } of keys) {\n                            const strKeyId = Buffer.from(keyId.keyId).toString('base64');\n                            newKeys.push(strKeyId);\n                            await keyStore.set({ 'app-state-sync-key': { [strKeyId]: keyData } });\n                            newAppStateSyncKeyId = strKeyId;\n                        }\n                        logger === null || logger === void 0 ? void 0 : logger.info({ newAppStateSyncKeyId, newKeys }, 'injecting new app state sync keys');\n                    });\n                    ev.emit('creds.update', { myAppStateKeyId: newAppStateSyncKeyId });\n                }\n                else {\n                    logger === null || logger === void 0 ? void 0 : logger.info({ protocolMsg }, 'recv app state sync with 0 keys');\n                }\n                break;\n            case WAProto_1.proto.Message.ProtocolMessage.Type.REVOKE:\n                ev.emit('messages.update', [\n                    {\n                        key: {\n                            ...message.key,\n                            id: protocolMsg.key.id\n                        },\n                        update: { message: null, messageStubType: Types_1.WAMessageStubType.REVOKE, key: message.key }\n                    }\n                ]);\n                break;\n            case WAProto_1.proto.Message.ProtocolMessage.Type.EPHEMERAL_SETTING:\n                Object.assign(chat, {\n                    ephemeralSettingTimestamp: (0, generics_1.toNumber)(message.messageTimestamp),\n                    ephemeralExpiration: protocolMsg.ephemeralExpiration || null\n                });\n                break;\n            case WAProto_1.proto.Message.ProtocolMessage.Type.PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE:\n                const response = protocolMsg.peerDataOperationRequestResponseMessage;\n                if (response) {\n                    placeholderResendCache === null || placeholderResendCache === void 0 ? void 0 : placeholderResendCache.del(response.stanzaId);\n                    // TODO: IMPLEMENT HISTORY SYNC ETC (sticker uploads etc.).\n                    const { peerDataOperationResult } = response;\n                    for (const result of peerDataOperationResult) {\n                        const { placeholderMessageResendResponse: retryResponse } = result;\n                        if (retryResponse) {\n                            const webMessageInfo = WAProto_1.proto.WebMessageInfo.decode(retryResponse.webMessageInfoBytes);\n                            // wait till another upsert event is available, don't want it to be part of the PDO response message\n                            setTimeout(() => {\n                                ev.emit('messages.upsert', {\n                                    messages: [webMessageInfo],\n                                    type: 'notify',\n                                    requestId: response.stanzaId\n                                });\n                            }, 500);\n                        }\n                    }\n                }\n                break;\n        }\n    }\n    else if (content === null || content === void 0 ? void 0 : content.reactionMessage) {\n        const reaction = {\n            ...content.reactionMessage,\n            key: message.key,\n        };\n        ev.emit('messages.reaction', [{\n                reaction,\n                key: (_d = content.reactionMessage) === null || _d === void 0 ? void 0 : _d.key,\n            }]);\n    }\n    else if (message.messageStubType) {\n        const jid = (_e = message.key) === null || _e === void 0 ? void 0 : _e.remoteJid;\n        //let actor = whatsappID (message.participant)\n        let participants;\n        const emitParticipantsUpdate = (action) => (ev.emit('group-participants.update', { id: jid, author: message.participant, participants, action }));\n        const emitGroupUpdate = (update) => {\n            var _a;\n            ev.emit('groups.update', [{ id: jid, ...update, author: (_a = message.participant) !== null && _a !== void 0 ? _a : undefined }]);\n        };\n        const emitGroupRequestJoin = (participant, action, method) => {\n            ev.emit('group.join-request', { id: jid, author: message.participant, participant, action, method: method });\n        };\n        const participantsIncludesMe = () => participants.find(jid => (0, WABinary_1.areJidsSameUser)(meId, jid));\n        switch (message.messageStubType) {\n            case Types_1.WAMessageStubType.GROUP_PARTICIPANT_CHANGE_NUMBER:\n                participants = message.messageStubParameters || [];\n                emitParticipantsUpdate('modify');\n                break;\n            case Types_1.WAMessageStubType.GROUP_PARTICIPANT_LEAVE:\n            case Types_1.WAMessageStubType.GROUP_PARTICIPANT_REMOVE:\n                participants = message.messageStubParameters || [];\n                emitParticipantsUpdate('remove');\n                // mark the chat read only if you left the group\n                if (participantsIncludesMe()) {\n                    chat.readOnly = true;\n                }\n                break;\n            case Types_1.WAMessageStubType.GROUP_PARTICIPANT_ADD:\n            case Types_1.WAMessageStubType.GROUP_PARTICIPANT_INVITE:\n            case Types_1.WAMessageStubType.GROUP_PARTICIPANT_ADD_REQUEST_JOIN:\n                participants = message.messageStubParameters || [];\n                if (participantsIncludesMe()) {\n                    chat.readOnly = false;\n                }\n                emitParticipantsUpdate('add');\n                break;\n            case Types_1.WAMessageStubType.GROUP_PARTICIPANT_DEMOTE:\n                participants = message.messageStubParameters || [];\n                emitParticipantsUpdate('demote');\n                break;\n            case Types_1.WAMessageStubType.GROUP_PARTICIPANT_PROMOTE:\n                participants = message.messageStubParameters || [];\n                emitParticipantsUpdate('promote');\n                break;\n            case Types_1.WAMessageStubType.GROUP_CHANGE_ANNOUNCE:\n                const announceValue = (_f = message.messageStubParameters) === null || _f === void 0 ? void 0 : _f[0];\n                emitGroupUpdate({ announce: announceValue === 'true' || announceValue === 'on' });\n                break;\n            case Types_1.WAMessageStubType.GROUP_CHANGE_RESTRICT:\n                const restrictValue = (_g = message.messageStubParameters) === null || _g === void 0 ? void 0 : _g[0];\n                emitGroupUpdate({ restrict: restrictValue === 'true' || restrictValue === 'on' });\n                break;\n            case Types_1.WAMessageStubType.GROUP_CHANGE_SUBJECT:\n                const name = (_h = message.messageStubParameters) === null || _h === void 0 ? void 0 : _h[0];\n                chat.name = name;\n                emitGroupUpdate({ subject: name });\n                break;\n            case Types_1.WAMessageStubType.GROUP_CHANGE_DESCRIPTION:\n                const description = (_j = message.messageStubParameters) === null || _j === void 0 ? void 0 : _j[0];\n                chat.description = description;\n                emitGroupUpdate({ desc: description });\n                break;\n            case Types_1.WAMessageStubType.GROUP_CHANGE_INVITE_LINK:\n                const code = (_k = message.messageStubParameters) === null || _k === void 0 ? void 0 : _k[0];\n                emitGroupUpdate({ inviteCode: code });\n                break;\n            case Types_1.WAMessageStubType.GROUP_MEMBER_ADD_MODE:\n                const memberAddValue = (_l = message.messageStubParameters) === null || _l === void 0 ? void 0 : _l[0];\n                emitGroupUpdate({ memberAddMode: memberAddValue === 'all_member_add' });\n                break;\n            case Types_1.WAMessageStubType.GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE:\n                const approvalMode = (_m = message.messageStubParameters) === null || _m === void 0 ? void 0 : _m[0];\n                emitGroupUpdate({ joinApprovalMode: approvalMode === 'on' });\n                break;\n            case Types_1.WAMessageStubType.GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST_NON_ADMIN_ADD:\n                const participant = (_o = message.messageStubParameters) === null || _o === void 0 ? void 0 : _o[0];\n                const action = (_p = message.messageStubParameters) === null || _p === void 0 ? void 0 : _p[1];\n                const method = (_q = message.messageStubParameters) === null || _q === void 0 ? void 0 : _q[2];\n                emitGroupRequestJoin(participant, action, method);\n                break;\n        }\n    }\n    else if (content === null || content === void 0 ? void 0 : content.pollUpdateMessage) {\n        const creationMsgKey = content.pollUpdateMessage.pollCreationMessageKey;\n        // we need to fetch the poll creation message to get the poll enc key\n        const pollMsg = await getMessage(creationMsgKey);\n        if (pollMsg) {\n            const meIdNormalised = (0, WABinary_1.jidNormalizedUser)(meId);\n            const pollCreatorJid = (0, generics_1.getKeyAuthor)(creationMsgKey, meIdNormalised);\n            const voterJid = (0, generics_1.getKeyAuthor)(message.key, meIdNormalised);\n            const pollEncKey = (_r = pollMsg.messageContextInfo) === null || _r === void 0 ? void 0 : _r.messageSecret;\n            try {\n                const voteMsg = decryptPollVote(content.pollUpdateMessage.vote, {\n                    pollEncKey,\n                    pollCreatorJid,\n                    pollMsgId: creationMsgKey.id,\n                    voterJid,\n                });\n                ev.emit('messages.update', [\n                    {\n                        key: creationMsgKey,\n                        update: {\n                            pollUpdates: [\n                                {\n                                    pollUpdateMessageKey: message.key,\n                                    vote: voteMsg,\n                                    senderTimestampMs: content.pollUpdateMessage.senderTimestampMs.toNumber(),\n                                }\n                            ]\n                        }\n                    }\n                ]);\n            }\n            catch (err) {\n                logger === null || logger === void 0 ? void 0 : logger.warn({ err, creationMsgKey }, 'failed to decrypt poll vote');\n            }\n        }\n        else {\n            logger === null || logger === void 0 ? void 0 : logger.warn({ creationMsgKey }, 'poll creation message not found, cannot decrypt update');\n        }\n    }\n    if (Object.keys(chat).length > 1) {\n        ev.emit('chats.update', [chat]);\n    }\n};\nexports.default = processMessage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}