{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst BinarySearch_1 = __importDefault(require(\"./BinarySearch\"));\nclass KeyedDB {\n  /**\n   * @param key Return the unique key used to sort items\n   * @param id The unique ID for the items\n   */\n  constructor(key, id) {\n    this.key = key;\n    this.idGetter = id || (v => this.key.key(v).toString());\n    this.dict = {};\n    this.array = [];\n  }\n  get length() {\n    return this.array.length;\n  }\n  get first() {\n    return this.array[0];\n  }\n  get last() {\n    return this.array[this.array.length - 1];\n  }\n  toJSON() {\n    return this.array;\n  }\n  /**\n   * Inserts items into the DB in klogN time.\n   * Where k is the number of items being inserted.\n   * @param values\n   */\n  insert(...values) {\n    values.forEach(v => this._insertSingle(v));\n  }\n  /**\n   * Upserts items into the DB in 2klogN time.\n   * Where k is the number of items being inserted.\n   *\n   * If a duplicate is found, it is deleted first and then the new one is inserted\n   * @param values\n   * @returns list of updated values\n   */\n  upsert(...values) {\n    const updates = [];\n    values.forEach(v => {\n      if (!v) return;\n      const deleted = this.deleteById(this.idGetter(v), false);\n      this._insertSingle(v);\n      // add to updates\n      deleted && updates.push(v);\n    });\n    return updates;\n  }\n  /**\n   * Inserts items only if they are not present in the DB\n   * @param values\n   * @returns list of all the inserted values\n   */\n  insertIfAbsent(...values) {\n    const insertions = [];\n    values.forEach(v => {\n      if (!v) return;\n      // if ID is present\n      const presentValue = this.get(this.idGetter(v));\n      if (presentValue) return;\n      // if key is present\n      const presentKey = this.firstIndex(v);\n      if (this.array[presentKey] && this.key.key(this.array[presentKey]) === this.key.key(v)) return;\n      this.insert(v);\n      insertions.push(v);\n    });\n    return insertions;\n  }\n  /**\n   * Deletes an item indexed by the ID\n   * @param id\n   * @param assertPresent\n   */\n  deleteById(id, assertPresent = true) {\n    const value = this.get(id);\n    if (!value) {\n      if (assertPresent) throw new Error(`Value not found`);else return;\n    }\n    return this.delete(value);\n  }\n  delete(value) {\n    const index = this.firstIndex(value);\n    if (index < 0 || index >= this.array.length || this.key.key(value) !== this.key.key(this.array[index])) {\n      return null;\n    }\n    delete this.dict[this.idGetter(value)];\n    return this.array.splice(index, 1)[0];\n  }\n  slice(start, end) {\n    const db = new KeyedDB(this.key, this.idGetter);\n    db.array = this.array.slice(start, end);\n    db.array.forEach(item => db.dict[this.idGetter(item)] = item);\n    return db;\n  }\n  /** Clears the DB */\n  clear() {\n    this.array = [];\n    this.dict = {};\n  }\n  get(id) {\n    return this.dict[id];\n  }\n  all() {\n    return this.array;\n  }\n  /**\n   * Updates a value specified by the ID\n   * and adjusts its position in the DB after an update if required\n   * @param id\n   * @param update\n   */\n  update(id, update) {\n    const value = this.get(id);\n    if (value) {\n      const idx = this.firstIndex(value);\n      if (idx >= 0 && idx < this.array.length && this.idGetter(this.array[idx]) === id) {\n        const oldKey = this.key.key(value);\n        update(value);\n        const newKey = this.key.key(value);\n        if (newKey !== oldKey) {\n          delete this.dict[id];\n          this.array.splice(idx, 1);\n          this._insertSingle(value);\n          return 2;\n        }\n        return 1;\n      }\n    }\n  }\n  /**\n   * @deprecated see `update`\n   */\n  updateKey(value, update) {\n    return this.update(this.idGetter(value), update);\n  }\n  filter(predicate) {\n    const db = new KeyedDB(this.key, this.idGetter);\n    db.array = this.array.filter((value, index) => {\n      if (predicate(value, index)) {\n        db.dict[this.idGetter(value)] = value;\n        return true;\n      }\n    });\n    return db;\n  }\n  /**\n   * Get the values of the data in a paginated manner\n   * @param value the value itself beyond which the content is to be retreived\n   * @param limit max number of items to retreive\n   * @param predicate optional filter\n   * @param mode whether to get the content `before` the cursor or `after` the cursor; default=`after`\n   */\n  paginatedByValue(value, limit, predicate, mode = 'after') {\n    return this.paginated(value && this.key.key(value), limit, predicate, mode);\n  }\n  /**\n   * Get the values of the data in a paginated manner\n   * @param value the cursor beyond which the content is to be retreived\n   * @param limit max number of items to retreive\n   * @param predicate optional filter\n   * @param mode whether to get the content `before` the cursor or `after` the cursor; default=`after`\n   */\n  paginated(cursor, limit, predicate, mode = 'after') {\n    let index = mode === 'after' ? 0 : this.array.length;\n    if (cursor !== null && typeof cursor !== 'undefined') {\n      index = BinarySearch_1.default(this.array, v => this.key.compare(cursor, this.key.key(v)));\n      if (index < 0) index = 0;\n      if (this.key.key(this.array[index]) === cursor) index += mode === 'after' ? 1 : 0;\n    }\n    return this.filtered(index, limit, mode, predicate);\n  }\n  _insertSingle(value) {\n    if (!value) throw new Error('falsey value');\n    const valueID = this.idGetter(value);\n    if (this.get(valueID)) {\n      throw new Error('duplicate ID being inserted: ' + valueID);\n    }\n    if (this.array.length > 0) {\n      const index = this.firstIndex(value);\n      if (index >= this.array.length) this.array.push(value);else if (index < 0) this.array.unshift(value);else if (this.key.key(value) !== this.key.key(this.array[index])) this.array.splice(index, 0, value);else throw new Error(`duplicate key: ${this.key.key(value)}, of inserting: ${valueID}, present: ${this.idGetter(this.array[index])}`);\n    } else {\n      this.array.push(value);\n    }\n    this.dict[valueID] = value;\n  }\n  filtered(start, count, mode, predicate) {\n    let arr;\n    if (mode === 'after') {\n      if (predicate) {\n        arr = [];\n        for (let item of this.array.slice(start)) {\n          predicate(item, start + arr.length) && arr.push(item);\n          if (arr.length >= count) break;\n        }\n      } else arr = this.array.slice(start, start + count);\n    } else if (mode === 'before') {\n      if (predicate) {\n        arr = [];\n        for (let i = start - 1; i >= 0; i--) {\n          let item = this.array[i];\n          predicate(item, start + arr.length) && arr.unshift(item);\n          if (arr.length >= count) break;\n        }\n      } else arr = this.array.slice(Math.max(start - count, 0), start);\n    }\n    return arr;\n  }\n  firstIndex(value) {\n    const valueKey = this.key.key(value);\n    return BinarySearch_1.default(this.array, v => this.key.compare(valueKey, this.key.key(v)));\n  }\n}\nexports.default = KeyedDB;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","BinarySearch_1","require","KeyedDB","constructor","key","id","idGetter","v","toString","dict","array","length","first","last","toJSON","insert","values","forEach","_insertSingle","upsert","updates","deleted","deleteById","push","insertIfAbsent","insertions","presentValue","get","presentKey","firstIndex","assertPresent","Error","delete","index","splice","slice","start","end","db","item","clear","all","update","idx","oldKey","newKey","updateKey","filter","predicate","paginatedByValue","limit","mode","paginated","cursor","default","compare","filtered","valueID","unshift","count","arr","i","Math","max","valueKey"],"sources":["C:/Users/vanitas/node_modules/@adiwajshing/keyed-db/lib/KeyedDB.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BinarySearch_1 = __importDefault(require(\"./BinarySearch\"));\nclass KeyedDB {\n    /**\n     * @param key Return the unique key used to sort items\n     * @param id The unique ID for the items\n     */\n    constructor(key, id) {\n        this.key = key;\n        this.idGetter = id || (v => this.key.key(v).toString());\n        this.dict = {};\n        this.array = [];\n    }\n    get length() {\n        return this.array.length;\n    }\n    get first() {\n        return this.array[0];\n    }\n    get last() {\n        return this.array[this.array.length - 1];\n    }\n    toJSON() {\n        return this.array;\n    }\n    /**\n     * Inserts items into the DB in klogN time.\n     * Where k is the number of items being inserted.\n     * @param values\n     */\n    insert(...values) {\n        values.forEach(v => this._insertSingle(v));\n    }\n    /**\n     * Upserts items into the DB in 2klogN time.\n     * Where k is the number of items being inserted.\n     *\n     * If a duplicate is found, it is deleted first and then the new one is inserted\n     * @param values\n     * @returns list of updated values\n     */\n    upsert(...values) {\n        const updates = [];\n        values.forEach(v => {\n            if (!v)\n                return;\n            const deleted = this.deleteById(this.idGetter(v), false);\n            this._insertSingle(v);\n            // add to updates\n            deleted && updates.push(v);\n        });\n        return updates;\n    }\n    /**\n     * Inserts items only if they are not present in the DB\n     * @param values\n     * @returns list of all the inserted values\n     */\n    insertIfAbsent(...values) {\n        const insertions = [];\n        values.forEach(v => {\n            if (!v)\n                return;\n            // if ID is present\n            const presentValue = this.get(this.idGetter(v));\n            if (presentValue)\n                return;\n            // if key is present\n            const presentKey = this.firstIndex(v);\n            if (this.array[presentKey] && this.key.key(this.array[presentKey]) === this.key.key(v))\n                return;\n            this.insert(v);\n            insertions.push(v);\n        });\n        return insertions;\n    }\n    /**\n     * Deletes an item indexed by the ID\n     * @param id\n     * @param assertPresent\n     */\n    deleteById(id, assertPresent = true) {\n        const value = this.get(id);\n        if (!value) {\n            if (assertPresent)\n                throw new Error(`Value not found`);\n            else\n                return;\n        }\n        return this.delete(value);\n    }\n    delete(value) {\n        const index = this.firstIndex(value);\n        if (index < 0 || index >= this.array.length || this.key.key(value) !== this.key.key(this.array[index])) {\n            return null;\n        }\n        delete this.dict[this.idGetter(value)];\n        return this.array.splice(index, 1)[0];\n    }\n    slice(start, end) {\n        const db = new KeyedDB(this.key, this.idGetter);\n        db.array = this.array.slice(start, end);\n        db.array.forEach(item => db.dict[this.idGetter(item)] = item);\n        return db;\n    }\n    /** Clears the DB */\n    clear() {\n        this.array = [];\n        this.dict = {};\n    }\n    get(id) {\n        return this.dict[id];\n    }\n    all() {\n        return this.array;\n    }\n    /**\n     * Updates a value specified by the ID\n     * and adjusts its position in the DB after an update if required\n     * @param id\n     * @param update\n     */\n    update(id, update) {\n        const value = this.get(id);\n        if (value) {\n            const idx = this.firstIndex(value);\n            if (idx >= 0 && idx < this.array.length && this.idGetter(this.array[idx]) === id) {\n                const oldKey = this.key.key(value);\n                update(value);\n                const newKey = this.key.key(value);\n                if (newKey !== oldKey) {\n                    delete this.dict[id];\n                    this.array.splice(idx, 1);\n                    this._insertSingle(value);\n                    return 2;\n                }\n                return 1;\n            }\n        }\n    }\n    /**\n     * @deprecated see `update`\n     */\n    updateKey(value, update) {\n        return this.update(this.idGetter(value), update);\n    }\n    filter(predicate) {\n        const db = new KeyedDB(this.key, this.idGetter);\n        db.array = this.array.filter((value, index) => {\n            if (predicate(value, index)) {\n                db.dict[this.idGetter(value)] = value;\n                return true;\n            }\n        });\n        return db;\n    }\n    /**\n     * Get the values of the data in a paginated manner\n     * @param value the value itself beyond which the content is to be retreived\n     * @param limit max number of items to retreive\n     * @param predicate optional filter\n     * @param mode whether to get the content `before` the cursor or `after` the cursor; default=`after`\n     */\n    paginatedByValue(value, limit, predicate, mode = 'after') {\n        return this.paginated(value && this.key.key(value), limit, predicate, mode);\n    }\n    /**\n     * Get the values of the data in a paginated manner\n     * @param value the cursor beyond which the content is to be retreived\n     * @param limit max number of items to retreive\n     * @param predicate optional filter\n     * @param mode whether to get the content `before` the cursor or `after` the cursor; default=`after`\n     */\n    paginated(cursor, limit, predicate, mode = 'after') {\n        let index = mode === 'after' ? 0 : this.array.length;\n        if (cursor !== null && typeof cursor !== 'undefined') {\n            index = BinarySearch_1.default(this.array, v => this.key.compare(cursor, this.key.key(v)));\n            if (index < 0)\n                index = 0;\n            if (this.key.key(this.array[index]) === cursor)\n                index += (mode === 'after' ? 1 : 0);\n        }\n        return this.filtered(index, limit, mode, predicate);\n    }\n    _insertSingle(value) {\n        if (!value)\n            throw new Error('falsey value');\n        const valueID = this.idGetter(value);\n        if (this.get(valueID)) {\n            throw new Error('duplicate ID being inserted: ' + valueID);\n        }\n        if (this.array.length > 0) {\n            const index = this.firstIndex(value);\n            if (index >= this.array.length)\n                this.array.push(value);\n            else if (index < 0)\n                this.array.unshift(value);\n            else if (this.key.key(value) !== this.key.key(this.array[index]))\n                this.array.splice(index, 0, value);\n            else\n                throw new Error(`duplicate key: ${this.key.key(value)}, of inserting: ${valueID}, present: ${this.idGetter(this.array[index])}`);\n        }\n        else {\n            this.array.push(value);\n        }\n        this.dict[valueID] = value;\n    }\n    filtered(start, count, mode, predicate) {\n        let arr;\n        if (mode === 'after') {\n            if (predicate) {\n                arr = [];\n                for (let item of this.array.slice(start)) {\n                    predicate(item, start + arr.length) && arr.push(item);\n                    if (arr.length >= count)\n                        break;\n                }\n            }\n            else\n                arr = this.array.slice(start, start + count);\n        }\n        else if (mode === 'before') {\n            if (predicate) {\n                arr = [];\n                for (let i = start - 1; i >= 0; i--) {\n                    let item = this.array[i];\n                    predicate(item, start + arr.length) && arr.unshift(item);\n                    if (arr.length >= count)\n                        break;\n                }\n            }\n            else\n                arr = this.array.slice(Math.max(start - count, 0), start);\n        }\n        return arr;\n    }\n    firstIndex(value) {\n        const valueKey = this.key.key(value);\n        return BinarySearch_1.default(this.array, v => this.key.compare(valueKey, this.key.key(v)));\n    }\n}\nexports.default = KeyedDB;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}