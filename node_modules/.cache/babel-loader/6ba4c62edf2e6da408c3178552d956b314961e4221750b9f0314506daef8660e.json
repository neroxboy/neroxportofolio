{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readXingHeader = exports.XingHeaderFlags = exports.LameEncoderVersion = exports.InfoTagHeaderTag = void 0;\nconst Token = require(\"token-types\");\nconst util = require(\"../common/Util\");\nconst ExtendedLameHeader_1 = require(\"./ExtendedLameHeader\");\n/**\n * Info Tag: Xing, LAME\n */\nexports.InfoTagHeaderTag = new Token.StringType(4, 'ascii');\n/**\n * LAME TAG value\n * Did not find any official documentation for this\n * Value e.g.: \"3.98.4\"\n */\nexports.LameEncoderVersion = new Token.StringType(6, 'ascii');\n/**\n * Info Tag\n * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n */\nexports.XingHeaderFlags = {\n  len: 4,\n  get: (buf, off) => {\n    return {\n      frames: util.isBitSet(buf, off, 31),\n      bytes: util.isBitSet(buf, off, 30),\n      toc: util.isBitSet(buf, off, 29),\n      vbrScale: util.isBitSet(buf, off, 28)\n    };\n  }\n};\n// /**\n//  * XING Header Tag\n//  * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n//  */\nasync function readXingHeader(tokenizer) {\n  const flags = await tokenizer.readToken(exports.XingHeaderFlags);\n  const xingInfoTag = {};\n  if (flags.frames) {\n    xingInfoTag.numFrames = await tokenizer.readToken(Token.UINT32_BE);\n  }\n  if (flags.bytes) {\n    xingInfoTag.streamSize = await tokenizer.readToken(Token.UINT32_BE);\n  }\n  if (flags.toc) {\n    xingInfoTag.toc = Buffer.alloc(100);\n    await tokenizer.readBuffer(xingInfoTag.toc);\n  }\n  if (flags.vbrScale) {\n    xingInfoTag.vbrScale = await tokenizer.readToken(Token.UINT32_BE);\n  }\n  const lameTag = await tokenizer.peekToken(new Token.StringType(4, 'ascii'));\n  if (lameTag === 'LAME') {\n    await tokenizer.ignore(4);\n    xingInfoTag.lame = {\n      version: await tokenizer.readToken(new Token.StringType(5, 'ascii'))\n    };\n    const match = xingInfoTag.lame.version.match(/\\d+.\\d+/g);\n    if (match) {\n      const majorMinorVersion = xingInfoTag.lame.version.match(/\\d+.\\d+/g)[0]; // e.g. 3.97\n      const version = majorMinorVersion.split('.').map(n => parseInt(n, 10));\n      if (version[0] >= 3 && version[1] >= 90) {\n        xingInfoTag.lame.extended = await tokenizer.readToken(ExtendedLameHeader_1.ExtendedLameHeader);\n      }\n    }\n  }\n  return xingInfoTag;\n}\nexports.readXingHeader = readXingHeader;","map":{"version":3,"names":["Object","defineProperty","exports","value","readXingHeader","XingHeaderFlags","LameEncoderVersion","InfoTagHeaderTag","Token","require","util","ExtendedLameHeader_1","StringType","len","get","buf","off","frames","isBitSet","bytes","toc","vbrScale","tokenizer","flags","readToken","xingInfoTag","numFrames","UINT32_BE","streamSize","Buffer","alloc","readBuffer","lameTag","peekToken","ignore","lame","version","match","majorMinorVersion","split","map","n","parseInt","extended","ExtendedLameHeader"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/mpeg/XingTag.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readXingHeader = exports.XingHeaderFlags = exports.LameEncoderVersion = exports.InfoTagHeaderTag = void 0;\nconst Token = require(\"token-types\");\nconst util = require(\"../common/Util\");\nconst ExtendedLameHeader_1 = require(\"./ExtendedLameHeader\");\n/**\n * Info Tag: Xing, LAME\n */\nexports.InfoTagHeaderTag = new Token.StringType(4, 'ascii');\n/**\n * LAME TAG value\n * Did not find any official documentation for this\n * Value e.g.: \"3.98.4\"\n */\nexports.LameEncoderVersion = new Token.StringType(6, 'ascii');\n/**\n * Info Tag\n * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n */\nexports.XingHeaderFlags = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            frames: util.isBitSet(buf, off, 31),\n            bytes: util.isBitSet(buf, off, 30),\n            toc: util.isBitSet(buf, off, 29),\n            vbrScale: util.isBitSet(buf, off, 28)\n        };\n    }\n};\n// /**\n//  * XING Header Tag\n//  * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n//  */\nasync function readXingHeader(tokenizer) {\n    const flags = await tokenizer.readToken(exports.XingHeaderFlags);\n    const xingInfoTag = {};\n    if (flags.frames) {\n        xingInfoTag.numFrames = await tokenizer.readToken(Token.UINT32_BE);\n    }\n    if (flags.bytes) {\n        xingInfoTag.streamSize = await tokenizer.readToken(Token.UINT32_BE);\n    }\n    if (flags.toc) {\n        xingInfoTag.toc = Buffer.alloc(100);\n        await tokenizer.readBuffer(xingInfoTag.toc);\n    }\n    if (flags.vbrScale) {\n        xingInfoTag.vbrScale = await tokenizer.readToken(Token.UINT32_BE);\n    }\n    const lameTag = await tokenizer.peekToken(new Token.StringType(4, 'ascii'));\n    if (lameTag === 'LAME') {\n        await tokenizer.ignore(4);\n        xingInfoTag.lame = {\n            version: await tokenizer.readToken(new Token.StringType(5, 'ascii'))\n        };\n        const match = xingInfoTag.lame.version.match(/\\d+.\\d+/g);\n        if (match) {\n            const majorMinorVersion = xingInfoTag.lame.version.match(/\\d+.\\d+/g)[0]; // e.g. 3.97\n            const version = majorMinorVersion.split('.').map(n => parseInt(n, 10));\n            if (version[0] >= 3 && version[1] >= 90) {\n                xingInfoTag.lame.extended = await tokenizer.readToken(ExtendedLameHeader_1.ExtendedLameHeader);\n            }\n        }\n    }\n    return xingInfoTag;\n}\nexports.readXingHeader = readXingHeader;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,cAAc,GAAGF,OAAO,CAACG,eAAe,GAAGH,OAAO,CAACI,kBAAkB,GAAGJ,OAAO,CAACK,gBAAgB,GAAG,KAAK,CAAC;AACjH,MAAMC,KAAK,GAAGC,OAAO,CAAC,aAAa,CAAC;AACpC,MAAMC,IAAI,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AACtC,MAAME,oBAAoB,GAAGF,OAAO,CAAC,sBAAsB,CAAC;AAC5D;AACA;AACA;AACAP,OAAO,CAACK,gBAAgB,GAAG,IAAIC,KAAK,CAACI,UAAU,CAAC,CAAC,EAAE,OAAO,CAAC;AAC3D;AACA;AACA;AACA;AACA;AACAV,OAAO,CAACI,kBAAkB,GAAG,IAAIE,KAAK,CAACI,UAAU,CAAC,CAAC,EAAE,OAAO,CAAC;AAC7D;AACA;AACA;AACA;AACAV,OAAO,CAACG,eAAe,GAAG;EACtBQ,GAAG,EAAE,CAAC;EACNC,GAAG,EAAEA,CAACC,GAAG,EAAEC,GAAG,KAAK;IACf,OAAO;MACHC,MAAM,EAAEP,IAAI,CAACQ,QAAQ,CAACH,GAAG,EAAEC,GAAG,EAAE,EAAE,CAAC;MACnCG,KAAK,EAAET,IAAI,CAACQ,QAAQ,CAACH,GAAG,EAAEC,GAAG,EAAE,EAAE,CAAC;MAClCI,GAAG,EAAEV,IAAI,CAACQ,QAAQ,CAACH,GAAG,EAAEC,GAAG,EAAE,EAAE,CAAC;MAChCK,QAAQ,EAAEX,IAAI,CAACQ,QAAQ,CAACH,GAAG,EAAEC,GAAG,EAAE,EAAE;IACxC,CAAC;EACL;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA,eAAeZ,cAAcA,CAACkB,SAAS,EAAE;EACrC,MAAMC,KAAK,GAAG,MAAMD,SAAS,CAACE,SAAS,CAACtB,OAAO,CAACG,eAAe,CAAC;EAChE,MAAMoB,WAAW,GAAG,CAAC,CAAC;EACtB,IAAIF,KAAK,CAACN,MAAM,EAAE;IACdQ,WAAW,CAACC,SAAS,GAAG,MAAMJ,SAAS,CAACE,SAAS,CAAChB,KAAK,CAACmB,SAAS,CAAC;EACtE;EACA,IAAIJ,KAAK,CAACJ,KAAK,EAAE;IACbM,WAAW,CAACG,UAAU,GAAG,MAAMN,SAAS,CAACE,SAAS,CAAChB,KAAK,CAACmB,SAAS,CAAC;EACvE;EACA,IAAIJ,KAAK,CAACH,GAAG,EAAE;IACXK,WAAW,CAACL,GAAG,GAAGS,MAAM,CAACC,KAAK,CAAC,GAAG,CAAC;IACnC,MAAMR,SAAS,CAACS,UAAU,CAACN,WAAW,CAACL,GAAG,CAAC;EAC/C;EACA,IAAIG,KAAK,CAACF,QAAQ,EAAE;IAChBI,WAAW,CAACJ,QAAQ,GAAG,MAAMC,SAAS,CAACE,SAAS,CAAChB,KAAK,CAACmB,SAAS,CAAC;EACrE;EACA,MAAMK,OAAO,GAAG,MAAMV,SAAS,CAACW,SAAS,CAAC,IAAIzB,KAAK,CAACI,UAAU,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;EAC3E,IAAIoB,OAAO,KAAK,MAAM,EAAE;IACpB,MAAMV,SAAS,CAACY,MAAM,CAAC,CAAC,CAAC;IACzBT,WAAW,CAACU,IAAI,GAAG;MACfC,OAAO,EAAE,MAAMd,SAAS,CAACE,SAAS,CAAC,IAAIhB,KAAK,CAACI,UAAU,CAAC,CAAC,EAAE,OAAO,CAAC;IACvE,CAAC;IACD,MAAMyB,KAAK,GAAGZ,WAAW,CAACU,IAAI,CAACC,OAAO,CAACC,KAAK,CAAC,UAAU,CAAC;IACxD,IAAIA,KAAK,EAAE;MACP,MAAMC,iBAAiB,GAAGb,WAAW,CAACU,IAAI,CAACC,OAAO,CAACC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MACzE,MAAMD,OAAO,GAAGE,iBAAiB,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,CAAC,IAAIC,QAAQ,CAACD,CAAC,EAAE,EAAE,CAAC,CAAC;MACtE,IAAIL,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,IAAIA,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE,EAAE;QACrCX,WAAW,CAACU,IAAI,CAACQ,QAAQ,GAAG,MAAMrB,SAAS,CAACE,SAAS,CAACb,oBAAoB,CAACiC,kBAAkB,CAAC;MAClG;IACJ;EACJ;EACA,OAAOnB,WAAW;AACtB;AACAvB,OAAO,CAACE,cAAc,GAAGA,cAAc","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}