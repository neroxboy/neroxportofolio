{"ast":null,"code":"const queue_job = require('./queue_job');\nconst SenderKeyMessage = require('./sender_key_message');\nconst crypto = require('libsignal/src/crypto');\nclass GroupCipher {\n  constructor(senderKeyStore, senderKeyName) {\n    this.senderKeyStore = senderKeyStore;\n    this.senderKeyName = senderKeyName;\n  }\n  queueJob(awaitable) {\n    return queue_job(this.senderKeyName.toString(), awaitable);\n  }\n  async encrypt(paddedPlaintext) {\n    return await this.queueJob(async () => {\n      const record = await this.senderKeyStore.loadSenderKey(this.senderKeyName);\n      if (!record) {\n        throw new Error(\"No SenderKeyRecord found for encryption\");\n      }\n      const senderKeyState = record.getSenderKeyState();\n      if (!senderKeyState) {\n        throw new Error(\"No session to encrypt message\");\n      }\n      const iteration = senderKeyState.getSenderChainKey().getIteration();\n      const senderKey = this.getSenderKey(senderKeyState, iteration === 0 ? 0 : iteration + 1);\n      const ciphertext = await this.getCipherText(senderKey.getIv(), senderKey.getCipherKey(), paddedPlaintext);\n      const senderKeyMessage = new SenderKeyMessage(senderKeyState.getKeyId(), senderKey.getIteration(), ciphertext, senderKeyState.getSigningKeyPrivate());\n      await this.senderKeyStore.storeSenderKey(this.senderKeyName, record);\n      return senderKeyMessage.serialize();\n    });\n  }\n  async decrypt(senderKeyMessageBytes) {\n    return await this.queueJob(async () => {\n      const record = await this.senderKeyStore.loadSenderKey(this.senderKeyName);\n      if (!record) {\n        throw new Error(\"No SenderKeyRecord found for decryption\");\n      }\n      const senderKeyMessage = new SenderKeyMessage(null, null, null, null, senderKeyMessageBytes);\n      const senderKeyState = record.getSenderKeyState(senderKeyMessage.getKeyId());\n      if (!senderKeyState) {\n        throw new Error(\"No session found to decrypt message\");\n      }\n      senderKeyMessage.verifySignature(senderKeyState.getSigningKeyPublic());\n      const senderKey = this.getSenderKey(senderKeyState, senderKeyMessage.getIteration());\n      // senderKeyState.senderKeyStateStructure.senderSigningKey.private =\n\n      const plaintext = await this.getPlainText(senderKey.getIv(), senderKey.getCipherKey(), senderKeyMessage.getCipherText());\n      await this.senderKeyStore.storeSenderKey(this.senderKeyName, record);\n      return plaintext;\n    });\n  }\n  getSenderKey(senderKeyState, iteration) {\n    let senderChainKey = senderKeyState.getSenderChainKey();\n    if (senderChainKey.getIteration() > iteration) {\n      if (senderKeyState.hasSenderMessageKey(iteration)) {\n        return senderKeyState.removeSenderMessageKey(iteration);\n      }\n      throw new Error(`Received message with old counter: ${senderChainKey.getIteration()}, ${iteration}`);\n    }\n    if (iteration - senderChainKey.getIteration() > 2000) {\n      throw new Error('Over 2000 messages into the future!');\n    }\n    while (senderChainKey.getIteration() < iteration) {\n      senderKeyState.addSenderMessageKey(senderChainKey.getSenderMessageKey());\n      senderChainKey = senderChainKey.getNext();\n    }\n    senderKeyState.setSenderChainKey(senderChainKey.getNext());\n    return senderChainKey.getSenderMessageKey();\n  }\n  getPlainText(iv, key, ciphertext) {\n    try {\n      const plaintext = crypto.decrypt(key, ciphertext, iv);\n      return plaintext;\n    } catch (e) {\n      //console.log(e.stack);\n      throw new Error('InvalidMessageException');\n    }\n  }\n  getCipherText(iv, key, plaintext) {\n    try {\n      iv = typeof iv === 'string' ? Buffer.from(iv, 'base64') : iv;\n      key = typeof key === 'string' ? Buffer.from(key, 'base64') : key;\n      const crypted = crypto.encrypt(key, Buffer.from(plaintext), iv);\n      return crypted;\n    } catch (e) {\n      //console.log(e.stack);\n      throw new Error('InvalidMessageException');\n    }\n  }\n}\nmodule.exports = GroupCipher;","map":{"version":3,"names":["queue_job","require","SenderKeyMessage","crypto","GroupCipher","constructor","senderKeyStore","senderKeyName","queueJob","awaitable","toString","encrypt","paddedPlaintext","record","loadSenderKey","Error","senderKeyState","getSenderKeyState","iteration","getSenderChainKey","getIteration","senderKey","getSenderKey","ciphertext","getCipherText","getIv","getCipherKey","senderKeyMessage","getKeyId","getSigningKeyPrivate","storeSenderKey","serialize","decrypt","senderKeyMessageBytes","verifySignature","getSigningKeyPublic","plaintext","getPlainText","senderChainKey","hasSenderMessageKey","removeSenderMessageKey","addSenderMessageKey","getSenderMessageKey","getNext","setSenderChainKey","iv","key","e","Buffer","from","crypted","module","exports"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/WASignalGroup/group_cipher.js"],"sourcesContent":["const queue_job = require('./queue_job');\nconst SenderKeyMessage = require('./sender_key_message');\nconst crypto = require('libsignal/src/crypto');\n\nclass GroupCipher {\n  constructor(senderKeyStore, senderKeyName) {\n    this.senderKeyStore = senderKeyStore;\n    this.senderKeyName = senderKeyName;\n  }\n\n  queueJob(awaitable) {\n    return queue_job(this.senderKeyName.toString(), awaitable)\n  }\n\n  async encrypt(paddedPlaintext) {\n    return await this.queueJob(async () => {\n      const record = await this.senderKeyStore.loadSenderKey(this.senderKeyName);\n      if (!record) {\n        throw new Error(\"No SenderKeyRecord found for encryption\")\n      }\n      const senderKeyState = record.getSenderKeyState();\n      if (!senderKeyState) {\n        throw new Error(\"No session to encrypt message\");\n      }\n      const iteration = senderKeyState.getSenderChainKey().getIteration()\n      const senderKey = this.getSenderKey(senderKeyState, iteration === 0 ? 0 : iteration + 1)\n\n      const ciphertext = await this.getCipherText(\n        senderKey.getIv(),\n        senderKey.getCipherKey(),\n        paddedPlaintext\n      );\n\n      const senderKeyMessage = new SenderKeyMessage(\n        senderKeyState.getKeyId(),\n        senderKey.getIteration(),\n        ciphertext,\n        senderKeyState.getSigningKeyPrivate()\n      );\n      await this.senderKeyStore.storeSenderKey(this.senderKeyName, record);\n      return senderKeyMessage.serialize()\n    })\n  }\n\n  async decrypt(senderKeyMessageBytes) {\n    return await this.queueJob(async () => {\n      const record = await this.senderKeyStore.loadSenderKey(this.senderKeyName);\n      if (!record) {\n        throw new Error(\"No SenderKeyRecord found for decryption\")\n      }\n      const senderKeyMessage = new SenderKeyMessage(null, null, null, null, senderKeyMessageBytes);\n      const senderKeyState = record.getSenderKeyState(senderKeyMessage.getKeyId());\n      if (!senderKeyState) {\n        throw new Error(\"No session found to decrypt message\")\n      }\n\n      senderKeyMessage.verifySignature(senderKeyState.getSigningKeyPublic());\n      const senderKey = this.getSenderKey(senderKeyState, senderKeyMessage.getIteration());\n      // senderKeyState.senderKeyStateStructure.senderSigningKey.private =\n\n      const plaintext = await this.getPlainText(\n        senderKey.getIv(),\n        senderKey.getCipherKey(),\n        senderKeyMessage.getCipherText()\n      );\n\n      await this.senderKeyStore.storeSenderKey(this.senderKeyName, record);\n\n      return plaintext;\n    })\n  }\n\n  getSenderKey(senderKeyState, iteration) {\n    let senderChainKey = senderKeyState.getSenderChainKey();\n    if (senderChainKey.getIteration() > iteration) {\n      if (senderKeyState.hasSenderMessageKey(iteration)) {\n        return senderKeyState.removeSenderMessageKey(iteration);\n      }\n      throw new Error(\n        `Received message with old counter: ${senderChainKey.getIteration()}, ${iteration}`\n      );\n    }\n\n    if (iteration - senderChainKey.getIteration() > 2000) {\n      throw new Error('Over 2000 messages into the future!');\n    }\n\n    while (senderChainKey.getIteration() < iteration) {\n      senderKeyState.addSenderMessageKey(senderChainKey.getSenderMessageKey());\n      senderChainKey = senderChainKey.getNext();\n    }\n\n    senderKeyState.setSenderChainKey(senderChainKey.getNext());\n    return senderChainKey.getSenderMessageKey();\n  }\n\n  getPlainText(iv, key, ciphertext) {\n    try {\n      const plaintext = crypto.decrypt(key, ciphertext, iv);\n      return plaintext;\n    } catch (e) {\n      //console.log(e.stack);\n      throw new Error('InvalidMessageException');\n    }\n  }\n\n  getCipherText(iv, key, plaintext) {\n    try {\n      iv = typeof iv === 'string' ? Buffer.from(iv, 'base64') : iv;\n      key = typeof key === 'string' ? Buffer.from(key, 'base64') : key;\n      const crypted = crypto.encrypt(key, Buffer.from(plaintext), iv);\n      return crypted;\n    } catch (e) {\n      //console.log(e.stack);\n      throw new Error('InvalidMessageException');\n    }\n  }\n}\n\nmodule.exports = GroupCipher;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}