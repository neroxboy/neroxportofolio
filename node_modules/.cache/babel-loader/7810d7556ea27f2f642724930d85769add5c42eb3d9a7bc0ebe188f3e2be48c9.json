{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeMessagesRecvSocket = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst crypto_1 = require(\"crypto\");\nconst node_cache_1 = __importDefault(require(\"node-cache\"));\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst Types_1 = require(\"../Types\");\nconst Utils_1 = require(\"../Utils\");\nconst Utils_2 = require(\"../Utils\");\nconst make_mutex_1 = require(\"../Utils/make-mutex\");\nconst WABinary_1 = require(\"../WABinary\");\nconst groups_1 = require(\"./groups\");\nconst messages_send_1 = require(\"./messages-send\");\nconst makeMessagesRecvSocket = config => {\n  const {\n    logger,\n    retryRequestDelayMs,\n    maxMsgRetryCount,\n    getMessage,\n    shouldIgnoreJid\n  } = config;\n  const sock = (0, messages_send_1.makeMessagesSocket)(config);\n  const {\n    ev,\n    authState,\n    ws,\n    processingMutex,\n    signalRepository,\n    query,\n    upsertMessage,\n    resyncAppState,\n    onUnexpectedError,\n    assertSessions,\n    sendNode,\n    relayMessage,\n    sendReceipt,\n    uploadPreKeys,\n    sendPeerDataOperationMessage\n  } = sock;\n  /** this mutex ensures that each retryRequest will wait for the previous one to finish */\n  const retryMutex = (0, make_mutex_1.makeMutex)();\n  const msgRetryCache = config.msgRetryCounterCache || new node_cache_1.default({\n    stdTTL: Defaults_1.DEFAULT_CACHE_TTLS.MSG_RETRY,\n    useClones: false\n  });\n  const callOfferCache = config.callOfferCache || new node_cache_1.default({\n    stdTTL: Defaults_1.DEFAULT_CACHE_TTLS.CALL_OFFER,\n    useClones: false\n  });\n  const placeholderResendCache = config.placeholderResendCache || new node_cache_1.default({\n    stdTTL: Defaults_1.DEFAULT_CACHE_TTLS.MSG_RETRY,\n    useClones: false\n  });\n  let sendActiveReceipts = false;\n  const sendMessageAck = async ({\n    tag,\n    attrs,\n    content\n  }) => {\n    const stanza = {\n      tag: 'ack',\n      attrs: {\n        id: attrs.id,\n        to: attrs.from,\n        class: tag\n      }\n    };\n    if (!!attrs.participant) {\n      stanza.attrs.participant = attrs.participant;\n    }\n    if (!!attrs.recipient) {\n      stanza.attrs.recipient = attrs.recipient;\n    }\n    if (!!attrs.type && (tag !== 'message' || (0, WABinary_1.getBinaryNodeChild)({\n      tag,\n      attrs,\n      content\n    }, 'unavailable'))) {\n      stanza.attrs.type = attrs.type;\n    }\n    if (tag === 'message' && (0, WABinary_1.getBinaryNodeChild)({\n      tag,\n      attrs,\n      content\n    }, 'unavailable')) {\n      stanza.attrs.from = authState.creds.me.id;\n    }\n    logger.debug({\n      recv: {\n        tag,\n        attrs\n      },\n      sent: stanza.attrs\n    }, 'sent ack');\n    await sendNode(stanza);\n  };\n  const rejectCall = async (callId, callFrom) => {\n    const stanza = {\n      tag: 'call',\n      attrs: {\n        from: authState.creds.me.id,\n        to: callFrom\n      },\n      content: [{\n        tag: 'reject',\n        attrs: {\n          'call-id': callId,\n          'call-creator': callFrom,\n          count: '0'\n        },\n        content: undefined\n      }]\n    };\n    await query(stanza);\n  };\n  const sendRetryRequest = async (node, forceIncludeKeys = false) => {\n    const {\n      fullMessage\n    } = (0, Utils_1.decodeMessageNode)(node, authState.creds.me.id, authState.creds.me.lid || '');\n    const {\n      key: msgKey\n    } = fullMessage;\n    const msgId = msgKey.id;\n    const key = `${msgId}:${msgKey === null || msgKey === void 0 ? void 0 : msgKey.participant}`;\n    let retryCount = msgRetryCache.get(key) || 0;\n    if (retryCount >= maxMsgRetryCount) {\n      logger.debug({\n        retryCount,\n        msgId\n      }, 'reached retry limit, clearing');\n      msgRetryCache.del(key);\n      return;\n    }\n    retryCount += 1;\n    msgRetryCache.set(key, retryCount);\n    const {\n      account,\n      signedPreKey,\n      signedIdentityKey: identityKey\n    } = authState.creds;\n    if (retryCount === 1) {\n      //request a resend via phone\n      const msgId = await requestPlaceholderResend(msgKey);\n      logger.debug(`sendRetryRequest: requested placeholder resend for message ${msgId}`);\n    }\n    const deviceIdentity = (0, Utils_1.encodeSignedDeviceIdentity)(account, true);\n    await authState.keys.transaction(async () => {\n      const receipt = {\n        tag: 'receipt',\n        attrs: {\n          id: msgId,\n          type: 'retry',\n          to: node.attrs.from\n        },\n        content: [{\n          tag: 'retry',\n          attrs: {\n            count: retryCount.toString(),\n            id: node.attrs.id,\n            t: node.attrs.t,\n            v: '1'\n          }\n        }, {\n          tag: 'registration',\n          attrs: {},\n          content: (0, Utils_1.encodeBigEndian)(authState.creds.registrationId)\n        }]\n      };\n      if (node.attrs.recipient) {\n        receipt.attrs.recipient = node.attrs.recipient;\n      }\n      if (node.attrs.participant) {\n        receipt.attrs.participant = node.attrs.participant;\n      }\n      if (retryCount > 1 || forceIncludeKeys) {\n        const {\n          update,\n          preKeys\n        } = await (0, Utils_1.getNextPreKeys)(authState, 1);\n        const [keyId] = Object.keys(preKeys);\n        const key = preKeys[+keyId];\n        const content = receipt.content;\n        content.push({\n          tag: 'keys',\n          attrs: {},\n          content: [{\n            tag: 'type',\n            attrs: {},\n            content: Buffer.from(Defaults_1.KEY_BUNDLE_TYPE)\n          }, {\n            tag: 'identity',\n            attrs: {},\n            content: identityKey.public\n          }, (0, Utils_1.xmppPreKey)(key, +keyId), (0, Utils_1.xmppSignedPreKey)(signedPreKey), {\n            tag: 'device-identity',\n            attrs: {},\n            content: deviceIdentity\n          }]\n        });\n        ev.emit('creds.update', update);\n      }\n      await sendNode(receipt);\n      logger.info({\n        msgAttrs: node.attrs,\n        retryCount\n      }, 'sent retry receipt');\n    });\n  };\n  const handleEncryptNotification = async node => {\n    const from = node.attrs.from;\n    if (from === WABinary_1.S_WHATSAPP_NET) {\n      const countChild = (0, WABinary_1.getBinaryNodeChild)(node, 'count');\n      const count = +countChild.attrs.value;\n      const shouldUploadMorePreKeys = count < Defaults_1.MIN_PREKEY_COUNT;\n      logger.debug({\n        count,\n        shouldUploadMorePreKeys\n      }, 'recv pre-key count');\n      if (shouldUploadMorePreKeys) {\n        await uploadPreKeys();\n      }\n    } else {\n      const identityNode = (0, WABinary_1.getBinaryNodeChild)(node, 'identity');\n      if (identityNode) {\n        logger.info({\n          jid: from\n        }, 'identity changed');\n        // not handling right now\n        // signal will override new identity anyway\n      } else {\n        logger.info({\n          node\n        }, 'unknown encrypt notification');\n      }\n    }\n  };\n  const handleGroupNotification = (participant, child, msg) => {\n    var _a, _b, _c, _d;\n    const participantJid = ((_b = (_a = (0, WABinary_1.getBinaryNodeChild)(child, 'participant')) === null || _a === void 0 ? void 0 : _a.attrs) === null || _b === void 0 ? void 0 : _b.jid) || participant;\n    switch (child === null || child === void 0 ? void 0 : child.tag) {\n      case 'create':\n        const metadata = (0, groups_1.extractGroupMetadata)(child);\n        msg.messageStubType = Types_1.WAMessageStubType.GROUP_CREATE;\n        msg.messageStubParameters = [metadata.subject];\n        msg.key = {\n          participant: metadata.owner\n        };\n        ev.emit('chats.upsert', [{\n          id: metadata.id,\n          name: metadata.subject,\n          conversationTimestamp: metadata.creation\n        }]);\n        ev.emit('groups.upsert', [{\n          ...metadata,\n          author: participant\n        }]);\n        break;\n      case 'ephemeral':\n      case 'not_ephemeral':\n        msg.message = {\n          protocolMessage: {\n            type: WAProto_1.proto.Message.ProtocolMessage.Type.EPHEMERAL_SETTING,\n            ephemeralExpiration: +(child.attrs.expiration || 0)\n          }\n        };\n        break;\n      case 'modify':\n        const oldNumber = (0, WABinary_1.getBinaryNodeChildren)(child, 'participant').map(p => p.attrs.jid);\n        msg.messageStubParameters = oldNumber || [];\n        msg.messageStubType = Types_1.WAMessageStubType.GROUP_PARTICIPANT_CHANGE_NUMBER;\n        break;\n      case 'promote':\n      case 'demote':\n      case 'remove':\n      case 'add':\n      case 'leave':\n        const stubType = `GROUP_PARTICIPANT_${child.tag.toUpperCase()}`;\n        msg.messageStubType = Types_1.WAMessageStubType[stubType];\n        const participants = (0, WABinary_1.getBinaryNodeChildren)(child, 'participant').map(p => p.attrs.jid);\n        if (participants.length === 1 &&\n        // if recv. \"remove\" message and sender removed themselves\n        // mark as left\n        (0, WABinary_1.areJidsSameUser)(participants[0], participant) && child.tag === 'remove') {\n          msg.messageStubType = Types_1.WAMessageStubType.GROUP_PARTICIPANT_LEAVE;\n        }\n        msg.messageStubParameters = participants;\n        break;\n      case 'subject':\n        msg.messageStubType = Types_1.WAMessageStubType.GROUP_CHANGE_SUBJECT;\n        msg.messageStubParameters = [child.attrs.subject];\n        break;\n      case 'description':\n        const description = (_d = (_c = (0, WABinary_1.getBinaryNodeChild)(child, 'body')) === null || _c === void 0 ? void 0 : _c.content) === null || _d === void 0 ? void 0 : _d.toString();\n        msg.messageStubType = Types_1.WAMessageStubType.GROUP_CHANGE_DESCRIPTION;\n        msg.messageStubParameters = description ? [description] : undefined;\n        break;\n      case 'announcement':\n      case 'not_announcement':\n        msg.messageStubType = Types_1.WAMessageStubType.GROUP_CHANGE_ANNOUNCE;\n        msg.messageStubParameters = [child.tag === 'announcement' ? 'on' : 'off'];\n        break;\n      case 'locked':\n      case 'unlocked':\n        msg.messageStubType = Types_1.WAMessageStubType.GROUP_CHANGE_RESTRICT;\n        msg.messageStubParameters = [child.tag === 'locked' ? 'on' : 'off'];\n        break;\n      case 'invite':\n        msg.messageStubType = Types_1.WAMessageStubType.GROUP_CHANGE_INVITE_LINK;\n        msg.messageStubParameters = [child.attrs.code];\n        break;\n      case 'member_add_mode':\n        const addMode = child.content;\n        if (addMode) {\n          msg.messageStubType = Types_1.WAMessageStubType.GROUP_MEMBER_ADD_MODE;\n          msg.messageStubParameters = [addMode.toString()];\n        }\n        break;\n      case 'membership_approval_mode':\n        const approvalMode = (0, WABinary_1.getBinaryNodeChild)(child, 'group_join');\n        if (approvalMode) {\n          msg.messageStubType = Types_1.WAMessageStubType.GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE;\n          msg.messageStubParameters = [approvalMode.attrs.state];\n        }\n        break;\n      case 'created_membership_requests':\n        msg.messageStubType = Types_1.WAMessageStubType.GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST_NON_ADMIN_ADD;\n        msg.messageStubParameters = [participantJid, 'created', child.attrs.request_method];\n        break;\n      case 'revoked_membership_requests':\n        const isDenied = (0, WABinary_1.areJidsSameUser)(participantJid, participant);\n        msg.messageStubType = Types_1.WAMessageStubType.GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST_NON_ADMIN_ADD;\n        msg.messageStubParameters = [participantJid, isDenied ? 'revoked' : 'rejected'];\n        break;\n    }\n  };\n  const processNotification = async node => {\n    var _a, _b, _c;\n    const result = {};\n    const [child] = (0, WABinary_1.getAllBinaryNodeChildren)(node);\n    const nodeType = node.attrs.type;\n    const from = (0, WABinary_1.jidNormalizedUser)(node.attrs.from);\n    switch (nodeType) {\n      case 'privacy_token':\n        const tokenList = (0, WABinary_1.getBinaryNodeChildren)(child, 'token');\n        for (const {\n          attrs,\n          content\n        } of tokenList) {\n          const jid = attrs.jid;\n          ev.emit('chats.update', [{\n            id: jid,\n            tcToken: content\n          }]);\n          logger.debug({\n            jid\n          }, 'got privacy token update');\n        }\n        break;\n      case 'w:gp2':\n        handleGroupNotification(node.attrs.participant, child, result);\n        break;\n      case 'mediaretry':\n        const event = (0, Utils_1.decodeMediaRetryNode)(node);\n        ev.emit('messages.media-update', [event]);\n        break;\n      case 'encrypt':\n        await handleEncryptNotification(node);\n        break;\n      case 'devices':\n        const devices = (0, WABinary_1.getBinaryNodeChildren)(child, 'device');\n        if ((0, WABinary_1.areJidsSameUser)(child.attrs.jid, authState.creds.me.id)) {\n          const deviceJids = devices.map(d => d.attrs.jid);\n          logger.info({\n            deviceJids\n          }, 'got my own devices');\n        }\n        break;\n      case 'server_sync':\n        const update = (0, WABinary_1.getBinaryNodeChild)(node, 'collection');\n        if (update) {\n          const name = update.attrs.name;\n          await resyncAppState([name], false);\n        }\n        break;\n      case 'picture':\n        const setPicture = (0, WABinary_1.getBinaryNodeChild)(node, 'set');\n        const delPicture = (0, WABinary_1.getBinaryNodeChild)(node, 'delete');\n        ev.emit('contacts.update', [{\n          id: (0, WABinary_1.jidNormalizedUser)((_a = node === null || node === void 0 ? void 0 : node.attrs) === null || _a === void 0 ? void 0 : _a.from) || ((_c = (_b = setPicture || delPicture) === null || _b === void 0 ? void 0 : _b.attrs) === null || _c === void 0 ? void 0 : _c.hash) || '',\n          imgUrl: setPicture ? 'changed' : 'removed'\n        }]);\n        if ((0, WABinary_1.isJidGroup)(from)) {\n          const node = setPicture || delPicture;\n          result.messageStubType = Types_1.WAMessageStubType.GROUP_CHANGE_ICON;\n          if (setPicture) {\n            result.messageStubParameters = [setPicture.attrs.id];\n          }\n          result.participant = node === null || node === void 0 ? void 0 : node.attrs.author;\n          result.key = {\n            ...(result.key || {}),\n            participant: setPicture === null || setPicture === void 0 ? void 0 : setPicture.attrs.author\n          };\n        }\n        break;\n      case 'account_sync':\n        if (child.tag === 'disappearing_mode') {\n          const newDuration = +child.attrs.duration;\n          const timestamp = +child.attrs.t;\n          logger.info({\n            newDuration\n          }, 'updated account disappearing mode');\n          ev.emit('creds.update', {\n            accountSettings: {\n              ...authState.creds.accountSettings,\n              defaultDisappearingMode: {\n                ephemeralExpiration: newDuration,\n                ephemeralSettingTimestamp: timestamp\n              }\n            }\n          });\n        } else if (child.tag === 'blocklist') {\n          const blocklists = (0, WABinary_1.getBinaryNodeChildren)(child, 'item');\n          for (const {\n            attrs\n          } of blocklists) {\n            const blocklist = [attrs.jid];\n            const type = attrs.action === 'block' ? 'add' : 'remove';\n            ev.emit('blocklist.update', {\n              blocklist,\n              type\n            });\n          }\n        }\n        break;\n      case 'link_code_companion_reg':\n        const linkCodeCompanionReg = (0, WABinary_1.getBinaryNodeChild)(node, 'link_code_companion_reg');\n        const ref = toRequiredBuffer((0, WABinary_1.getBinaryNodeChildBuffer)(linkCodeCompanionReg, 'link_code_pairing_ref'));\n        const primaryIdentityPublicKey = toRequiredBuffer((0, WABinary_1.getBinaryNodeChildBuffer)(linkCodeCompanionReg, 'primary_identity_pub'));\n        const primaryEphemeralPublicKeyWrapped = toRequiredBuffer((0, WABinary_1.getBinaryNodeChildBuffer)(linkCodeCompanionReg, 'link_code_pairing_wrapped_primary_ephemeral_pub'));\n        const codePairingPublicKey = await decipherLinkPublicKey(primaryEphemeralPublicKeyWrapped);\n        const companionSharedKey = Utils_1.Curve.sharedKey(authState.creds.pairingEphemeralKeyPair.private, codePairingPublicKey);\n        const random = (0, crypto_1.randomBytes)(32);\n        const linkCodeSalt = (0, crypto_1.randomBytes)(32);\n        const linkCodePairingExpanded = (0, Utils_1.hkdf)(companionSharedKey, 32, {\n          salt: linkCodeSalt,\n          info: 'link_code_pairing_key_bundle_encryption_key'\n        });\n        const encryptPayload = Buffer.concat([Buffer.from(authState.creds.signedIdentityKey.public), primaryIdentityPublicKey, random]);\n        const encryptIv = (0, crypto_1.randomBytes)(12);\n        const encrypted = (0, Utils_1.aesEncryptGCM)(encryptPayload, linkCodePairingExpanded, encryptIv, Buffer.alloc(0));\n        const encryptedPayload = Buffer.concat([linkCodeSalt, encryptIv, encrypted]);\n        const identitySharedKey = Utils_1.Curve.sharedKey(authState.creds.signedIdentityKey.private, primaryIdentityPublicKey);\n        const identityPayload = Buffer.concat([companionSharedKey, identitySharedKey, random]);\n        authState.creds.advSecretKey = (0, Utils_1.hkdf)(identityPayload, 32, {\n          info: 'adv_secret'\n        }).toString('base64');\n        await query({\n          tag: 'iq',\n          attrs: {\n            to: WABinary_1.S_WHATSAPP_NET,\n            type: 'set',\n            id: sock.generateMessageTag(),\n            xmlns: 'md'\n          },\n          content: [{\n            tag: 'link_code_companion_reg',\n            attrs: {\n              jid: authState.creds.me.id,\n              stage: 'companion_finish'\n            },\n            content: [{\n              tag: 'link_code_pairing_wrapped_key_bundle',\n              attrs: {},\n              content: encryptedPayload\n            }, {\n              tag: 'companion_identity_public',\n              attrs: {},\n              content: authState.creds.signedIdentityKey.public\n            }, {\n              tag: 'link_code_pairing_ref',\n              attrs: {},\n              content: ref\n            }]\n          }]\n        });\n        authState.creds.registered = true;\n        ev.emit('creds.update', authState.creds);\n    }\n    if (Object.keys(result).length) {\n      return result;\n    }\n  };\n  async function decipherLinkPublicKey(data) {\n    const buffer = toRequiredBuffer(data);\n    const salt = buffer.slice(0, 32);\n    const secretKey = await (0, Utils_1.derivePairingCodeKey)(authState.creds.pairingCode, salt);\n    const iv = buffer.slice(32, 48);\n    const payload = buffer.slice(48, 80);\n    return (0, Utils_1.aesDecryptCTR)(payload, secretKey, iv);\n  }\n  function toRequiredBuffer(data) {\n    if (data === undefined) {\n      throw new boom_1.Boom('Invalid buffer', {\n        statusCode: 400\n      });\n    }\n    return data instanceof Buffer ? data : Buffer.from(data);\n  }\n  const willSendMessageAgain = (id, participant) => {\n    const key = `${id}:${participant}`;\n    const retryCount = msgRetryCache.get(key) || 0;\n    return retryCount < maxMsgRetryCount;\n  };\n  const updateSendMessageAgainCount = (id, participant) => {\n    const key = `${id}:${participant}`;\n    const newValue = (msgRetryCache.get(key) || 0) + 1;\n    msgRetryCache.set(key, newValue);\n  };\n  const sendMessagesAgain = async (key, ids, retryNode) => {\n    var _a;\n    const msgs = await Promise.all(ids.map(id => getMessage({\n      ...key,\n      id\n    })));\n    const remoteJid = key.remoteJid;\n    const participant = key.participant || remoteJid;\n    // if it's the primary jid sending the request\n    // just re-send the message to everyone\n    // prevents the first message decryption failure\n    const sendToAll = !((_a = (0, WABinary_1.jidDecode)(participant)) === null || _a === void 0 ? void 0 : _a.device);\n    await assertSessions([participant], true);\n    if ((0, WABinary_1.isJidGroup)(remoteJid)) {\n      await authState.keys.set({\n        'sender-key-memory': {\n          [remoteJid]: null\n        }\n      });\n    }\n    logger.debug({\n      participant,\n      sendToAll\n    }, 'forced new session for retry recp');\n    for (let i = 0; i < msgs.length; i++) {\n      const msg = msgs[i];\n      if (msg) {\n        updateSendMessageAgainCount(ids[i], participant);\n        const msgRelayOpts = {\n          messageId: ids[i]\n        };\n        if (sendToAll) {\n          msgRelayOpts.useUserDevicesCache = false;\n        } else {\n          msgRelayOpts.participant = {\n            jid: participant,\n            count: +retryNode.attrs.count\n          };\n        }\n        await relayMessage(key.remoteJid, msg, msgRelayOpts);\n      } else {\n        logger.debug({\n          jid: key.remoteJid,\n          id: ids[i]\n        }, 'recv retry request, but message not available');\n      }\n    }\n  };\n  const handleReceipt = async node => {\n    var _a, _b;\n    const {\n      attrs,\n      content\n    } = node;\n    const isLid = attrs.from.includes('lid');\n    const isNodeFromMe = (0, WABinary_1.areJidsSameUser)(attrs.participant || attrs.from, isLid ? (_a = authState.creds.me) === null || _a === void 0 ? void 0 : _a.lid : (_b = authState.creds.me) === null || _b === void 0 ? void 0 : _b.id);\n    const remoteJid = !isNodeFromMe || (0, WABinary_1.isJidGroup)(attrs.from) ? attrs.from : attrs.recipient;\n    const fromMe = !attrs.recipient || attrs.type === 'retry' && isNodeFromMe;\n    const key = {\n      remoteJid,\n      id: '',\n      fromMe,\n      participant: attrs.participant\n    };\n    if (shouldIgnoreJid(remoteJid) && remoteJid !== '@s.whatsapp.net') {\n      logger.debug({\n        remoteJid\n      }, 'ignoring receipt from jid');\n      await sendMessageAck(node);\n      return;\n    }\n    const ids = [attrs.id];\n    if (Array.isArray(content)) {\n      const items = (0, WABinary_1.getBinaryNodeChildren)(content[0], 'item');\n      ids.push(...items.map(i => i.attrs.id));\n    }\n    try {\n      await Promise.all([processingMutex.mutex(async () => {\n        const status = (0, Utils_1.getStatusFromReceiptType)(attrs.type);\n        if (typeof status !== 'undefined' && (\n        // basically, we only want to know when a message from us has been delivered to/read by the other person\n        // or another device of ours has read some messages\n        status > WAProto_1.proto.WebMessageInfo.Status.DELIVERY_ACK || !isNodeFromMe)) {\n          if ((0, WABinary_1.isJidGroup)(remoteJid) || (0, WABinary_1.isJidStatusBroadcast)(remoteJid)) {\n            if (attrs.participant) {\n              const updateKey = status === WAProto_1.proto.WebMessageInfo.Status.DELIVERY_ACK ? 'receiptTimestamp' : 'readTimestamp';\n              ev.emit('message-receipt.update', ids.map(id => ({\n                key: {\n                  ...key,\n                  id\n                },\n                receipt: {\n                  userJid: (0, WABinary_1.jidNormalizedUser)(attrs.participant),\n                  [updateKey]: +attrs.t\n                }\n              })));\n            }\n          } else {\n            ev.emit('messages.update', ids.map(id => ({\n              key: {\n                ...key,\n                id\n              },\n              update: {\n                status\n              }\n            })));\n          }\n        }\n        if (attrs.type === 'retry') {\n          // correctly set who is asking for the retry\n          key.participant = key.participant || attrs.from;\n          const retryNode = (0, WABinary_1.getBinaryNodeChild)(node, 'retry');\n          if (willSendMessageAgain(ids[0], key.participant)) {\n            if (key.fromMe) {\n              try {\n                logger.debug({\n                  attrs,\n                  key\n                }, 'recv retry request');\n                await sendMessagesAgain(key, ids, retryNode);\n              } catch (error) {\n                logger.error({\n                  key,\n                  ids,\n                  trace: error.stack\n                }, 'error in sending message again');\n              }\n            } else {\n              logger.info({\n                attrs,\n                key\n              }, 'recv retry for not fromMe message');\n            }\n          } else {\n            logger.info({\n              attrs,\n              key\n            }, 'will not send message again, as sent too many times');\n          }\n        }\n      })]);\n    } finally {\n      await sendMessageAck(node);\n    }\n  };\n  const handleNotification = async node => {\n    const remoteJid = node.attrs.from;\n    if (shouldIgnoreJid(remoteJid) && remoteJid !== '@s.whatsapp.net') {\n      logger.debug({\n        remoteJid,\n        id: node.attrs.id\n      }, 'ignored notification');\n      await sendMessageAck(node);\n      return;\n    }\n    try {\n      await Promise.all([processingMutex.mutex(async () => {\n        var _a;\n        const msg = await processNotification(node);\n        if (msg) {\n          const fromMe = (0, WABinary_1.areJidsSameUser)(node.attrs.participant || remoteJid, authState.creds.me.id);\n          msg.key = {\n            remoteJid,\n            fromMe,\n            participant: node.attrs.participant,\n            id: node.attrs.id,\n            ...(msg.key || {})\n          };\n          (_a = msg.participant) !== null && _a !== void 0 ? _a : msg.participant = node.attrs.participant;\n          msg.messageTimestamp = +node.attrs.t;\n          const fullMsg = WAProto_1.proto.WebMessageInfo.fromObject(msg);\n          await upsertMessage(fullMsg, 'append');\n        }\n      })]);\n    } finally {\n      await sendMessageAck(node);\n    }\n  };\n  const handleMessage = async node => {\n    var _a, _b, _c;\n    if (shouldIgnoreJid(node.attrs.from) && node.attrs.from !== '@s.whatsapp.net') {\n      logger.debug({\n        key: node.attrs.key\n      }, 'ignored message');\n      await sendMessageAck(node);\n      return;\n    }\n    let response;\n    if ((0, WABinary_1.getBinaryNodeChild)(node, 'unavailable') && !(0, WABinary_1.getBinaryNodeChild)(node, 'enc')) {\n      await sendMessageAck(node);\n      const {\n        key\n      } = (0, Utils_1.decodeMessageNode)(node, authState.creds.me.id, authState.creds.me.lid || '').fullMessage;\n      response = await requestPlaceholderResend(key);\n      if (response === 'RESOLVED') {\n        return;\n      }\n      logger.debug('received unavailable message, acked and requested resend from phone');\n    } else {\n      if (placeholderResendCache.get(node.attrs.id)) {\n        placeholderResendCache.del(node.attrs.id);\n      }\n    }\n    const {\n      fullMessage: msg,\n      category,\n      author,\n      decrypt\n    } = (0, Utils_1.decryptMessageNode)(node, authState.creds.me.id, authState.creds.me.lid || '', signalRepository, logger);\n    if (response && ((_a = msg === null || msg === void 0 ? void 0 : msg.messageStubParameters) === null || _a === void 0 ? void 0 : _a[0]) === Utils_1.NO_MESSAGE_FOUND_ERROR_TEXT) {\n      msg.messageStubParameters = [Utils_1.NO_MESSAGE_FOUND_ERROR_TEXT, response];\n    }\n    if (((_c = (_b = msg.message) === null || _b === void 0 ? void 0 : _b.protocolMessage) === null || _c === void 0 ? void 0 : _c.type) === WAProto_1.proto.Message.ProtocolMessage.Type.SHARE_PHONE_NUMBER) {\n      if (node.attrs.sender_pn) {\n        ev.emit('chats.phoneNumberShare', {\n          lid: node.attrs.from,\n          jid: node.attrs.sender_pn\n        });\n      }\n    }\n    try {\n      await Promise.all([processingMutex.mutex(async () => {\n        await decrypt();\n        // message failed to decrypt\n        if (msg.messageStubType === WAProto_1.proto.WebMessageInfo.StubType.CIPHERTEXT) {\n          retryMutex.mutex(async () => {\n            if (ws.isOpen) {\n              if ((0, WABinary_1.getBinaryNodeChild)(node, 'unavailable')) {\n                return;\n              }\n              const encNode = (0, WABinary_1.getBinaryNodeChild)(node, 'enc');\n              await sendRetryRequest(node, !encNode);\n              if (retryRequestDelayMs) {\n                await (0, Utils_1.delay)(retryRequestDelayMs);\n              }\n            } else {\n              logger.debug({\n                node\n              }, 'connection closed, ignoring retry req');\n            }\n          });\n        } else {\n          // no type in the receipt => message delivered\n          let type = undefined;\n          let participant = msg.key.participant;\n          if (category === 'peer') {\n            // special peer message\n            type = 'peer_msg';\n          } else if (msg.key.fromMe) {\n            // message was sent by us from a different device\n            type = 'sender';\n            // need to specially handle this case\n            if ((0, WABinary_1.isJidUser)(msg.key.remoteJid)) {\n              participant = author;\n            }\n          } else if (!sendActiveReceipts) {\n            type = 'inactive';\n          }\n          await sendReceipt(msg.key.remoteJid, participant, [msg.key.id], type);\n          // send ack for history message\n          const isAnyHistoryMsg = (0, Utils_1.getHistoryMsg)(msg.message);\n          if (isAnyHistoryMsg) {\n            const jid = (0, WABinary_1.jidNormalizedUser)(msg.key.remoteJid);\n            await sendReceipt(jid, undefined, [msg.key.id], 'hist_sync');\n          }\n        }\n        (0, Utils_2.cleanMessage)(msg, authState.creds.me.id);\n        await upsertMessage(msg, node.attrs.offline ? 'append' : 'notify');\n      })]);\n    } finally {\n      await sendMessageAck(node);\n    }\n  };\n  const fetchMessageHistory = async (count, oldestMsgKey, oldestMsgTimestamp) => {\n    var _a;\n    if (!((_a = authState.creds.me) === null || _a === void 0 ? void 0 : _a.id)) {\n      throw new boom_1.Boom('Not authenticated');\n    }\n    const pdoMessage = {\n      historySyncOnDemandRequest: {\n        chatJid: oldestMsgKey.remoteJid,\n        oldestMsgFromMe: oldestMsgKey.fromMe,\n        oldestMsgId: oldestMsgKey.id,\n        oldestMsgTimestampMs: oldestMsgTimestamp,\n        onDemandMsgCount: count\n      },\n      peerDataOperationRequestType: WAProto_1.proto.Message.PeerDataOperationRequestType.HISTORY_SYNC_ON_DEMAND\n    };\n    return sendPeerDataOperationMessage(pdoMessage);\n  };\n  const requestPlaceholderResend = async messageKey => {\n    var _a;\n    if (!((_a = authState.creds.me) === null || _a === void 0 ? void 0 : _a.id)) {\n      throw new boom_1.Boom('Not authenticated');\n    }\n    if (placeholderResendCache.get(messageKey === null || messageKey === void 0 ? void 0 : messageKey.id)) {\n      logger.debug('already requested resend', {\n        messageKey\n      });\n      return;\n    } else {\n      placeholderResendCache.set(messageKey === null || messageKey === void 0 ? void 0 : messageKey.id, true);\n    }\n    await (0, Utils_1.delay)(5000);\n    if (!placeholderResendCache.get(messageKey === null || messageKey === void 0 ? void 0 : messageKey.id)) {\n      logger.debug('message received while resend requested', {\n        messageKey\n      });\n      return 'RESOLVED';\n    }\n    const pdoMessage = {\n      placeholderMessageResendRequest: [{\n        messageKey\n      }],\n      peerDataOperationRequestType: WAProto_1.proto.Message.PeerDataOperationRequestType.PLACEHOLDER_MESSAGE_RESEND\n    };\n    setTimeout(() => {\n      if (placeholderResendCache.get(messageKey === null || messageKey === void 0 ? void 0 : messageKey.id)) {\n        logger.debug('PDO message without response after 15 seconds. Phone possibly offline', {\n          messageKey\n        });\n        placeholderResendCache.del(messageKey === null || messageKey === void 0 ? void 0 : messageKey.id);\n      }\n    }, 15000);\n    return sendPeerDataOperationMessage(pdoMessage);\n  };\n  const handleCall = async node => {\n    const {\n      attrs\n    } = node;\n    const [infoChild] = (0, WABinary_1.getAllBinaryNodeChildren)(node);\n    const callId = infoChild.attrs['call-id'];\n    const from = infoChild.attrs.from || infoChild.attrs['call-creator'];\n    const status = (0, Utils_1.getCallStatusFromNode)(infoChild);\n    const call = {\n      chatId: attrs.from,\n      from,\n      id: callId,\n      date: new Date(+attrs.t * 1000),\n      offline: !!attrs.offline,\n      status\n    };\n    if (status === 'offer') {\n      call.isVideo = !!(0, WABinary_1.getBinaryNodeChild)(infoChild, 'video');\n      call.isGroup = infoChild.attrs.type === 'group' || !!infoChild.attrs['group-jid'];\n      call.groupJid = infoChild.attrs['group-jid'];\n      callOfferCache.set(call.id, call);\n    }\n    const existingCall = callOfferCache.get(call.id);\n    // use existing call info to populate this event\n    if (existingCall) {\n      call.isVideo = existingCall.isVideo;\n      call.isGroup = existingCall.isGroup;\n    }\n    // delete data once call has ended\n    if (status === 'reject' || status === 'accept' || status === 'timeout' || status === 'terminate') {\n      callOfferCache.del(call.id);\n    }\n    ev.emit('call', [call]);\n    await sendMessageAck(node);\n  };\n  const handleBadAck = async ({\n    attrs\n  }) => {\n    const key = {\n      remoteJid: attrs.from,\n      fromMe: true,\n      id: attrs.id\n    };\n    // current hypothesis is that if pash is sent in the ack\n    // it means -- the message hasn't reached all devices yet\n    // we'll retry sending the message here\n    if (attrs.phash) {\n      logger.info({\n        attrs\n      }, 'received phash in ack, resending message...');\n      const msg = await getMessage(key);\n      if (msg) {\n        await relayMessage(key.remoteJid, msg, {\n          messageId: key.id,\n          useUserDevicesCache: false\n        });\n      } else {\n        logger.warn({\n          attrs\n        }, 'could not send message again, as it was not found');\n      }\n    }\n    // error in acknowledgement,\n    // device could not display the message\n    if (attrs.error) {\n      logger.warn({\n        attrs\n      }, 'received error in ack');\n      ev.emit('messages.update', [{\n        key,\n        update: {\n          status: Types_1.WAMessageStatus.ERROR,\n          messageStubParameters: [attrs.error]\n        }\n      }]);\n    }\n  };\n  /// processes a node with the given function\n  /// and adds the task to the existing buffer if we're buffering events\n  const processNodeWithBuffer = async (node, identifier, exec) => {\n    ev.buffer();\n    await execTask();\n    ev.flush();\n    function execTask() {\n      return exec(node).catch(err => onUnexpectedError(err, identifier));\n    }\n  };\n  // recv a message\n  ws.on('CB:message', node => {\n    processNodeWithBuffer(node, 'processing message', handleMessage);\n  });\n  ws.on('CB:call', async node => {\n    processNodeWithBuffer(node, 'handling call', handleCall);\n  });\n  ws.on('CB:receipt', node => {\n    processNodeWithBuffer(node, 'handling receipt', handleReceipt);\n  });\n  ws.on('CB:notification', async node => {\n    processNodeWithBuffer(node, 'handling notification', handleNotification);\n  });\n  ws.on('CB:ack,class:message', node => {\n    handleBadAck(node).catch(error => onUnexpectedError(error, 'handling bad ack'));\n  });\n  ev.on('call', ([call]) => {\n    // missed call + group call notification message generation\n    if (call.status === 'timeout' || call.status === 'offer' && call.isGroup) {\n      const msg = {\n        key: {\n          remoteJid: call.chatId,\n          id: call.id,\n          fromMe: false\n        },\n        messageTimestamp: (0, Utils_1.unixTimestampSeconds)(call.date)\n      };\n      if (call.status === 'timeout') {\n        if (call.isGroup) {\n          msg.messageStubType = call.isVideo ? Types_1.WAMessageStubType.CALL_MISSED_GROUP_VIDEO : Types_1.WAMessageStubType.CALL_MISSED_GROUP_VOICE;\n        } else {\n          msg.messageStubType = call.isVideo ? Types_1.WAMessageStubType.CALL_MISSED_VIDEO : Types_1.WAMessageStubType.CALL_MISSED_VOICE;\n        }\n      } else {\n        msg.message = {\n          call: {\n            callKey: Buffer.from(call.id)\n          }\n        };\n      }\n      const protoMsg = WAProto_1.proto.WebMessageInfo.fromObject(msg);\n      upsertMessage(protoMsg, call.offline ? 'append' : 'notify');\n    }\n  });\n  ev.on('connection.update', ({\n    isOnline\n  }) => {\n    if (typeof isOnline !== 'undefined') {\n      sendActiveReceipts = isOnline;\n      logger.trace(`sendActiveReceipts set to \"${sendActiveReceipts}\"`);\n    }\n  });\n  return {\n    ...sock,\n    sendMessageAck,\n    sendRetryRequest,\n    rejectCall,\n    fetchMessageHistory,\n    requestPlaceholderResend\n  };\n};\nexports.makeMessagesRecvSocket = makeMessagesRecvSocket;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","makeMessagesRecvSocket","boom_1","require","crypto_1","node_cache_1","WAProto_1","Defaults_1","Types_1","Utils_1","Utils_2","make_mutex_1","WABinary_1","groups_1","messages_send_1","config","logger","retryRequestDelayMs","maxMsgRetryCount","getMessage","shouldIgnoreJid","sock","makeMessagesSocket","ev","authState","ws","processingMutex","signalRepository","query","upsertMessage","resyncAppState","onUnexpectedError","assertSessions","sendNode","relayMessage","sendReceipt","uploadPreKeys","sendPeerDataOperationMessage","retryMutex","makeMutex","msgRetryCache","msgRetryCounterCache","default","stdTTL","DEFAULT_CACHE_TTLS","MSG_RETRY","useClones","callOfferCache","CALL_OFFER","placeholderResendCache","sendActiveReceipts","sendMessageAck","tag","attrs","content","stanza","id","to","from","class","participant","recipient","type","getBinaryNodeChild","creds","me","debug","recv","sent","rejectCall","callId","callFrom","count","undefined","sendRetryRequest","node","forceIncludeKeys","fullMessage","decodeMessageNode","lid","key","msgKey","msgId","retryCount","get","del","set","account","signedPreKey","signedIdentityKey","identityKey","requestPlaceholderResend","deviceIdentity","encodeSignedDeviceIdentity","keys","transaction","receipt","toString","t","v","encodeBigEndian","registrationId","update","preKeys","getNextPreKeys","keyId","push","Buffer","KEY_BUNDLE_TYPE","public","xmppPreKey","xmppSignedPreKey","emit","info","msgAttrs","handleEncryptNotification","S_WHATSAPP_NET","countChild","shouldUploadMorePreKeys","MIN_PREKEY_COUNT","identityNode","jid","handleGroupNotification","child","msg","_a","_b","_c","_d","participantJid","metadata","extractGroupMetadata","messageStubType","WAMessageStubType","GROUP_CREATE","messageStubParameters","subject","owner","name","conversationTimestamp","creation","author","message","protocolMessage","proto","Message","ProtocolMessage","Type","EPHEMERAL_SETTING","ephemeralExpiration","expiration","oldNumber","getBinaryNodeChildren","map","p","GROUP_PARTICIPANT_CHANGE_NUMBER","stubType","toUpperCase","participants","length","areJidsSameUser","GROUP_PARTICIPANT_LEAVE","GROUP_CHANGE_SUBJECT","description","GROUP_CHANGE_DESCRIPTION","GROUP_CHANGE_ANNOUNCE","GROUP_CHANGE_RESTRICT","GROUP_CHANGE_INVITE_LINK","code","addMode","GROUP_MEMBER_ADD_MODE","approvalMode","GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE","state","GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST_NON_ADMIN_ADD","request_method","isDenied","processNotification","result","getAllBinaryNodeChildren","nodeType","jidNormalizedUser","tokenList","tcToken","event","decodeMediaRetryNode","devices","deviceJids","d","setPicture","delPicture","hash","imgUrl","isJidGroup","GROUP_CHANGE_ICON","newDuration","duration","timestamp","accountSettings","defaultDisappearingMode","ephemeralSettingTimestamp","blocklists","blocklist","action","linkCodeCompanionReg","ref","toRequiredBuffer","getBinaryNodeChildBuffer","primaryIdentityPublicKey","primaryEphemeralPublicKeyWrapped","codePairingPublicKey","decipherLinkPublicKey","companionSharedKey","Curve","sharedKey","pairingEphemeralKeyPair","private","random","randomBytes","linkCodeSalt","linkCodePairingExpanded","hkdf","salt","encryptPayload","concat","encryptIv","encrypted","aesEncryptGCM","alloc","encryptedPayload","identitySharedKey","identityPayload","advSecretKey","generateMessageTag","xmlns","stage","registered","data","buffer","slice","secretKey","derivePairingCodeKey","pairingCode","iv","payload","aesDecryptCTR","Boom","statusCode","willSendMessageAgain","updateSendMessageAgainCount","newValue","sendMessagesAgain","ids","retryNode","msgs","Promise","all","remoteJid","sendToAll","jidDecode","device","i","msgRelayOpts","messageId","useUserDevicesCache","handleReceipt","isLid","includes","isNodeFromMe","fromMe","Array","isArray","items","mutex","status","getStatusFromReceiptType","WebMessageInfo","Status","DELIVERY_ACK","isJidStatusBroadcast","updateKey","userJid","error","trace","stack","handleNotification","messageTimestamp","fullMsg","fromObject","handleMessage","response","category","decrypt","decryptMessageNode","NO_MESSAGE_FOUND_ERROR_TEXT","SHARE_PHONE_NUMBER","sender_pn","StubType","CIPHERTEXT","isOpen","encNode","delay","isJidUser","isAnyHistoryMsg","getHistoryMsg","cleanMessage","offline","fetchMessageHistory","oldestMsgKey","oldestMsgTimestamp","pdoMessage","historySyncOnDemandRequest","chatJid","oldestMsgFromMe","oldestMsgId","oldestMsgTimestampMs","onDemandMsgCount","peerDataOperationRequestType","PeerDataOperationRequestType","HISTORY_SYNC_ON_DEMAND","messageKey","placeholderMessageResendRequest","PLACEHOLDER_MESSAGE_RESEND","setTimeout","handleCall","infoChild","getCallStatusFromNode","call","chatId","date","Date","isVideo","isGroup","groupJid","existingCall","handleBadAck","phash","warn","WAMessageStatus","ERROR","processNodeWithBuffer","identifier","exec","execTask","flush","catch","err","on","unixTimestampSeconds","CALL_MISSED_GROUP_VIDEO","CALL_MISSED_GROUP_VOICE","CALL_MISSED_VIDEO","CALL_MISSED_VOICE","callKey","protoMsg","isOnline"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Socket/messages-recv.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeMessagesRecvSocket = void 0;\nconst boom_1 = require(\"@hapi/boom\");\nconst crypto_1 = require(\"crypto\");\nconst node_cache_1 = __importDefault(require(\"node-cache\"));\nconst WAProto_1 = require(\"../../WAProto\");\nconst Defaults_1 = require(\"../Defaults\");\nconst Types_1 = require(\"../Types\");\nconst Utils_1 = require(\"../Utils\");\nconst Utils_2 = require(\"../Utils\");\nconst make_mutex_1 = require(\"../Utils/make-mutex\");\nconst WABinary_1 = require(\"../WABinary\");\nconst groups_1 = require(\"./groups\");\nconst messages_send_1 = require(\"./messages-send\");\nconst makeMessagesRecvSocket = (config) => {\n    const { logger, retryRequestDelayMs, maxMsgRetryCount, getMessage, shouldIgnoreJid } = config;\n    const sock = (0, messages_send_1.makeMessagesSocket)(config);\n    const { ev, authState, ws, processingMutex, signalRepository, query, upsertMessage, resyncAppState, onUnexpectedError, assertSessions, sendNode, relayMessage, sendReceipt, uploadPreKeys, sendPeerDataOperationMessage, } = sock;\n    /** this mutex ensures that each retryRequest will wait for the previous one to finish */\n    const retryMutex = (0, make_mutex_1.makeMutex)();\n    const msgRetryCache = config.msgRetryCounterCache || new node_cache_1.default({\n        stdTTL: Defaults_1.DEFAULT_CACHE_TTLS.MSG_RETRY,\n        useClones: false\n    });\n    const callOfferCache = config.callOfferCache || new node_cache_1.default({\n        stdTTL: Defaults_1.DEFAULT_CACHE_TTLS.CALL_OFFER,\n        useClones: false\n    });\n    const placeholderResendCache = config.placeholderResendCache || new node_cache_1.default({\n        stdTTL: Defaults_1.DEFAULT_CACHE_TTLS.MSG_RETRY,\n        useClones: false\n    });\n    let sendActiveReceipts = false;\n    const sendMessageAck = async ({ tag, attrs, content }) => {\n        const stanza = {\n            tag: 'ack',\n            attrs: {\n                id: attrs.id,\n                to: attrs.from,\n                class: tag,\n            }\n        };\n        if (!!attrs.participant) {\n            stanza.attrs.participant = attrs.participant;\n        }\n        if (!!attrs.recipient) {\n            stanza.attrs.recipient = attrs.recipient;\n        }\n        if (!!attrs.type && (tag !== 'message' || (0, WABinary_1.getBinaryNodeChild)({ tag, attrs, content }, 'unavailable'))) {\n            stanza.attrs.type = attrs.type;\n        }\n        if (tag === 'message' && (0, WABinary_1.getBinaryNodeChild)({ tag, attrs, content }, 'unavailable')) {\n            stanza.attrs.from = authState.creds.me.id;\n        }\n        logger.debug({ recv: { tag, attrs }, sent: stanza.attrs }, 'sent ack');\n        await sendNode(stanza);\n    };\n    const rejectCall = async (callId, callFrom) => {\n        const stanza = ({\n            tag: 'call',\n            attrs: {\n                from: authState.creds.me.id,\n                to: callFrom,\n            },\n            content: [{\n                    tag: 'reject',\n                    attrs: {\n                        'call-id': callId,\n                        'call-creator': callFrom,\n                        count: '0',\n                    },\n                    content: undefined,\n                }],\n        });\n        await query(stanza);\n    };\n    const sendRetryRequest = async (node, forceIncludeKeys = false) => {\n        const { fullMessage } = (0, Utils_1.decodeMessageNode)(node, authState.creds.me.id, authState.creds.me.lid || '');\n        const { key: msgKey } = fullMessage;\n        const msgId = msgKey.id;\n        const key = `${msgId}:${msgKey === null || msgKey === void 0 ? void 0 : msgKey.participant}`;\n        let retryCount = msgRetryCache.get(key) || 0;\n        if (retryCount >= maxMsgRetryCount) {\n            logger.debug({ retryCount, msgId }, 'reached retry limit, clearing');\n            msgRetryCache.del(key);\n            return;\n        }\n        retryCount += 1;\n        msgRetryCache.set(key, retryCount);\n        const { account, signedPreKey, signedIdentityKey: identityKey } = authState.creds;\n        if (retryCount === 1) {\n            //request a resend via phone\n            const msgId = await requestPlaceholderResend(msgKey);\n            logger.debug(`sendRetryRequest: requested placeholder resend for message ${msgId}`);\n        }\n        const deviceIdentity = (0, Utils_1.encodeSignedDeviceIdentity)(account, true);\n        await authState.keys.transaction(async () => {\n            const receipt = {\n                tag: 'receipt',\n                attrs: {\n                    id: msgId,\n                    type: 'retry',\n                    to: node.attrs.from\n                },\n                content: [\n                    {\n                        tag: 'retry',\n                        attrs: {\n                            count: retryCount.toString(),\n                            id: node.attrs.id,\n                            t: node.attrs.t,\n                            v: '1'\n                        }\n                    },\n                    {\n                        tag: 'registration',\n                        attrs: {},\n                        content: (0, Utils_1.encodeBigEndian)(authState.creds.registrationId)\n                    }\n                ]\n            };\n            if (node.attrs.recipient) {\n                receipt.attrs.recipient = node.attrs.recipient;\n            }\n            if (node.attrs.participant) {\n                receipt.attrs.participant = node.attrs.participant;\n            }\n            if (retryCount > 1 || forceIncludeKeys) {\n                const { update, preKeys } = await (0, Utils_1.getNextPreKeys)(authState, 1);\n                const [keyId] = Object.keys(preKeys);\n                const key = preKeys[+keyId];\n                const content = receipt.content;\n                content.push({\n                    tag: 'keys',\n                    attrs: {},\n                    content: [\n                        { tag: 'type', attrs: {}, content: Buffer.from(Defaults_1.KEY_BUNDLE_TYPE) },\n                        { tag: 'identity', attrs: {}, content: identityKey.public },\n                        (0, Utils_1.xmppPreKey)(key, +keyId),\n                        (0, Utils_1.xmppSignedPreKey)(signedPreKey),\n                        { tag: 'device-identity', attrs: {}, content: deviceIdentity }\n                    ]\n                });\n                ev.emit('creds.update', update);\n            }\n            await sendNode(receipt);\n            logger.info({ msgAttrs: node.attrs, retryCount }, 'sent retry receipt');\n        });\n    };\n    const handleEncryptNotification = async (node) => {\n        const from = node.attrs.from;\n        if (from === WABinary_1.S_WHATSAPP_NET) {\n            const countChild = (0, WABinary_1.getBinaryNodeChild)(node, 'count');\n            const count = +countChild.attrs.value;\n            const shouldUploadMorePreKeys = count < Defaults_1.MIN_PREKEY_COUNT;\n            logger.debug({ count, shouldUploadMorePreKeys }, 'recv pre-key count');\n            if (shouldUploadMorePreKeys) {\n                await uploadPreKeys();\n            }\n        }\n        else {\n            const identityNode = (0, WABinary_1.getBinaryNodeChild)(node, 'identity');\n            if (identityNode) {\n                logger.info({ jid: from }, 'identity changed');\n                // not handling right now\n                // signal will override new identity anyway\n            }\n            else {\n                logger.info({ node }, 'unknown encrypt notification');\n            }\n        }\n    };\n    const handleGroupNotification = (participant, child, msg) => {\n        var _a, _b, _c, _d;\n        const participantJid = ((_b = (_a = (0, WABinary_1.getBinaryNodeChild)(child, 'participant')) === null || _a === void 0 ? void 0 : _a.attrs) === null || _b === void 0 ? void 0 : _b.jid) || participant;\n        switch (child === null || child === void 0 ? void 0 : child.tag) {\n            case 'create':\n                const metadata = (0, groups_1.extractGroupMetadata)(child);\n                msg.messageStubType = Types_1.WAMessageStubType.GROUP_CREATE;\n                msg.messageStubParameters = [metadata.subject];\n                msg.key = { participant: metadata.owner };\n                ev.emit('chats.upsert', [{\n                        id: metadata.id,\n                        name: metadata.subject,\n                        conversationTimestamp: metadata.creation,\n                    }]);\n                ev.emit('groups.upsert', [{\n                        ...metadata,\n                        author: participant\n                    }]);\n                break;\n            case 'ephemeral':\n            case 'not_ephemeral':\n                msg.message = {\n                    protocolMessage: {\n                        type: WAProto_1.proto.Message.ProtocolMessage.Type.EPHEMERAL_SETTING,\n                        ephemeralExpiration: +(child.attrs.expiration || 0)\n                    }\n                };\n                break;\n            case 'modify':\n                const oldNumber = (0, WABinary_1.getBinaryNodeChildren)(child, 'participant').map(p => p.attrs.jid);\n                msg.messageStubParameters = oldNumber || [];\n                msg.messageStubType = Types_1.WAMessageStubType.GROUP_PARTICIPANT_CHANGE_NUMBER;\n                break;\n            case 'promote':\n            case 'demote':\n            case 'remove':\n            case 'add':\n            case 'leave':\n                const stubType = `GROUP_PARTICIPANT_${child.tag.toUpperCase()}`;\n                msg.messageStubType = Types_1.WAMessageStubType[stubType];\n                const participants = (0, WABinary_1.getBinaryNodeChildren)(child, 'participant').map(p => p.attrs.jid);\n                if (participants.length === 1 &&\n                    // if recv. \"remove\" message and sender removed themselves\n                    // mark as left\n                    (0, WABinary_1.areJidsSameUser)(participants[0], participant) &&\n                    child.tag === 'remove') {\n                    msg.messageStubType = Types_1.WAMessageStubType.GROUP_PARTICIPANT_LEAVE;\n                }\n                msg.messageStubParameters = participants;\n                break;\n            case 'subject':\n                msg.messageStubType = Types_1.WAMessageStubType.GROUP_CHANGE_SUBJECT;\n                msg.messageStubParameters = [child.attrs.subject];\n                break;\n            case 'description':\n                const description = (_d = (_c = (0, WABinary_1.getBinaryNodeChild)(child, 'body')) === null || _c === void 0 ? void 0 : _c.content) === null || _d === void 0 ? void 0 : _d.toString();\n                msg.messageStubType = Types_1.WAMessageStubType.GROUP_CHANGE_DESCRIPTION;\n                msg.messageStubParameters = description ? [description] : undefined;\n                break;\n            case 'announcement':\n            case 'not_announcement':\n                msg.messageStubType = Types_1.WAMessageStubType.GROUP_CHANGE_ANNOUNCE;\n                msg.messageStubParameters = [(child.tag === 'announcement') ? 'on' : 'off'];\n                break;\n            case 'locked':\n            case 'unlocked':\n                msg.messageStubType = Types_1.WAMessageStubType.GROUP_CHANGE_RESTRICT;\n                msg.messageStubParameters = [(child.tag === 'locked') ? 'on' : 'off'];\n                break;\n            case 'invite':\n                msg.messageStubType = Types_1.WAMessageStubType.GROUP_CHANGE_INVITE_LINK;\n                msg.messageStubParameters = [child.attrs.code];\n                break;\n            case 'member_add_mode':\n                const addMode = child.content;\n                if (addMode) {\n                    msg.messageStubType = Types_1.WAMessageStubType.GROUP_MEMBER_ADD_MODE;\n                    msg.messageStubParameters = [addMode.toString()];\n                }\n                break;\n            case 'membership_approval_mode':\n                const approvalMode = (0, WABinary_1.getBinaryNodeChild)(child, 'group_join');\n                if (approvalMode) {\n                    msg.messageStubType = Types_1.WAMessageStubType.GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE;\n                    msg.messageStubParameters = [approvalMode.attrs.state];\n                }\n                break;\n            case 'created_membership_requests':\n                msg.messageStubType = Types_1.WAMessageStubType.GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST_NON_ADMIN_ADD;\n                msg.messageStubParameters = [participantJid, 'created', child.attrs.request_method];\n                break;\n            case 'revoked_membership_requests':\n                const isDenied = (0, WABinary_1.areJidsSameUser)(participantJid, participant);\n                msg.messageStubType = Types_1.WAMessageStubType.GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST_NON_ADMIN_ADD;\n                msg.messageStubParameters = [participantJid, isDenied ? 'revoked' : 'rejected'];\n                break;\n        }\n    };\n    const processNotification = async (node) => {\n        var _a, _b, _c;\n        const result = {};\n        const [child] = (0, WABinary_1.getAllBinaryNodeChildren)(node);\n        const nodeType = node.attrs.type;\n        const from = (0, WABinary_1.jidNormalizedUser)(node.attrs.from);\n        switch (nodeType) {\n            case 'privacy_token':\n                const tokenList = (0, WABinary_1.getBinaryNodeChildren)(child, 'token');\n                for (const { attrs, content } of tokenList) {\n                    const jid = attrs.jid;\n                    ev.emit('chats.update', [\n                        {\n                            id: jid,\n                            tcToken: content\n                        }\n                    ]);\n                    logger.debug({ jid }, 'got privacy token update');\n                }\n                break;\n            case 'w:gp2':\n                handleGroupNotification(node.attrs.participant, child, result);\n                break;\n            case 'mediaretry':\n                const event = (0, Utils_1.decodeMediaRetryNode)(node);\n                ev.emit('messages.media-update', [event]);\n                break;\n            case 'encrypt':\n                await handleEncryptNotification(node);\n                break;\n            case 'devices':\n                const devices = (0, WABinary_1.getBinaryNodeChildren)(child, 'device');\n                if ((0, WABinary_1.areJidsSameUser)(child.attrs.jid, authState.creds.me.id)) {\n                    const deviceJids = devices.map(d => d.attrs.jid);\n                    logger.info({ deviceJids }, 'got my own devices');\n                }\n                break;\n            case 'server_sync':\n                const update = (0, WABinary_1.getBinaryNodeChild)(node, 'collection');\n                if (update) {\n                    const name = update.attrs.name;\n                    await resyncAppState([name], false);\n                }\n                break;\n            case 'picture':\n                const setPicture = (0, WABinary_1.getBinaryNodeChild)(node, 'set');\n                const delPicture = (0, WABinary_1.getBinaryNodeChild)(node, 'delete');\n                ev.emit('contacts.update', [{\n                        id: (0, WABinary_1.jidNormalizedUser)((_a = node === null || node === void 0 ? void 0 : node.attrs) === null || _a === void 0 ? void 0 : _a.from) || ((_c = (_b = (setPicture || delPicture)) === null || _b === void 0 ? void 0 : _b.attrs) === null || _c === void 0 ? void 0 : _c.hash) || '',\n                        imgUrl: setPicture ? 'changed' : 'removed'\n                    }]);\n                if ((0, WABinary_1.isJidGroup)(from)) {\n                    const node = setPicture || delPicture;\n                    result.messageStubType = Types_1.WAMessageStubType.GROUP_CHANGE_ICON;\n                    if (setPicture) {\n                        result.messageStubParameters = [setPicture.attrs.id];\n                    }\n                    result.participant = node === null || node === void 0 ? void 0 : node.attrs.author;\n                    result.key = {\n                        ...result.key || {},\n                        participant: setPicture === null || setPicture === void 0 ? void 0 : setPicture.attrs.author\n                    };\n                }\n                break;\n            case 'account_sync':\n                if (child.tag === 'disappearing_mode') {\n                    const newDuration = +child.attrs.duration;\n                    const timestamp = +child.attrs.t;\n                    logger.info({ newDuration }, 'updated account disappearing mode');\n                    ev.emit('creds.update', {\n                        accountSettings: {\n                            ...authState.creds.accountSettings,\n                            defaultDisappearingMode: {\n                                ephemeralExpiration: newDuration,\n                                ephemeralSettingTimestamp: timestamp,\n                            },\n                        }\n                    });\n                }\n                else if (child.tag === 'blocklist') {\n                    const blocklists = (0, WABinary_1.getBinaryNodeChildren)(child, 'item');\n                    for (const { attrs } of blocklists) {\n                        const blocklist = [attrs.jid];\n                        const type = (attrs.action === 'block') ? 'add' : 'remove';\n                        ev.emit('blocklist.update', { blocklist, type });\n                    }\n                }\n                break;\n            case 'link_code_companion_reg':\n                const linkCodeCompanionReg = (0, WABinary_1.getBinaryNodeChild)(node, 'link_code_companion_reg');\n                const ref = toRequiredBuffer((0, WABinary_1.getBinaryNodeChildBuffer)(linkCodeCompanionReg, 'link_code_pairing_ref'));\n                const primaryIdentityPublicKey = toRequiredBuffer((0, WABinary_1.getBinaryNodeChildBuffer)(linkCodeCompanionReg, 'primary_identity_pub'));\n                const primaryEphemeralPublicKeyWrapped = toRequiredBuffer((0, WABinary_1.getBinaryNodeChildBuffer)(linkCodeCompanionReg, 'link_code_pairing_wrapped_primary_ephemeral_pub'));\n                const codePairingPublicKey = await decipherLinkPublicKey(primaryEphemeralPublicKeyWrapped);\n                const companionSharedKey = Utils_1.Curve.sharedKey(authState.creds.pairingEphemeralKeyPair.private, codePairingPublicKey);\n                const random = (0, crypto_1.randomBytes)(32);\n                const linkCodeSalt = (0, crypto_1.randomBytes)(32);\n                const linkCodePairingExpanded = (0, Utils_1.hkdf)(companionSharedKey, 32, {\n                    salt: linkCodeSalt,\n                    info: 'link_code_pairing_key_bundle_encryption_key'\n                });\n                const encryptPayload = Buffer.concat([Buffer.from(authState.creds.signedIdentityKey.public), primaryIdentityPublicKey, random]);\n                const encryptIv = (0, crypto_1.randomBytes)(12);\n                const encrypted = (0, Utils_1.aesEncryptGCM)(encryptPayload, linkCodePairingExpanded, encryptIv, Buffer.alloc(0));\n                const encryptedPayload = Buffer.concat([linkCodeSalt, encryptIv, encrypted]);\n                const identitySharedKey = Utils_1.Curve.sharedKey(authState.creds.signedIdentityKey.private, primaryIdentityPublicKey);\n                const identityPayload = Buffer.concat([companionSharedKey, identitySharedKey, random]);\n                authState.creds.advSecretKey = (0, Utils_1.hkdf)(identityPayload, 32, { info: 'adv_secret' }).toString('base64');\n                await query({\n                    tag: 'iq',\n                    attrs: {\n                        to: WABinary_1.S_WHATSAPP_NET,\n                        type: 'set',\n                        id: sock.generateMessageTag(),\n                        xmlns: 'md'\n                    },\n                    content: [\n                        {\n                            tag: 'link_code_companion_reg',\n                            attrs: {\n                                jid: authState.creds.me.id,\n                                stage: 'companion_finish',\n                            },\n                            content: [\n                                {\n                                    tag: 'link_code_pairing_wrapped_key_bundle',\n                                    attrs: {},\n                                    content: encryptedPayload\n                                },\n                                {\n                                    tag: 'companion_identity_public',\n                                    attrs: {},\n                                    content: authState.creds.signedIdentityKey.public\n                                },\n                                {\n                                    tag: 'link_code_pairing_ref',\n                                    attrs: {},\n                                    content: ref\n                                }\n                            ]\n                        }\n                    ]\n                });\n                authState.creds.registered = true;\n                ev.emit('creds.update', authState.creds);\n        }\n        if (Object.keys(result).length) {\n            return result;\n        }\n    };\n    async function decipherLinkPublicKey(data) {\n        const buffer = toRequiredBuffer(data);\n        const salt = buffer.slice(0, 32);\n        const secretKey = await (0, Utils_1.derivePairingCodeKey)(authState.creds.pairingCode, salt);\n        const iv = buffer.slice(32, 48);\n        const payload = buffer.slice(48, 80);\n        return (0, Utils_1.aesDecryptCTR)(payload, secretKey, iv);\n    }\n    function toRequiredBuffer(data) {\n        if (data === undefined) {\n            throw new boom_1.Boom('Invalid buffer', { statusCode: 400 });\n        }\n        return data instanceof Buffer ? data : Buffer.from(data);\n    }\n    const willSendMessageAgain = (id, participant) => {\n        const key = `${id}:${participant}`;\n        const retryCount = msgRetryCache.get(key) || 0;\n        return retryCount < maxMsgRetryCount;\n    };\n    const updateSendMessageAgainCount = (id, participant) => {\n        const key = `${id}:${participant}`;\n        const newValue = (msgRetryCache.get(key) || 0) + 1;\n        msgRetryCache.set(key, newValue);\n    };\n    const sendMessagesAgain = async (key, ids, retryNode) => {\n        var _a;\n        const msgs = await Promise.all(ids.map(id => getMessage({ ...key, id })));\n        const remoteJid = key.remoteJid;\n        const participant = key.participant || remoteJid;\n        // if it's the primary jid sending the request\n        // just re-send the message to everyone\n        // prevents the first message decryption failure\n        const sendToAll = !((_a = (0, WABinary_1.jidDecode)(participant)) === null || _a === void 0 ? void 0 : _a.device);\n        await assertSessions([participant], true);\n        if ((0, WABinary_1.isJidGroup)(remoteJid)) {\n            await authState.keys.set({ 'sender-key-memory': { [remoteJid]: null } });\n        }\n        logger.debug({ participant, sendToAll }, 'forced new session for retry recp');\n        for (let i = 0; i < msgs.length; i++) {\n            const msg = msgs[i];\n            if (msg) {\n                updateSendMessageAgainCount(ids[i], participant);\n                const msgRelayOpts = { messageId: ids[i] };\n                if (sendToAll) {\n                    msgRelayOpts.useUserDevicesCache = false;\n                }\n                else {\n                    msgRelayOpts.participant = {\n                        jid: participant,\n                        count: +retryNode.attrs.count\n                    };\n                }\n                await relayMessage(key.remoteJid, msg, msgRelayOpts);\n            }\n            else {\n                logger.debug({ jid: key.remoteJid, id: ids[i] }, 'recv retry request, but message not available');\n            }\n        }\n    };\n    const handleReceipt = async (node) => {\n        var _a, _b;\n        const { attrs, content } = node;\n        const isLid = attrs.from.includes('lid');\n        const isNodeFromMe = (0, WABinary_1.areJidsSameUser)(attrs.participant || attrs.from, isLid ? (_a = authState.creds.me) === null || _a === void 0 ? void 0 : _a.lid : (_b = authState.creds.me) === null || _b === void 0 ? void 0 : _b.id);\n        const remoteJid = !isNodeFromMe || (0, WABinary_1.isJidGroup)(attrs.from) ? attrs.from : attrs.recipient;\n        const fromMe = !attrs.recipient || (attrs.type === 'retry' && isNodeFromMe);\n        const key = {\n            remoteJid,\n            id: '',\n            fromMe,\n            participant: attrs.participant\n        };\n        if (shouldIgnoreJid(remoteJid) && remoteJid !== '@s.whatsapp.net') {\n            logger.debug({ remoteJid }, 'ignoring receipt from jid');\n            await sendMessageAck(node);\n            return;\n        }\n        const ids = [attrs.id];\n        if (Array.isArray(content)) {\n            const items = (0, WABinary_1.getBinaryNodeChildren)(content[0], 'item');\n            ids.push(...items.map(i => i.attrs.id));\n        }\n        try {\n            await Promise.all([\n                processingMutex.mutex(async () => {\n                    const status = (0, Utils_1.getStatusFromReceiptType)(attrs.type);\n                    if (typeof status !== 'undefined' &&\n                        (\n                        // basically, we only want to know when a message from us has been delivered to/read by the other person\n                        // or another device of ours has read some messages\n                        status > WAProto_1.proto.WebMessageInfo.Status.DELIVERY_ACK ||\n                            !isNodeFromMe)) {\n                        if ((0, WABinary_1.isJidGroup)(remoteJid) || (0, WABinary_1.isJidStatusBroadcast)(remoteJid)) {\n                            if (attrs.participant) {\n                                const updateKey = status === WAProto_1.proto.WebMessageInfo.Status.DELIVERY_ACK ? 'receiptTimestamp' : 'readTimestamp';\n                                ev.emit('message-receipt.update', ids.map(id => ({\n                                    key: { ...key, id },\n                                    receipt: {\n                                        userJid: (0, WABinary_1.jidNormalizedUser)(attrs.participant),\n                                        [updateKey]: +attrs.t\n                                    }\n                                })));\n                            }\n                        }\n                        else {\n                            ev.emit('messages.update', ids.map(id => ({\n                                key: { ...key, id },\n                                update: { status }\n                            })));\n                        }\n                    }\n                    if (attrs.type === 'retry') {\n                        // correctly set who is asking for the retry\n                        key.participant = key.participant || attrs.from;\n                        const retryNode = (0, WABinary_1.getBinaryNodeChild)(node, 'retry');\n                        if (willSendMessageAgain(ids[0], key.participant)) {\n                            if (key.fromMe) {\n                                try {\n                                    logger.debug({ attrs, key }, 'recv retry request');\n                                    await sendMessagesAgain(key, ids, retryNode);\n                                }\n                                catch (error) {\n                                    logger.error({ key, ids, trace: error.stack }, 'error in sending message again');\n                                }\n                            }\n                            else {\n                                logger.info({ attrs, key }, 'recv retry for not fromMe message');\n                            }\n                        }\n                        else {\n                            logger.info({ attrs, key }, 'will not send message again, as sent too many times');\n                        }\n                    }\n                })\n            ]);\n        }\n        finally {\n            await sendMessageAck(node);\n        }\n    };\n    const handleNotification = async (node) => {\n        const remoteJid = node.attrs.from;\n        if (shouldIgnoreJid(remoteJid) && remoteJid !== '@s.whatsapp.net') {\n            logger.debug({ remoteJid, id: node.attrs.id }, 'ignored notification');\n            await sendMessageAck(node);\n            return;\n        }\n        try {\n            await Promise.all([\n                processingMutex.mutex(async () => {\n                    var _a;\n                    const msg = await processNotification(node);\n                    if (msg) {\n                        const fromMe = (0, WABinary_1.areJidsSameUser)(node.attrs.participant || remoteJid, authState.creds.me.id);\n                        msg.key = {\n                            remoteJid,\n                            fromMe,\n                            participant: node.attrs.participant,\n                            id: node.attrs.id,\n                            ...(msg.key || {})\n                        };\n                        (_a = msg.participant) !== null && _a !== void 0 ? _a : (msg.participant = node.attrs.participant);\n                        msg.messageTimestamp = +node.attrs.t;\n                        const fullMsg = WAProto_1.proto.WebMessageInfo.fromObject(msg);\n                        await upsertMessage(fullMsg, 'append');\n                    }\n                })\n            ]);\n        }\n        finally {\n            await sendMessageAck(node);\n        }\n    };\n    const handleMessage = async (node) => {\n        var _a, _b, _c;\n        if (shouldIgnoreJid(node.attrs.from) && node.attrs.from !== '@s.whatsapp.net') {\n            logger.debug({ key: node.attrs.key }, 'ignored message');\n            await sendMessageAck(node);\n            return;\n        }\n        let response;\n        if ((0, WABinary_1.getBinaryNodeChild)(node, 'unavailable') && !(0, WABinary_1.getBinaryNodeChild)(node, 'enc')) {\n            await sendMessageAck(node);\n            const { key } = (0, Utils_1.decodeMessageNode)(node, authState.creds.me.id, authState.creds.me.lid || '').fullMessage;\n            response = await requestPlaceholderResend(key);\n            if (response === 'RESOLVED') {\n                return;\n            }\n            logger.debug('received unavailable message, acked and requested resend from phone');\n        }\n        else {\n            if (placeholderResendCache.get(node.attrs.id)) {\n                placeholderResendCache.del(node.attrs.id);\n            }\n        }\n        const { fullMessage: msg, category, author, decrypt } = (0, Utils_1.decryptMessageNode)(node, authState.creds.me.id, authState.creds.me.lid || '', signalRepository, logger);\n        if (response && ((_a = msg === null || msg === void 0 ? void 0 : msg.messageStubParameters) === null || _a === void 0 ? void 0 : _a[0]) === Utils_1.NO_MESSAGE_FOUND_ERROR_TEXT) {\n            msg.messageStubParameters = [Utils_1.NO_MESSAGE_FOUND_ERROR_TEXT, response];\n        }\n        if (((_c = (_b = msg.message) === null || _b === void 0 ? void 0 : _b.protocolMessage) === null || _c === void 0 ? void 0 : _c.type) === WAProto_1.proto.Message.ProtocolMessage.Type.SHARE_PHONE_NUMBER) {\n            if (node.attrs.sender_pn) {\n                ev.emit('chats.phoneNumberShare', { lid: node.attrs.from, jid: node.attrs.sender_pn });\n            }\n        }\n        try {\n            await Promise.all([\n                processingMutex.mutex(async () => {\n                    await decrypt();\n                    // message failed to decrypt\n                    if (msg.messageStubType === WAProto_1.proto.WebMessageInfo.StubType.CIPHERTEXT) {\n                        retryMutex.mutex(async () => {\n                            if (ws.isOpen) {\n                                if ((0, WABinary_1.getBinaryNodeChild)(node, 'unavailable')) {\n                                    return;\n                                }\n                                const encNode = (0, WABinary_1.getBinaryNodeChild)(node, 'enc');\n                                await sendRetryRequest(node, !encNode);\n                                if (retryRequestDelayMs) {\n                                    await (0, Utils_1.delay)(retryRequestDelayMs);\n                                }\n                            }\n                            else {\n                                logger.debug({ node }, 'connection closed, ignoring retry req');\n                            }\n                        });\n                    }\n                    else {\n                        // no type in the receipt => message delivered\n                        let type = undefined;\n                        let participant = msg.key.participant;\n                        if (category === 'peer') { // special peer message\n                            type = 'peer_msg';\n                        }\n                        else if (msg.key.fromMe) { // message was sent by us from a different device\n                            type = 'sender';\n                            // need to specially handle this case\n                            if ((0, WABinary_1.isJidUser)(msg.key.remoteJid)) {\n                                participant = author;\n                            }\n                        }\n                        else if (!sendActiveReceipts) {\n                            type = 'inactive';\n                        }\n                        await sendReceipt(msg.key.remoteJid, participant, [msg.key.id], type);\n                        // send ack for history message\n                        const isAnyHistoryMsg = (0, Utils_1.getHistoryMsg)(msg.message);\n                        if (isAnyHistoryMsg) {\n                            const jid = (0, WABinary_1.jidNormalizedUser)(msg.key.remoteJid);\n                            await sendReceipt(jid, undefined, [msg.key.id], 'hist_sync');\n                        }\n                    }\n                    (0, Utils_2.cleanMessage)(msg, authState.creds.me.id);\n                    await upsertMessage(msg, node.attrs.offline ? 'append' : 'notify');\n                })\n            ]);\n        }\n        finally {\n            await sendMessageAck(node);\n        }\n    };\n    const fetchMessageHistory = async (count, oldestMsgKey, oldestMsgTimestamp) => {\n        var _a;\n        if (!((_a = authState.creds.me) === null || _a === void 0 ? void 0 : _a.id)) {\n            throw new boom_1.Boom('Not authenticated');\n        }\n        const pdoMessage = {\n            historySyncOnDemandRequest: {\n                chatJid: oldestMsgKey.remoteJid,\n                oldestMsgFromMe: oldestMsgKey.fromMe,\n                oldestMsgId: oldestMsgKey.id,\n                oldestMsgTimestampMs: oldestMsgTimestamp,\n                onDemandMsgCount: count\n            },\n            peerDataOperationRequestType: WAProto_1.proto.Message.PeerDataOperationRequestType.HISTORY_SYNC_ON_DEMAND\n        };\n        return sendPeerDataOperationMessage(pdoMessage);\n    };\n    const requestPlaceholderResend = async (messageKey) => {\n        var _a;\n        if (!((_a = authState.creds.me) === null || _a === void 0 ? void 0 : _a.id)) {\n            throw new boom_1.Boom('Not authenticated');\n        }\n        if (placeholderResendCache.get(messageKey === null || messageKey === void 0 ? void 0 : messageKey.id)) {\n            logger.debug('already requested resend', { messageKey });\n            return;\n        }\n        else {\n            placeholderResendCache.set(messageKey === null || messageKey === void 0 ? void 0 : messageKey.id, true);\n        }\n        await (0, Utils_1.delay)(5000);\n        if (!placeholderResendCache.get(messageKey === null || messageKey === void 0 ? void 0 : messageKey.id)) {\n            logger.debug('message received while resend requested', { messageKey });\n            return 'RESOLVED';\n        }\n        const pdoMessage = {\n            placeholderMessageResendRequest: [{\n                    messageKey\n                }],\n            peerDataOperationRequestType: WAProto_1.proto.Message.PeerDataOperationRequestType.PLACEHOLDER_MESSAGE_RESEND\n        };\n        setTimeout(() => {\n            if (placeholderResendCache.get(messageKey === null || messageKey === void 0 ? void 0 : messageKey.id)) {\n                logger.debug('PDO message without response after 15 seconds. Phone possibly offline', { messageKey });\n                placeholderResendCache.del(messageKey === null || messageKey === void 0 ? void 0 : messageKey.id);\n            }\n        }, 15000);\n        return sendPeerDataOperationMessage(pdoMessage);\n    };\n    const handleCall = async (node) => {\n        const { attrs } = node;\n        const [infoChild] = (0, WABinary_1.getAllBinaryNodeChildren)(node);\n        const callId = infoChild.attrs['call-id'];\n        const from = infoChild.attrs.from || infoChild.attrs['call-creator'];\n        const status = (0, Utils_1.getCallStatusFromNode)(infoChild);\n        const call = {\n            chatId: attrs.from,\n            from,\n            id: callId,\n            date: new Date(+attrs.t * 1000),\n            offline: !!attrs.offline,\n            status,\n        };\n        if (status === 'offer') {\n            call.isVideo = !!(0, WABinary_1.getBinaryNodeChild)(infoChild, 'video');\n            call.isGroup = infoChild.attrs.type === 'group' || !!infoChild.attrs['group-jid'];\n            call.groupJid = infoChild.attrs['group-jid'];\n            callOfferCache.set(call.id, call);\n        }\n        const existingCall = callOfferCache.get(call.id);\n        // use existing call info to populate this event\n        if (existingCall) {\n            call.isVideo = existingCall.isVideo;\n            call.isGroup = existingCall.isGroup;\n        }\n        // delete data once call has ended\n        if (status === 'reject' || status === 'accept' || status === 'timeout' || status === 'terminate') {\n            callOfferCache.del(call.id);\n        }\n        ev.emit('call', [call]);\n        await sendMessageAck(node);\n    };\n    const handleBadAck = async ({ attrs }) => {\n        const key = { remoteJid: attrs.from, fromMe: true, id: attrs.id };\n        // current hypothesis is that if pash is sent in the ack\n        // it means -- the message hasn't reached all devices yet\n        // we'll retry sending the message here\n        if (attrs.phash) {\n            logger.info({ attrs }, 'received phash in ack, resending message...');\n            const msg = await getMessage(key);\n            if (msg) {\n                await relayMessage(key.remoteJid, msg, { messageId: key.id, useUserDevicesCache: false });\n            }\n            else {\n                logger.warn({ attrs }, 'could not send message again, as it was not found');\n            }\n        }\n        // error in acknowledgement,\n        // device could not display the message\n        if (attrs.error) {\n            logger.warn({ attrs }, 'received error in ack');\n            ev.emit('messages.update', [\n                {\n                    key,\n                    update: {\n                        status: Types_1.WAMessageStatus.ERROR,\n                        messageStubParameters: [\n                            attrs.error\n                        ]\n                    }\n                }\n            ]);\n        }\n    };\n    /// processes a node with the given function\n    /// and adds the task to the existing buffer if we're buffering events\n    const processNodeWithBuffer = async (node, identifier, exec) => {\n        ev.buffer();\n        await execTask();\n        ev.flush();\n        function execTask() {\n            return exec(node)\n                .catch(err => onUnexpectedError(err, identifier));\n        }\n    };\n    // recv a message\n    ws.on('CB:message', (node) => {\n        processNodeWithBuffer(node, 'processing message', handleMessage);\n    });\n    ws.on('CB:call', async (node) => {\n        processNodeWithBuffer(node, 'handling call', handleCall);\n    });\n    ws.on('CB:receipt', node => {\n        processNodeWithBuffer(node, 'handling receipt', handleReceipt);\n    });\n    ws.on('CB:notification', async (node) => {\n        processNodeWithBuffer(node, 'handling notification', handleNotification);\n    });\n    ws.on('CB:ack,class:message', (node) => {\n        handleBadAck(node)\n            .catch(error => onUnexpectedError(error, 'handling bad ack'));\n    });\n    ev.on('call', ([call]) => {\n        // missed call + group call notification message generation\n        if (call.status === 'timeout' || (call.status === 'offer' && call.isGroup)) {\n            const msg = {\n                key: {\n                    remoteJid: call.chatId,\n                    id: call.id,\n                    fromMe: false\n                },\n                messageTimestamp: (0, Utils_1.unixTimestampSeconds)(call.date),\n            };\n            if (call.status === 'timeout') {\n                if (call.isGroup) {\n                    msg.messageStubType = call.isVideo ? Types_1.WAMessageStubType.CALL_MISSED_GROUP_VIDEO : Types_1.WAMessageStubType.CALL_MISSED_GROUP_VOICE;\n                }\n                else {\n                    msg.messageStubType = call.isVideo ? Types_1.WAMessageStubType.CALL_MISSED_VIDEO : Types_1.WAMessageStubType.CALL_MISSED_VOICE;\n                }\n            }\n            else {\n                msg.message = { call: { callKey: Buffer.from(call.id) } };\n            }\n            const protoMsg = WAProto_1.proto.WebMessageInfo.fromObject(msg);\n            upsertMessage(protoMsg, call.offline ? 'append' : 'notify');\n        }\n    });\n    ev.on('connection.update', ({ isOnline }) => {\n        if (typeof isOnline !== 'undefined') {\n            sendActiveReceipts = isOnline;\n            logger.trace(`sendActiveReceipts set to \"${sendActiveReceipts}\"`);\n        }\n    });\n    return {\n        ...sock,\n        sendMessageAck,\n        sendRetryRequest,\n        rejectCall,\n        fetchMessageHistory,\n        requestPlaceholderResend,\n    };\n};\nexports.makeMessagesRecvSocket = makeMessagesRecvSocket;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}