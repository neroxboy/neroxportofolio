{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useMultiFileAuthState = void 0;\nconst async_lock_1 = __importDefault(require(\"async-lock\"));\nconst promises_1 = require(\"fs/promises\");\nconst path_1 = require(\"path\");\nconst WAProto_1 = require(\"../../WAProto\");\nconst auth_utils_1 = require(\"./auth-utils\");\nconst generics_1 = require(\"./generics\");\n// We need to lock files due to the fact that we are using async functions to read and write files\n// https://github.com/WhiskeySockets/Baileys/issues/794\n// https://github.com/nodejs/node/issues/26338\n// Default pending is 1000, set it to infinity\n// https://github.com/rogierschouten/async-lock/issues/63\nconst fileLock = new async_lock_1.default({\n  maxPending: Infinity\n});\n/**\n * stores the full authentication state in a single folder.\n * Far more efficient than singlefileauthstate\n *\n * Again, I wouldn't endorse this for any production level use other than perhaps a bot.\n * Would recommend writing an auth state for use with a proper SQL or No-SQL DB\n * */\nconst useMultiFileAuthState = async folder => {\n  const writeData = (data, file) => {\n    const filePath = (0, path_1.join)(folder, fixFileName(file));\n    return fileLock.acquire(filePath, () => (0, promises_1.writeFile)((0, path_1.join)(filePath), JSON.stringify(data, generics_1.BufferJSON.replacer)));\n  };\n  const readData = async file => {\n    try {\n      const filePath = (0, path_1.join)(folder, fixFileName(file));\n      const data = await fileLock.acquire(filePath, () => (0, promises_1.readFile)(filePath, {\n        encoding: 'utf-8'\n      }));\n      return JSON.parse(data, generics_1.BufferJSON.reviver);\n    } catch (error) {\n      return null;\n    }\n  };\n  const removeData = async file => {\n    try {\n      const filePath = (0, path_1.join)(folder, fixFileName(file));\n      await fileLock.acquire(filePath, () => (0, promises_1.unlink)(filePath));\n    } catch (_a) {}\n  };\n  const folderInfo = await (0, promises_1.stat)(folder).catch(() => {});\n  if (folderInfo) {\n    if (!folderInfo.isDirectory()) {\n      throw new Error(`found something that is not a directory at ${folder}, either delete it or specify a different location`);\n    }\n  } else {\n    await (0, promises_1.mkdir)(folder, {\n      recursive: true\n    });\n  }\n  const fixFileName = file => {\n    var _a;\n    return (_a = file === null || file === void 0 ? void 0 : file.replace(/\\//g, '__')) === null || _a === void 0 ? void 0 : _a.replace(/:/g, '-');\n  };\n  const creds = (await readData('creds.json')) || (0, auth_utils_1.initAuthCreds)();\n  return {\n    state: {\n      creds,\n      keys: {\n        get: async (type, ids) => {\n          const data = {};\n          await Promise.all(ids.map(async id => {\n            let value = await readData(`${type}-${id}.json`);\n            if (type === 'app-state-sync-key' && value) {\n              value = WAProto_1.proto.Message.AppStateSyncKeyData.fromObject(value);\n            }\n            data[id] = value;\n          }));\n          return data;\n        },\n        set: async data => {\n          const tasks = [];\n          for (const category in data) {\n            for (const id in data[category]) {\n              const value = data[category][id];\n              const file = `${category}-${id}.json`;\n              tasks.push(value ? writeData(value, file) : removeData(file));\n            }\n          }\n          await Promise.all(tasks);\n        }\n      }\n    },\n    saveCreds: () => {\n      return writeData(creds, 'creds.json');\n    }\n  };\n};\nexports.useMultiFileAuthState = useMultiFileAuthState;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","useMultiFileAuthState","async_lock_1","require","promises_1","path_1","WAProto_1","auth_utils_1","generics_1","fileLock","default","maxPending","Infinity","folder","writeData","data","file","filePath","join","fixFileName","acquire","writeFile","JSON","stringify","BufferJSON","replacer","readData","readFile","encoding","parse","reviver","error","removeData","unlink","_a","folderInfo","stat","catch","isDirectory","Error","mkdir","recursive","replace","creds","initAuthCreds","state","keys","get","type","ids","Promise","all","map","id","proto","Message","AppStateSyncKeyData","fromObject","set","tasks","category","push","saveCreds"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Utils/use-multi-file-auth-state.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useMultiFileAuthState = void 0;\nconst async_lock_1 = __importDefault(require(\"async-lock\"));\nconst promises_1 = require(\"fs/promises\");\nconst path_1 = require(\"path\");\nconst WAProto_1 = require(\"../../WAProto\");\nconst auth_utils_1 = require(\"./auth-utils\");\nconst generics_1 = require(\"./generics\");\n// We need to lock files due to the fact that we are using async functions to read and write files\n// https://github.com/WhiskeySockets/Baileys/issues/794\n// https://github.com/nodejs/node/issues/26338\n// Default pending is 1000, set it to infinity\n// https://github.com/rogierschouten/async-lock/issues/63\nconst fileLock = new async_lock_1.default({ maxPending: Infinity });\n/**\n * stores the full authentication state in a single folder.\n * Far more efficient than singlefileauthstate\n *\n * Again, I wouldn't endorse this for any production level use other than perhaps a bot.\n * Would recommend writing an auth state for use with a proper SQL or No-SQL DB\n * */\nconst useMultiFileAuthState = async (folder) => {\n    const writeData = (data, file) => {\n        const filePath = (0, path_1.join)(folder, fixFileName(file));\n        return fileLock.acquire(filePath, () => (0, promises_1.writeFile)((0, path_1.join)(filePath), JSON.stringify(data, generics_1.BufferJSON.replacer)));\n    };\n    const readData = async (file) => {\n        try {\n            const filePath = (0, path_1.join)(folder, fixFileName(file));\n            const data = await fileLock.acquire(filePath, () => (0, promises_1.readFile)(filePath, { encoding: 'utf-8' }));\n            return JSON.parse(data, generics_1.BufferJSON.reviver);\n        }\n        catch (error) {\n            return null;\n        }\n    };\n    const removeData = async (file) => {\n        try {\n            const filePath = (0, path_1.join)(folder, fixFileName(file));\n            await fileLock.acquire(filePath, () => (0, promises_1.unlink)(filePath));\n        }\n        catch (_a) {\n        }\n    };\n    const folderInfo = await (0, promises_1.stat)(folder).catch(() => { });\n    if (folderInfo) {\n        if (!folderInfo.isDirectory()) {\n            throw new Error(`found something that is not a directory at ${folder}, either delete it or specify a different location`);\n        }\n    }\n    else {\n        await (0, promises_1.mkdir)(folder, { recursive: true });\n    }\n    const fixFileName = (file) => { var _a; return (_a = file === null || file === void 0 ? void 0 : file.replace(/\\//g, '__')) === null || _a === void 0 ? void 0 : _a.replace(/:/g, '-'); };\n    const creds = await readData('creds.json') || (0, auth_utils_1.initAuthCreds)();\n    return {\n        state: {\n            creds,\n            keys: {\n                get: async (type, ids) => {\n                    const data = {};\n                    await Promise.all(ids.map(async (id) => {\n                        let value = await readData(`${type}-${id}.json`);\n                        if (type === 'app-state-sync-key' && value) {\n                            value = WAProto_1.proto.Message.AppStateSyncKeyData.fromObject(value);\n                        }\n                        data[id] = value;\n                    }));\n                    return data;\n                },\n                set: async (data) => {\n                    const tasks = [];\n                    for (const category in data) {\n                        for (const id in data[category]) {\n                            const value = data[category][id];\n                            const file = `${category}-${id}.json`;\n                            tasks.push(value ? writeData(value, file) : removeData(file));\n                        }\n                    }\n                    await Promise.all(tasks);\n                }\n            }\n        },\n        saveCreds: () => {\n            return writeData(creds, 'creds.json');\n        }\n    };\n};\nexports.useMultiFileAuthState = useMultiFileAuthState;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}