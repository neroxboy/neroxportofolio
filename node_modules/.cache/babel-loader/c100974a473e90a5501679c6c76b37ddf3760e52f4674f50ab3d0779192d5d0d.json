{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeEventBuffer = void 0;\nconst events_1 = __importDefault(require(\"events\"));\nconst Types_1 = require(\"../Types\");\nconst generics_1 = require(\"./generics\");\nconst messages_1 = require(\"./messages\");\nconst process_message_1 = require(\"./process-message\");\nconst BUFFERABLE_EVENT = ['messaging-history.set', 'chats.upsert', 'chats.update', 'chats.delete', 'contacts.upsert', 'contacts.update', 'messages.upsert', 'messages.update', 'messages.delete', 'messages.reaction', 'message-receipt.update', 'groups.update'];\nconst BUFFERABLE_EVENT_SET = new Set(BUFFERABLE_EVENT);\n/**\n * The event buffer logically consolidates different events into a single event\n * making the data processing more efficient.\n * @param ev the baileys event emitter\n */\nconst makeEventBuffer = logger => {\n  const ev = new events_1.default();\n  const historyCache = new Set();\n  let data = makeBufferData();\n  let buffersInProgress = 0;\n  // take the generic event and fire it as a baileys event\n  ev.on('event', map => {\n    for (const event in map) {\n      ev.emit(event, map[event]);\n    }\n  });\n  function buffer() {\n    buffersInProgress += 1;\n  }\n  function flush(force = false) {\n    // no buffer going on\n    if (!buffersInProgress) {\n      return false;\n    }\n    if (!force) {\n      // reduce the number of buffers in progress\n      buffersInProgress -= 1;\n      // if there are still some buffers going on\n      // then we don't flush now\n      if (buffersInProgress) {\n        return false;\n      }\n    }\n    const newData = makeBufferData();\n    const chatUpdates = Object.values(data.chatUpdates);\n    // gather the remaining conditional events so we re-queue them\n    let conditionalChatUpdatesLeft = 0;\n    for (const update of chatUpdates) {\n      if (update.conditional) {\n        conditionalChatUpdatesLeft += 1;\n        newData.chatUpdates[update.id] = update;\n        delete data.chatUpdates[update.id];\n      }\n    }\n    const consolidatedData = consolidateEvents(data);\n    if (Object.keys(consolidatedData).length) {\n      ev.emit('event', consolidatedData);\n    }\n    data = newData;\n    logger.trace({\n      conditionalChatUpdatesLeft\n    }, 'released buffered events');\n    return true;\n  }\n  return {\n    process(handler) {\n      const listener = map => {\n        handler(map);\n      };\n      ev.on('event', listener);\n      return () => {\n        ev.off('event', listener);\n      };\n    },\n    emit(event, evData) {\n      if (buffersInProgress && BUFFERABLE_EVENT_SET.has(event)) {\n        append(data, historyCache, event, evData, logger);\n        return true;\n      }\n      return ev.emit('event', {\n        [event]: evData\n      });\n    },\n    isBuffering() {\n      return buffersInProgress > 0;\n    },\n    buffer,\n    flush,\n    createBufferedFunction(work) {\n      return async (...args) => {\n        buffer();\n        try {\n          const result = await work(...args);\n          return result;\n        } finally {\n          flush();\n        }\n      };\n    },\n    on: (...args) => ev.on(...args),\n    off: (...args) => ev.off(...args),\n    removeAllListeners: (...args) => ev.removeAllListeners(...args)\n  };\n};\nexports.makeEventBuffer = makeEventBuffer;\nconst makeBufferData = () => {\n  return {\n    historySets: {\n      chats: {},\n      messages: {},\n      contacts: {},\n      isLatest: false,\n      empty: true\n    },\n    chatUpserts: {},\n    chatUpdates: {},\n    chatDeletes: new Set(),\n    contactUpserts: {},\n    contactUpdates: {},\n    messageUpserts: {},\n    messageUpdates: {},\n    messageReactions: {},\n    messageDeletes: {},\n    messageReceipts: {},\n    groupUpdates: {}\n  };\n};\nfunction append(data, historyCache, event, eventData, logger) {\n  var _a, _b, _c;\n  switch (event) {\n    case 'messaging-history.set':\n      for (const chat of eventData.chats) {\n        const existingChat = data.historySets.chats[chat.id];\n        if (existingChat) {\n          existingChat.endOfHistoryTransferType = chat.endOfHistoryTransferType;\n        }\n        if (!existingChat && !historyCache.has(chat.id)) {\n          data.historySets.chats[chat.id] = chat;\n          historyCache.add(chat.id);\n          absorbingChatUpdate(chat);\n        }\n      }\n      for (const contact of eventData.contacts) {\n        const existingContact = data.historySets.contacts[contact.id];\n        if (existingContact) {\n          Object.assign(existingContact, (0, generics_1.trimUndefined)(contact));\n        } else {\n          const historyContactId = `c:${contact.id}`;\n          const hasAnyName = contact.notify || contact.name || contact.verifiedName;\n          if (!historyCache.has(historyContactId) || hasAnyName) {\n            data.historySets.contacts[contact.id] = contact;\n            historyCache.add(historyContactId);\n          }\n        }\n      }\n      for (const message of eventData.messages) {\n        const key = stringifyMessageKey(message.key);\n        const existingMsg = data.historySets.messages[key];\n        if (!existingMsg && !historyCache.has(key)) {\n          data.historySets.messages[key] = message;\n          historyCache.add(key);\n        }\n      }\n      data.historySets.empty = false;\n      data.historySets.syncType = eventData.syncType;\n      data.historySets.progress = eventData.progress;\n      data.historySets.peerDataRequestSessionId = eventData.peerDataRequestSessionId;\n      data.historySets.isLatest = eventData.isLatest || data.historySets.isLatest;\n      break;\n    case 'chats.upsert':\n      for (const chat of eventData) {\n        let upsert = data.chatUpserts[chat.id];\n        if (!upsert) {\n          upsert = data.historySets[chat.id];\n          if (upsert) {\n            logger.debug({\n              chatId: chat.id\n            }, 'absorbed chat upsert in chat set');\n          }\n        }\n        if (upsert) {\n          upsert = concatChats(upsert, chat);\n        } else {\n          upsert = chat;\n          data.chatUpserts[chat.id] = upsert;\n        }\n        absorbingChatUpdate(upsert);\n        if (data.chatDeletes.has(chat.id)) {\n          data.chatDeletes.delete(chat.id);\n        }\n      }\n      break;\n    case 'chats.update':\n      for (const update of eventData) {\n        const chatId = update.id;\n        const conditionMatches = update.conditional ? update.conditional(data) : true;\n        if (conditionMatches) {\n          delete update.conditional;\n          // if there is an existing upsert, merge the update into it\n          const upsert = data.historySets.chats[chatId] || data.chatUpserts[chatId];\n          if (upsert) {\n            concatChats(upsert, update);\n          } else {\n            // merge the update into the existing update\n            const chatUpdate = data.chatUpdates[chatId] || {};\n            data.chatUpdates[chatId] = concatChats(chatUpdate, update);\n          }\n        } else if (conditionMatches === undefined) {\n          // condition yet to be fulfilled\n          data.chatUpdates[chatId] = update;\n        }\n        // otherwise -- condition not met, update is invalid\n        // if the chat has been updated\n        // ignore any existing chat delete\n        if (data.chatDeletes.has(chatId)) {\n          data.chatDeletes.delete(chatId);\n        }\n      }\n      break;\n    case 'chats.delete':\n      for (const chatId of eventData) {\n        if (!data.chatDeletes.has(chatId)) {\n          data.chatDeletes.add(chatId);\n        }\n        // remove any prior updates & upserts\n        if (data.chatUpdates[chatId]) {\n          delete data.chatUpdates[chatId];\n        }\n        if (data.chatUpserts[chatId]) {\n          delete data.chatUpserts[chatId];\n        }\n        if (data.historySets.chats[chatId]) {\n          delete data.historySets.chats[chatId];\n        }\n      }\n      break;\n    case 'contacts.upsert':\n      for (const contact of eventData) {\n        let upsert = data.contactUpserts[contact.id];\n        if (!upsert) {\n          upsert = data.historySets.contacts[contact.id];\n          if (upsert) {\n            logger.debug({\n              contactId: contact.id\n            }, 'absorbed contact upsert in contact set');\n          }\n        }\n        if (upsert) {\n          upsert = Object.assign(upsert, (0, generics_1.trimUndefined)(contact));\n        } else {\n          upsert = contact;\n          data.contactUpserts[contact.id] = upsert;\n        }\n        if (data.contactUpdates[contact.id]) {\n          upsert = Object.assign(data.contactUpdates[contact.id], (0, generics_1.trimUndefined)(contact));\n          delete data.contactUpdates[contact.id];\n        }\n      }\n      break;\n    case 'contacts.update':\n      const contactUpdates = eventData;\n      for (const update of contactUpdates) {\n        const id = update.id;\n        // merge into prior upsert\n        const upsert = data.historySets.contacts[id] || data.contactUpserts[id];\n        if (upsert) {\n          Object.assign(upsert, update);\n        } else {\n          // merge into prior update\n          const contactUpdate = data.contactUpdates[id] || {};\n          data.contactUpdates[id] = Object.assign(contactUpdate, update);\n        }\n      }\n      break;\n    case 'messages.upsert':\n      const {\n        messages,\n        type\n      } = eventData;\n      for (const message of messages) {\n        const key = stringifyMessageKey(message.key);\n        let existing = (_a = data.messageUpserts[key]) === null || _a === void 0 ? void 0 : _a.message;\n        if (!existing) {\n          existing = data.historySets.messages[key];\n          if (existing) {\n            logger.debug({\n              messageId: key\n            }, 'absorbed message upsert in message set');\n          }\n        }\n        if (existing) {\n          message.messageTimestamp = existing.messageTimestamp;\n        }\n        if (data.messageUpdates[key]) {\n          logger.debug('absorbed prior message update in message upsert');\n          Object.assign(message, data.messageUpdates[key].update);\n          delete data.messageUpdates[key];\n        }\n        if (data.historySets.messages[key]) {\n          data.historySets.messages[key] = message;\n        } else {\n          data.messageUpserts[key] = {\n            message,\n            type: type === 'notify' || ((_b = data.messageUpserts[key]) === null || _b === void 0 ? void 0 : _b.type) === 'notify' ? 'notify' : type\n          };\n        }\n      }\n      break;\n    case 'messages.update':\n      const msgUpdates = eventData;\n      for (const {\n        key,\n        update\n      } of msgUpdates) {\n        const keyStr = stringifyMessageKey(key);\n        const existing = data.historySets.messages[keyStr] || ((_c = data.messageUpserts[keyStr]) === null || _c === void 0 ? void 0 : _c.message);\n        if (existing) {\n          Object.assign(existing, update);\n          // if the message was received & read by us\n          // the chat counter must have been incremented\n          // so we need to decrement it\n          if (update.status === Types_1.WAMessageStatus.READ && !key.fromMe) {\n            decrementChatReadCounterIfMsgDidUnread(existing);\n          }\n        } else {\n          const msgUpdate = data.messageUpdates[keyStr] || {\n            key,\n            update: {}\n          };\n          Object.assign(msgUpdate.update, update);\n          data.messageUpdates[keyStr] = msgUpdate;\n        }\n      }\n      break;\n    case 'messages.delete':\n      const deleteData = eventData;\n      if ('keys' in deleteData) {\n        const {\n          keys\n        } = deleteData;\n        for (const key of keys) {\n          const keyStr = stringifyMessageKey(key);\n          if (!data.messageDeletes[keyStr]) {\n            data.messageDeletes[keyStr] = key;\n          }\n          if (data.messageUpserts[keyStr]) {\n            delete data.messageUpserts[keyStr];\n          }\n          if (data.messageUpdates[keyStr]) {\n            delete data.messageUpdates[keyStr];\n          }\n        }\n      } else {\n        // TODO: add support\n      }\n      break;\n    case 'messages.reaction':\n      const reactions = eventData;\n      for (const {\n        key,\n        reaction\n      } of reactions) {\n        const keyStr = stringifyMessageKey(key);\n        const existing = data.messageUpserts[keyStr];\n        if (existing) {\n          (0, messages_1.updateMessageWithReaction)(existing.message, reaction);\n        } else {\n          data.messageReactions[keyStr] = data.messageReactions[keyStr] || {\n            key,\n            reactions: []\n          };\n          (0, messages_1.updateMessageWithReaction)(data.messageReactions[keyStr], reaction);\n        }\n      }\n      break;\n    case 'message-receipt.update':\n      const receipts = eventData;\n      for (const {\n        key,\n        receipt\n      } of receipts) {\n        const keyStr = stringifyMessageKey(key);\n        const existing = data.messageUpserts[keyStr];\n        if (existing) {\n          (0, messages_1.updateMessageWithReceipt)(existing.message, receipt);\n        } else {\n          data.messageReceipts[keyStr] = data.messageReceipts[keyStr] || {\n            key,\n            userReceipt: []\n          };\n          (0, messages_1.updateMessageWithReceipt)(data.messageReceipts[keyStr], receipt);\n        }\n      }\n      break;\n    case 'groups.update':\n      const groupUpdates = eventData;\n      for (const update of groupUpdates) {\n        const id = update.id;\n        const groupUpdate = data.groupUpdates[id] || {};\n        if (!data.groupUpdates[id]) {\n          data.groupUpdates[id] = Object.assign(groupUpdate, update);\n        }\n      }\n      break;\n    default:\n      throw new Error(`\"${event}\" cannot be buffered`);\n  }\n  function absorbingChatUpdate(existing) {\n    const chatId = existing.id;\n    const update = data.chatUpdates[chatId];\n    if (update) {\n      const conditionMatches = update.conditional ? update.conditional(data) : true;\n      if (conditionMatches) {\n        delete update.conditional;\n        logger.debug({\n          chatId\n        }, 'absorbed chat update in existing chat');\n        Object.assign(existing, concatChats(update, existing));\n        delete data.chatUpdates[chatId];\n      } else if (conditionMatches === false) {\n        logger.debug({\n          chatId\n        }, 'chat update condition fail, removing');\n        delete data.chatUpdates[chatId];\n      }\n    }\n  }\n  function decrementChatReadCounterIfMsgDidUnread(message) {\n    // decrement chat unread counter\n    // if the message has already been marked read by us\n    const chatId = message.key.remoteJid;\n    const chat = data.chatUpdates[chatId] || data.chatUpserts[chatId];\n    if ((0, process_message_1.isRealMessage)(message, '') && (0, process_message_1.shouldIncrementChatUnread)(message) && typeof (chat === null || chat === void 0 ? void 0 : chat.unreadCount) === 'number' && chat.unreadCount > 0) {\n      logger.debug({\n        chatId: chat.id\n      }, 'decrementing chat counter');\n      chat.unreadCount -= 1;\n      if (chat.unreadCount === 0) {\n        delete chat.unreadCount;\n      }\n    }\n  }\n}\nfunction consolidateEvents(data) {\n  const map = {};\n  if (!data.historySets.empty) {\n    map['messaging-history.set'] = {\n      chats: Object.values(data.historySets.chats),\n      messages: Object.values(data.historySets.messages),\n      contacts: Object.values(data.historySets.contacts),\n      syncType: data.historySets.syncType,\n      progress: data.historySets.progress,\n      isLatest: data.historySets.isLatest,\n      peerDataRequestSessionId: data.historySets.peerDataRequestSessionId\n    };\n  }\n  const chatUpsertList = Object.values(data.chatUpserts);\n  if (chatUpsertList.length) {\n    map['chats.upsert'] = chatUpsertList;\n  }\n  const chatUpdateList = Object.values(data.chatUpdates);\n  if (chatUpdateList.length) {\n    map['chats.update'] = chatUpdateList;\n  }\n  const chatDeleteList = Array.from(data.chatDeletes);\n  if (chatDeleteList.length) {\n    map['chats.delete'] = chatDeleteList;\n  }\n  const messageUpsertList = Object.values(data.messageUpserts);\n  if (messageUpsertList.length) {\n    const type = messageUpsertList[0].type;\n    map['messages.upsert'] = {\n      messages: messageUpsertList.map(m => m.message),\n      type\n    };\n  }\n  const messageUpdateList = Object.values(data.messageUpdates);\n  if (messageUpdateList.length) {\n    map['messages.update'] = messageUpdateList;\n  }\n  const messageDeleteList = Object.values(data.messageDeletes);\n  if (messageDeleteList.length) {\n    map['messages.delete'] = {\n      keys: messageDeleteList\n    };\n  }\n  const messageReactionList = Object.values(data.messageReactions).flatMap(({\n    key,\n    reactions\n  }) => reactions.flatMap(reaction => ({\n    key,\n    reaction\n  })));\n  if (messageReactionList.length) {\n    map['messages.reaction'] = messageReactionList;\n  }\n  const messageReceiptList = Object.values(data.messageReceipts).flatMap(({\n    key,\n    userReceipt\n  }) => userReceipt.flatMap(receipt => ({\n    key,\n    receipt\n  })));\n  if (messageReceiptList.length) {\n    map['message-receipt.update'] = messageReceiptList;\n  }\n  const contactUpsertList = Object.values(data.contactUpserts);\n  if (contactUpsertList.length) {\n    map['contacts.upsert'] = contactUpsertList;\n  }\n  const contactUpdateList = Object.values(data.contactUpdates);\n  if (contactUpdateList.length) {\n    map['contacts.update'] = contactUpdateList;\n  }\n  const groupUpdateList = Object.values(data.groupUpdates);\n  if (groupUpdateList.length) {\n    map['groups.update'] = groupUpdateList;\n  }\n  return map;\n}\nfunction concatChats(a, b) {\n  if (b.unreadCount === null) {\n    // neutralize unread counter\n    if (a.unreadCount < 0) {\n      a.unreadCount = undefined;\n      b.unreadCount = undefined;\n    }\n  }\n  if (typeof a.unreadCount === 'number' && typeof b.unreadCount === 'number') {\n    b = {\n      ...b\n    };\n    if (b.unreadCount >= 0) {\n      b.unreadCount = Math.max(b.unreadCount, 0) + Math.max(a.unreadCount, 0);\n    }\n  }\n  return Object.assign(a, b);\n}\nconst stringifyMessageKey = key => `${key.remoteJid},${key.id},${key.fromMe ? '1' : '0'}`;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","makeEventBuffer","events_1","require","Types_1","generics_1","messages_1","process_message_1","BUFFERABLE_EVENT","BUFFERABLE_EVENT_SET","Set","logger","ev","default","historyCache","data","makeBufferData","buffersInProgress","on","map","event","emit","buffer","flush","force","newData","chatUpdates","values","conditionalChatUpdatesLeft","update","conditional","id","consolidatedData","consolidateEvents","keys","length","trace","process","handler","listener","off","evData","has","append","isBuffering","createBufferedFunction","work","args","result","removeAllListeners","historySets","chats","messages","contacts","isLatest","empty","chatUpserts","chatDeletes","contactUpserts","contactUpdates","messageUpserts","messageUpdates","messageReactions","messageDeletes","messageReceipts","groupUpdates","eventData","_a","_b","_c","chat","existingChat","endOfHistoryTransferType","add","absorbingChatUpdate","contact","existingContact","assign","trimUndefined","historyContactId","hasAnyName","notify","name","verifiedName","message","key","stringifyMessageKey","existingMsg","syncType","progress","peerDataRequestSessionId","upsert","debug","chatId","concatChats","delete","conditionMatches","chatUpdate","undefined","contactId","contactUpdate","type","existing","messageId","messageTimestamp","msgUpdates","keyStr","status","WAMessageStatus","READ","fromMe","decrementChatReadCounterIfMsgDidUnread","msgUpdate","deleteData","reactions","reaction","updateMessageWithReaction","receipts","receipt","updateMessageWithReceipt","userReceipt","groupUpdate","Error","remoteJid","isRealMessage","shouldIncrementChatUnread","unreadCount","chatUpsertList","chatUpdateList","chatDeleteList","Array","from","messageUpsertList","m","messageUpdateList","messageDeleteList","messageReactionList","flatMap","messageReceiptList","contactUpsertList","contactUpdateList","groupUpdateList","a","b","Math","max"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Utils/event-buffer.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeEventBuffer = void 0;\nconst events_1 = __importDefault(require(\"events\"));\nconst Types_1 = require(\"../Types\");\nconst generics_1 = require(\"./generics\");\nconst messages_1 = require(\"./messages\");\nconst process_message_1 = require(\"./process-message\");\nconst BUFFERABLE_EVENT = [\n    'messaging-history.set',\n    'chats.upsert',\n    'chats.update',\n    'chats.delete',\n    'contacts.upsert',\n    'contacts.update',\n    'messages.upsert',\n    'messages.update',\n    'messages.delete',\n    'messages.reaction',\n    'message-receipt.update',\n    'groups.update',\n];\nconst BUFFERABLE_EVENT_SET = new Set(BUFFERABLE_EVENT);\n/**\n * The event buffer logically consolidates different events into a single event\n * making the data processing more efficient.\n * @param ev the baileys event emitter\n */\nconst makeEventBuffer = (logger) => {\n    const ev = new events_1.default();\n    const historyCache = new Set();\n    let data = makeBufferData();\n    let buffersInProgress = 0;\n    // take the generic event and fire it as a baileys event\n    ev.on('event', (map) => {\n        for (const event in map) {\n            ev.emit(event, map[event]);\n        }\n    });\n    function buffer() {\n        buffersInProgress += 1;\n    }\n    function flush(force = false) {\n        // no buffer going on\n        if (!buffersInProgress) {\n            return false;\n        }\n        if (!force) {\n            // reduce the number of buffers in progress\n            buffersInProgress -= 1;\n            // if there are still some buffers going on\n            // then we don't flush now\n            if (buffersInProgress) {\n                return false;\n            }\n        }\n        const newData = makeBufferData();\n        const chatUpdates = Object.values(data.chatUpdates);\n        // gather the remaining conditional events so we re-queue them\n        let conditionalChatUpdatesLeft = 0;\n        for (const update of chatUpdates) {\n            if (update.conditional) {\n                conditionalChatUpdatesLeft += 1;\n                newData.chatUpdates[update.id] = update;\n                delete data.chatUpdates[update.id];\n            }\n        }\n        const consolidatedData = consolidateEvents(data);\n        if (Object.keys(consolidatedData).length) {\n            ev.emit('event', consolidatedData);\n        }\n        data = newData;\n        logger.trace({ conditionalChatUpdatesLeft }, 'released buffered events');\n        return true;\n    }\n    return {\n        process(handler) {\n            const listener = (map) => {\n                handler(map);\n            };\n            ev.on('event', listener);\n            return () => {\n                ev.off('event', listener);\n            };\n        },\n        emit(event, evData) {\n            if (buffersInProgress && BUFFERABLE_EVENT_SET.has(event)) {\n                append(data, historyCache, event, evData, logger);\n                return true;\n            }\n            return ev.emit('event', { [event]: evData });\n        },\n        isBuffering() {\n            return buffersInProgress > 0;\n        },\n        buffer,\n        flush,\n        createBufferedFunction(work) {\n            return async (...args) => {\n                buffer();\n                try {\n                    const result = await work(...args);\n                    return result;\n                }\n                finally {\n                    flush();\n                }\n            };\n        },\n        on: (...args) => ev.on(...args),\n        off: (...args) => ev.off(...args),\n        removeAllListeners: (...args) => ev.removeAllListeners(...args),\n    };\n};\nexports.makeEventBuffer = makeEventBuffer;\nconst makeBufferData = () => {\n    return {\n        historySets: {\n            chats: {},\n            messages: {},\n            contacts: {},\n            isLatest: false,\n            empty: true\n        },\n        chatUpserts: {},\n        chatUpdates: {},\n        chatDeletes: new Set(),\n        contactUpserts: {},\n        contactUpdates: {},\n        messageUpserts: {},\n        messageUpdates: {},\n        messageReactions: {},\n        messageDeletes: {},\n        messageReceipts: {},\n        groupUpdates: {}\n    };\n};\nfunction append(data, historyCache, event, eventData, logger) {\n    var _a, _b, _c;\n    switch (event) {\n        case 'messaging-history.set':\n            for (const chat of eventData.chats) {\n                const existingChat = data.historySets.chats[chat.id];\n                if (existingChat) {\n                    existingChat.endOfHistoryTransferType = chat.endOfHistoryTransferType;\n                }\n                if (!existingChat && !historyCache.has(chat.id)) {\n                    data.historySets.chats[chat.id] = chat;\n                    historyCache.add(chat.id);\n                    absorbingChatUpdate(chat);\n                }\n            }\n            for (const contact of eventData.contacts) {\n                const existingContact = data.historySets.contacts[contact.id];\n                if (existingContact) {\n                    Object.assign(existingContact, (0, generics_1.trimUndefined)(contact));\n                }\n                else {\n                    const historyContactId = `c:${contact.id}`;\n                    const hasAnyName = contact.notify || contact.name || contact.verifiedName;\n                    if (!historyCache.has(historyContactId) || hasAnyName) {\n                        data.historySets.contacts[contact.id] = contact;\n                        historyCache.add(historyContactId);\n                    }\n                }\n            }\n            for (const message of eventData.messages) {\n                const key = stringifyMessageKey(message.key);\n                const existingMsg = data.historySets.messages[key];\n                if (!existingMsg && !historyCache.has(key)) {\n                    data.historySets.messages[key] = message;\n                    historyCache.add(key);\n                }\n            }\n            data.historySets.empty = false;\n            data.historySets.syncType = eventData.syncType;\n            data.historySets.progress = eventData.progress;\n            data.historySets.peerDataRequestSessionId = eventData.peerDataRequestSessionId;\n            data.historySets.isLatest = eventData.isLatest || data.historySets.isLatest;\n            break;\n        case 'chats.upsert':\n            for (const chat of eventData) {\n                let upsert = data.chatUpserts[chat.id];\n                if (!upsert) {\n                    upsert = data.historySets[chat.id];\n                    if (upsert) {\n                        logger.debug({ chatId: chat.id }, 'absorbed chat upsert in chat set');\n                    }\n                }\n                if (upsert) {\n                    upsert = concatChats(upsert, chat);\n                }\n                else {\n                    upsert = chat;\n                    data.chatUpserts[chat.id] = upsert;\n                }\n                absorbingChatUpdate(upsert);\n                if (data.chatDeletes.has(chat.id)) {\n                    data.chatDeletes.delete(chat.id);\n                }\n            }\n            break;\n        case 'chats.update':\n            for (const update of eventData) {\n                const chatId = update.id;\n                const conditionMatches = update.conditional ? update.conditional(data) : true;\n                if (conditionMatches) {\n                    delete update.conditional;\n                    // if there is an existing upsert, merge the update into it\n                    const upsert = data.historySets.chats[chatId] || data.chatUpserts[chatId];\n                    if (upsert) {\n                        concatChats(upsert, update);\n                    }\n                    else {\n                        // merge the update into the existing update\n                        const chatUpdate = data.chatUpdates[chatId] || {};\n                        data.chatUpdates[chatId] = concatChats(chatUpdate, update);\n                    }\n                }\n                else if (conditionMatches === undefined) {\n                    // condition yet to be fulfilled\n                    data.chatUpdates[chatId] = update;\n                }\n                // otherwise -- condition not met, update is invalid\n                // if the chat has been updated\n                // ignore any existing chat delete\n                if (data.chatDeletes.has(chatId)) {\n                    data.chatDeletes.delete(chatId);\n                }\n            }\n            break;\n        case 'chats.delete':\n            for (const chatId of eventData) {\n                if (!data.chatDeletes.has(chatId)) {\n                    data.chatDeletes.add(chatId);\n                }\n                // remove any prior updates & upserts\n                if (data.chatUpdates[chatId]) {\n                    delete data.chatUpdates[chatId];\n                }\n                if (data.chatUpserts[chatId]) {\n                    delete data.chatUpserts[chatId];\n                }\n                if (data.historySets.chats[chatId]) {\n                    delete data.historySets.chats[chatId];\n                }\n            }\n            break;\n        case 'contacts.upsert':\n            for (const contact of eventData) {\n                let upsert = data.contactUpserts[contact.id];\n                if (!upsert) {\n                    upsert = data.historySets.contacts[contact.id];\n                    if (upsert) {\n                        logger.debug({ contactId: contact.id }, 'absorbed contact upsert in contact set');\n                    }\n                }\n                if (upsert) {\n                    upsert = Object.assign(upsert, (0, generics_1.trimUndefined)(contact));\n                }\n                else {\n                    upsert = contact;\n                    data.contactUpserts[contact.id] = upsert;\n                }\n                if (data.contactUpdates[contact.id]) {\n                    upsert = Object.assign(data.contactUpdates[contact.id], (0, generics_1.trimUndefined)(contact));\n                    delete data.contactUpdates[contact.id];\n                }\n            }\n            break;\n        case 'contacts.update':\n            const contactUpdates = eventData;\n            for (const update of contactUpdates) {\n                const id = update.id;\n                // merge into prior upsert\n                const upsert = data.historySets.contacts[id] || data.contactUpserts[id];\n                if (upsert) {\n                    Object.assign(upsert, update);\n                }\n                else {\n                    // merge into prior update\n                    const contactUpdate = data.contactUpdates[id] || {};\n                    data.contactUpdates[id] = Object.assign(contactUpdate, update);\n                }\n            }\n            break;\n        case 'messages.upsert':\n            const { messages, type } = eventData;\n            for (const message of messages) {\n                const key = stringifyMessageKey(message.key);\n                let existing = (_a = data.messageUpserts[key]) === null || _a === void 0 ? void 0 : _a.message;\n                if (!existing) {\n                    existing = data.historySets.messages[key];\n                    if (existing) {\n                        logger.debug({ messageId: key }, 'absorbed message upsert in message set');\n                    }\n                }\n                if (existing) {\n                    message.messageTimestamp = existing.messageTimestamp;\n                }\n                if (data.messageUpdates[key]) {\n                    logger.debug('absorbed prior message update in message upsert');\n                    Object.assign(message, data.messageUpdates[key].update);\n                    delete data.messageUpdates[key];\n                }\n                if (data.historySets.messages[key]) {\n                    data.historySets.messages[key] = message;\n                }\n                else {\n                    data.messageUpserts[key] = {\n                        message,\n                        type: type === 'notify' || ((_b = data.messageUpserts[key]) === null || _b === void 0 ? void 0 : _b.type) === 'notify'\n                            ? 'notify'\n                            : type\n                    };\n                }\n            }\n            break;\n        case 'messages.update':\n            const msgUpdates = eventData;\n            for (const { key, update } of msgUpdates) {\n                const keyStr = stringifyMessageKey(key);\n                const existing = data.historySets.messages[keyStr] || ((_c = data.messageUpserts[keyStr]) === null || _c === void 0 ? void 0 : _c.message);\n                if (existing) {\n                    Object.assign(existing, update);\n                    // if the message was received & read by us\n                    // the chat counter must have been incremented\n                    // so we need to decrement it\n                    if (update.status === Types_1.WAMessageStatus.READ && !key.fromMe) {\n                        decrementChatReadCounterIfMsgDidUnread(existing);\n                    }\n                }\n                else {\n                    const msgUpdate = data.messageUpdates[keyStr] || { key, update: {} };\n                    Object.assign(msgUpdate.update, update);\n                    data.messageUpdates[keyStr] = msgUpdate;\n                }\n            }\n            break;\n        case 'messages.delete':\n            const deleteData = eventData;\n            if ('keys' in deleteData) {\n                const { keys } = deleteData;\n                for (const key of keys) {\n                    const keyStr = stringifyMessageKey(key);\n                    if (!data.messageDeletes[keyStr]) {\n                        data.messageDeletes[keyStr] = key;\n                    }\n                    if (data.messageUpserts[keyStr]) {\n                        delete data.messageUpserts[keyStr];\n                    }\n                    if (data.messageUpdates[keyStr]) {\n                        delete data.messageUpdates[keyStr];\n                    }\n                }\n            }\n            else {\n                // TODO: add support\n            }\n            break;\n        case 'messages.reaction':\n            const reactions = eventData;\n            for (const { key, reaction } of reactions) {\n                const keyStr = stringifyMessageKey(key);\n                const existing = data.messageUpserts[keyStr];\n                if (existing) {\n                    (0, messages_1.updateMessageWithReaction)(existing.message, reaction);\n                }\n                else {\n                    data.messageReactions[keyStr] = data.messageReactions[keyStr]\n                        || { key, reactions: [] };\n                    (0, messages_1.updateMessageWithReaction)(data.messageReactions[keyStr], reaction);\n                }\n            }\n            break;\n        case 'message-receipt.update':\n            const receipts = eventData;\n            for (const { key, receipt } of receipts) {\n                const keyStr = stringifyMessageKey(key);\n                const existing = data.messageUpserts[keyStr];\n                if (existing) {\n                    (0, messages_1.updateMessageWithReceipt)(existing.message, receipt);\n                }\n                else {\n                    data.messageReceipts[keyStr] = data.messageReceipts[keyStr]\n                        || { key, userReceipt: [] };\n                    (0, messages_1.updateMessageWithReceipt)(data.messageReceipts[keyStr], receipt);\n                }\n            }\n            break;\n        case 'groups.update':\n            const groupUpdates = eventData;\n            for (const update of groupUpdates) {\n                const id = update.id;\n                const groupUpdate = data.groupUpdates[id] || {};\n                if (!data.groupUpdates[id]) {\n                    data.groupUpdates[id] = Object.assign(groupUpdate, update);\n                }\n            }\n            break;\n        default:\n            throw new Error(`\"${event}\" cannot be buffered`);\n    }\n    function absorbingChatUpdate(existing) {\n        const chatId = existing.id;\n        const update = data.chatUpdates[chatId];\n        if (update) {\n            const conditionMatches = update.conditional ? update.conditional(data) : true;\n            if (conditionMatches) {\n                delete update.conditional;\n                logger.debug({ chatId }, 'absorbed chat update in existing chat');\n                Object.assign(existing, concatChats(update, existing));\n                delete data.chatUpdates[chatId];\n            }\n            else if (conditionMatches === false) {\n                logger.debug({ chatId }, 'chat update condition fail, removing');\n                delete data.chatUpdates[chatId];\n            }\n        }\n    }\n    function decrementChatReadCounterIfMsgDidUnread(message) {\n        // decrement chat unread counter\n        // if the message has already been marked read by us\n        const chatId = message.key.remoteJid;\n        const chat = data.chatUpdates[chatId] || data.chatUpserts[chatId];\n        if ((0, process_message_1.isRealMessage)(message, '')\n            && (0, process_message_1.shouldIncrementChatUnread)(message)\n            && typeof (chat === null || chat === void 0 ? void 0 : chat.unreadCount) === 'number'\n            && chat.unreadCount > 0) {\n            logger.debug({ chatId: chat.id }, 'decrementing chat counter');\n            chat.unreadCount -= 1;\n            if (chat.unreadCount === 0) {\n                delete chat.unreadCount;\n            }\n        }\n    }\n}\nfunction consolidateEvents(data) {\n    const map = {};\n    if (!data.historySets.empty) {\n        map['messaging-history.set'] = {\n            chats: Object.values(data.historySets.chats),\n            messages: Object.values(data.historySets.messages),\n            contacts: Object.values(data.historySets.contacts),\n            syncType: data.historySets.syncType,\n            progress: data.historySets.progress,\n            isLatest: data.historySets.isLatest,\n            peerDataRequestSessionId: data.historySets.peerDataRequestSessionId\n        };\n    }\n    const chatUpsertList = Object.values(data.chatUpserts);\n    if (chatUpsertList.length) {\n        map['chats.upsert'] = chatUpsertList;\n    }\n    const chatUpdateList = Object.values(data.chatUpdates);\n    if (chatUpdateList.length) {\n        map['chats.update'] = chatUpdateList;\n    }\n    const chatDeleteList = Array.from(data.chatDeletes);\n    if (chatDeleteList.length) {\n        map['chats.delete'] = chatDeleteList;\n    }\n    const messageUpsertList = Object.values(data.messageUpserts);\n    if (messageUpsertList.length) {\n        const type = messageUpsertList[0].type;\n        map['messages.upsert'] = {\n            messages: messageUpsertList.map(m => m.message),\n            type\n        };\n    }\n    const messageUpdateList = Object.values(data.messageUpdates);\n    if (messageUpdateList.length) {\n        map['messages.update'] = messageUpdateList;\n    }\n    const messageDeleteList = Object.values(data.messageDeletes);\n    if (messageDeleteList.length) {\n        map['messages.delete'] = { keys: messageDeleteList };\n    }\n    const messageReactionList = Object.values(data.messageReactions).flatMap(({ key, reactions }) => reactions.flatMap(reaction => ({ key, reaction })));\n    if (messageReactionList.length) {\n        map['messages.reaction'] = messageReactionList;\n    }\n    const messageReceiptList = Object.values(data.messageReceipts).flatMap(({ key, userReceipt }) => userReceipt.flatMap(receipt => ({ key, receipt })));\n    if (messageReceiptList.length) {\n        map['message-receipt.update'] = messageReceiptList;\n    }\n    const contactUpsertList = Object.values(data.contactUpserts);\n    if (contactUpsertList.length) {\n        map['contacts.upsert'] = contactUpsertList;\n    }\n    const contactUpdateList = Object.values(data.contactUpdates);\n    if (contactUpdateList.length) {\n        map['contacts.update'] = contactUpdateList;\n    }\n    const groupUpdateList = Object.values(data.groupUpdates);\n    if (groupUpdateList.length) {\n        map['groups.update'] = groupUpdateList;\n    }\n    return map;\n}\nfunction concatChats(a, b) {\n    if (b.unreadCount === null) {\n        // neutralize unread counter\n        if (a.unreadCount < 0) {\n            a.unreadCount = undefined;\n            b.unreadCount = undefined;\n        }\n    }\n    if (typeof a.unreadCount === 'number' && typeof b.unreadCount === 'number') {\n        b = { ...b };\n        if (b.unreadCount >= 0) {\n            b.unreadCount = Math.max(b.unreadCount, 0) + Math.max(a.unreadCount, 0);\n        }\n    }\n    return Object.assign(a, b);\n}\nconst stringifyMessageKey = (key) => `${key.remoteJid},${key.id},${key.fromMe ? '1' : '0'}`;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}