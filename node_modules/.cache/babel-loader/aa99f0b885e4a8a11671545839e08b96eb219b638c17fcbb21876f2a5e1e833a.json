{"ast":null,"code":"// vim: ts=4:sw=4:expandtab\n\nconst ChainType = require('./chain_type');\nconst ProtocolAddress = require('./protocol_address');\nconst SessionBuilder = require('./session_builder');\nconst SessionRecord = require('./session_record');\nconst crypto = require('./crypto');\nconst curve = require('./curve');\nconst errors = require('./errors');\nconst protobufs = require('./protobufs');\nconst queueJob = require('./queue_job');\nconst VERSION = 3;\nfunction assertBuffer(value) {\n  if (!(value instanceof Buffer)) {\n    throw TypeError(`Expected Buffer instead of: ${value.constructor.name}`);\n  }\n  return value;\n}\nclass SessionCipher {\n  constructor(storage, protocolAddress) {\n    if (!(protocolAddress instanceof ProtocolAddress)) {\n      throw new TypeError(\"protocolAddress must be a ProtocolAddress\");\n    }\n    this.addr = protocolAddress;\n    this.storage = storage;\n  }\n  _encodeTupleByte(number1, number2) {\n    if (number1 > 15 || number2 > 15) {\n      throw TypeError(\"Numbers must be 4 bits or less\");\n    }\n    return number1 << 4 | number2;\n  }\n  _decodeTupleByte(byte) {\n    return [byte >> 4, byte & 0xf];\n  }\n  toString() {\n    return `<SessionCipher(${this.addr.toString()})>`;\n  }\n  async getRecord() {\n    const record = await this.storage.loadSession(this.addr.toString());\n    if (record && !(record instanceof SessionRecord)) {\n      throw new TypeError('SessionRecord type expected from loadSession');\n    }\n    return record;\n  }\n  async storeRecord(record) {\n    record.removeOldSessions();\n    await this.storage.storeSession(this.addr.toString(), record);\n  }\n  async queueJob(awaitable) {\n    return await queueJob(this.addr.toString(), awaitable);\n  }\n  async encrypt(data) {\n    assertBuffer(data);\n    const ourIdentityKey = await this.storage.getOurIdentity();\n    return await this.queueJob(async () => {\n      const record = await this.getRecord();\n      if (!record) {\n        throw new errors.SessionError(\"No sessions\");\n      }\n      const session = record.getOpenSession();\n      if (!session) {\n        throw new errors.SessionError(\"No open session\");\n      }\n      const remoteIdentityKey = session.indexInfo.remoteIdentityKey;\n      if (!(await this.storage.isTrustedIdentity(this.addr.id, remoteIdentityKey))) {\n        throw new errors.UntrustedIdentityKeyError(this.addr.id, remoteIdentityKey);\n      }\n      const chain = session.getChain(session.currentRatchet.ephemeralKeyPair.pubKey);\n      if (chain.chainType === ChainType.RECEIVING) {\n        throw new Error(\"Tried to encrypt on a receiving chain\");\n      }\n      this.fillMessageKeys(chain, chain.chainKey.counter + 1);\n      const keys = crypto.deriveSecrets(chain.messageKeys[chain.chainKey.counter], Buffer.alloc(32), Buffer.from(\"WhisperMessageKeys\"));\n      delete chain.messageKeys[chain.chainKey.counter];\n      const msg = protobufs.WhisperMessage.create();\n      msg.ephemeralKey = session.currentRatchet.ephemeralKeyPair.pubKey;\n      msg.counter = chain.chainKey.counter;\n      msg.previousCounter = session.currentRatchet.previousCounter;\n      msg.ciphertext = crypto.encrypt(keys[0], data, keys[2].slice(0, 16));\n      const msgBuf = protobufs.WhisperMessage.encode(msg).finish();\n      const macInput = Buffer.alloc(msgBuf.byteLength + 33 * 2 + 1);\n      macInput.set(ourIdentityKey.pubKey);\n      macInput.set(session.indexInfo.remoteIdentityKey, 33);\n      macInput[33 * 2] = this._encodeTupleByte(VERSION, VERSION);\n      macInput.set(msgBuf, 33 * 2 + 1);\n      const mac = crypto.calculateMAC(keys[1], macInput);\n      const result = Buffer.alloc(msgBuf.byteLength + 9);\n      result[0] = this._encodeTupleByte(VERSION, VERSION);\n      result.set(msgBuf, 1);\n      result.set(mac.slice(0, 8), msgBuf.byteLength + 1);\n      await this.storeRecord(record);\n      let type, body;\n      if (session.pendingPreKey) {\n        type = 3; // prekey bundle\n        const preKeyMsg = protobufs.PreKeyWhisperMessage.create({\n          identityKey: ourIdentityKey.pubKey,\n          registrationId: await this.storage.getOurRegistrationId(),\n          baseKey: session.pendingPreKey.baseKey,\n          signedPreKeyId: session.pendingPreKey.signedKeyId,\n          message: result\n        });\n        if (session.pendingPreKey.preKeyId) {\n          preKeyMsg.preKeyId = session.pendingPreKey.preKeyId;\n        }\n        body = Buffer.concat([Buffer.from([this._encodeTupleByte(VERSION, VERSION)]), Buffer.from(protobufs.PreKeyWhisperMessage.encode(preKeyMsg).finish())]);\n      } else {\n        type = 1; // normal\n        body = result;\n      }\n      return {\n        type,\n        body,\n        registrationId: session.registrationId\n      };\n    });\n  }\n  async decryptWithSessions(data, sessions) {\n    // Iterate through the sessions, attempting to decrypt using each one.\n    // Stop and return the result if we get a valid result.\n    if (!sessions.length) {\n      throw new errors.SessionError(\"No sessions available\");\n    }\n    const errs = [];\n    for (const session of sessions) {\n      let plaintext;\n      try {\n        plaintext = await this.doDecryptWhisperMessage(data, session);\n        session.indexInfo.used = Date.now();\n        return {\n          session,\n          plaintext\n        };\n      } catch (e) {\n        errs.push(e);\n      }\n    }\n    console.error(\"Failed to decrypt message with any known session...\");\n    for (const e of errs) {\n      console.error(\"Session error:\" + e, e.stack);\n    }\n    throw new errors.SessionError(\"No matching sessions found for message\");\n  }\n  async decryptWhisperMessage(data) {\n    assertBuffer(data);\n    return await this.queueJob(async () => {\n      const record = await this.getRecord();\n      if (!record) {\n        throw new errors.SessionError(\"No session record\");\n      }\n      const result = await this.decryptWithSessions(data, record.getSessions());\n      const remoteIdentityKey = result.session.indexInfo.remoteIdentityKey;\n      if (!(await this.storage.isTrustedIdentity(this.addr.id, remoteIdentityKey))) {\n        throw new errors.UntrustedIdentityKeyError(this.addr.id, remoteIdentityKey);\n      }\n      if (record.isClosed(result.session)) {\n        // It's possible for this to happen when processing a backlog of messages.\n        // The message was, hopefully, just sent back in a time when this session\n        // was the most current.  Simply make a note of it and continue.  If our\n        // actual open session is for reason invalid, that must be handled via\n        // a full SessionError response.\n        console.warn(\"Decrypted message with closed session.\");\n      }\n      await this.storeRecord(record);\n      return result.plaintext;\n    });\n  }\n  async decryptPreKeyWhisperMessage(data) {\n    assertBuffer(data);\n    const versions = this._decodeTupleByte(data[0]);\n    if (versions[1] > 3 || versions[0] < 3) {\n      // min version > 3 or max version < 3\n      throw new Error(\"Incompatible version number on PreKeyWhisperMessage\");\n    }\n    return await this.queueJob(async () => {\n      let record = await this.getRecord();\n      const preKeyProto = protobufs.PreKeyWhisperMessage.decode(data.slice(1));\n      if (!record) {\n        if (preKeyProto.registrationId == null) {\n          throw new Error(\"No registrationId\");\n        }\n        record = new SessionRecord();\n      }\n      const builder = new SessionBuilder(this.storage, this.addr);\n      const preKeyId = await builder.initIncoming(record, preKeyProto);\n      const session = record.getSession(preKeyProto.baseKey);\n      const plaintext = await this.doDecryptWhisperMessage(preKeyProto.message, session);\n      await this.storeRecord(record);\n      if (preKeyId) {\n        await this.storage.removePreKey(preKeyId);\n      }\n      return plaintext;\n    });\n  }\n  async doDecryptWhisperMessage(messageBuffer, session) {\n    assertBuffer(messageBuffer);\n    if (!session) {\n      throw new TypeError(\"session required\");\n    }\n    const versions = this._decodeTupleByte(messageBuffer[0]);\n    if (versions[1] > 3 || versions[0] < 3) {\n      // min version > 3 or max version < 3\n      throw new Error(\"Incompatible version number on WhisperMessage\");\n    }\n    const messageProto = messageBuffer.slice(1, -8);\n    const message = protobufs.WhisperMessage.decode(messageProto);\n    this.maybeStepRatchet(session, message.ephemeralKey, message.previousCounter);\n    const chain = session.getChain(message.ephemeralKey);\n    if (chain.chainType === ChainType.SENDING) {\n      throw new Error(\"Tried to decrypt on a sending chain\");\n    }\n    this.fillMessageKeys(chain, message.counter);\n    if (!chain.messageKeys.hasOwnProperty(message.counter)) {\n      // Most likely the message was already decrypted and we are trying to process\n      // twice.  This can happen if the user restarts before the server gets an ACK.\n      throw new errors.MessageCounterError('Key used already or never filled');\n    }\n    const messageKey = chain.messageKeys[message.counter];\n    delete chain.messageKeys[message.counter];\n    const keys = crypto.deriveSecrets(messageKey, Buffer.alloc(32), Buffer.from(\"WhisperMessageKeys\"));\n    const ourIdentityKey = await this.storage.getOurIdentity();\n    const macInput = Buffer.alloc(messageProto.byteLength + 33 * 2 + 1);\n    macInput.set(session.indexInfo.remoteIdentityKey);\n    macInput.set(ourIdentityKey.pubKey, 33);\n    macInput[33 * 2] = this._encodeTupleByte(VERSION, VERSION);\n    macInput.set(messageProto, 33 * 2 + 1);\n    // This is where we most likely fail if the session is not a match.\n    // Don't misinterpret this as corruption.\n    crypto.verifyMAC(macInput, keys[1], messageBuffer.slice(-8), 8);\n    const plaintext = crypto.decrypt(keys[0], message.ciphertext, keys[2].slice(0, 16));\n    delete session.pendingPreKey;\n    return plaintext;\n  }\n  fillMessageKeys(chain, counter) {\n    if (chain.chainKey.counter >= counter) {\n      return;\n    }\n    if (counter - chain.chainKey.counter > 2000) {\n      throw new errors.SessionError('Over 2000 messages into the future!');\n    }\n    if (chain.chainKey.key === undefined) {\n      throw new errors.SessionError('Chain closed');\n    }\n    const key = chain.chainKey.key;\n    chain.messageKeys[chain.chainKey.counter + 1] = crypto.calculateMAC(key, Buffer.from([1]));\n    chain.chainKey.key = crypto.calculateMAC(key, Buffer.from([2]));\n    chain.chainKey.counter += 1;\n    return this.fillMessageKeys(chain, counter);\n  }\n  maybeStepRatchet(session, remoteKey, previousCounter) {\n    if (session.getChain(remoteKey)) {\n      return;\n    }\n    const ratchet = session.currentRatchet;\n    let previousRatchet = session.getChain(ratchet.lastRemoteEphemeralKey);\n    if (previousRatchet) {\n      this.fillMessageKeys(previousRatchet, previousCounter);\n      delete previousRatchet.chainKey.key; // Close\n    }\n    this.calculateRatchet(session, remoteKey, false);\n    // Now swap the ephemeral key and calculate the new sending chain\n    const prevCounter = session.getChain(ratchet.ephemeralKeyPair.pubKey);\n    if (prevCounter) {\n      ratchet.previousCounter = prevCounter.chainKey.counter;\n      session.deleteChain(ratchet.ephemeralKeyPair.pubKey);\n    }\n    ratchet.ephemeralKeyPair = curve.generateKeyPair();\n    this.calculateRatchet(session, remoteKey, true);\n    ratchet.lastRemoteEphemeralKey = remoteKey;\n  }\n  calculateRatchet(session, remoteKey, sending) {\n    let ratchet = session.currentRatchet;\n    const sharedSecret = curve.calculateAgreement(remoteKey, ratchet.ephemeralKeyPair.privKey);\n    const masterKey = crypto.deriveSecrets(sharedSecret, ratchet.rootKey, Buffer.from(\"WhisperRatchet\"), /*chunks*/2);\n    const chainKey = sending ? ratchet.ephemeralKeyPair.pubKey : remoteKey;\n    session.addChain(chainKey, {\n      messageKeys: {},\n      chainKey: {\n        counter: -1,\n        key: masterKey[1]\n      },\n      chainType: sending ? ChainType.SENDING : ChainType.RECEIVING\n    });\n    ratchet.rootKey = masterKey[0];\n  }\n  async hasOpenSession() {\n    return await this.queueJob(async () => {\n      const record = await this.getRecord();\n      if (!record) {\n        return false;\n      }\n      return record.haveOpenSession();\n    });\n  }\n  async closeOpenSession() {\n    return await this.queueJob(async () => {\n      const record = await this.getRecord();\n      if (record) {\n        const openSession = record.getOpenSession();\n        if (openSession) {\n          record.closeSession(openSession);\n          await this.storeRecord(record);\n        }\n      }\n    });\n  }\n}\nmodule.exports = SessionCipher;","map":{"version":3,"names":["ChainType","require","ProtocolAddress","SessionBuilder","SessionRecord","crypto","curve","errors","protobufs","queueJob","VERSION","assertBuffer","value","Buffer","TypeError","constructor","name","SessionCipher","storage","protocolAddress","addr","_encodeTupleByte","number1","number2","_decodeTupleByte","byte","toString","getRecord","record","loadSession","storeRecord","removeOldSessions","storeSession","awaitable","encrypt","data","ourIdentityKey","getOurIdentity","SessionError","session","getOpenSession","remoteIdentityKey","indexInfo","isTrustedIdentity","id","UntrustedIdentityKeyError","chain","getChain","currentRatchet","ephemeralKeyPair","pubKey","chainType","RECEIVING","Error","fillMessageKeys","chainKey","counter","keys","deriveSecrets","messageKeys","alloc","from","msg","WhisperMessage","create","ephemeralKey","previousCounter","ciphertext","slice","msgBuf","encode","finish","macInput","byteLength","set","mac","calculateMAC","result","type","body","pendingPreKey","preKeyMsg","PreKeyWhisperMessage","identityKey","registrationId","getOurRegistrationId","baseKey","signedPreKeyId","signedKeyId","message","preKeyId","concat","decryptWithSessions","sessions","length","errs","plaintext","doDecryptWhisperMessage","used","Date","now","e","push","console","error","stack","decryptWhisperMessage","getSessions","isClosed","warn","decryptPreKeyWhisperMessage","versions","preKeyProto","decode","builder","initIncoming","getSession","removePreKey","messageBuffer","messageProto","maybeStepRatchet","SENDING","hasOwnProperty","MessageCounterError","messageKey","verifyMAC","decrypt","key","undefined","remoteKey","ratchet","previousRatchet","lastRemoteEphemeralKey","calculateRatchet","prevCounter","deleteChain","generateKeyPair","sending","sharedSecret","calculateAgreement","privKey","masterKey","rootKey","addChain","hasOpenSession","haveOpenSession","closeOpenSession","openSession","closeSession","module","exports"],"sources":["C:/Users/vanitas/node_modules/libsignal/src/session_cipher.js"],"sourcesContent":["// vim: ts=4:sw=4:expandtab\n\nconst ChainType = require('./chain_type');\nconst ProtocolAddress = require('./protocol_address');\nconst SessionBuilder = require('./session_builder');\nconst SessionRecord = require('./session_record');\nconst crypto = require('./crypto');\nconst curve = require('./curve');\nconst errors = require('./errors');\nconst protobufs = require('./protobufs');\nconst queueJob = require('./queue_job');\n\nconst VERSION = 3;\n\nfunction assertBuffer(value) {\n    if (!(value instanceof Buffer)) {\n        throw TypeError(`Expected Buffer instead of: ${value.constructor.name}`);\n    }\n    return value;\n}\n\n\nclass SessionCipher {\n\n    constructor(storage, protocolAddress) {\n        if (!(protocolAddress instanceof ProtocolAddress)) {\n            throw new TypeError(\"protocolAddress must be a ProtocolAddress\");\n        }\n        this.addr = protocolAddress;\n        this.storage = storage;\n    }\n\n    _encodeTupleByte(number1, number2) {\n        if (number1 > 15 || number2 > 15) {\n            throw TypeError(\"Numbers must be 4 bits or less\");\n        }\n        return (number1 << 4) | number2;\n    }\n\n    _decodeTupleByte(byte) {\n        return [byte >> 4, byte & 0xf];\n    }\n\n    toString() {\n        return `<SessionCipher(${this.addr.toString()})>`;\n    }\n\n    async getRecord() {\n        const record = await this.storage.loadSession(this.addr.toString());\n        if (record && !(record instanceof SessionRecord)) {\n            throw new TypeError('SessionRecord type expected from loadSession'); \n        }\n        return record;\n    }\n\n    async storeRecord(record) {\n        record.removeOldSessions();\n        await this.storage.storeSession(this.addr.toString(), record);\n    }\n\n    async queueJob(awaitable) {\n        return await queueJob(this.addr.toString(), awaitable);\n    }\n\n    async encrypt(data) {\n        assertBuffer(data);\n        const ourIdentityKey = await this.storage.getOurIdentity();\n        return await this.queueJob(async () => {\n            const record = await this.getRecord();\n            if (!record) {\n                throw new errors.SessionError(\"No sessions\");\n            }\n            const session = record.getOpenSession();\n            if (!session) {\n                throw new errors.SessionError(\"No open session\");\n            }\n            const remoteIdentityKey = session.indexInfo.remoteIdentityKey;\n            if (!await this.storage.isTrustedIdentity(this.addr.id, remoteIdentityKey)) {\n                throw new errors.UntrustedIdentityKeyError(this.addr.id, remoteIdentityKey);\n            }\n            const chain = session.getChain(session.currentRatchet.ephemeralKeyPair.pubKey);\n            if (chain.chainType === ChainType.RECEIVING) {\n                throw new Error(\"Tried to encrypt on a receiving chain\");\n            }\n            this.fillMessageKeys(chain, chain.chainKey.counter + 1);\n            const keys = crypto.deriveSecrets(chain.messageKeys[chain.chainKey.counter],\n                                              Buffer.alloc(32), Buffer.from(\"WhisperMessageKeys\"));\n            delete chain.messageKeys[chain.chainKey.counter];\n            const msg = protobufs.WhisperMessage.create();\n            msg.ephemeralKey = session.currentRatchet.ephemeralKeyPair.pubKey;\n            msg.counter = chain.chainKey.counter;\n            msg.previousCounter = session.currentRatchet.previousCounter;\n            msg.ciphertext = crypto.encrypt(keys[0], data, keys[2].slice(0, 16));\n            const msgBuf = protobufs.WhisperMessage.encode(msg).finish();\n            const macInput = Buffer.alloc(msgBuf.byteLength + (33 * 2) + 1);\n            macInput.set(ourIdentityKey.pubKey);\n            macInput.set(session.indexInfo.remoteIdentityKey, 33);\n            macInput[33 * 2] = this._encodeTupleByte(VERSION, VERSION);\n            macInput.set(msgBuf, (33 * 2) + 1);\n            const mac = crypto.calculateMAC(keys[1], macInput);\n            const result = Buffer.alloc(msgBuf.byteLength + 9);\n            result[0] = this._encodeTupleByte(VERSION, VERSION);\n            result.set(msgBuf, 1);\n            result.set(mac.slice(0, 8), msgBuf.byteLength + 1);\n            await this.storeRecord(record);\n            let type, body;\n            if (session.pendingPreKey) {\n                type = 3;  // prekey bundle\n                const preKeyMsg = protobufs.PreKeyWhisperMessage.create({\n                    identityKey: ourIdentityKey.pubKey,\n                    registrationId: await this.storage.getOurRegistrationId(),\n                    baseKey: session.pendingPreKey.baseKey,\n                    signedPreKeyId: session.pendingPreKey.signedKeyId,\n                    message: result\n                });\n                if (session.pendingPreKey.preKeyId) {\n                    preKeyMsg.preKeyId = session.pendingPreKey.preKeyId;\n                }\n                body = Buffer.concat([\n                    Buffer.from([this._encodeTupleByte(VERSION, VERSION)]),\n                    Buffer.from(\n                        protobufs.PreKeyWhisperMessage.encode(preKeyMsg).finish()\n                    )\n                ]);\n            } else {\n                type = 1;  // normal\n                body = result;\n            }\n            return {\n                type,\n                body,\n                registrationId: session.registrationId\n            };\n        });\n    }\n\n    async decryptWithSessions(data, sessions) {\n        // Iterate through the sessions, attempting to decrypt using each one.\n        // Stop and return the result if we get a valid result.\n        if (!sessions.length) {\n            throw new errors.SessionError(\"No sessions available\");\n        }   \n        const errs = [];\n        for (const session of sessions) {\n            let plaintext; \n            try {\n                plaintext = await this.doDecryptWhisperMessage(data, session);\n                session.indexInfo.used = Date.now();\n                return {\n                    session,\n                    plaintext\n                };\n            } catch(e) {\n                errs.push(e);\n            }\n        }\n        console.error(\"Failed to decrypt message with any known session...\");\n        for (const e of errs) {\n            console.error(\"Session error:\" + e, e.stack);\n        }\n        throw new errors.SessionError(\"No matching sessions found for message\");\n    }\n\n    async decryptWhisperMessage(data) {\n        assertBuffer(data);\n        return await this.queueJob(async () => {\n            const record = await this.getRecord();\n            if (!record) {\n                throw new errors.SessionError(\"No session record\");\n            }\n            const result = await this.decryptWithSessions(data, record.getSessions());\n            const remoteIdentityKey = result.session.indexInfo.remoteIdentityKey;\n            if (!await this.storage.isTrustedIdentity(this.addr.id, remoteIdentityKey)) {\n                throw new errors.UntrustedIdentityKeyError(this.addr.id, remoteIdentityKey);\n            }   \n            if (record.isClosed(result.session)) {\n                // It's possible for this to happen when processing a backlog of messages.\n                // The message was, hopefully, just sent back in a time when this session\n                // was the most current.  Simply make a note of it and continue.  If our\n                // actual open session is for reason invalid, that must be handled via\n                // a full SessionError response.\n                console.warn(\"Decrypted message with closed session.\");\n            }\n            await this.storeRecord(record);\n            return result.plaintext;\n        });\n    }\n\n    async decryptPreKeyWhisperMessage(data) {\n        assertBuffer(data);\n        const versions = this._decodeTupleByte(data[0]);\n        if (versions[1] > 3 || versions[0] < 3) {  // min version > 3 or max version < 3\n            throw new Error(\"Incompatible version number on PreKeyWhisperMessage\");\n        }\n        return await this.queueJob(async () => {\n            let record = await this.getRecord();\n            const preKeyProto = protobufs.PreKeyWhisperMessage.decode(data.slice(1));\n            if (!record) {\n                if (preKeyProto.registrationId == null) {\n                    throw new Error(\"No registrationId\");\n                }\n                record = new SessionRecord();\n            }\n            const builder = new SessionBuilder(this.storage, this.addr);\n            const preKeyId = await builder.initIncoming(record, preKeyProto);\n            const session = record.getSession(preKeyProto.baseKey);\n            const plaintext = await this.doDecryptWhisperMessage(preKeyProto.message, session);\n            await this.storeRecord(record);\n            if (preKeyId) {\n                await this.storage.removePreKey(preKeyId);\n            }\n            return plaintext;\n        });\n    }\n\n    async doDecryptWhisperMessage(messageBuffer, session) {\n        assertBuffer(messageBuffer);\n        if (!session) {\n            throw new TypeError(\"session required\");\n        }\n        const versions = this._decodeTupleByte(messageBuffer[0]);\n        if (versions[1] > 3 || versions[0] < 3) {  // min version > 3 or max version < 3\n            throw new Error(\"Incompatible version number on WhisperMessage\");\n        }\n        const messageProto = messageBuffer.slice(1, -8);\n        const message = protobufs.WhisperMessage.decode(messageProto);\n        this.maybeStepRatchet(session, message.ephemeralKey, message.previousCounter);\n        const chain = session.getChain(message.ephemeralKey);\n        if (chain.chainType === ChainType.SENDING) {\n            throw new Error(\"Tried to decrypt on a sending chain\");\n        }\n        this.fillMessageKeys(chain, message.counter);\n        if (!chain.messageKeys.hasOwnProperty(message.counter)) {\n            // Most likely the message was already decrypted and we are trying to process\n            // twice.  This can happen if the user restarts before the server gets an ACK.\n            throw new errors.MessageCounterError('Key used already or never filled');\n        }\n        const messageKey = chain.messageKeys[message.counter];\n        delete chain.messageKeys[message.counter];\n        const keys = crypto.deriveSecrets(messageKey, Buffer.alloc(32),\n                                          Buffer.from(\"WhisperMessageKeys\"));\n        const ourIdentityKey = await this.storage.getOurIdentity();\n        const macInput = Buffer.alloc(messageProto.byteLength + (33 * 2) + 1);\n        macInput.set(session.indexInfo.remoteIdentityKey);\n        macInput.set(ourIdentityKey.pubKey, 33);\n        macInput[33 * 2] = this._encodeTupleByte(VERSION, VERSION);\n        macInput.set(messageProto, (33 * 2) + 1);\n        // This is where we most likely fail if the session is not a match.\n        // Don't misinterpret this as corruption.\n        crypto.verifyMAC(macInput, keys[1], messageBuffer.slice(-8), 8);\n        const plaintext = crypto.decrypt(keys[0], message.ciphertext, keys[2].slice(0, 16));\n        delete session.pendingPreKey;\n        return plaintext;\n    }\n\n    fillMessageKeys(chain, counter) {\n        if (chain.chainKey.counter >= counter) {\n            return;\n        }\n        if (counter - chain.chainKey.counter > 2000) {\n            throw new errors.SessionError('Over 2000 messages into the future!');\n        }\n        if (chain.chainKey.key === undefined) {\n            throw new errors.SessionError('Chain closed');\n        }\n        const key = chain.chainKey.key;\n        chain.messageKeys[chain.chainKey.counter + 1] = crypto.calculateMAC(key, Buffer.from([1]));\n        chain.chainKey.key = crypto.calculateMAC(key, Buffer.from([2]));\n        chain.chainKey.counter += 1;\n        return this.fillMessageKeys(chain, counter);\n    }\n\n    maybeStepRatchet(session, remoteKey, previousCounter) {\n        if (session.getChain(remoteKey)) {\n            return;\n        }\n        const ratchet = session.currentRatchet;\n        let previousRatchet = session.getChain(ratchet.lastRemoteEphemeralKey);\n        if (previousRatchet) {\n            this.fillMessageKeys(previousRatchet, previousCounter);\n            delete previousRatchet.chainKey.key;  // Close\n        }\n        this.calculateRatchet(session, remoteKey, false);\n        // Now swap the ephemeral key and calculate the new sending chain\n        const prevCounter = session.getChain(ratchet.ephemeralKeyPair.pubKey);\n        if (prevCounter) {\n            ratchet.previousCounter = prevCounter.chainKey.counter;\n            session.deleteChain(ratchet.ephemeralKeyPair.pubKey);\n        }\n        ratchet.ephemeralKeyPair = curve.generateKeyPair();\n        this.calculateRatchet(session, remoteKey, true);\n        ratchet.lastRemoteEphemeralKey = remoteKey;\n    }\n\n    calculateRatchet(session, remoteKey, sending) {\n        let ratchet = session.currentRatchet;\n        const sharedSecret = curve.calculateAgreement(remoteKey, ratchet.ephemeralKeyPair.privKey);\n        const masterKey = crypto.deriveSecrets(sharedSecret, ratchet.rootKey,\n                                               Buffer.from(\"WhisperRatchet\"), /*chunks*/ 2);\n        const chainKey = sending ? ratchet.ephemeralKeyPair.pubKey : remoteKey;\n        session.addChain(chainKey, {\n            messageKeys: {},\n            chainKey: {\n                counter: -1,\n                key: masterKey[1]\n            },\n            chainType: sending ? ChainType.SENDING : ChainType.RECEIVING\n        });\n        ratchet.rootKey = masterKey[0];\n    }\n\n    async hasOpenSession() {\n        return await this.queueJob(async () => {\n            const record = await this.getRecord();\n            if (!record) {\n                return false;\n            }\n            return record.haveOpenSession();\n        });\n    }\n\n    async closeOpenSession() {\n        return await this.queueJob(async () => {\n            const record = await this.getRecord();\n            if (record) {\n                const openSession = record.getOpenSession();\n                if (openSession) {\n                    record.closeSession(openSession);\n                    await this.storeRecord(record);\n                }\n            }\n        });\n    }\n}\n\nmodule.exports = SessionCipher;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}