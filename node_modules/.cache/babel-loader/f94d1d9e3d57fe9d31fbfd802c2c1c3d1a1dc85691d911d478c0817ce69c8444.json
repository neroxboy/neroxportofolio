{"ast":null,"code":"'use strict';\n\nvar AsyncLock = function (opts) {\n  opts = opts || {};\n  this.Promise = opts.Promise || Promise;\n\n  // format: {key : [fn, fn]}\n  // queues[key] = null indicates no job running for key\n  this.queues = Object.create(null);\n\n  // lock is reentrant for same domain\n  this.domainReentrant = opts.domainReentrant || false;\n  if (this.domainReentrant) {\n    if (typeof process === 'undefined' || typeof process.domain === 'undefined') {\n      throw new Error('Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, ' + 'use a NodeJS version that still implements Domain, or install a browser polyfill.');\n    }\n    // domain of current running func {key : fn}\n    this.domains = Object.create(null);\n  }\n  this.timeout = opts.timeout || AsyncLock.DEFAULT_TIMEOUT;\n  this.maxOccupationTime = opts.maxOccupationTime || AsyncLock.DEFAULT_MAX_OCCUPATION_TIME;\n  this.maxExecutionTime = opts.maxExecutionTime || AsyncLock.DEFAULT_MAX_EXECUTION_TIME;\n  if (opts.maxPending === Infinity || Number.isInteger(opts.maxPending) && opts.maxPending >= 0) {\n    this.maxPending = opts.maxPending;\n  } else {\n    this.maxPending = AsyncLock.DEFAULT_MAX_PENDING;\n  }\n};\nAsyncLock.DEFAULT_TIMEOUT = 0; //Never\nAsyncLock.DEFAULT_MAX_OCCUPATION_TIME = 0; //Never\nAsyncLock.DEFAULT_MAX_EXECUTION_TIME = 0; //Never\nAsyncLock.DEFAULT_MAX_PENDING = 1000;\n\n/**\n * Acquire Locks\n *\n * @param {String|Array} key \tresource key or keys to lock\n * @param {function} fn \tasync function\n * @param {function} cb \tcallback function, otherwise will return a promise\n * @param {Object} opts \toptions\n */\nAsyncLock.prototype.acquire = function (key, fn, cb, opts) {\n  if (Array.isArray(key)) {\n    return this._acquireBatch(key, fn, cb, opts);\n  }\n  if (typeof fn !== 'function') {\n    throw new Error('You must pass a function to execute');\n  }\n\n  // faux-deferred promise using new Promise() (as Promise.defer is deprecated)\n  var deferredResolve = null;\n  var deferredReject = null;\n  var deferred = null;\n  if (typeof cb !== 'function') {\n    opts = cb;\n    cb = null;\n\n    // will return a promise\n    deferred = new this.Promise(function (resolve, reject) {\n      deferredResolve = resolve;\n      deferredReject = reject;\n    });\n  }\n  opts = opts || {};\n  var resolved = false;\n  var timer = null;\n  var occupationTimer = null;\n  var executionTimer = null;\n  var self = this;\n  var done = function (locked, err, ret) {\n    if (occupationTimer) {\n      clearTimeout(occupationTimer);\n      occupationTimer = null;\n    }\n    if (executionTimer) {\n      clearTimeout(executionTimer);\n      executionTimer = null;\n    }\n    if (locked) {\n      if (!!self.queues[key] && self.queues[key].length === 0) {\n        delete self.queues[key];\n      }\n      if (self.domainReentrant) {\n        delete self.domains[key];\n      }\n    }\n    if (!resolved) {\n      if (!deferred) {\n        if (typeof cb === 'function') {\n          cb(err, ret);\n        }\n      } else {\n        //promise mode\n        if (err) {\n          deferredReject(err);\n        } else {\n          deferredResolve(ret);\n        }\n      }\n      resolved = true;\n    }\n    if (locked) {\n      //run next func\n      if (!!self.queues[key] && self.queues[key].length > 0) {\n        self.queues[key].shift()();\n      }\n    }\n  };\n  var exec = function (locked) {\n    if (resolved) {\n      // may due to timed out\n      return done(locked);\n    }\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    if (self.domainReentrant && locked) {\n      self.domains[key] = process.domain;\n    }\n    var maxExecutionTime = opts.maxExecutionTime || self.maxExecutionTime;\n    if (maxExecutionTime) {\n      executionTimer = setTimeout(function () {\n        if (!!self.queues[key]) {\n          done(locked, new Error('Maximum execution time is exceeded ' + key));\n        }\n      }, maxExecutionTime);\n    }\n\n    // Callback mode\n    if (fn.length === 1) {\n      var called = false;\n      try {\n        fn(function (err, ret) {\n          if (!called) {\n            called = true;\n            done(locked, err, ret);\n          }\n        });\n      } catch (err) {\n        // catching error thrown in user function fn\n        if (!called) {\n          called = true;\n          done(locked, err);\n        }\n      }\n    } else {\n      // Promise mode\n      self._promiseTry(function () {\n        return fn();\n      }).then(function (ret) {\n        done(locked, undefined, ret);\n      }, function (error) {\n        done(locked, error);\n      });\n    }\n  };\n  if (self.domainReentrant && !!process.domain) {\n    exec = process.domain.bind(exec);\n  }\n  var maxPending = opts.maxPending || self.maxPending;\n  if (!self.queues[key]) {\n    self.queues[key] = [];\n    exec(true);\n  } else if (self.domainReentrant && !!process.domain && process.domain === self.domains[key]) {\n    // If code is in the same domain of current running task, run it directly\n    // Since lock is re-enterable\n    exec(false);\n  } else if (self.queues[key].length >= maxPending) {\n    done(false, new Error('Too many pending tasks in queue ' + key));\n  } else {\n    var taskFn = function () {\n      exec(true);\n    };\n    if (opts.skipQueue) {\n      self.queues[key].unshift(taskFn);\n    } else {\n      self.queues[key].push(taskFn);\n    }\n    var timeout = opts.timeout || self.timeout;\n    if (timeout) {\n      timer = setTimeout(function () {\n        timer = null;\n        done(false, new Error('async-lock timed out in queue ' + key));\n      }, timeout);\n    }\n  }\n  var maxOccupationTime = opts.maxOccupationTime || self.maxOccupationTime;\n  if (maxOccupationTime) {\n    occupationTimer = setTimeout(function () {\n      if (!!self.queues[key]) {\n        done(false, new Error('Maximum occupation time is exceeded in queue ' + key));\n      }\n    }, maxOccupationTime);\n  }\n  if (deferred) {\n    return deferred;\n  }\n};\n\n/*\n * Below is how this function works:\n *\n * Equivalent code:\n * self.acquire(key1, function(cb){\n *     self.acquire(key2, function(cb){\n *         self.acquire(key3, fn, cb);\n *     }, cb);\n * }, cb);\n *\n * Equivalent code:\n * var fn3 = getFn(key3, fn);\n * var fn2 = getFn(key2, fn3);\n * var fn1 = getFn(key1, fn2);\n * fn1(cb);\n */\nAsyncLock.prototype._acquireBatch = function (keys, fn, cb, opts) {\n  if (typeof cb !== 'function') {\n    opts = cb;\n    cb = null;\n  }\n  var self = this;\n  var getFn = function (key, fn) {\n    return function (cb) {\n      self.acquire(key, fn, cb, opts);\n    };\n  };\n  var fnx = keys.reduceRight(function (prev, key) {\n    return getFn(key, prev);\n  }, fn);\n  if (typeof cb === 'function') {\n    fnx(cb);\n  } else {\n    return new this.Promise(function (resolve, reject) {\n      // check for promise mode in case keys is empty array\n      if (fnx.length === 1) {\n        fnx(function (err, ret) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(ret);\n          }\n        });\n      } else {\n        resolve(fnx());\n      }\n    });\n  }\n};\n\n/*\n *\tWhether there is any running or pending asyncFunc\n *\n *\t@param {String} key\n */\nAsyncLock.prototype.isBusy = function (key) {\n  if (!key) {\n    return Object.keys(this.queues).length > 0;\n  } else {\n    return !!this.queues[key];\n  }\n};\n\n/**\n * Promise.try() implementation to become independent of Q-specific methods\n */\nAsyncLock.prototype._promiseTry = function (fn) {\n  try {\n    return this.Promise.resolve(fn());\n  } catch (e) {\n    return this.Promise.reject(e);\n  }\n};\nmodule.exports = AsyncLock;","map":{"version":3,"names":["AsyncLock","opts","Promise","queues","Object","create","domainReentrant","process","domain","Error","domains","timeout","DEFAULT_TIMEOUT","maxOccupationTime","DEFAULT_MAX_OCCUPATION_TIME","maxExecutionTime","DEFAULT_MAX_EXECUTION_TIME","maxPending","Infinity","Number","isInteger","DEFAULT_MAX_PENDING","prototype","acquire","key","fn","cb","Array","isArray","_acquireBatch","deferredResolve","deferredReject","deferred","resolve","reject","resolved","timer","occupationTimer","executionTimer","self","done","locked","err","ret","clearTimeout","length","shift","exec","setTimeout","called","_promiseTry","then","undefined","error","bind","taskFn","skipQueue","unshift","push","keys","getFn","fnx","reduceRight","prev","isBusy","e","module","exports"],"sources":["C:/Users/vanitas/node_modules/async-lock/lib/index.js"],"sourcesContent":["'use strict';\n\nvar AsyncLock = function (opts) {\n\topts = opts || {};\n\n\tthis.Promise = opts.Promise || Promise;\n\n\t// format: {key : [fn, fn]}\n\t// queues[key] = null indicates no job running for key\n\tthis.queues = Object.create(null);\n\n\t// lock is reentrant for same domain\n\tthis.domainReentrant = opts.domainReentrant || false;\n\tif (this.domainReentrant) {\n\t\tif (typeof process === 'undefined' || typeof process.domain === 'undefined') {\n\t\t\tthrow new Error(\n\t\t\t\t'Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, ' +\n\t\t\t\t'use a NodeJS version that still implements Domain, or install a browser polyfill.');\n\t\t}\n\t\t// domain of current running func {key : fn}\n\t\tthis.domains = Object.create(null);\n\t}\n\n\tthis.timeout = opts.timeout || AsyncLock.DEFAULT_TIMEOUT;\n\tthis.maxOccupationTime = opts.maxOccupationTime || AsyncLock.DEFAULT_MAX_OCCUPATION_TIME;\n\tthis.maxExecutionTime = opts.maxExecutionTime || AsyncLock.DEFAULT_MAX_EXECUTION_TIME;\n\tif (opts.maxPending === Infinity || (Number.isInteger(opts.maxPending) && opts.maxPending >= 0)) {\n\t\tthis.maxPending = opts.maxPending;\n\t} else {\n\t\tthis.maxPending = AsyncLock.DEFAULT_MAX_PENDING;\n\t}\n};\n\nAsyncLock.DEFAULT_TIMEOUT = 0; //Never\nAsyncLock.DEFAULT_MAX_OCCUPATION_TIME = 0; //Never\nAsyncLock.DEFAULT_MAX_EXECUTION_TIME = 0; //Never\nAsyncLock.DEFAULT_MAX_PENDING = 1000;\n\n/**\n * Acquire Locks\n *\n * @param {String|Array} key \tresource key or keys to lock\n * @param {function} fn \tasync function\n * @param {function} cb \tcallback function, otherwise will return a promise\n * @param {Object} opts \toptions\n */\nAsyncLock.prototype.acquire = function (key, fn, cb, opts) {\n\tif (Array.isArray(key)) {\n\t\treturn this._acquireBatch(key, fn, cb, opts);\n\t}\n\n\tif (typeof (fn) !== 'function') {\n\t\tthrow new Error('You must pass a function to execute');\n\t}\n\n\t// faux-deferred promise using new Promise() (as Promise.defer is deprecated)\n\tvar deferredResolve = null;\n\tvar deferredReject = null;\n\tvar deferred = null;\n\n\tif (typeof (cb) !== 'function') {\n\t\topts = cb;\n\t\tcb = null;\n\n\t\t// will return a promise\n\t\tdeferred = new this.Promise(function(resolve, reject) {\n\t\t\tdeferredResolve = resolve;\n\t\t\tdeferredReject = reject;\n\t\t});\n\t}\n\n\topts = opts || {};\n\n\tvar resolved = false;\n\tvar timer = null;\n\tvar occupationTimer = null;\n\tvar executionTimer = null;\n\tvar self = this;\n\n\tvar done = function (locked, err, ret) {\n\n\t\tif (occupationTimer) {\n\t\t\tclearTimeout(occupationTimer);\n\t\t\toccupationTimer = null;\n\t\t}\n\n\t\tif (executionTimer) {\n\t\t\tclearTimeout(executionTimer);\n\t\t\texecutionTimer = null;\n\t\t}\n\n\t\tif (locked) {\n\t\t\tif (!!self.queues[key] && self.queues[key].length === 0) {\n\t\t\t\tdelete self.queues[key];\n\t\t\t}\n\t\t\tif (self.domainReentrant) {\n\t\t\t\tdelete self.domains[key];\n\t\t\t}\n\t\t}\n\n\t\tif (!resolved) {\n\t\t\tif (!deferred) {\n\t\t\t\tif (typeof (cb) === 'function') {\n\t\t\t\t\tcb(err, ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//promise mode\n\t\t\t\tif (err) {\n\t\t\t\t\tdeferredReject(err);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdeferredResolve(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresolved = true;\n\t\t}\n\n\t\tif (locked) {\n\t\t\t//run next func\n\t\t\tif (!!self.queues[key] && self.queues[key].length > 0) {\n\t\t\t\tself.queues[key].shift()();\n\t\t\t}\n\t\t}\n\t};\n\n\tvar exec = function (locked) {\n\t\tif (resolved) { // may due to timed out\n\t\t\treturn done(locked);\n\t\t}\n\n\t\tif (timer) {\n\t\t\tclearTimeout(timer);\n\t\t\ttimer = null;\n\t\t}\n\n\t\tif (self.domainReentrant && locked) {\n\t\t\tself.domains[key] = process.domain;\n\t\t}\n\n\t\tvar maxExecutionTime = opts.maxExecutionTime || self.maxExecutionTime;\n\t\tif (maxExecutionTime) {\n\t\t\texecutionTimer = setTimeout(function () {\n\t\t\t\tif (!!self.queues[key]) {\n\t\t\t\t\tdone(locked, new Error('Maximum execution time is exceeded ' + key));\n\t\t\t\t}\n\t\t\t}, maxExecutionTime);\n\t\t}\n\n\t\t// Callback mode\n\t\tif (fn.length === 1) {\n\t\t\tvar called = false;\n\t\t\ttry {\n\t\t\t\tfn(function (err, ret) {\n\t\t\t\t\tif (!called) {\n\t\t\t\t\t\tcalled = true;\n\t\t\t\t\t\tdone(locked, err, ret);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\t// catching error thrown in user function fn\n\t\t\t\tif (!called) {\n\t\t\t\t\tcalled = true;\n\t\t\t\t\tdone(locked, err);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Promise mode\n\t\t\tself._promiseTry(function () {\n\t\t\t\treturn fn();\n\t\t\t})\n\t\t\t.then(function(ret){\n\t\t\t\tdone(locked, undefined, ret);\n\t\t\t}, function(error){\n\t\t\t\tdone(locked, error);\n\t\t\t});\n\t\t}\n\t};\n\n\tif (self.domainReentrant && !!process.domain) {\n\t\texec = process.domain.bind(exec);\n\t}\n\n\tvar maxPending = opts.maxPending || self.maxPending;\n\n\tif (!self.queues[key]) {\n\t\tself.queues[key] = [];\n\t\texec(true);\n\t}\n\telse if (self.domainReentrant && !!process.domain && process.domain === self.domains[key]) {\n\t\t// If code is in the same domain of current running task, run it directly\n\t\t// Since lock is re-enterable\n\t\texec(false);\n\t}\n\telse if (self.queues[key].length >= maxPending) {\n\t\tdone(false, new Error('Too many pending tasks in queue ' + key));\n\t}\n\telse {\n\t\tvar taskFn = function () {\n\t\t\texec(true);\n\t\t};\n\t\tif (opts.skipQueue) {\n\t\t\tself.queues[key].unshift(taskFn);\n\t\t} else {\n\t\t\tself.queues[key].push(taskFn);\n\t\t}\n\n\t\tvar timeout = opts.timeout || self.timeout;\n\t\tif (timeout) {\n\t\t\ttimer = setTimeout(function () {\n\t\t\t\ttimer = null;\n\t\t\t\tdone(false, new Error('async-lock timed out in queue ' + key));\n\t\t\t}, timeout);\n\t\t}\n\t}\n\n\tvar maxOccupationTime = opts.maxOccupationTime || self.maxOccupationTime;\n\t\tif (maxOccupationTime) {\n\t\t\toccupationTimer = setTimeout(function () {\n\t\t\t\tif (!!self.queues[key]) {\n\t\t\t\t\tdone(false, new Error('Maximum occupation time is exceeded in queue ' + key));\n\t\t\t\t}\n\t\t\t}, maxOccupationTime);\n\t\t}\n\n\tif (deferred) {\n\t\treturn deferred;\n\t}\n};\n\n/*\n * Below is how this function works:\n *\n * Equivalent code:\n * self.acquire(key1, function(cb){\n *     self.acquire(key2, function(cb){\n *         self.acquire(key3, fn, cb);\n *     }, cb);\n * }, cb);\n *\n * Equivalent code:\n * var fn3 = getFn(key3, fn);\n * var fn2 = getFn(key2, fn3);\n * var fn1 = getFn(key1, fn2);\n * fn1(cb);\n */\nAsyncLock.prototype._acquireBatch = function (keys, fn, cb, opts) {\n\tif (typeof (cb) !== 'function') {\n\t\topts = cb;\n\t\tcb = null;\n\t}\n\n\tvar self = this;\n\tvar getFn = function (key, fn) {\n\t\treturn function (cb) {\n\t\t\tself.acquire(key, fn, cb, opts);\n\t\t};\n\t};\n\n\tvar fnx = keys.reduceRight(function (prev, key) {\n\t\treturn getFn(key, prev);\n\t}, fn);\n\n\tif (typeof (cb) === 'function') {\n\t\tfnx(cb);\n\t}\n\telse {\n\t\treturn new this.Promise(function (resolve, reject) {\n\t\t\t// check for promise mode in case keys is empty array\n\t\t\tif (fnx.length === 1) {\n\t\t\t\tfnx(function (err, ret) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresolve(ret);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tresolve(fnx());\n\t\t\t}\n\t\t});\n\t}\n};\n\n/*\n *\tWhether there is any running or pending asyncFunc\n *\n *\t@param {String} key\n */\nAsyncLock.prototype.isBusy = function (key) {\n\tif (!key) {\n\t\treturn Object.keys(this.queues).length > 0;\n\t}\n\telse {\n\t\treturn !!this.queues[key];\n\t}\n};\n\n/**\n * Promise.try() implementation to become independent of Q-specific methods\n */\nAsyncLock.prototype._promiseTry = function(fn) {\n\ttry {\n\t\treturn this.Promise.resolve(fn());\n\t} catch (e) {\n\t\treturn this.Promise.reject(e);\n\t}\n};\n\nmodule.exports = AsyncLock;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}