{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeBinaryNode = void 0;\nconst constants = __importStar(require(\"./constants\"));\nconst jid_utils_1 = require(\"./jid-utils\");\nconst encodeBinaryNode = (node, opts = constants, buffer = [0]) => {\n  const encoded = encodeBinaryNodeInner(node, opts, buffer);\n  return Buffer.from(encoded);\n};\nexports.encodeBinaryNode = encodeBinaryNode;\nconst encodeBinaryNodeInner = ({\n  tag,\n  attrs,\n  content\n}, opts, buffer) => {\n  const {\n    TAGS,\n    TOKEN_MAP\n  } = opts;\n  const pushByte = value => buffer.push(value & 0xff);\n  const pushInt = (value, n, littleEndian = false) => {\n    for (let i = 0; i < n; i++) {\n      const curShift = littleEndian ? i : n - 1 - i;\n      buffer.push(value >> curShift * 8 & 0xff);\n    }\n  };\n  const pushBytes = bytes => bytes.forEach(b => buffer.push(b));\n  const pushInt16 = value => {\n    pushBytes([value >> 8 & 0xff, value & 0xff]);\n  };\n  const pushInt20 = value => pushBytes([value >> 16 & 0x0f, value >> 8 & 0xff, value & 0xff]);\n  const writeByteLength = length => {\n    if (length >= 4294967296) {\n      throw new Error('string too large to encode: ' + length);\n    }\n    if (length >= 1 << 20) {\n      pushByte(TAGS.BINARY_32);\n      pushInt(length, 4); // 32 bit integer\n    } else if (length >= 256) {\n      pushByte(TAGS.BINARY_20);\n      pushInt20(length);\n    } else {\n      pushByte(TAGS.BINARY_8);\n      pushByte(length);\n    }\n  };\n  const writeStringRaw = str => {\n    const bytes = Buffer.from(str, 'utf-8');\n    writeByteLength(bytes.length);\n    pushBytes(bytes);\n  };\n  const writeJid = ({\n    domainType,\n    device,\n    user,\n    server\n  }) => {\n    if (typeof device !== 'undefined') {\n      pushByte(TAGS.AD_JID);\n      pushByte(domainType || 0);\n      pushByte(device || 0);\n      writeString(user);\n    } else {\n      pushByte(TAGS.JID_PAIR);\n      if (user.length) {\n        writeString(user);\n      } else {\n        pushByte(TAGS.LIST_EMPTY);\n      }\n      writeString(server);\n    }\n  };\n  const packNibble = char => {\n    switch (char) {\n      case '-':\n        return 10;\n      case '.':\n        return 11;\n      case '\\0':\n        return 15;\n      default:\n        if (char >= '0' && char <= '9') {\n          return char.charCodeAt(0) - '0'.charCodeAt(0);\n        }\n        throw new Error(`invalid byte for nibble \"${char}\"`);\n    }\n  };\n  const packHex = char => {\n    if (char >= '0' && char <= '9') {\n      return char.charCodeAt(0) - '0'.charCodeAt(0);\n    }\n    if (char >= 'A' && char <= 'F') {\n      return 10 + char.charCodeAt(0) - 'A'.charCodeAt(0);\n    }\n    if (char >= 'a' && char <= 'f') {\n      return 10 + char.charCodeAt(0) - 'a'.charCodeAt(0);\n    }\n    if (char === '\\0') {\n      return 15;\n    }\n    throw new Error(`Invalid hex char \"${char}\"`);\n  };\n  const writePackedBytes = (str, type) => {\n    if (str.length > TAGS.PACKED_MAX) {\n      throw new Error('Too many bytes to pack');\n    }\n    pushByte(type === 'nibble' ? TAGS.NIBBLE_8 : TAGS.HEX_8);\n    let roundedLength = Math.ceil(str.length / 2.0);\n    if (str.length % 2 !== 0) {\n      roundedLength |= 128;\n    }\n    pushByte(roundedLength);\n    const packFunction = type === 'nibble' ? packNibble : packHex;\n    const packBytePair = (v1, v2) => {\n      const result = packFunction(v1) << 4 | packFunction(v2);\n      return result;\n    };\n    const strLengthHalf = Math.floor(str.length / 2);\n    for (let i = 0; i < strLengthHalf; i++) {\n      pushByte(packBytePair(str[2 * i], str[2 * i + 1]));\n    }\n    if (str.length % 2 !== 0) {\n      pushByte(packBytePair(str[str.length - 1], '\\x00'));\n    }\n  };\n  const isNibble = str => {\n    if (str.length > TAGS.PACKED_MAX) {\n      return false;\n    }\n    for (let i = 0; i < str.length; i++) {\n      const char = str[i];\n      const isInNibbleRange = char >= '0' && char <= '9';\n      if (!isInNibbleRange && char !== '-' && char !== '.') {\n        return false;\n      }\n    }\n    return true;\n  };\n  const isHex = str => {\n    if (str.length > TAGS.PACKED_MAX) {\n      return false;\n    }\n    for (let i = 0; i < str.length; i++) {\n      const char = str[i];\n      const isInNibbleRange = char >= '0' && char <= '9';\n      if (!isInNibbleRange && !(char >= 'A' && char <= 'F') && !(char >= 'a' && char <= 'f')) {\n        return false;\n      }\n    }\n    return true;\n  };\n  const writeString = str => {\n    const tokenIndex = TOKEN_MAP[str];\n    if (tokenIndex) {\n      if (typeof tokenIndex.dict === 'number') {\n        pushByte(TAGS.DICTIONARY_0 + tokenIndex.dict);\n      }\n      pushByte(tokenIndex.index);\n    } else if (isNibble(str)) {\n      writePackedBytes(str, 'nibble');\n    } else if (isHex(str)) {\n      writePackedBytes(str, 'hex');\n    } else if (str) {\n      const decodedJid = (0, jid_utils_1.jidDecode)(str);\n      if (decodedJid) {\n        writeJid(decodedJid);\n      } else {\n        writeStringRaw(str);\n      }\n    }\n  };\n  const writeListStart = listSize => {\n    if (listSize === 0) {\n      pushByte(TAGS.LIST_EMPTY);\n    } else if (listSize < 256) {\n      pushBytes([TAGS.LIST_8, listSize]);\n    } else {\n      pushByte(TAGS.LIST_16);\n      pushInt16(listSize);\n    }\n  };\n  const validAttributes = Object.keys(attrs).filter(k => typeof attrs[k] !== 'undefined' && attrs[k] !== null);\n  writeListStart(2 * validAttributes.length + 1 + (typeof content !== 'undefined' ? 1 : 0));\n  writeString(tag);\n  for (const key of validAttributes) {\n    if (typeof attrs[key] === 'string') {\n      writeString(key);\n      writeString(attrs[key]);\n    }\n  }\n  if (typeof content === 'string') {\n    writeString(content);\n  } else if (Buffer.isBuffer(content) || content instanceof Uint8Array) {\n    writeByteLength(content.length);\n    pushBytes(content);\n  } else if (Array.isArray(content)) {\n    writeListStart(content.length);\n    for (const item of content) {\n      encodeBinaryNodeInner(item, opts, buffer);\n    }\n  } else if (typeof content === 'undefined') {\n    // do nothing\n  } else {\n    throw new Error(`invalid children for header \"${tag}\": ${content} (${typeof content})`);\n  }\n  return buffer;\n};","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","encodeBinaryNode","constants","require","jid_utils_1","node","opts","buffer","encoded","encodeBinaryNodeInner","Buffer","from","tag","attrs","content","TAGS","TOKEN_MAP","pushByte","push","pushInt","n","littleEndian","i","curShift","pushBytes","bytes","forEach","b","pushInt16","pushInt20","writeByteLength","length","Error","BINARY_32","BINARY_20","BINARY_8","writeStringRaw","str","writeJid","domainType","device","user","server","AD_JID","writeString","JID_PAIR","LIST_EMPTY","packNibble","char","charCodeAt","packHex","writePackedBytes","type","PACKED_MAX","NIBBLE_8","HEX_8","roundedLength","Math","ceil","packFunction","packBytePair","v1","v2","strLengthHalf","floor","isNibble","isInNibbleRange","isHex","tokenIndex","dict","DICTIONARY_0","index","decodedJid","jidDecode","writeListStart","listSize","LIST_8","LIST_16","validAttributes","keys","filter","key","isBuffer","Uint8Array","Array","isArray","item"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/WABinary/encode.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeBinaryNode = void 0;\nconst constants = __importStar(require(\"./constants\"));\nconst jid_utils_1 = require(\"./jid-utils\");\nconst encodeBinaryNode = (node, opts = constants, buffer = [0]) => {\n    const encoded = encodeBinaryNodeInner(node, opts, buffer);\n    return Buffer.from(encoded);\n};\nexports.encodeBinaryNode = encodeBinaryNode;\nconst encodeBinaryNodeInner = ({ tag, attrs, content }, opts, buffer) => {\n    const { TAGS, TOKEN_MAP } = opts;\n    const pushByte = (value) => buffer.push(value & 0xff);\n    const pushInt = (value, n, littleEndian = false) => {\n        for (let i = 0; i < n; i++) {\n            const curShift = littleEndian ? i : n - 1 - i;\n            buffer.push((value >> (curShift * 8)) & 0xff);\n        }\n    };\n    const pushBytes = (bytes) => (bytes.forEach(b => buffer.push(b)));\n    const pushInt16 = (value) => {\n        pushBytes([(value >> 8) & 0xff, value & 0xff]);\n    };\n    const pushInt20 = (value) => (pushBytes([(value >> 16) & 0x0f, (value >> 8) & 0xff, value & 0xff]));\n    const writeByteLength = (length) => {\n        if (length >= 4294967296) {\n            throw new Error('string too large to encode: ' + length);\n        }\n        if (length >= 1 << 20) {\n            pushByte(TAGS.BINARY_32);\n            pushInt(length, 4); // 32 bit integer\n        }\n        else if (length >= 256) {\n            pushByte(TAGS.BINARY_20);\n            pushInt20(length);\n        }\n        else {\n            pushByte(TAGS.BINARY_8);\n            pushByte(length);\n        }\n    };\n    const writeStringRaw = (str) => {\n        const bytes = Buffer.from(str, 'utf-8');\n        writeByteLength(bytes.length);\n        pushBytes(bytes);\n    };\n    const writeJid = ({ domainType, device, user, server }) => {\n        if (typeof device !== 'undefined') {\n            pushByte(TAGS.AD_JID);\n            pushByte(domainType || 0);\n            pushByte(device || 0);\n            writeString(user);\n        }\n        else {\n            pushByte(TAGS.JID_PAIR);\n            if (user.length) {\n                writeString(user);\n            }\n            else {\n                pushByte(TAGS.LIST_EMPTY);\n            }\n            writeString(server);\n        }\n    };\n    const packNibble = (char) => {\n        switch (char) {\n            case '-':\n                return 10;\n            case '.':\n                return 11;\n            case '\\0':\n                return 15;\n            default:\n                if (char >= '0' && char <= '9') {\n                    return char.charCodeAt(0) - '0'.charCodeAt(0);\n                }\n                throw new Error(`invalid byte for nibble \"${char}\"`);\n        }\n    };\n    const packHex = (char) => {\n        if (char >= '0' && char <= '9') {\n            return char.charCodeAt(0) - '0'.charCodeAt(0);\n        }\n        if (char >= 'A' && char <= 'F') {\n            return 10 + char.charCodeAt(0) - 'A'.charCodeAt(0);\n        }\n        if (char >= 'a' && char <= 'f') {\n            return 10 + char.charCodeAt(0) - 'a'.charCodeAt(0);\n        }\n        if (char === '\\0') {\n            return 15;\n        }\n        throw new Error(`Invalid hex char \"${char}\"`);\n    };\n    const writePackedBytes = (str, type) => {\n        if (str.length > TAGS.PACKED_MAX) {\n            throw new Error('Too many bytes to pack');\n        }\n        pushByte(type === 'nibble' ? TAGS.NIBBLE_8 : TAGS.HEX_8);\n        let roundedLength = Math.ceil(str.length / 2.0);\n        if (str.length % 2 !== 0) {\n            roundedLength |= 128;\n        }\n        pushByte(roundedLength);\n        const packFunction = type === 'nibble' ? packNibble : packHex;\n        const packBytePair = (v1, v2) => {\n            const result = (packFunction(v1) << 4) | packFunction(v2);\n            return result;\n        };\n        const strLengthHalf = Math.floor(str.length / 2);\n        for (let i = 0; i < strLengthHalf; i++) {\n            pushByte(packBytePair(str[2 * i], str[2 * i + 1]));\n        }\n        if (str.length % 2 !== 0) {\n            pushByte(packBytePair(str[str.length - 1], '\\x00'));\n        }\n    };\n    const isNibble = (str) => {\n        if (str.length > TAGS.PACKED_MAX) {\n            return false;\n        }\n        for (let i = 0; i < str.length; i++) {\n            const char = str[i];\n            const isInNibbleRange = char >= '0' && char <= '9';\n            if (!isInNibbleRange && char !== '-' && char !== '.') {\n                return false;\n            }\n        }\n        return true;\n    };\n    const isHex = (str) => {\n        if (str.length > TAGS.PACKED_MAX) {\n            return false;\n        }\n        for (let i = 0; i < str.length; i++) {\n            const char = str[i];\n            const isInNibbleRange = char >= '0' && char <= '9';\n            if (!isInNibbleRange && !(char >= 'A' && char <= 'F') && !(char >= 'a' && char <= 'f')) {\n                return false;\n            }\n        }\n        return true;\n    };\n    const writeString = (str) => {\n        const tokenIndex = TOKEN_MAP[str];\n        if (tokenIndex) {\n            if (typeof tokenIndex.dict === 'number') {\n                pushByte(TAGS.DICTIONARY_0 + tokenIndex.dict);\n            }\n            pushByte(tokenIndex.index);\n        }\n        else if (isNibble(str)) {\n            writePackedBytes(str, 'nibble');\n        }\n        else if (isHex(str)) {\n            writePackedBytes(str, 'hex');\n        }\n        else if (str) {\n            const decodedJid = (0, jid_utils_1.jidDecode)(str);\n            if (decodedJid) {\n                writeJid(decodedJid);\n            }\n            else {\n                writeStringRaw(str);\n            }\n        }\n    };\n    const writeListStart = (listSize) => {\n        if (listSize === 0) {\n            pushByte(TAGS.LIST_EMPTY);\n        }\n        else if (listSize < 256) {\n            pushBytes([TAGS.LIST_8, listSize]);\n        }\n        else {\n            pushByte(TAGS.LIST_16);\n            pushInt16(listSize);\n        }\n    };\n    const validAttributes = Object.keys(attrs).filter(k => (typeof attrs[k] !== 'undefined' && attrs[k] !== null));\n    writeListStart(2 * validAttributes.length + 1 + (typeof content !== 'undefined' ? 1 : 0));\n    writeString(tag);\n    for (const key of validAttributes) {\n        if (typeof attrs[key] === 'string') {\n            writeString(key);\n            writeString(attrs[key]);\n        }\n    }\n    if (typeof content === 'string') {\n        writeString(content);\n    }\n    else if (Buffer.isBuffer(content) || content instanceof Uint8Array) {\n        writeByteLength(content.length);\n        pushBytes(content);\n    }\n    else if (Array.isArray(content)) {\n        writeListStart(content.length);\n        for (const item of content) {\n            encodeBinaryNodeInner(item, opts, buffer);\n        }\n    }\n    else if (typeof content === 'undefined') {\n        // do nothing\n    }\n    else {\n        throw new Error(`invalid children for header \"${tag}\": ${content} (${typeof content})`);\n    }\n    return buffer;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}