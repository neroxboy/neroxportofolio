{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.memoryStore = memoryStore;\nconst lru_cache_1 = require(\"lru-cache\");\nconst lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\nfunction clone(object) {\n  if (typeof object === 'object' && object !== null) {\n    return (0, lodash_clonedeep_1.default)(object);\n  }\n  return object;\n}\n/**\n * Wrapper for lru-cache.\n */\nfunction memoryStore(arguments_) {\n  const shouldCloneBeforeSet = arguments_?.shouldCloneBeforeSet !== false; // Clone by default\n  const isCacheable = arguments_?.isCacheable ?? (value => value !== undefined);\n  const lruOptions = {\n    ttlAutopurge: true,\n    ...arguments_,\n    max: arguments_?.max ?? 500,\n    ttl: arguments_?.ttl === undefined ? 0 : arguments_.ttl\n  };\n  const lruCache = new lru_cache_1.LRUCache(lruOptions);\n  return {\n    async del(key) {\n      lruCache.delete(key);\n    },\n    get: async key => lruCache.get(key),\n    keys: async () => [...lruCache.keys()],\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    mget: async (...arguments_) => arguments_.map(x => lruCache.get(x)),\n    async mset(arguments_, ttl) {\n      const opt = {\n        ttl: ttl ?? lruOptions.ttl\n      };\n      for (const [key, value] of arguments_) {\n        if (!isCacheable(value)) {\n          throw new Error(`no cacheable value ${JSON.stringify(value)}`);\n        }\n        if (shouldCloneBeforeSet) {\n          lruCache.set(key, clone(value), opt);\n        } else {\n          lruCache.set(key, value, opt);\n        }\n      }\n    },\n    async mdel(...arguments_) {\n      for (const key of arguments_) {\n        lruCache.delete(key);\n      }\n    },\n    async reset() {\n      lruCache.clear();\n    },\n    ttl: async key => lruCache.getRemainingTTL(key),\n    async set(key, value, opt) {\n      if (!isCacheable(value)) {\n        throw new Error(`no cacheable value ${JSON.stringify(value)}`);\n      }\n      if (shouldCloneBeforeSet) {\n        value = clone(value);\n      }\n      const ttl = opt ?? lruOptions.ttl;\n      lruCache.set(key, value, {\n        ttl\n      });\n    },\n    get calculatedSize() {\n      return lruCache.calculatedSize;\n    },\n    /**\n    * This method is not available in the caching modules.\n    */\n    get size() {\n      return lruCache.size;\n    },\n    /**\n    * This method is not available in the caching modules.\n    */\n    dump: () => lruCache.dump(),\n    /**\n    * This method is not available in the caching modules.\n    */\n    load(...arguments_) {\n      lruCache.load(...arguments_);\n    }\n  };\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","memoryStore","lru_cache_1","require","lodash_clonedeep_1","clone","object","default","arguments_","shouldCloneBeforeSet","isCacheable","undefined","lruOptions","ttlAutopurge","max","ttl","lruCache","LRUCache","del","key","delete","get","keys","mget","map","x","mset","opt","Error","JSON","stringify","set","mdel","reset","clear","getRemainingTTL","calculatedSize","size","dump","load"],"sources":["C:/Users/vanitas/node_modules/cache-manager/dist/stores/memory.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.memoryStore = memoryStore;\nconst lru_cache_1 = require(\"lru-cache\");\nconst lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\nfunction clone(object) {\n    if (typeof object === 'object' && object !== null) {\n        return (0, lodash_clonedeep_1.default)(object);\n    }\n    return object;\n}\n/**\n * Wrapper for lru-cache.\n */\nfunction memoryStore(arguments_) {\n    const shouldCloneBeforeSet = arguments_?.shouldCloneBeforeSet !== false; // Clone by default\n    const isCacheable = arguments_?.isCacheable ?? (value => value !== undefined);\n    const lruOptions = {\n        ttlAutopurge: true,\n        ...arguments_,\n        max: arguments_?.max ?? 500,\n        ttl: arguments_?.ttl === undefined ? 0 : arguments_.ttl,\n    };\n    const lruCache = new lru_cache_1.LRUCache(lruOptions);\n    return {\n        async del(key) {\n            lruCache.delete(key);\n        },\n        get: async (key) => lruCache.get(key),\n        keys: async () => [...lruCache.keys()],\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        mget: async (...arguments_) => arguments_.map(x => lruCache.get(x)),\n        async mset(arguments_, ttl) {\n            const opt = { ttl: ttl ?? lruOptions.ttl };\n            for (const [key, value] of arguments_) {\n                if (!isCacheable(value)) {\n                    throw new Error(`no cacheable value ${JSON.stringify(value)}`);\n                }\n                if (shouldCloneBeforeSet) {\n                    lruCache.set(key, clone(value), opt);\n                }\n                else {\n                    lruCache.set(key, value, opt);\n                }\n            }\n        },\n        async mdel(...arguments_) {\n            for (const key of arguments_) {\n                lruCache.delete(key);\n            }\n        },\n        async reset() {\n            lruCache.clear();\n        },\n        ttl: async (key) => lruCache.getRemainingTTL(key),\n        async set(key, value, opt) {\n            if (!isCacheable(value)) {\n                throw new Error(`no cacheable value ${JSON.stringify(value)}`);\n            }\n            if (shouldCloneBeforeSet) {\n                value = clone(value);\n            }\n            const ttl = opt ?? lruOptions.ttl;\n            lruCache.set(key, value, { ttl });\n        },\n        get calculatedSize() {\n            return lruCache.calculatedSize;\n        },\n        /**\n     * This method is not available in the caching modules.\n     */\n        get size() {\n            return lruCache.size;\n        },\n        /**\n     * This method is not available in the caching modules.\n     */\n        dump: () => lruCache.dump(),\n        /**\n     * This method is not available in the caching modules.\n     */\n        load(...arguments_) {\n            lruCache.load(...arguments_);\n        },\n    };\n}\n//# sourceMappingURL=memory.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}