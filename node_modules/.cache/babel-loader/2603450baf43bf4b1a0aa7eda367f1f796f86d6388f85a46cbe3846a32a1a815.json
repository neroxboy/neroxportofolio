{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initAuthCreds = exports.addTransactionCapability = exports.makeCacheableSignalKeyStore = void 0;\nconst crypto_1 = require(\"crypto\");\nconst node_cache_1 = __importDefault(require(\"node-cache\"));\nconst uuid_1 = require(\"uuid\");\nconst Defaults_1 = require(\"../Defaults\");\nconst crypto_2 = require(\"./crypto\");\nconst generics_1 = require(\"./generics\");\n/**\n * Adds caching capability to a SignalKeyStore\n * @param store the store to add caching to\n * @param logger to log trace events\n * @param _cache cache store to use\n */\nfunction makeCacheableSignalKeyStore(store, logger, _cache) {\n  const cache = _cache || new node_cache_1.default({\n    stdTTL: Defaults_1.DEFAULT_CACHE_TTLS.SIGNAL_STORE,\n    useClones: false,\n    deleteOnExpire: true\n  });\n  function getUniqueId(type, id) {\n    return `${type}.${id}`;\n  }\n  return {\n    async get(type, ids) {\n      const data = {};\n      const idsToFetch = [];\n      for (const id of ids) {\n        const item = cache.get(getUniqueId(type, id));\n        if (typeof item !== 'undefined') {\n          data[id] = item;\n        } else {\n          idsToFetch.push(id);\n        }\n      }\n      if (idsToFetch.length) {\n        logger.trace({\n          items: idsToFetch.length\n        }, 'loading from store');\n        const fetched = await store.get(type, idsToFetch);\n        for (const id of idsToFetch) {\n          const item = fetched[id];\n          if (item) {\n            data[id] = item;\n            cache.set(getUniqueId(type, id), item);\n          }\n        }\n      }\n      return data;\n    },\n    async set(data) {\n      let keys = 0;\n      for (const type in data) {\n        for (const id in data[type]) {\n          cache.set(getUniqueId(type, id), data[type][id]);\n          keys += 1;\n        }\n      }\n      logger.trace({\n        keys\n      }, 'updated cache');\n      await store.set(data);\n    },\n    async clear() {\n      var _a;\n      cache.flushAll();\n      await ((_a = store.clear) === null || _a === void 0 ? void 0 : _a.call(store));\n    }\n  };\n}\nexports.makeCacheableSignalKeyStore = makeCacheableSignalKeyStore;\n/**\n * Adds DB like transaction capability (https://en.wikipedia.org/wiki/Database_transaction) to the SignalKeyStore,\n * this allows batch read & write operations & improves the performance of the lib\n * @param state the key store to apply this capability to\n * @param logger logger to log events\n * @returns SignalKeyStore with transaction capability\n */\nconst addTransactionCapability = (state, logger, {\n  maxCommitRetries,\n  delayBetweenTriesMs\n}) => {\n  // number of queries made to the DB during the transaction\n  // only there for logging purposes\n  let dbQueriesInTransaction = 0;\n  let transactionCache = {};\n  let mutations = {};\n  let transactionsInProgress = 0;\n  return {\n    get: async (type, ids) => {\n      if (isInTransaction()) {\n        const dict = transactionCache[type];\n        const idsRequiringFetch = dict ? ids.filter(item => typeof dict[item] === 'undefined') : ids;\n        // only fetch if there are any items to fetch\n        if (idsRequiringFetch.length) {\n          dbQueriesInTransaction += 1;\n          const result = await state.get(type, idsRequiringFetch);\n          transactionCache[type] || (transactionCache[type] = {});\n          Object.assign(transactionCache[type], result);\n        }\n        return ids.reduce((dict, id) => {\n          var _a;\n          const value = (_a = transactionCache[type]) === null || _a === void 0 ? void 0 : _a[id];\n          if (value) {\n            dict[id] = value;\n          }\n          return dict;\n        }, {});\n      } else {\n        return state.get(type, ids);\n      }\n    },\n    set: data => {\n      if (isInTransaction()) {\n        logger.trace({\n          types: Object.keys(data)\n        }, 'caching in transaction');\n        for (const key in data) {\n          transactionCache[key] = transactionCache[key] || {};\n          Object.assign(transactionCache[key], data[key]);\n          mutations[key] = mutations[key] || {};\n          Object.assign(mutations[key], data[key]);\n        }\n      } else {\n        return state.set(data);\n      }\n    },\n    isInTransaction,\n    async transaction(work) {\n      let result;\n      transactionsInProgress += 1;\n      if (transactionsInProgress === 1) {\n        logger.trace('entering transaction');\n      }\n      try {\n        result = await work();\n        // commit if this is the outermost transaction\n        if (transactionsInProgress === 1) {\n          if (Object.keys(mutations).length) {\n            logger.trace('committing transaction');\n            // retry mechanism to ensure we've some recovery\n            // in case a transaction fails in the first attempt\n            let tries = maxCommitRetries;\n            while (tries) {\n              tries -= 1;\n              try {\n                await state.set(mutations);\n                logger.trace({\n                  dbQueriesInTransaction\n                }, 'committed transaction');\n                break;\n              } catch (error) {\n                logger.warn(`failed to commit ${Object.keys(mutations).length} mutations, tries left=${tries}`);\n                await (0, generics_1.delay)(delayBetweenTriesMs);\n              }\n            }\n          } else {\n            logger.trace('no mutations in transaction');\n          }\n        }\n      } finally {\n        transactionsInProgress -= 1;\n        if (transactionsInProgress === 0) {\n          transactionCache = {};\n          mutations = {};\n          dbQueriesInTransaction = 0;\n        }\n      }\n      return result;\n    }\n  };\n  function isInTransaction() {\n    return transactionsInProgress > 0;\n  }\n};\nexports.addTransactionCapability = addTransactionCapability;\nconst initAuthCreds = () => {\n  const identityKey = crypto_2.Curve.generateKeyPair();\n  return {\n    noiseKey: crypto_2.Curve.generateKeyPair(),\n    pairingEphemeralKeyPair: crypto_2.Curve.generateKeyPair(),\n    signedIdentityKey: identityKey,\n    signedPreKey: (0, crypto_2.signedKeyPair)(identityKey, 1),\n    registrationId: (0, generics_1.generateRegistrationId)(),\n    advSecretKey: (0, crypto_1.randomBytes)(32).toString('base64'),\n    processedHistoryMessages: [],\n    nextPreKeyId: 1,\n    firstUnuploadedPreKeyId: 1,\n    accountSyncCounter: 0,\n    accountSettings: {\n      unarchiveChats: false\n    },\n    // mobile creds\n    deviceId: Buffer.from((0, uuid_1.v4)().replace(/-/g, ''), 'hex').toString('base64url'),\n    phoneId: (0, uuid_1.v4)(),\n    identityId: (0, crypto_1.randomBytes)(20),\n    registered: false,\n    backupToken: (0, crypto_1.randomBytes)(20),\n    registration: {},\n    pairingCode: undefined,\n    lastPropHash: undefined,\n    routingInfo: undefined\n  };\n};\nexports.initAuthCreds = initAuthCreds;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","initAuthCreds","addTransactionCapability","makeCacheableSignalKeyStore","crypto_1","require","node_cache_1","uuid_1","Defaults_1","crypto_2","generics_1","store","logger","_cache","cache","default","stdTTL","DEFAULT_CACHE_TTLS","SIGNAL_STORE","useClones","deleteOnExpire","getUniqueId","type","id","get","ids","data","idsToFetch","item","push","length","trace","items","fetched","set","keys","clear","_a","flushAll","call","state","maxCommitRetries","delayBetweenTriesMs","dbQueriesInTransaction","transactionCache","mutations","transactionsInProgress","isInTransaction","dict","idsRequiringFetch","filter","result","assign","reduce","types","key","transaction","work","tries","error","warn","delay","identityKey","Curve","generateKeyPair","noiseKey","pairingEphemeralKeyPair","signedIdentityKey","signedPreKey","signedKeyPair","registrationId","generateRegistrationId","advSecretKey","randomBytes","toString","processedHistoryMessages","nextPreKeyId","firstUnuploadedPreKeyId","accountSyncCounter","accountSettings","unarchiveChats","deviceId","Buffer","from","v4","replace","phoneId","identityId","registered","backupToken","registration","pairingCode","undefined","lastPropHash","routingInfo"],"sources":["C:/Users/vanitas/node_modules/@whiskeysockets/baileys/lib/Utils/auth-utils.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.initAuthCreds = exports.addTransactionCapability = exports.makeCacheableSignalKeyStore = void 0;\nconst crypto_1 = require(\"crypto\");\nconst node_cache_1 = __importDefault(require(\"node-cache\"));\nconst uuid_1 = require(\"uuid\");\nconst Defaults_1 = require(\"../Defaults\");\nconst crypto_2 = require(\"./crypto\");\nconst generics_1 = require(\"./generics\");\n/**\n * Adds caching capability to a SignalKeyStore\n * @param store the store to add caching to\n * @param logger to log trace events\n * @param _cache cache store to use\n */\nfunction makeCacheableSignalKeyStore(store, logger, _cache) {\n    const cache = _cache || new node_cache_1.default({\n        stdTTL: Defaults_1.DEFAULT_CACHE_TTLS.SIGNAL_STORE,\n        useClones: false,\n        deleteOnExpire: true,\n    });\n    function getUniqueId(type, id) {\n        return `${type}.${id}`;\n    }\n    return {\n        async get(type, ids) {\n            const data = {};\n            const idsToFetch = [];\n            for (const id of ids) {\n                const item = cache.get(getUniqueId(type, id));\n                if (typeof item !== 'undefined') {\n                    data[id] = item;\n                }\n                else {\n                    idsToFetch.push(id);\n                }\n            }\n            if (idsToFetch.length) {\n                logger.trace({ items: idsToFetch.length }, 'loading from store');\n                const fetched = await store.get(type, idsToFetch);\n                for (const id of idsToFetch) {\n                    const item = fetched[id];\n                    if (item) {\n                        data[id] = item;\n                        cache.set(getUniqueId(type, id), item);\n                    }\n                }\n            }\n            return data;\n        },\n        async set(data) {\n            let keys = 0;\n            for (const type in data) {\n                for (const id in data[type]) {\n                    cache.set(getUniqueId(type, id), data[type][id]);\n                    keys += 1;\n                }\n            }\n            logger.trace({ keys }, 'updated cache');\n            await store.set(data);\n        },\n        async clear() {\n            var _a;\n            cache.flushAll();\n            await ((_a = store.clear) === null || _a === void 0 ? void 0 : _a.call(store));\n        }\n    };\n}\nexports.makeCacheableSignalKeyStore = makeCacheableSignalKeyStore;\n/**\n * Adds DB like transaction capability (https://en.wikipedia.org/wiki/Database_transaction) to the SignalKeyStore,\n * this allows batch read & write operations & improves the performance of the lib\n * @param state the key store to apply this capability to\n * @param logger logger to log events\n * @returns SignalKeyStore with transaction capability\n */\nconst addTransactionCapability = (state, logger, { maxCommitRetries, delayBetweenTriesMs }) => {\n    // number of queries made to the DB during the transaction\n    // only there for logging purposes\n    let dbQueriesInTransaction = 0;\n    let transactionCache = {};\n    let mutations = {};\n    let transactionsInProgress = 0;\n    return {\n        get: async (type, ids) => {\n            if (isInTransaction()) {\n                const dict = transactionCache[type];\n                const idsRequiringFetch = dict\n                    ? ids.filter(item => typeof dict[item] === 'undefined')\n                    : ids;\n                // only fetch if there are any items to fetch\n                if (idsRequiringFetch.length) {\n                    dbQueriesInTransaction += 1;\n                    const result = await state.get(type, idsRequiringFetch);\n                    transactionCache[type] || (transactionCache[type] = {});\n                    Object.assign(transactionCache[type], result);\n                }\n                return ids.reduce((dict, id) => {\n                    var _a;\n                    const value = (_a = transactionCache[type]) === null || _a === void 0 ? void 0 : _a[id];\n                    if (value) {\n                        dict[id] = value;\n                    }\n                    return dict;\n                }, {});\n            }\n            else {\n                return state.get(type, ids);\n            }\n        },\n        set: data => {\n            if (isInTransaction()) {\n                logger.trace({ types: Object.keys(data) }, 'caching in transaction');\n                for (const key in data) {\n                    transactionCache[key] = transactionCache[key] || {};\n                    Object.assign(transactionCache[key], data[key]);\n                    mutations[key] = mutations[key] || {};\n                    Object.assign(mutations[key], data[key]);\n                }\n            }\n            else {\n                return state.set(data);\n            }\n        },\n        isInTransaction,\n        async transaction(work) {\n            let result;\n            transactionsInProgress += 1;\n            if (transactionsInProgress === 1) {\n                logger.trace('entering transaction');\n            }\n            try {\n                result = await work();\n                // commit if this is the outermost transaction\n                if (transactionsInProgress === 1) {\n                    if (Object.keys(mutations).length) {\n                        logger.trace('committing transaction');\n                        // retry mechanism to ensure we've some recovery\n                        // in case a transaction fails in the first attempt\n                        let tries = maxCommitRetries;\n                        while (tries) {\n                            tries -= 1;\n                            try {\n                                await state.set(mutations);\n                                logger.trace({ dbQueriesInTransaction }, 'committed transaction');\n                                break;\n                            }\n                            catch (error) {\n                                logger.warn(`failed to commit ${Object.keys(mutations).length} mutations, tries left=${tries}`);\n                                await (0, generics_1.delay)(delayBetweenTriesMs);\n                            }\n                        }\n                    }\n                    else {\n                        logger.trace('no mutations in transaction');\n                    }\n                }\n            }\n            finally {\n                transactionsInProgress -= 1;\n                if (transactionsInProgress === 0) {\n                    transactionCache = {};\n                    mutations = {};\n                    dbQueriesInTransaction = 0;\n                }\n            }\n            return result;\n        }\n    };\n    function isInTransaction() {\n        return transactionsInProgress > 0;\n    }\n};\nexports.addTransactionCapability = addTransactionCapability;\nconst initAuthCreds = () => {\n    const identityKey = crypto_2.Curve.generateKeyPair();\n    return {\n        noiseKey: crypto_2.Curve.generateKeyPair(),\n        pairingEphemeralKeyPair: crypto_2.Curve.generateKeyPair(),\n        signedIdentityKey: identityKey,\n        signedPreKey: (0, crypto_2.signedKeyPair)(identityKey, 1),\n        registrationId: (0, generics_1.generateRegistrationId)(),\n        advSecretKey: (0, crypto_1.randomBytes)(32).toString('base64'),\n        processedHistoryMessages: [],\n        nextPreKeyId: 1,\n        firstUnuploadedPreKeyId: 1,\n        accountSyncCounter: 0,\n        accountSettings: {\n            unarchiveChats: false\n        },\n        // mobile creds\n        deviceId: Buffer.from((0, uuid_1.v4)().replace(/-/g, ''), 'hex').toString('base64url'),\n        phoneId: (0, uuid_1.v4)(),\n        identityId: (0, crypto_1.randomBytes)(20),\n        registered: false,\n        backupToken: (0, crypto_1.randomBytes)(20),\n        registration: {},\n        pairingCode: undefined,\n        lastPropHash: undefined,\n        routingInfo: undefined,\n    };\n};\nexports.initAuthCreds = initAuthCreds;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}