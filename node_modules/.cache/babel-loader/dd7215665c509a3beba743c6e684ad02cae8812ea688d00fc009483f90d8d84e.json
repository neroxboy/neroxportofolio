{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FlacParser = void 0;\nconst token_types_1 = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst util = require(\"../common/Util\");\nconst Vorbis_1 = require(\"../ogg/vorbis/Vorbis\");\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst VorbisParser_1 = require(\"../ogg/vorbis/VorbisParser\");\nconst VorbisDecoder_1 = require(\"../ogg/vorbis/VorbisDecoder\");\nconst debug = (0, debug_1.default)('music-metadata:parser:FLAC');\n/**\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\n * ref: https://xiph.org/flac/format.html#metadata_block\n */\nvar BlockType;\n(function (BlockType) {\n  BlockType[BlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\n  BlockType[BlockType[\"PADDING\"] = 1] = \"PADDING\";\n  BlockType[BlockType[\"APPLICATION\"] = 2] = \"APPLICATION\";\n  BlockType[BlockType[\"SEEKTABLE\"] = 3] = \"SEEKTABLE\";\n  BlockType[BlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\n  BlockType[BlockType[\"CUESHEET\"] = 5] = \"CUESHEET\";\n  BlockType[BlockType[\"PICTURE\"] = 6] = \"PICTURE\";\n})(BlockType || (BlockType = {}));\nclass FlacParser extends AbstractID3Parser_1.AbstractID3Parser {\n  constructor() {\n    super(...arguments);\n    this.padding = 0;\n  }\n  /**\n   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n   * @param {INativeMetadataCollector} metadata Output\n   * @param {ITokenizer} tokenizer Input\n   * @param {IOptions} options Parsing options\n   */\n  init(metadata, tokenizer, options) {\n    super.init(metadata, tokenizer, options);\n    this.vorbisParser = new VorbisParser_1.VorbisParser(metadata, options);\n    return this;\n  }\n  async postId3v2Parse() {\n    const fourCC = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n    if (fourCC.toString() !== 'fLaC') {\n      throw new Error('Invalid FLAC preamble');\n    }\n    let blockHeader;\n    do {\n      // Read block header\n      blockHeader = await this.tokenizer.readToken(Metadata.BlockHeader);\n      // Parse block data\n      await this.parseDataBlock(blockHeader);\n    } while (!blockHeader.lastBlock);\n    if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n      const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n      this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n    }\n  }\n  parseDataBlock(blockHeader) {\n    debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n    switch (blockHeader.type) {\n      case BlockType.STREAMINFO:\n        return this.parseBlockStreamInfo(blockHeader.length);\n      case BlockType.PADDING:\n        this.padding += blockHeader.length;\n        break;\n      case BlockType.APPLICATION:\n        break;\n      case BlockType.SEEKTABLE:\n        break;\n      case BlockType.VORBIS_COMMENT:\n        return this.parseComment(blockHeader.length);\n      case BlockType.CUESHEET:\n        break;\n      case BlockType.PICTURE:\n        return this.parsePicture(blockHeader.length).then();\n      default:\n        this.metadata.addWarning('Unknown block type: ' + blockHeader.type);\n    }\n    // Ignore data block\n    return this.tokenizer.ignore(blockHeader.length).then();\n  }\n  /**\n   * Parse STREAMINFO\n   */\n  async parseBlockStreamInfo(dataLen) {\n    if (dataLen !== Metadata.BlockStreamInfo.len) throw new Error('Unexpected block-stream-info length');\n    const streamInfo = await this.tokenizer.readToken(Metadata.BlockStreamInfo);\n    this.metadata.setFormat('container', 'FLAC');\n    this.metadata.setFormat('codec', 'FLAC');\n    this.metadata.setFormat('lossless', true);\n    this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n    this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n    this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n    if (streamInfo.totalSamples > 0) {\n      this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n    }\n  }\n  /**\n   * Parse VORBIS_COMMENT\n   * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n   */\n  async parseComment(dataLen) {\n    const data = await this.tokenizer.readToken(new token_types_1.Uint8ArrayType(dataLen));\n    const decoder = new VorbisDecoder_1.VorbisDecoder(data, 0);\n    decoder.readStringUtf8(); // vendor (skip)\n    const commentListLength = decoder.readInt32();\n    for (let i = 0; i < commentListLength; i++) {\n      const tag = decoder.parseUserComment();\n      this.vorbisParser.addTag(tag.key, tag.value);\n    }\n  }\n  async parsePicture(dataLen) {\n    if (this.options.skipCovers) {\n      return this.tokenizer.ignore(dataLen);\n    } else {\n      const picture = await this.tokenizer.readToken(new Vorbis_1.VorbisPictureToken(dataLen));\n      this.vorbisParser.addTag('METADATA_BLOCK_PICTURE', picture);\n    }\n  }\n}\nexports.FlacParser = FlacParser;\nclass Metadata {}\nMetadata.BlockHeader = {\n  len: 4,\n  get: (buf, off) => {\n    return {\n      lastBlock: util.getBit(buf, off, 7),\n      type: util.getBitAllignedNumber(buf, off, 1, 7),\n      length: token_types_1.UINT24_BE.get(buf, off + 1)\n    };\n  }\n};\n/**\n * METADATA_BLOCK_DATA\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\n */\nMetadata.BlockStreamInfo = {\n  len: 34,\n  get: (buf, off) => {\n    return {\n      // The minimum block size (in samples) used in the stream.\n      minimumBlockSize: token_types_1.UINT16_BE.get(buf, off),\n      // The maximum block size (in samples) used in the stream.\n      // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n      maximumBlockSize: token_types_1.UINT16_BE.get(buf, off + 2) / 1000,\n      // The minimum frame size (in bytes) used in the stream.\n      // May be 0 to imply the value is not known.\n      minimumFrameSize: token_types_1.UINT24_BE.get(buf, off + 4),\n      // The maximum frame size (in bytes) used in the stream.\n      // May be 0 to imply the value is not known.\n      maximumFrameSize: token_types_1.UINT24_BE.get(buf, off + 7),\n      // Sample rate in Hz. Though 20 bits are available,\n      // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n      // Also, a value of 0 is invalid.\n      sampleRate: token_types_1.UINT24_BE.get(buf, off + 10) >> 4,\n      // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n      // (number of channels)-1. FLAC supports from 1 to 8 channels\n      channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n      // bits per sample)-1.\n      // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n      bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n      // Total samples in stream.\n      // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n      // A value of zero here means the number of total samples is unknown.\n      totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),\n      // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n      fileMD5: new token_types_1.Uint8ArrayType(16).get(buf, off + 18)\n    };\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","FlacParser","token_types_1","require","debug_1","util","Vorbis_1","AbstractID3Parser_1","FourCC_1","VorbisParser_1","VorbisDecoder_1","debug","default","BlockType","AbstractID3Parser","constructor","arguments","padding","init","metadata","tokenizer","options","vorbisParser","VorbisParser","postId3v2Parse","fourCC","readToken","FourCcToken","toString","Error","blockHeader","Metadata","BlockHeader","parseDataBlock","lastBlock","fileInfo","size","format","duration","dataSize","position","setFormat","type","length","STREAMINFO","parseBlockStreamInfo","PADDING","APPLICATION","SEEKTABLE","VORBIS_COMMENT","parseComment","CUESHEET","PICTURE","parsePicture","then","addWarning","ignore","dataLen","BlockStreamInfo","len","streamInfo","channels","bitsPerSample","sampleRate","totalSamples","data","Uint8ArrayType","decoder","VorbisDecoder","readStringUtf8","commentListLength","readInt32","i","tag","parseUserComment","addTag","key","skipCovers","picture","VorbisPictureToken","get","buf","off","getBit","getBitAllignedNumber","UINT24_BE","minimumBlockSize","UINT16_BE","maximumBlockSize","minimumFrameSize","maximumFrameSize","fileMD5"],"sources":["C:/Users/vanitas/node_modules/music-metadata/lib/flac/FlacParser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlacParser = void 0;\nconst token_types_1 = require(\"token-types\");\nconst debug_1 = require(\"debug\");\nconst util = require(\"../common/Util\");\nconst Vorbis_1 = require(\"../ogg/vorbis/Vorbis\");\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst VorbisParser_1 = require(\"../ogg/vorbis/VorbisParser\");\nconst VorbisDecoder_1 = require(\"../ogg/vorbis/VorbisDecoder\");\nconst debug = (0, debug_1.default)('music-metadata:parser:FLAC');\n/**\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\n * ref: https://xiph.org/flac/format.html#metadata_block\n */\nvar BlockType;\n(function (BlockType) {\n    BlockType[BlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\n    BlockType[BlockType[\"PADDING\"] = 1] = \"PADDING\";\n    BlockType[BlockType[\"APPLICATION\"] = 2] = \"APPLICATION\";\n    BlockType[BlockType[\"SEEKTABLE\"] = 3] = \"SEEKTABLE\";\n    BlockType[BlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\n    BlockType[BlockType[\"CUESHEET\"] = 5] = \"CUESHEET\";\n    BlockType[BlockType[\"PICTURE\"] = 6] = \"PICTURE\";\n})(BlockType || (BlockType = {}));\nclass FlacParser extends AbstractID3Parser_1.AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.padding = 0;\n    }\n    /**\n     * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n     * @param {INativeMetadataCollector} metadata Output\n     * @param {ITokenizer} tokenizer Input\n     * @param {IOptions} options Parsing options\n     */\n    init(metadata, tokenizer, options) {\n        super.init(metadata, tokenizer, options);\n        this.vorbisParser = new VorbisParser_1.VorbisParser(metadata, options);\n        return this;\n    }\n    async postId3v2Parse() {\n        const fourCC = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        if (fourCC.toString() !== 'fLaC') {\n            throw new Error('Invalid FLAC preamble');\n        }\n        let blockHeader;\n        do {\n            // Read block header\n            blockHeader = await this.tokenizer.readToken(Metadata.BlockHeader);\n            // Parse block data\n            await this.parseDataBlock(blockHeader);\n        } while (!blockHeader.lastBlock);\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n        }\n    }\n    parseDataBlock(blockHeader) {\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n        switch (blockHeader.type) {\n            case BlockType.STREAMINFO:\n                return this.parseBlockStreamInfo(blockHeader.length);\n            case BlockType.PADDING:\n                this.padding += blockHeader.length;\n                break;\n            case BlockType.APPLICATION:\n                break;\n            case BlockType.SEEKTABLE:\n                break;\n            case BlockType.VORBIS_COMMENT:\n                return this.parseComment(blockHeader.length);\n            case BlockType.CUESHEET:\n                break;\n            case BlockType.PICTURE:\n                return this.parsePicture(blockHeader.length).then();\n            default:\n                this.metadata.addWarning('Unknown block type: ' + blockHeader.type);\n        }\n        // Ignore data block\n        return this.tokenizer.ignore(blockHeader.length).then();\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    async parseBlockStreamInfo(dataLen) {\n        if (dataLen !== Metadata.BlockStreamInfo.len)\n            throw new Error('Unexpected block-stream-info length');\n        const streamInfo = await this.tokenizer.readToken(Metadata.BlockStreamInfo);\n        this.metadata.setFormat('container', 'FLAC');\n        this.metadata.setFormat('codec', 'FLAC');\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n        if (streamInfo.totalSamples > 0) {\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n        }\n    }\n    /**\n     * Parse VORBIS_COMMENT\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async parseComment(dataLen) {\n        const data = await this.tokenizer.readToken(new token_types_1.Uint8ArrayType(dataLen));\n        const decoder = new VorbisDecoder_1.VorbisDecoder(data, 0);\n        decoder.readStringUtf8(); // vendor (skip)\n        const commentListLength = decoder.readInt32();\n        for (let i = 0; i < commentListLength; i++) {\n            const tag = decoder.parseUserComment();\n            this.vorbisParser.addTag(tag.key, tag.value);\n        }\n    }\n    async parsePicture(dataLen) {\n        if (this.options.skipCovers) {\n            return this.tokenizer.ignore(dataLen);\n        }\n        else {\n            const picture = await this.tokenizer.readToken(new Vorbis_1.VorbisPictureToken(dataLen));\n            this.vorbisParser.addTag('METADATA_BLOCK_PICTURE', picture);\n        }\n    }\n}\nexports.FlacParser = FlacParser;\nclass Metadata {\n}\nMetadata.BlockHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            lastBlock: util.getBit(buf, off, 7),\n            type: util.getBitAllignedNumber(buf, off, 1, 7),\n            length: token_types_1.UINT24_BE.get(buf, off + 1)\n        };\n    }\n};\n/**\n * METADATA_BLOCK_DATA\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\n */\nMetadata.BlockStreamInfo = {\n    len: 34,\n    get: (buf, off) => {\n        return {\n            // The minimum block size (in samples) used in the stream.\n            minimumBlockSize: token_types_1.UINT16_BE.get(buf, off),\n            // The maximum block size (in samples) used in the stream.\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n            maximumBlockSize: token_types_1.UINT16_BE.get(buf, off + 2) / 1000,\n            // The minimum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            minimumFrameSize: token_types_1.UINT24_BE.get(buf, off + 4),\n            // The maximum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            maximumFrameSize: token_types_1.UINT24_BE.get(buf, off + 7),\n            // Sample rate in Hz. Though 20 bits are available,\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n            // Also, a value of 0 is invalid.\n            sampleRate: token_types_1.UINT24_BE.get(buf, off + 10) >> 4,\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\n            channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n            // bits per sample)-1.\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n            bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n            // Total samples in stream.\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n            // A value of zero here means the number of total samples is unknown.\n            totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n            fileMD5: new token_types_1.Uint8ArrayType(16).get(buf, off + 18)\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}